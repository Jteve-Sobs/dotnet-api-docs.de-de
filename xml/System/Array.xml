<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Array.xml" source-language="en-US" target-language="de-DE">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-efd8310" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5e05b5b2-d481-4262-b7b7-7de7ac2afe075fe79373523154dee59083c1e0c45afe5404a045.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5fe79373523154dee59083c1e0c45afe5404a045</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">df6cf590aa3087f6c7c202712eee781c6a3c8f96</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">05/07/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the base class for all arrays in the common language runtime.</source>
          <target state="translated">Stellt Methoden zum Erstellen, Bearbeiten, Durchsuchen und Sortieren von Arrays bereit und ist damit Basisklasse für alle Arrays in der Common Language Runtime.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> class is not part of the <ph id="ph2">&lt;xref:System.Collections&gt;</ph> namespaces.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array&gt;</ph> Klasse ist nicht Teil der <ph id="ph2">&lt;xref:System.Collections&gt;</ph> Namespaces.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>However, it is still considered a collection because it is based on the <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated">Allerdings es dennoch als eine Sammlung, da er basiert die <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> Schnittstelle.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> class is the base class for language implementations that support arrays.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array&gt;</ph> Klasse ist die Basisklasse für Implementierungen von Sprache, die Arrays unterstützen.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>However, only the system and compilers can derive explicitly from the <ph id="ph1">&lt;xref:System.Array&gt;</ph> class.</source>
          <target state="translated">Allerdings nur die System- und die Compiler können explizit aus Ableiten der <ph id="ph1">&lt;xref:System.Array&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Users should employ the array constructs provided by the language.</source>
          <target state="translated">Benutzer sollten die Arraykonstrukte, die von der Sprache bereitgestellte einsetzen.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>An element is a value in an <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Ein Element ist ein Wert in einer <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The length of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is the total number of elements it can contain.</source>
          <target state="translated">Die Länge einer <ph id="ph1">&lt;xref:System.Array&gt;</ph> ist die Gesamtanzahl von Elementen enthalten.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The lower bound of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is the index of its first element.</source>
          <target state="translated">Die untere Grenze einer <ph id="ph1">&lt;xref:System.Array&gt;</ph> ist der Index des ersten darin enthaltenen Elements.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>An <ph id="ph1">&lt;xref:System.Array&gt;</ph> can have any lower bound, but it has a lower bound of zero by default.</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.Array&gt;</ph> können untere Grenze, aber es wurde eine Untergrenze von 0 (null), wird standardmäßig.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>A different lower bound can be defined when creating an instance of the <ph id="ph1">&lt;xref:System.Array&gt;</ph> class using <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph>.A multidimensional <ph id="ph3">&lt;xref:System.Array&gt;</ph> can have different bounds for each dimension.</source>
          <target state="translated">Eine andere Untergrenze definiert werden können, beim Erstellen einer Instanz von der <ph id="ph1">&lt;xref:System.Array&gt;</ph> -Klasse unter Verwendung <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph>. Ein mehrdimensionales <ph id="ph3">&lt;xref:System.Array&gt;</ph> können verschiedene Grenzen für jede Dimension haben.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>An array can have a maximum of 32 dimensions.</source>
          <target state="translated">Ein Array kann maximal 32 Dimensionen aufweisen.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Unlike the classes in the <ph id="ph1">&lt;xref:System.Collections&gt;</ph> namespaces, <ph id="ph2">&lt;xref:System.Array&gt;</ph> has a fixed capacity.</source>
          <target state="translated">Im Gegensatz zu Klassen in der <ph id="ph1">&lt;xref:System.Collections&gt;</ph> Namespaces <ph id="ph2">&lt;xref:System.Array&gt;</ph> hat eine feste Kapazität.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>To increase the capacity, you must create a new <ph id="ph1">&lt;xref:System.Array&gt;</ph> object with the required capacity, copy the elements from the old <ph id="ph2">&lt;xref:System.Array&gt;</ph> object to the new one, and delete the old <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Um die Kapazität zu erhöhen, müssen Sie ein neues erstellen <ph id="ph1">&lt;xref:System.Array&gt;</ph> -Objekt mit der erforderlichen Kapazität, kopieren Sie die Elemente aus der alten <ph id="ph2">&lt;xref:System.Array&gt;</ph> Objekt in das neue Projekt, und löschen die alte <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>By default, the maximum size of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is 2 gigabytes (GB).</source>
          <target state="translated">Standardmäßig ist die maximale Größe einer <ph id="ph1">&lt;xref:System.Array&gt;</ph> beträgt 2 Gigabyte (GB).</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>In a 64-bit environment, you can avoid the size restriction by setting the <ph id="ph1">`enabled`</ph> attribute of the <bpt id="p1">[</bpt>gcAllowVeryLargeObjects<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md)</ept> configuration element to <ph id="ph2">`true`</ph> in the run-time environment.</source>
          <target state="translated">In einer 64-Bit-Umgebung können Sie die Größe Einschränkung vermeiden, indem die <ph id="ph1">`enabled`</ph> Attribut des der <bpt id="p1">[</bpt>GcAllowVeryLargeObjects<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md)</ept> zu Konfigurationselement <ph id="ph2">`true`</ph> in der Umgebung zur Laufzeit.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>However, the array will still be limited to a total of 4 billion elements, and to a maximum index of 0X7FEFFFFF in any given dimension (0X7FFFFFC7 for byte arrays and arrays of single-byte structures).</source>
          <target state="translated">Das Array wird jedoch weiterhin auf insgesamt 4 Milliarden Elemente, und klicken Sie auf eine maximale Index des 0X7FEFFFFF in den angegebenen Dimensionen (0X7FFFFFC7 für Bytearrays und Arrays von einzelbytestrukturen) beschränkt sein.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Single-dimensional arrays implement the <ph id="ph1">&lt;xref:System.Collections.Generic.IList%601?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType&gt;</ph> and <ph id="ph5">&lt;xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType&gt;</ph> generic interfaces.</source>
          <target state="translated">Eindimensionale Arrays implementieren die <ph id="ph1">&lt;xref:System.Collections.Generic.IList%601?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType&gt;</ph> und <ph id="ph5">&lt;xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType&gt;</ph> generische Schnittstellen.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The implementations are provided to arrays at run time, and as a result, the generic interfaces do not appear in the declaration syntax for the <ph id="ph1">&lt;xref:System.Array&gt;</ph> class.</source>
          <target state="translated">Die Implementierungen sind für Arrays zur Laufzeit bereitgestellt und die generischen Schnittstellen werden daher nicht angezeigt, in der Syntax für Deklarationen für die <ph id="ph1">&lt;xref:System.Array&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>In addition,  there are no reference topics for interface members that are accessible only by casting an array to the generic interface type (explicit interface implementations).</source>
          <target state="translated">Darüber hinaus stehen keine Referenzthemen für Schnittstellenmember, die nur durch Umwandlung einem Array mit den generischen Schnittstellentyp (explizite schnittstellenimplementierungen) zugegriffen werden kann.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The key thing to be aware of when you cast an array to one of these interfaces is that members which add, insert, or remove elements throw <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">Wichtigster Punkt ist, achten Sie bei einem Array mit einer dieser Schnittstellen Umwandlung ist, dass Mitglieder, von denen hinzufügen, einfügen oder Entfernen von Elementen Throw <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source><ph id="ph1">&lt;xref:System.Type&gt;</ph> objects provide information about array type declarations.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type&gt;</ph> Objekte Aufschluss darüber geben Arraydeklarationen-Typ.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source><ph id="ph1">&lt;xref:System.Array&gt;</ph> objects with the same array type share the same <ph id="ph2">&lt;xref:System.Type&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> Objekte mit der gleichen Arraytyp verwenden dieselbe <ph id="ph2">&lt;xref:System.Type&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source><ph id="ph1">&lt;xref:System.Type.IsArray%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.GetElementType%2A?displayProperty=nameWithType&gt;</ph> might not return the expected results with <ph id="ph3">&lt;xref:System.Array&gt;</ph> because if an array is cast to the type <ph id="ph4">&lt;xref:System.Array&gt;</ph>, the result is an object, not an array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsArray%2A?displayProperty=nameWithType&gt;</ph> und <ph id="ph2">&lt;xref:System.Type.GetElementType%2A?displayProperty=nameWithType&gt;</ph> möglicherweise nicht die erwarteten Ergebnisse mit zurück <ph id="ph3">&lt;xref:System.Array&gt;</ph> da ein Array, in den Typ umgewandelt wird <ph id="ph4">&lt;xref:System.Array&gt;</ph>, das Ergebnis ist ein Objekt, das kein Array.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>That is, <ph id="ph1">`typeof(System.Array).IsArray`</ph> returns <ph id="ph2">`false`</ph>, and <ph id="ph3">`typeof(System.Array).GetElementType`</ph> returns <ph id="ph4">`null`</ph>.</source>
          <target state="translated">D. h. <ph id="ph1">`typeof(System.Array).IsArray`</ph> gibt <ph id="ph2">`false`</ph>, und <ph id="ph3">`typeof(System.Array).GetElementType`</ph> gibt <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> method copies elements not only between arrays of the same type but also between standard arrays of different types; it handles type casting automatically.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> Methode kopiert die Elemente, die nicht nur zwischen Arrays mit den gleichen Typ, sondern auch zwischen standard Arrays mit verschiedenen Typen; sie Typumwandlung von Elementen automatisch behandelt.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Some methods, such as <ph id="ph1">&lt;xref:System.Array.CreateInstance%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Copy%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Array.CopyTo%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Array.GetValue%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.Array.SetValue%2A&gt;</ph>, provide overloads that accept 64-bit integers as parameters to accommodate large capacity arrays.</source>
          <target state="translated">Einige Methoden, wie z. B. <ph id="ph1">&lt;xref:System.Array.CreateInstance%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Copy%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Array.CopyTo%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Array.GetValue%2A&gt;</ph>, und <ph id="ph5">&lt;xref:System.Array.SetValue%2A&gt;</ph>, geben Sie die Überladungen, die 64-Bit-Ganzzahlen als Parameter für die Kapazität Arrays gerecht zu akzeptieren.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source><ph id="ph1">&lt;xref:System.Array.LongLength%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetLongLength%2A&gt;</ph> return 64-bit integers indicating the length of the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.LongLength%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Array.GetLongLength%2A&gt;</ph> 64-Bit-Ganzzahlen, die die Länge des Arrays zurück.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is not guaranteed to be sorted.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array&gt;</ph> ist nicht garantiert werden.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>You must sort the <ph id="ph1">&lt;xref:System.Array&gt;</ph> prior to performing operations (such as <ph id="ph2">&lt;xref:System.Array.BinarySearch%2A&gt;</ph>) that require the <ph id="ph3">&lt;xref:System.Array&gt;</ph> to be sorted.</source>
          <target state="translated">Sie sortieren, müssen die <ph id="ph1">&lt;xref:System.Array&gt;</ph> vor dem Ausführen von Vorgängen (z. B. <ph id="ph2">&lt;xref:System.Array.BinarySearch%2A&gt;</ph>), erfordern die <ph id="ph3">&lt;xref:System.Array&gt;</ph> sortiert werden.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Using an <ph id="ph1">&lt;xref:System.Array&gt;</ph> object of pointers in native code is not supported and will throw a <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> for several methods.</source>
          <target state="translated">Mithilfe einer <ph id="ph1">&lt;xref:System.Array&gt;</ph> Objekt von Zeigern in systemeigenem Code wird nicht unterstützt und löst eine <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> für mehrere Methoden.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The following code example shows how <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> copies elements between an array of type integer and an array of type <ph id="ph2">&lt;xref:System.Object&gt;</ph>.</source>
          <target state="translated">Das folgende Codebeispiel zeigt, wie <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> kopiert die Elemente zwischen ein Array vom Typ Integer und ein Array vom Typ <ph id="ph2">&lt;xref:System.Object&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>The following code example creates and initializes an <ph id="ph1">&lt;xref:System.Array&gt;</ph> and displays its properties and its elements.</source>
          <target state="translated">Im folgenden Codebeispiel wird erstellt und initialisiert ein <ph id="ph1">&lt;xref:System.Array&gt;</ph> und seine Eigenschaften und Elemente angezeigt.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Public static (<ph id="ph1">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) members of this type are thread safe.</source>
          <target state="translated">Öffentliche statische (<ph id="ph1">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) Member dieses Typs sind threadsicher.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Any instance members are not guaranteed to be thread safe.</source>
          <target state="translated">Bei Instanzmembern ist die Threadsicherheit nicht gewährleistet.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>This implementation does not provide a synchronized (thread safe) wrapper for an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>; however, .NET Framework classes based on <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> provide their own synchronized version of the collection using the <ph id="ph3">&lt;see cref="P:System.Array.SyncRoot" /&gt;</ph> property.</source>
          <target state="translated">Diese Implementierung bietet keinen synchronisierten (threadsicheren) Wrapper für ein <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>jedoch .NET Framework-Klassen basierend auf <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> bieten eigene synchronisierte Version der Auflistung mithilfe der <ph id="ph3">&lt;see cref="P:System.Array.SyncRoot" /&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Array">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>The type of the elements of the array.</source>
          <target state="translated">Der Typ der Elemente des Arrays.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>The one-dimensional, zero-based array to wrap in a read-only <ph id="ph1">&lt;see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /&gt;</ph> wrapper.</source>
          <target state="translated">Das eindimensionale, nullbasierte Array, das mit einem schreibgeschützten <ph id="ph1">&lt;see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /&gt;</ph>-Wrapper umschlossen werden soll.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>Returns a read-only wrapper for the specified array.</source>
          <target state="translated">Gibt einen schreibgeschützten Wrapper für das angegebene Array zurück.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>A read-only <ph id="ph1">&lt;see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /&gt;</ph> wrapper for the specified array.</source>
          <target state="translated">Ein schreibgeschützter <ph id="ph1">&lt;see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /&gt;</ph>-Wrapper für das angegebene Array.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>To prevent any modifications to the array, expose the array only through this wrapper.</source>
          <target state="translated">Um zu verhindern, dass die Änderungen an das Array verfügbar zu machen das Array nur über diesen Wrapper.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>A collection that is read-only is simply a collection with a wrapper that prevents modifying the collection; therefore, if changes are made to the underlying collection, the read-only collection reflects those changes.</source>
          <target state="translated">Eine Auflistung, die schreibgeschützt ist, ist eine Auflistung mit einem Wrapper, der verhindert, dass die Auflistung ändern; Wenn Änderungen an der zugrunde liegenden Auflistung vorgenommen werden, spiegelt die schreibgeschützte Auflistung daher diese Änderungen wider.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Diese Methode ist ein o(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source>The following example wraps an array in a read-only <ph id="ph1">&lt;xref:System.Collections.ObjectModel.ReadOnlyCollection%601&gt;</ph>.</source>
          <target state="translated">Im folgende Beispiel umschließt ein Array in eine schreibgeschützte <ph id="ph1">&lt;xref:System.Collections.ObjectModel.ReadOnlyCollection%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Array.AsReadOnly``1(``0[])">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Searches a one-dimensional sorted <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> for a value, using a binary search algorithm.</source>
          <target state="translated">Durchsucht ein sortiertes eindimensionales <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> mithilfe eines binären Suchalgorithmus nach einem Wert.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>The sorted one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Das zu durchsuchende sortierte eindimensionale <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>The object to search for.</source>
          <target state="translated">Das Objekt, nach dem gesucht werden soll.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>Searches an entire one-dimensional sorted array for a specific element, using the <ph id="ph1">&lt;see cref="T:System.IComparable" /&gt;</ph> interface implemented by each element of the array and by the specified object.</source>
          <target state="translated">Durchsucht ein ganzes sortiertes eindimensionales Array mithilfe der <ph id="ph1">&lt;see cref="T:System.IComparable" /&gt;</ph>-Schnittstelle, die von jedem Element des Arrays und durch das angegebene Objekt implementiert wird, nach einem bestimmten Element.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated">Der Index des angegebenen <ph id="ph1">&lt;paramref name="value" /&gt;</ph> im angegebenen <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, sofern <ph id="ph3">&lt;paramref name="value" /&gt;</ph> gefunden wurde, andernfalls eine negative Zahl.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="value" /&gt;</ph> nicht gefunden wurde und <ph id="ph2">&lt;paramref name="value" /&gt;</ph> kleiner als mindestens ein Element in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <ph id="ph4">&lt;paramref name="value" /&gt;</ph> ist.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="value" /&gt;</ph> nicht gefunden wurde und <ph id="ph2">&lt;paramref name="value" /&gt;</ph> größer als alle Elemente in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1).</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Wenn diese Methode mit einem nicht sortierten <ph id="ph1">&lt;paramref name="array" /&gt;</ph> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <ph id="ph2">&lt;paramref name="value" /&gt;</ph> in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> vorhanden ist.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">Diese Methode unterstützt keine Suchen von Arrays, die negative Indizes enthalten.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> muss vor dem Aufrufen dieser Methode sortiert werden.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Array&gt;</ph> enthält keinen den angegebenen Wert gibt die Methode eine negative ganze Zahl zurück.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result  to produce an index.</source>
          <target state="translated">Sie können die bitweiser Komplementoperator anwenden (~ in c# <ph id="ph1">`Not`</ph> in Visual Basic) auf das Ergebnis negativ, um einen Index zu erzeugen.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>If this index is one greater than the upper bound of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">Wenn dieser Index einer ist größer als die obere Grenze des Arrays, es sind keine Elemente größer als <ph id="ph1">`value`</ph> im Array.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">Andernfalls ist der Index des ersten Elements, das größer ist als <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>Either <ph id="ph1">`value`</ph> or every element of <ph id="ph2">`array`</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface, which is used for comparisons.</source>
          <target state="translated">Entweder <ph id="ph1">`value`</ph> oder jedes Element des <ph id="ph2">`array`</ph> implementieren müssen die <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> -Schnittstelle, die für Vergleiche verwendet wird.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Die Elemente der <ph id="ph1">`array`</ph> muss bereits in das Erhöhen des Werts gemäß der Sortierreihenfolge von definierten sortiert werden die <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> Implementierung; anderenfalls das Ergebnis möglicherweise nicht korrekt.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>If<ph id="ph1">`value`</ph> does not implement the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> interface, the elements of <ph id="ph3">`array`</ph> are not tested for <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> before the search begins.</source>
          <target state="translated">Wenn<ph id="ph1">`value`</ph> implementiert nicht die <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> Schnittstelle, die Elemente der <ph id="ph3">`array`</ph> nicht getestet werden <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> vor Beginn der Suche.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>An exception is thrown if the search encounters an element that does not implement <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</source>
          <target state="translated">Eine Ausnahme wird ausgelöst, wenn die Suche ein Element gefunden wird, die nicht implementiert <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">Doppelte Elemente sind zulässig.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Array&gt;</ph> enthält mehr als ein Element gleich <ph id="ph2">`value`</ph>, die Methode gibt den Index nur ein vorkommen, aber nicht unbedingt das erste Schema zurück.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception.</source>
          <target state="translated"><ph id="ph1">`null`</ph> kann mit anderen Verweistypen immer verglichen werden. Daher geben Vergleiche mit <ph id="ph2">`null`</ph> eine Ausnahme nicht generiert.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Für jedes Element getestet <ph id="ph1">`value`</ph> übergeben wird, an die entsprechende <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> -Implementierung, auch wenn <ph id="ph3">`value`</ph> ist <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">D. h. die <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> Implementierung bestimmt, wie ein angegebenes Element zu vergleicht <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (Log <ph id="ph1">`n`</ph>)-Vorgang, in dem <ph id="ph2">`n`</ph> ist die <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> von <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>The following code example shows how to use <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> to locate a specific object in an <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> zum Suchen eines bestimmten Objekts in ein <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>The array is created with its elements in ascending sort order.</source>
          <target state="translated">Das Array wird mit seiner Elemente in aufsteigender Reihenfolge erstellt.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> method requires the array to be sorted in ascending order.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> Methode erfordert das Array in aufsteigender Reihenfolge sortiert werden.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> verfügt über einen Typ, der nicht mit den Elementen von <ph id="ph2">&lt;paramref name="array" /&gt;</ph> kompatibel ist.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> does not implement the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> interface, and the search encounters an element that does not implement the <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> implementiert nicht die <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph>-Schnittstelle, und bei der Suche wird ein Element gefunden, das die <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph>-Schnittstelle nicht implementiert.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>The sorted one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Das zu durchsuchende sortierte eindimensionale <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>The object to search for.</source>
          <target state="translated">Das Objekt, nach dem gesucht werden soll.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>-Implementierung, die beim Vergleich von Elementen verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph>, wenn die <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph>-Implementierung des jeweiligen Elements verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>Searches an entire one-dimensional sorted array for a value using the specified <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> interface.</source>
          <target state="translated">Durchsucht ein ganzes sortiertes eindimensionales Array mithilfe der angegebenen <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>-Schnittstelle nach einem Wert.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated">Der Index des angegebenen <ph id="ph1">&lt;paramref name="value" /&gt;</ph> im angegebenen <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, sofern <ph id="ph3">&lt;paramref name="value" /&gt;</ph> gefunden wurde, andernfalls eine negative Zahl.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="value" /&gt;</ph> nicht gefunden wurde und <ph id="ph2">&lt;paramref name="value" /&gt;</ph> kleiner als mindestens ein Element in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <ph id="ph4">&lt;paramref name="value" /&gt;</ph> ist.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="value" /&gt;</ph> nicht gefunden wurde und <ph id="ph2">&lt;paramref name="value" /&gt;</ph> größer als alle Elemente in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1).</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Wenn diese Methode mit einem nicht sortierten <ph id="ph1">&lt;paramref name="array" /&gt;</ph> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <ph id="ph2">&lt;paramref name="value" /&gt;</ph> in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> vorhanden ist.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">Diese Methode unterstützt keine Suchen von Arrays, die negative Indizes enthalten.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> muss vor dem Aufrufen dieser Methode sortiert werden.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Array&gt;</ph> enthält keinen den angegebenen Wert gibt die Methode eine negative ganze Zahl zurück.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result  to produce an index.</source>
          <target state="translated">Sie können die bitweiser Komplementoperator anwenden (~ in c# <ph id="ph1">`Not`</ph> in Visual Basic) auf das Ergebnis negativ, um einen Index zu erzeugen.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If this index is one greater than the upper bound of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">Wenn dieser Index einer ist größer als die obere Grenze des Arrays, es sind keine Elemente größer als <ph id="ph1">`value`</ph> im Array.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">Andernfalls ist der Index des ersten Elements, das größer ist als <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>The comparer customizes how the elements are compared.</source>
          <target state="translated">Der Vergleich wird bestimmt, wie die Elemente verglichen werden.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>For example, you can use a <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> as the comparer to perform case-insensitive string searches.</source>
          <target state="translated">Beispielsweise können Sie eine <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> als Vergleich Groß-/Kleinschreibung Zeichenfolgensuche ausführen.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is not <ph id="ph2">`null`</ph>, the elements of <ph id="ph3">`array`</ph> are compared to the specified value using the specified <ph id="ph4">&lt;xref:System.Collections.IComparer&gt;</ph> implementation.</source>
          <target state="translated">Wenn <ph id="ph1">`comparer`</ph> nicht <ph id="ph2">`null`</ph>, die Elemente der <ph id="ph3">`array`</ph> verglichen werden, auf den angegebenen Wert mit dem angegebenen <ph id="ph4">&lt;xref:System.Collections.IComparer&gt;</ph> Implementierung.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by <ph id="ph2">`comparer`</ph>; otherwise, the result might be incorrect.</source>
          <target state="translated">Die Elemente der <ph id="ph1">`array`</ph> muss bereits in das Erhöhen des Werts gemäß der Sortierreihenfolge von definierten sortiert werden <ph id="ph2">`comparer`</ph>ist, andernfalls das Ergebnis möglicherweise nicht korrekt.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If<ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, the comparison is done using the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implementation provided by the element itself or by the specified value.</source>
          <target state="translated">Wenn<ph id="ph1">`comparer`</ph> ist <ph id="ph2">`null`</ph>, der Vergleich erfolgt mithilfe der <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> Implementierung, die durch das Element selbst oder durch den angegebenen Wert bereitgestellt.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Die Elemente der <ph id="ph1">`array`</ph> muss bereits in das Erhöhen des Werts gemäß der Sortierreihenfolge von definierten sortiert werden die <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> Implementierung; anderenfalls das Ergebnis möglicherweise nicht korrekt.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph> and <ph id="ph3">`value`</ph> does not implement the <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interface, the elements of <ph id="ph5">`array`</ph> are not tested for <ph id="ph6">&lt;xref:System.IComparable&gt;</ph> before the search begins.</source>
          <target state="translated">Wenn <ph id="ph1">`comparer`</ph> ist <ph id="ph2">`null`</ph> und <ph id="ph3">`value`</ph> implementiert nicht die <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> Schnittstelle, die Elemente der <ph id="ph5">`array`</ph> nicht getestet werden <ph id="ph6">&lt;xref:System.IComparable&gt;</ph> vor Beginn der Suche.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>An exception is thrown if the search encounters an element that does not implement <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</source>
          <target state="translated">Eine Ausnahme wird ausgelöst, wenn die Suche ein Element gefunden wird, die nicht implementiert <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">Doppelte Elemente sind zulässig.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Array&gt;</ph> enthält mehr als ein Element gleich <ph id="ph2">`value`</ph>, die Methode gibt den Index nur ein vorkommen, aber nicht unbedingt das erste Schema zurück.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception.</source>
          <target state="translated"><ph id="ph1">`null`</ph> kann mit anderen Verweistypen immer verglichen werden. Daher geben Vergleiche mit <ph id="ph2">`null`</ph> eine Ausnahme nicht generiert.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Für jedes Element getestet <ph id="ph1">`value`</ph> übergeben wird, an die entsprechende <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> -Implementierung, auch wenn <ph id="ph3">`value`</ph> ist <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">D. h. die <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> Implementierung bestimmt, wie ein angegebenes Element zu vergleicht <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (Log <ph id="ph1">`n`</ph>)-Vorgang, in dem <ph id="ph2">`n`</ph> ist die <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> von <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph4">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph> und <ph id="ph3">&lt;paramref name="value" /&gt;</ph> verfügt über einen Typ, der nicht mit den Elementen von <ph id="ph4">&lt;paramref name="array" /&gt;</ph> kompatibel ist.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="value" /&gt;</ph> does not implement the <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph> interface, and the search encounters an element that does not implement the <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> ist<ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="value" /&gt;</ph> implementiert nicht die <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph>-Schnittstelle, und bei der Suche wird ein Element gefunden, das die <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph>-Schnittstelle nicht implementiert.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>The sorted one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Das zu durchsuchende sortierte eindimensionale <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>The starting index of the range to search.</source>
          <target state="translated">Der Startindex des zu durchsuchenden Bereichs.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>The length of the range to search.</source>
          <target state="translated">Die Länge des zu durchsuchenden Bereichs.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>The object to search for.</source>
          <target state="translated">Das Objekt, nach dem gesucht werden soll.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>Searches a range of elements in a one-dimensional sorted array for a value, using the <ph id="ph1">&lt;see cref="T:System.IComparable" /&gt;</ph> interface implemented by each element of the array and by the specified value.</source>
          <target state="translated">Durchsucht einen Bereich von Elementen in einem sortierten eindimensionalen Array mithilfe der <ph id="ph1">&lt;see cref="T:System.IComparable" /&gt;</ph>-Schnittstelle, die von jedem Element des Arrays und durch den angegebenen Wert implementiert wird, nach einem Wert.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated">Der Index des angegebenen <ph id="ph1">&lt;paramref name="value" /&gt;</ph> im angegebenen <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, sofern <ph id="ph3">&lt;paramref name="value" /&gt;</ph> gefunden wurde, andernfalls eine negative Zahl.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="value" /&gt;</ph> nicht gefunden wurde und <ph id="ph2">&lt;paramref name="value" /&gt;</ph> kleiner als mindestens ein Element in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <ph id="ph4">&lt;paramref name="value" /&gt;</ph> ist.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="value" /&gt;</ph> nicht gefunden wurde und <ph id="ph2">&lt;paramref name="value" /&gt;</ph> größer als alle Elemente in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1).</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Wenn diese Methode mit einem nicht sortierten <ph id="ph1">&lt;paramref name="array" /&gt;</ph> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <ph id="ph2">&lt;paramref name="value" /&gt;</ph> in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> vorhanden ist.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">Diese Methode unterstützt keine Suchen von Arrays, die negative Indizes enthalten.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> muss vor dem Aufrufen dieser Methode sortiert werden.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Array&gt;</ph> enthält keinen den angegebenen Wert gibt die Methode eine negative ganze Zahl zurück.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result to produce an index.</source>
          <target state="translated">Sie können die bitweiser Komplementoperator anwenden (~ in c# <ph id="ph1">`Not`</ph> in Visual Basic) auf das Ergebnis negativ, um einen Index zu erzeugen.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>If this index is one greater than the upper bound of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">Wenn dieser Index einer ist größer als die obere Grenze des Arrays, es sind keine Elemente größer als <ph id="ph1">`value`</ph> im Array.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">Andernfalls ist der Index des ersten Elements, das größer ist als <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>Either <ph id="ph1">`value`</ph> or every element of <ph id="ph2">`array`</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface, which is used for comparisons.</source>
          <target state="translated">Entweder <ph id="ph1">`value`</ph> oder jedes Element des <ph id="ph2">`array`</ph> implementieren müssen die <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> -Schnittstelle, die für Vergleiche verwendet wird.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Die Elemente der <ph id="ph1">`array`</ph> muss bereits in das Erhöhen des Werts gemäß der Sortierreihenfolge von definierten sortiert werden die <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> Implementierung; anderenfalls das Ergebnis möglicherweise nicht korrekt.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>If <ph id="ph1">`value`</ph> does not implement the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> interface, the elements of <ph id="ph3">`array`</ph> are not tested for <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> before the search begins.</source>
          <target state="translated">Wenn <ph id="ph1">`value`</ph> implementiert nicht die <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> Schnittstelle, die Elemente der <ph id="ph3">`array`</ph> nicht getestet werden <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> vor Beginn der Suche.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>An exception is thrown if the search encounters an element that does not implement <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</source>
          <target state="translated">Eine Ausnahme wird ausgelöst, wenn die Suche ein Element gefunden wird, die nicht implementiert <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">Doppelte Elemente sind zulässig.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Array&gt;</ph> enthält mehr als ein Element gleich <ph id="ph2">`value`</ph>, die Methode gibt den Index nur ein vorkommen, aber nicht unbedingt das erste Schema zurück.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception.</source>
          <target state="translated"><ph id="ph1">`null`</ph> kann mit anderen Verweistypen immer verglichen werden. Daher geben Vergleiche mit <ph id="ph2">`null`</ph> eine Ausnahme nicht generiert.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Für jedes Element getestet <ph id="ph1">`value`</ph> übergeben wird, an die entsprechende <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> -Implementierung, auch wenn <ph id="ph3">`value`</ph> ist <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">D. h. die <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> Implementierung bestimmt, wie ein angegebenes Element zu vergleicht <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (Log <ph id="ph1">`n`</ph>)-Vorgang, in dem <ph id="ph2">`n`</ph> ist <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ist kleiner als die untere <ph id="ph2">&lt;paramref name="array" /&gt;</ph>-Grenze.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> und <ph id="ph2">&lt;paramref name="length" /&gt;</ph> geben keinen gültigen Bereich im <ph id="ph3">&lt;paramref name="array" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> verfügt über einen Typ, der nicht mit den Elementen von <ph id="ph2">&lt;paramref name="array" /&gt;</ph> kompatibel ist.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> does not implement the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> interface, and the search encounters an element that does not implement the <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> implementiert nicht die <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph>-Schnittstelle, und bei der Suche wird ein Element gefunden, das die <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph>-Schnittstelle nicht implementiert.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The sorted one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Das zu durchsuchende sortierte eindimensionale <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The starting index of the range to search.</source>
          <target state="translated">Der Startindex des zu durchsuchenden Bereichs.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The length of the range to search.</source>
          <target state="translated">Die Länge des zu durchsuchenden Bereichs.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The object to search for.</source>
          <target state="translated">Das Objekt, nach dem gesucht werden soll.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>-Implementierung, die beim Vergleich von Elementen verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph>, wenn die <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph>-Implementierung des jeweiligen Elements verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>Searches a range of elements in a one-dimensional sorted array for a value, using the specified <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> interface.</source>
          <target state="translated">Durchsucht einen Bereich von Elementen in einem sortierten eindimensionalen Array mithilfe der angegebenen <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>-Schnittstelle nach einem Wert.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated">Der Index des angegebenen <ph id="ph1">&lt;paramref name="value" /&gt;</ph> im angegebenen <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, sofern <ph id="ph3">&lt;paramref name="value" /&gt;</ph> gefunden wurde, andernfalls eine negative Zahl.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="value" /&gt;</ph> nicht gefunden wurde und <ph id="ph2">&lt;paramref name="value" /&gt;</ph> kleiner als mindestens ein Element in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <ph id="ph4">&lt;paramref name="value" /&gt;</ph> ist.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="value" /&gt;</ph> nicht gefunden wurde und <ph id="ph2">&lt;paramref name="value" /&gt;</ph> größer als alle Elemente in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1).</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Wenn diese Methode mit einem nicht sortierten <ph id="ph1">&lt;paramref name="array" /&gt;</ph> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <ph id="ph2">&lt;paramref name="value" /&gt;</ph> in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> vorhanden ist.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">Diese Methode unterstützt keine Suchen von Arrays, die negative Indizes enthalten.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> muss vor dem Aufrufen dieser Methode sortiert werden.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Array&gt;</ph> enthält keinen den angegebenen Wert gibt die Methode eine negative ganze Zahl zurück.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result  to produce an index.</source>
          <target state="translated">Sie können die bitweiser Komplementoperator anwenden (~ in c# <ph id="ph1">`Not`</ph> in Visual Basic) auf das Ergebnis negativ, um einen Index zu erzeugen.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If this index is one greater than the upper bound of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">Wenn dieser Index einer ist größer als die obere Grenze des Arrays, es sind keine Elemente größer als <ph id="ph1">`value`</ph> im Array.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">Andernfalls ist der Index des ersten Elements, das größer ist als <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The comparer customizes how the elements are compared.</source>
          <target state="translated">Der Vergleich wird bestimmt, wie die Elemente verglichen werden.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>For example, you can use a <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> as the comparer to perform case-insensitive string searches.</source>
          <target state="translated">Beispielsweise können Sie eine <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> als Vergleich Groß-/Kleinschreibung Zeichenfolgensuche ausführen.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is not <ph id="ph2">`null`</ph>, the elements of <ph id="ph3">`array`</ph> are compared to the specified value using the specified <ph id="ph4">&lt;xref:System.Collections.IComparer&gt;</ph> implementation.</source>
          <target state="translated">Wenn <ph id="ph1">`comparer`</ph> nicht <ph id="ph2">`null`</ph>, die Elemente der <ph id="ph3">`array`</ph> verglichen werden, auf den angegebenen Wert mit dem angegebenen <ph id="ph4">&lt;xref:System.Collections.IComparer&gt;</ph> Implementierung.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by <ph id="ph2">`comparer`</ph>; otherwise, the result might be incorrect.</source>
          <target state="translated">Die Elemente der <ph id="ph1">`array`</ph> muss bereits in das Erhöhen des Werts gemäß der Sortierreihenfolge von definierten sortiert werden <ph id="ph2">`comparer`</ph>ist, andernfalls das Ergebnis möglicherweise nicht korrekt.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, the comparison is done using the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> implementation provided by the element itself or by the specified value.</source>
          <target state="translated">Wenn <ph id="ph1">`comparer`</ph> ist <ph id="ph2">`null`</ph>, der Vergleich erfolgt mithilfe der <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> Implementierung, die durch das Element selbst oder durch den angegebenen Wert bereitgestellt.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Die Elemente der <ph id="ph1">`array`</ph> muss bereits in das Erhöhen des Werts gemäß der Sortierreihenfolge von definierten sortiert werden die <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> Implementierung; anderenfalls das Ergebnis möglicherweise nicht korrekt.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph> and <ph id="ph3">`value`</ph> does not implement the <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interface, the elements of <ph id="ph5">`array`</ph> are not tested for <ph id="ph6">&lt;xref:System.IComparable&gt;</ph> before the search begins.</source>
          <target state="translated">Wenn <ph id="ph1">`comparer`</ph> ist <ph id="ph2">`null`</ph> und <ph id="ph3">`value`</ph> implementiert nicht die <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> Schnittstelle, die Elemente der <ph id="ph5">`array`</ph> nicht getestet werden <ph id="ph6">&lt;xref:System.IComparable&gt;</ph> vor Beginn der Suche.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>An exception is thrown if the search encounters an element that does not implement <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</source>
          <target state="translated">Eine Ausnahme wird ausgelöst, wenn die Suche ein Element gefunden wird, die nicht implementiert <ph id="ph1">&lt;xref:System.IComparable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">Doppelte Elemente sind zulässig.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Array&gt;</ph> enthält mehr als ein Element gleich <ph id="ph2">`value`</ph>, die Methode gibt den Index nur ein vorkommen, aber nicht unbedingt das erste Schema zurück.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception when using <ph id="ph3">&lt;xref:System.IComparable&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`null`</ph> kann mit anderen Verweistypen immer verglichen werden. Daher geben Vergleiche mit <ph id="ph2">`null`</ph> eine Ausnahme nicht generiert, bei Verwendung von <ph id="ph3">&lt;xref:System.IComparable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Für jedes Element getestet <ph id="ph1">`value`</ph> übergeben wird, an die entsprechende <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> -Implementierung, auch wenn <ph id="ph3">`value`</ph> ist <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">D. h. die <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> Implementierung bestimmt, wie ein angegebenes Element zu vergleicht <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (Log <ph id="ph1">`n`</ph>)-Vorgang, in dem <ph id="ph2">`n`</ph> ist <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ist kleiner als die untere <ph id="ph2">&lt;paramref name="array" /&gt;</ph>-Grenze.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> und <ph id="ph2">&lt;paramref name="length" /&gt;</ph> geben keinen gültigen Bereich im <ph id="ph3">&lt;paramref name="array" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph4">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph> und <ph id="ph3">&lt;paramref name="value" /&gt;</ph> verfügt über einen Typ, der nicht mit den Elementen von <ph id="ph4">&lt;paramref name="array" /&gt;</ph> kompatibel ist.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="value" /&gt;</ph> does not implement the <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph> interface, and the search encounters an element that does not implement the <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> ist<ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;paramref name="value" /&gt;</ph> implementiert nicht die <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph>-Schnittstelle, und bei der Suche wird ein Element gefunden, das die <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph>-Schnittstelle nicht implementiert.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Der Typ der Elemente des Arrays.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The sorted one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Das zu durchsuchende sortierte eindimensionale und nullbasierte <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The object to search for.</source>
          <target state="translated">Das Objekt, nach dem gesucht werden soll.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>Searches an entire one-dimensional sorted array for a specific element, using the <ph id="ph1">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implemented by each element of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> and by the specified object.</source>
          <target state="translated">Durchsucht ein ganzes sortiertes eindimensionales Array mithilfe der generischen <ph id="ph1">&lt;see cref="T:System.IComparable`1" /&gt;</ph>-Schnittstelle, die von jedem Element des <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> und vom angegebenen Objekt implementiert wird, nach einem bestimmten Element.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated">Der Index des angegebenen <ph id="ph1">&lt;paramref name="value" /&gt;</ph> im angegebenen <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, sofern <ph id="ph3">&lt;paramref name="value" /&gt;</ph> gefunden wurde, andernfalls eine negative Zahl.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="value" /&gt;</ph> nicht gefunden wurde und <ph id="ph2">&lt;paramref name="value" /&gt;</ph> kleiner als mindestens ein Element in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <ph id="ph4">&lt;paramref name="value" /&gt;</ph> ist.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="value" /&gt;</ph> nicht gefunden wurde und <ph id="ph2">&lt;paramref name="value" /&gt;</ph> größer als alle Elemente in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1).</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Wenn diese Methode mit einem nicht sortierten <ph id="ph1">&lt;paramref name="array" /&gt;</ph> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <ph id="ph2">&lt;paramref name="value" /&gt;</ph> in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> vorhanden ist.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">Diese Methode unterstützt keine Suchen von Arrays, die negative Indizes enthalten.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> muss vor dem Aufrufen dieser Methode sortiert werden.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>If <ph id="ph1">`array`</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Wenn <ph id="ph1">`array`</ph> enthält keinen den angegebenen Wert gibt die Methode eine negative ganze Zahl zurück.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result  to produce an index.</source>
          <target state="translated">Sie können die bitweiser Komplementoperator anwenden (~ in c# <ph id="ph1">`Not`</ph> in Visual Basic) auf das Ergebnis negativ, um einen Index zu erzeugen.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>If this index is equal to the size of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">Wenn dieser Index gleich der Größe des Arrays ist, befinden sich keine Elemente größer als <ph id="ph1">`value`</ph> im Array.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">Andernfalls ist der Index des ersten Elements, das größer ist als <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source><ph id="ph1">`T`</ph> must implement the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> generic interface, which is used for comparisons.</source>
          <target state="translated"><ph id="ph1">`T`</ph> Implementieren Sie müssen die <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> generische Schnittstellen, die für Vergleiche verwendet wird.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Die Elemente der <ph id="ph1">`array`</ph> muss bereits in das Erhöhen des Werts gemäß der Sortierreihenfolge von definierten sortiert werden die <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> Implementierung; anderenfalls das Ergebnis möglicherweise nicht korrekt.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">Doppelte Elemente sind zulässig.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Array&gt;</ph> enthält mehr als ein Element gleich <ph id="ph2">`value`</ph>, die Methode gibt den Index nur ein vorkommen, aber nicht unbedingt das erste Schema zurück.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception.</source>
          <target state="translated"><ph id="ph1">`null`</ph> kann mit anderen Verweistypen immer verglichen werden. Daher geben Vergleiche mit <ph id="ph2">`null`</ph> eine Ausnahme nicht generiert.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Für jedes Element getestet <ph id="ph1">`value`</ph> übergeben wird, an die entsprechende <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> -Implementierung, auch wenn <ph id="ph3">`value`</ph> ist <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">D. h. die <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> Implementierung bestimmt, wie ein angegebenes Element zu vergleicht <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (Log <ph id="ph1">`n`</ph>)-Vorgang, in dem <ph id="ph2">`n`</ph> ist die <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> von <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%29&gt;</ph> generic method overload and the <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> generic method overload.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%29&gt;</ph> generischen methodenüberladung und die <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> generischen methodenüberladung.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>An array of strings is created, in no particular order.</source>
          <target state="translated">Ein Array von Zeichenfolgen wird erstellt, ohne bestimmte Reihenfolge.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The array is displayed, sorted, and displayed again.</source>
          <target state="translated">Das Array wird angezeigt, sortiert und erneut angezeigt.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>Arrays must be sorted in order to use the <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> method.</source>
          <target state="translated">Arrays müssen sortiert werden, um mithilfe der <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The calls to the <ph id="ph1">&lt;xref:System.Array.Sort%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</source>
          <target state="translated">Die Aufrufe an die <ph id="ph1">&lt;xref:System.Array.Sort%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> generische Methoden nicht suchen alle Aufrufe an ihre nicht generischen Entsprechungen unterscheiden, da Visual Basic, c# und C++ den Typ des vom Typ des ersten Arguments der generischen Typparameter abgeleitet werden.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Bei Verwendung der <bpt id="p1">[</bpt>Ildasm.exe (IL-Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> um die Microsoft intermediate Language (MSIL) zu untersuchen, sehen Sie, dass die generischen Methoden aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> generic method overload is then used to search for two strings, one that is not in the array and one that is.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> generischen methodenüberladung wird dann verwendet, um zwei Zeichenfolgen zu suchen, ist eine, die nicht in das Array und eine ist.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The array and the return value of the <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> method are passed to the <ph id="ph2">`ShowWhere`</ph> generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array.</source>
          <target state="translated">Das Array und den Rückgabewert der <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> an die Methode übergeben werden die <ph id="ph2">`ShowWhere`</ph> generische Methode, die den Indexwert zeigt an, wenn die Zeichenfolge gefunden wird, und andernfalls die Elemente die Suchzeichenfolge fallen würde zwischen wären im Array.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source>The index is negative if the string is not in the array, so the <ph id="ph1">`ShowWhere`</ph> method takes the bitwise complement (the ~ operator in C# and Visual C++, <ph id="ph2">`Xor`</ph>-1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</source>
          <target state="translated">Der Index ist negativ, wenn die Zeichenfolge nicht im Array wird also die <ph id="ph1">`ShowWhere`</ph> Methode nimmt das bitweise Komplement (die ~ Operator in c# und Visual C++ <ph id="ph2">`Xor`</ph>-1 in Visual Basic) um den Index des ersten Elements in der Liste zu erhalten, die größer ist als bei einer Suche str Ing.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0)">
          <source><ph id="ph1">&lt;paramref name="T" /&gt;</ph> does not implement the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Die generische <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph>-Schnittstelle wird von <ph id="ph1">&lt;paramref name="T" /&gt;</ph> nicht implementiert.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Der Typ der Elemente des Arrays.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The sorted one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Das zu durchsuchende sortierte eindimensionale und nullbasierte <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The object to search for.</source>
          <target state="translated">Das Objekt, nach dem gesucht werden soll.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph>-Implementierung, die beim Vergleich von Elementen verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph>, wenn die <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph>-Implementierung des jeweiligen Elements verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>Searches an entire one-dimensional sorted array for a value using the specified <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Durchsucht ein ganzes sortiertes eindimensionales Array mithilfe der angegebenen generischen <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph>-Schnittstelle nach einem Wert.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated">Der Index des angegebenen <ph id="ph1">&lt;paramref name="value" /&gt;</ph> im angegebenen <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, sofern <ph id="ph3">&lt;paramref name="value" /&gt;</ph> gefunden wurde, andernfalls eine negative Zahl.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="value" /&gt;</ph> nicht gefunden wurde und <ph id="ph2">&lt;paramref name="value" /&gt;</ph> kleiner als mindestens ein Element in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <ph id="ph4">&lt;paramref name="value" /&gt;</ph> ist.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="value" /&gt;</ph> nicht gefunden wurde und <ph id="ph2">&lt;paramref name="value" /&gt;</ph> größer als alle Elemente in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1).</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Wenn diese Methode mit einem nicht sortierten <ph id="ph1">&lt;paramref name="array" /&gt;</ph> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <ph id="ph2">&lt;paramref name="value" /&gt;</ph> in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> vorhanden ist.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">Diese Methode unterstützt keine Suchen von Arrays, die negative Indizes enthalten.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> muss vor dem Aufrufen dieser Methode sortiert werden.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Array&gt;</ph> enthält keinen den angegebenen Wert gibt die Methode eine negative ganze Zahl zurück.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result to produce an index.</source>
          <target state="translated">Sie können die bitweiser Komplementoperator anwenden (~ in c# <ph id="ph1">`Not`</ph> in Visual Basic) auf das Ergebnis negativ, um einen Index zu erzeugen.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If this index is equal to the size of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">Wenn dieser Index gleich der Größe des Arrays ist, befinden sich keine Elemente größer als <ph id="ph1">`value`</ph> im Array.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">Andernfalls ist der Index des ersten Elements, das größer ist als <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The comparer customizes how the elements are compared.</source>
          <target state="translated">Der Vergleich wird bestimmt, wie die Elemente verglichen werden.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>For example, you can use a <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> as the comparer to perform case-insensitive string searches.</source>
          <target state="translated">Beispielsweise können Sie eine <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> als Vergleich Groß-/Kleinschreibung Zeichenfolgensuche ausführen.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is not <ph id="ph2">`null`</ph>, the elements of <ph id="ph3">`array`</ph> are compared to the specified value using the specified <ph id="ph4">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> generic interface implementation.</source>
          <target state="translated">Wenn <ph id="ph1">`comparer`</ph> nicht <ph id="ph2">`null`</ph>, die Elemente der <ph id="ph3">`array`</ph> verglichen werden, auf den angegebenen Wert mit dem angegebenen <ph id="ph4">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> generische Implementierung.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by <ph id="ph2">`comparer`</ph>; otherwise, the result might be incorrect.</source>
          <target state="translated">Die Elemente der <ph id="ph1">`array`</ph> muss bereits in das Erhöhen des Werts gemäß der Sortierreihenfolge von definierten sortiert werden <ph id="ph2">`comparer`</ph>ist, andernfalls das Ergebnis möglicherweise nicht korrekt.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, the comparison is done using the <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> generic interface implementation provided by <ph id="ph4">`T`</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">`comparer`</ph> ist <ph id="ph2">`null`</ph>, der Vergleich erfolgt mithilfe der <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> generische Implementierung von bereitgestellten <ph id="ph4">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Die Elemente der <ph id="ph1">`array`</ph> muss bereits in das Erhöhen des Werts gemäß der Sortierreihenfolge von definierten sortiert werden die <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> Implementierung; anderenfalls das Ergebnis möglicherweise nicht korrekt.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph> and <ph id="ph3">`value`</ph> does not implement the <ph id="ph4">&lt;xref:System.IComparable%601&gt;</ph> generic interface, the elements of <ph id="ph5">`array`</ph> are not tested for <ph id="ph6">&lt;xref:System.IComparable%601&gt;</ph> before the search begins.</source>
          <target state="translated">Wenn <ph id="ph1">`comparer`</ph> ist <ph id="ph2">`null`</ph> und <ph id="ph3">`value`</ph> implementiert nicht die <ph id="ph4">&lt;xref:System.IComparable%601&gt;</ph> generische Schnittstelle, die Elemente der <ph id="ph5">`array`</ph> nicht getestet werden <ph id="ph6">&lt;xref:System.IComparable%601&gt;</ph> vor Beginn der Suche.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>An exception is thrown if the search encounters an element that does not implement <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph>.</source>
          <target state="translated">Eine Ausnahme wird ausgelöst, wenn die Suche ein Element gefunden wird, die nicht implementiert <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">Doppelte Elemente sind zulässig.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Array&gt;</ph> enthält mehr als ein Element gleich <ph id="ph2">`value`</ph>, die Methode gibt den Index nur ein vorkommen, aber nicht unbedingt das erste Schema zurück.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception.</source>
          <target state="translated"><ph id="ph1">`null`</ph> kann mit anderen Verweistypen immer verglichen werden. Daher geben Vergleiche mit <ph id="ph2">`null`</ph> eine Ausnahme nicht generiert.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Für jedes Element getestet <ph id="ph1">`value`</ph> übergeben wird, an die entsprechende <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> -Implementierung, auch wenn <ph id="ph3">`value`</ph> ist <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">D. h. die <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> Implementierung bestimmt, wie ein angegebenes Element zu vergleicht <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (Log <ph id="ph1">`n`</ph>)-Vorgang, in dem <ph id="ph2">`n`</ph> ist die <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> von <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload and the <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generischen methodenüberladung und die <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generischen methodenüberladung.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">Im Codebeispiel wird einen alternativer Vergleich für Zeichenfolgen, die mit dem Namen definiert <ph id="ph1">`ReverseCompare`</ph>, implementiert die <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generische Schnittstelle.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">Der Vergleich ruft die <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> -Methode, die Reihenfolge der verglichenen Elemente umkehren, sodass Zeichenfolgen hoch zu niedrig anstelle von niedrig zu hoch sortieren.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The array is displayed, sorted, and displayed again.</source>
          <target state="translated">Das Array wird angezeigt, sortiert und erneut angezeigt.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>Arrays must be sorted in order to use the <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> method.</source>
          <target state="translated">Arrays müssen sortiert werden, um mithilfe der <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The calls to the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</source>
          <target state="translated">Die Aufrufe an die <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> und <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generische Methoden nicht suchen alle Aufrufe an ihre nicht generischen Entsprechungen unterscheiden, da Visual Basic, c# und C++ den Typ des vom Typ des ersten Arguments der generischen Typparameter abgeleitet werden.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Bei Verwendung der <bpt id="p1">[</bpt>Ildasm.exe (IL-Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> um die Microsoft intermediate Language (MSIL) zu untersuchen, sehen Sie, dass die generischen Methoden aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload is then used to search for two strings, one that is not in the array and one that is.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generischen methodenüberladung wird dann verwendet, um zwei Zeichenfolgen zu suchen, ist eine, die nicht in das Array und eine ist.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The array and the return value of the <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> method are passed to the <ph id="ph2">`ShowWhere`</ph> generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array.</source>
          <target state="translated">Das Array und den Rückgabewert der <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> an die Methode übergeben werden die <ph id="ph2">`ShowWhere`</ph> generische Methode, die den Indexwert zeigt an, wenn die Zeichenfolge gefunden wird, und andernfalls die Elemente die Suchzeichenfolge fallen würde zwischen wären im Array.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source>The index is negative if the string is not n the array, so the <ph id="ph1">`ShowWhere`</ph> method takes the bitwise complement (the ~ operator in C# and Visual C++, <ph id="ph2">`Xor`</ph> -1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</source>
          <target state="translated">Der Index ist negativ, wenn die Zeichenfolge nicht n ist das Array daher die <ph id="ph1">`ShowWhere`</ph> Methode nimmt das bitweise Komplement (den ~ Operator in c# und Visual C++ <ph id="ph2">`Xor`</ph> -1 in Visual Basic) um den Index des ersten Elements in der Liste zu erhalten, die größer ist als die Suche d NG.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph4">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph> und <ph id="ph3">&lt;paramref name="value" /&gt;</ph> verfügt über einen Typ, der nicht mit den Elementen von <ph id="ph4">&lt;paramref name="array" /&gt;</ph> kompatibel ist.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="T" /&gt;</ph> does not implement the <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph> und <ph id="ph3">&lt;paramref name="T" /&gt;</ph> implementiert die generische <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph>-Schnittstelle nicht.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Der Typ der Elemente des Arrays.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>The sorted one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Das zu durchsuchende sortierte eindimensionale und nullbasierte <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>The starting index of the range to search.</source>
          <target state="translated">Der Startindex des zu durchsuchenden Bereichs.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>The length of the range to search.</source>
          <target state="translated">Die Länge des zu durchsuchenden Bereichs.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>The object to search for.</source>
          <target state="translated">Das Objekt, nach dem gesucht werden soll.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>Searches a range of elements in a one-dimensional sorted array for a value, using the <ph id="ph1">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implemented by each element of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> and by the specified value.</source>
          <target state="translated">Durchsucht einen Bereich von Elementen in einem sortierten eindimensionalen Array mithilfe der generischen <ph id="ph1">&lt;see cref="T:System.IComparable`1" /&gt;</ph>-Schnittstelle, die von jedem Element des <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> und vom angegebenen Wert implementiert wird, nach einem Wert.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated">Der Index des angegebenen <ph id="ph1">&lt;paramref name="value" /&gt;</ph> im angegebenen <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, sofern <ph id="ph3">&lt;paramref name="value" /&gt;</ph> gefunden wurde, andernfalls eine negative Zahl.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="value" /&gt;</ph> nicht gefunden wurde und <ph id="ph2">&lt;paramref name="value" /&gt;</ph> kleiner als mindestens ein Element in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <ph id="ph4">&lt;paramref name="value" /&gt;</ph> ist.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="value" /&gt;</ph> nicht gefunden wurde und <ph id="ph2">&lt;paramref name="value" /&gt;</ph> größer als alle Elemente in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1).</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Wenn diese Methode mit einem nicht sortierten <ph id="ph1">&lt;paramref name="array" /&gt;</ph> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <ph id="ph2">&lt;paramref name="value" /&gt;</ph> in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> vorhanden ist.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">Diese Methode unterstützt keine Suchen von Arrays, die negative Indizes enthalten.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> muss vor dem Aufrufen dieser Methode sortiert werden.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>If the array does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Wenn das Array nicht den angegebenen Wert enthält, gibt die Methode eine negative ganze Zahl zurück.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result  to produce an index.</source>
          <target state="translated">Sie können die bitweiser Komplementoperator anwenden (~ in c# <ph id="ph1">`Not`</ph> in Visual Basic) auf das Ergebnis negativ, um einen Index zu erzeugen.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>If this index is equal to the size of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">Wenn dieser Index gleich der Größe des Arrays ist, befinden sich keine Elemente größer als <ph id="ph1">`value`</ph> im Array.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">Andernfalls ist der Index des ersten Elements, das größer ist als <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">`T`</ph> must implement the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> generic interface, which is used for comparisons.</source>
          <target state="translated"><ph id="ph1">`T`</ph> Implementieren Sie müssen die <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> generische Schnittstellen, die für Vergleiche verwendet wird.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Die Elemente der <ph id="ph1">`array`</ph> muss bereits in das Erhöhen des Werts gemäß der Sortierreihenfolge von definierten sortiert werden die <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> Implementierung; anderenfalls das Ergebnis möglicherweise nicht korrekt.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">Doppelte Elemente sind zulässig.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Array&gt;</ph> enthält mehr als ein Element gleich <ph id="ph2">`value`</ph>, die Methode gibt den Index nur ein vorkommen, aber nicht unbedingt das erste Schema zurück.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception.</source>
          <target state="translated"><ph id="ph1">`null`</ph> kann mit anderen Verweistypen immer verglichen werden. Daher geben Vergleiche mit <ph id="ph2">`null`</ph> eine Ausnahme nicht generiert.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Für jedes Element getestet <ph id="ph1">`value`</ph> übergeben wird, an die entsprechende <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> -Implementierung, auch wenn <ph id="ph3">`value`</ph> ist <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">D. h. die <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> Implementierung bestimmt, wie ein angegebenes Element zu vergleicht <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (Log <ph id="ph1">`n`</ph>)-Vorgang, in dem <ph id="ph2">`n`</ph> ist <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ist kleiner als die Untergrenze von <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> und <ph id="ph2">&lt;paramref name="length" /&gt;</ph> geben keinen gültigen Bereich im <ph id="ph3">&lt;paramref name="array" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> verfügt über einen Typ, der nicht mit den Elementen von <ph id="ph2">&lt;paramref name="array" /&gt;</ph> kompatibel ist.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)">
          <source><ph id="ph1">&lt;paramref name="T" /&gt;</ph> does not implement the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Die generische <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph>-Schnittstelle wird von <ph id="ph1">&lt;paramref name="T" /&gt;</ph> nicht implementiert.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Der Typ der Elemente des Arrays.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The sorted one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Das zu durchsuchende sortierte eindimensionale und nullbasierte <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The starting index of the range to search.</source>
          <target state="translated">Der Startindex des zu durchsuchenden Bereichs.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The length of the range to search.</source>
          <target state="translated">Die Länge des zu durchsuchenden Bereichs.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The object to search for.</source>
          <target state="translated">Das Objekt, nach dem gesucht werden soll.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph>-Implementierung, die beim Vergleich von Elementen verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph>, wenn die <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph>-Implementierung des jeweiligen Elements verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>Searches a range of elements in a one-dimensional sorted array for a value, using the specified <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Durchsucht einen Bereich von Elementen in einem sortierten eindimensionalen Array mithilfe der angegebenen generischen <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph>-Schnittstelle nach einem Wert.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The index of the specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the specified <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is found; otherwise, a negative number.</source>
          <target state="translated">Der Index des angegebenen <ph id="ph1">&lt;paramref name="value" /&gt;</ph> im angegebenen <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, sofern <ph id="ph3">&lt;paramref name="value" /&gt;</ph> gefunden wurde, andernfalls eine negative Zahl.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is less than one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of the index of the first element that is larger than <ph id="ph4">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="value" /&gt;</ph> nicht gefunden wurde und <ph id="ph2">&lt;paramref name="value" /&gt;</ph> kleiner als mindestens ein Element in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <ph id="ph4">&lt;paramref name="value" /&gt;</ph> ist.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not found and <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is greater than all elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>, the negative number returned is the bitwise complement of (the index of the last element plus 1).</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="value" /&gt;</ph> nicht gefunden wurde und <ph id="ph2">&lt;paramref name="value" /&gt;</ph> größer als alle Elemente in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1).</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If this method is called with a non-sorted <ph id="ph1">&lt;paramref name="array" /&gt;</ph>, the return value can be incorrect and a negative number could be returned, even if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is present in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Wenn diese Methode mit einem nicht sortierten <ph id="ph1">&lt;paramref name="array" /&gt;</ph> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <ph id="ph2">&lt;paramref name="value" /&gt;</ph> in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> vorhanden ist.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>This method does not support searching arrays that contain negative indexes.</source>
          <target state="translated">Diese Methode unterstützt keine Suchen von Arrays, die negative Indizes enthalten.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">`array`</ph> must be sorted before calling this method.</source>
          <target state="translated"><ph id="ph1">`array`</ph> muss vor dem Aufrufen dieser Methode sortiert werden.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If the array does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Wenn das Array nicht den angegebenen Wert enthält, gibt die Methode eine negative ganze Zahl zurück.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>You can apply the bitwise complement operator (~ in C#, <ph id="ph1">`Not`</ph> in Visual Basic) to the negative result  to produce an index.</source>
          <target state="translated">Sie können die bitweiser Komplementoperator anwenden (~ in c# <ph id="ph1">`Not`</ph> in Visual Basic) auf das Ergebnis negativ, um einen Index zu erzeugen.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If this index is equal to the size of the array, there are no elements larger than <ph id="ph1">`value`</ph> in the array.</source>
          <target state="translated">Wenn dieser Index gleich der Größe des Arrays ist, befinden sich keine Elemente größer als <ph id="ph1">`value`</ph> im Array.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>Otherwise, it is the index of the first element that is larger than <ph id="ph1">`value`</ph>.</source>
          <target state="translated">Andernfalls ist der Index des ersten Elements, das größer ist als <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The comparer customizes how the elements are compared.</source>
          <target state="translated">Der Vergleich wird bestimmt, wie die Elemente verglichen werden.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>For example, you can use a <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> as the comparer to perform case-insensitive string searches.</source>
          <target state="translated">Beispielsweise können Sie eine <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType&gt;</ph> als Vergleich Groß-/Kleinschreibung Zeichenfolgensuche ausführen.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is not <ph id="ph2">`null`</ph>, the elements of <ph id="ph3">`array`</ph> are compared to the specified value using the specified <ph id="ph4">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> generic interface implementation.</source>
          <target state="translated">Wenn <ph id="ph1">`comparer`</ph> nicht <ph id="ph2">`null`</ph>, die Elemente der <ph id="ph3">`array`</ph> verglichen werden, auf den angegebenen Wert mit dem angegebenen <ph id="ph4">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> generische Implementierung.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by <ph id="ph2">`comparer`</ph>; otherwise, the result might be incorrect.</source>
          <target state="translated">Die Elemente der <ph id="ph1">`array`</ph> muss bereits in das Erhöhen des Werts gemäß der Sortierreihenfolge von definierten sortiert werden <ph id="ph2">`comparer`</ph>ist, andernfalls das Ergebnis möglicherweise nicht korrekt.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, the comparison is done using the <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> generic interface implementation provided for type <ph id="ph4">`T`</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">`comparer`</ph> ist <ph id="ph2">`null`</ph>, der Vergleich erfolgt mithilfe der <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> generische Implementierung für Typ bereitgestellten <ph id="ph4">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> must already be sorted in increasing value according to the sort order defined by the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation; otherwise, the result might be incorrect.</source>
          <target state="translated">Die Elemente der <ph id="ph1">`array`</ph> muss bereits in das Erhöhen des Werts gemäß der Sortierreihenfolge von definierten sortiert werden die <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> Implementierung; anderenfalls das Ergebnis möglicherweise nicht korrekt.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>Duplicate elements are allowed.</source>
          <target state="translated">Doppelte Elemente sind zulässig.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> contains more than one element equal to <ph id="ph2">`value`</ph>, the method returns the index of only one of the occurrences, and not necessarily the first one.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Array&gt;</ph> enthält mehr als ein Element gleich <ph id="ph2">`value`</ph>, die Methode gibt den Index nur ein vorkommen, aber nicht unbedingt das erste Schema zurück.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">`null`</ph> can always be compared with any other reference type; therefore, comparisons with <ph id="ph2">`null`</ph> do not generate an exception when using <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`null`</ph> kann mit anderen Verweistypen immer verglichen werden. Daher geben Vergleiche mit <ph id="ph2">`null`</ph> eine Ausnahme nicht generiert, bei Verwendung von <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>For every element tested, <ph id="ph1">`value`</ph> is passed to the appropriate <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> implementation, even if <ph id="ph3">`value`</ph> is <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Für jedes Element getestet <ph id="ph1">`value`</ph> übergeben wird, an die entsprechende <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> -Implementierung, auch wenn <ph id="ph3">`value`</ph> ist <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>That is, the <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> implementation determines how a given element compares to <ph id="ph2">`null`</ph>.</source>
          <target state="translated">D. h. die <ph id="ph1">&lt;xref:System.IComparable%601&gt;</ph> Implementierung bestimmt, wie ein angegebenes Element zu vergleicht <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>This method is an O(log <ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (Log <ph id="ph1">`n`</ph>)-Vorgang, in dem <ph id="ph2">`n`</ph> ist <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ist kleiner als die Untergrenze von <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> und <ph id="ph2">&lt;paramref name="length" /&gt;</ph> geben keinen gültigen Bereich im <ph id="ph3">&lt;paramref name="array" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is of a type that is not compatible with the elements of <ph id="ph4">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>, und <ph id="ph3">&lt;paramref name="value" /&gt;</ph> verfügt über einen Typ, der nicht mit den Elementen von <ph id="ph4">&lt;paramref name="array" /&gt;</ph> kompatibel ist.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="T" /&gt;</ph> does not implement the <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>, und <ph id="ph3">&lt;paramref name="T" /&gt;</ph> implementiert die generische <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph>-Schnittstelle nicht.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The array whose elements need to be cleared.</source>
          <target state="translated">Das Array, dessen Elemente gelöscht werden sollen.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The starting index of the range of elements to clear.</source>
          <target state="translated">Der Startindex für den Bereich der zu löschenden Elemente.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The number of elements to clear.</source>
          <target state="translated">Die Anzahl der zu löschenden Elemente.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>Sets a range of elements in an array to the default value of each element type.</source>
          <target state="translated">Legt einen Bereich von Elementen in einem Array mit dem Standardwert der einzelnen Elementtypen fest.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>This method resets each element in an array to the element type's default value.</source>
          <target state="translated">Diese Methode setzt auf den Elementtyp Standardwert jedes Element in einem Array zurück.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>It sets elements of reference types (including <ph id="ph1">&lt;xref:System.String&gt;</ph> elements) to <ph id="ph2">`null`</ph>, and sets elements of value types to the default values shown in the following table.</source>
          <target state="translated">Elemente von Verweistypen wird (einschließlich <ph id="ph1">&lt;xref:System.String&gt;</ph> Elemente), <ph id="ph2">`null`</ph>, und Elemente von Werttypen, die in der folgenden Tabelle aufgeführten Standardwerte festgelegt.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>Type</source>
          <target state="translated">Typ</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>Value</source>
          <target state="translated">Wert</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>All integral and floating point numeric types</source>
          <target state="translated">Alle numerischen Ganzzahl- und Gleitkommatyps Point-Typen</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>0 (zero)</source>
          <target state="translated">0 (null)</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>Other value types</source>
          <target state="translated">Andere Werttypen</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>Default value of the type's fields</source>
          <target state="translated">Standardwert, der die Felder des Typs</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The range of cleared elements wrap from row to row in a multi-dimensional array.</source>
          <target state="translated">Des Bereichs von Elementen Wrap deaktiviert von Zeile zu Zeile, in ein mehrdimensionales Array.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>This method only clears the values of the elements; it does not delete the elements themselves.</source>
          <target state="translated">Diese Methode löscht nur die Werte der Elemente. die Elemente selbst werden nicht gelöscht.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>An array has a fixed size; therefore, elements cannot be added or removed.</source>
          <target state="translated">Ein Array hat eine feste Größe; Daher können nicht Elemente hinzugefügt oder entfernt werden soll.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>) Vorgang, wobei <ph id="ph2">`n`</ph> ist <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Array.Clear%2A&gt;</ph> method to reset integer values in a one-dimensional, two-dimensional, and three-dimensional array.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.Array.Clear%2A&gt;</ph> Methode, um ganzzahlige Werte in ein eindimensionales, zweidimensionalen und dreidimensionale Array zurückzusetzen.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The following example defines a <ph id="ph1">`TimeZoneTime`</ph> structure that includes a <ph id="ph2">&lt;xref:System.TimeZoneInfo&gt;</ph> field and a <ph id="ph3">&lt;xref:System.DateTimeOffset&gt;</ph> field.</source>
          <target state="translated">Das folgende Beispiel definiert eine <ph id="ph1">`TimeZoneTime`</ph> -Struktur, die umfasst eine <ph id="ph2">&lt;xref:System.TimeZoneInfo&gt;</ph> Feld und einem <ph id="ph3">&lt;xref:System.DateTimeOffset&gt;</ph> Feld.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>It then calls the <ph id="ph1">&lt;xref:System.Array.Clear%2A&gt;</ph> method to clear one element in a two-element array of <ph id="ph2">`TimeZoneTime`</ph> values.</source>
          <target state="translated">Er ruft dann die <ph id="ph1">&lt;xref:System.Array.Clear%2A&gt;</ph> Methode, um ein Element in ein Array von zwei Elementen deaktivieren <ph id="ph2">`TimeZoneTime`</ph> Werte.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The method sets the value of the cleared element to the default value of a <ph id="ph1">&lt;xref:System.TimeZoneInfo&gt;</ph> object, which is <ph id="ph2">`null`</ph>, and the default value of a <ph id="ph3">&lt;xref:System.DateTimeOffset&gt;</ph> object, which is <ph id="ph4">&lt;xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Die Methode wird der Wert des gelöschten Elements auf den Standardwert einer <ph id="ph1">&lt;xref:System.TimeZoneInfo&gt;</ph> Objekt, das <ph id="ph2">`null`</ph>, und der Standardwert von einer <ph id="ph3">&lt;xref:System.DateTimeOffset&gt;</ph> Objekt, das <ph id="ph4">&lt;xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ist kleiner als die Untergrenze von <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Array.Clear(System.Array,System.Int32,System.Int32)">
          <source>The sum of <ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is greater than the size of <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Die Summe von <ph id="ph1">&lt;paramref name="index" /&gt;</ph> und <ph id="ph2">&lt;paramref name="length" /&gt;</ph> ist größer als die Größe des <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Array.Clone">
          <source>Creates a shallow copy of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Erstellt eine flache Kopie von <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Array.Clone">
          <source>A shallow copy of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Eine flache Kopie von <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clone">
          <source>A shallow copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies only the elements of the <ph id="ph2">&lt;xref:System.Array&gt;</ph>, whether they are reference types or value types, but it does not copy the objects that the references refer to.</source>
          <target state="translated">Eine flache Kopie von einer <ph id="ph1">&lt;xref:System.Array&gt;</ph> kopiert nur die Elemente von der <ph id="ph2">&lt;xref:System.Array&gt;</ph>, ob sie Verweis- oder Werttypen sind, aber die Objekte, die auf die verwiesen wird nicht kopiert.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clone">
          <source>The references in the new <ph id="ph1">&lt;xref:System.Array&gt;</ph> point to the same objects that the references in the original <ph id="ph2">&lt;xref:System.Array&gt;</ph> point to.</source>
          <target state="translated">Die Verweise in der neuen <ph id="ph1">&lt;xref:System.Array&gt;</ph> zeigen auf dieselben Objekte, die Verweise in der ursprünglichen <ph id="ph2">&lt;xref:System.Array&gt;</ph> zeigen Sie auf.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clone">
          <source>In contrast, a deep copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">Im Gegensatz dazu eine tiefe Kopie von einer <ph id="ph1">&lt;xref:System.Array&gt;</ph> kopiert die Elemente und alles, was auf die Elemente direkt oder indirekt verweist.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clone">
          <source>The clone is of the same <ph id="ph1">&lt;xref:System.Type&gt;</ph> as the original <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Der Klon hat die gleiche <ph id="ph1">&lt;xref:System.Type&gt;</ph> wie beim ursprünglichen <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clone">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>) Vorgang, wobei <ph id="ph2">`n`</ph> ist <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Clone">
          <source>The following code example clones a <ph id="ph1">&lt;xref:System.Globalization.CultureInfo?displayProperty=nameWithType&gt;</ph> array and demonstrates the behavior of a shallow copy.</source>
          <target state="translated">Im folgenden Beispiel wird codeklone ein <ph id="ph1">&lt;xref:System.Globalization.CultureInfo?displayProperty=nameWithType&gt;</ph> array erstellt und veranschaulicht das Verhalten von eine flache Kopie.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the data to copy.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>, das die zu kopierenden Daten enthält.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the index in the <bpt id="p1">&lt;c&gt;</bpt>sourceArray<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">Eine 32-Bit-Ganzzahl, die den Index im <bpt id="p1">&lt;c&gt;</bpt>sourceArray<ept id="p1">&lt;/c&gt;</ept> angibt, ab dem kopiert werden soll.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that receives the data.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>, das die Daten empfängt.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the index in the <bpt id="p1">&lt;c&gt;</bpt>destinationArray<ept id="p1">&lt;/c&gt;</ept> at which storing begins.</source>
          <target state="translated">Eine 32-Bit-Ganzzahl, die den Index im <bpt id="p1">&lt;c&gt;</bpt>destinationArray<ept id="p1">&lt;/c&gt;</ept> angibt, ab dem gespeichert werden soll.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the number of elements to copy.</source>
          <target state="translated">Eine 32-Bit-Ganzzahl, die die Anzahl der zu kopierenden Elemente darstellt.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Copies a range of elements from an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> starting at the specified source index and pastes them to another <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> starting at the specified destination index.</source>
          <target state="translated">Kopiert einen beim angegebenen Quellindex beginnenden Elementbereich aus einem <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> und fügt ihn ab dem angegebenen Zielindex in ein anderes <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> ein.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Guarantees that all changes are undone if the copy does not succeed completely.</source>
          <target state="translated">Stellt sicher, dass alle Änderungen rückgängig gemacht werden, wenn der Kopiervorgang nicht vollständig abgeschlossen wurde.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> parameters must have the same number of dimensions.</source>
          <target state="translated">Die <ph id="ph1">`sourceArray`</ph> und <ph id="ph2">`destinationArray`</ph> Parameter müssen die gleiche Anzahl von Dimensionen aufweisen.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`sourceArray`</ph> type must be the same as or derived from the <ph id="ph2">`destinationArray`</ph> type; otherwise, an <ph id="ph3">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown.</source>
          <target state="translated">Der <ph id="ph1">`sourceArray`</ph> Typ identisch sein müssen oder abgeleitet wurde. der <ph id="ph2">`destinationArray`</ph> handelt, andernfalls ein <ph id="ph3">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> ausgelöst.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Unlike <ph id="ph1">&lt;xref:System.Array.Copy%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.ConstrainedCopy%2A&gt;</ph> verifies the compatibility of the array types before performing any operation.</source>
          <target state="translated">Im Gegensatz zu <ph id="ph1">&lt;xref:System.Array.Copy%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.ConstrainedCopy%2A&gt;</ph> überprüft die Kompatibilität der Arraytypen vor dem Ausführen von Vorgängen.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end-to-end.</source>
          <target state="translated">Beim Kopieren zwischen mehrdimensionalen Arrays verhält sich das Array wie ein langes eindimensionales Array, in denen Zeilen (oder Spalten) konzeptionell End-to-End-angeordnet sind.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</source>
          <target state="translated">Wenn ein Array drei Zeilen (oder Spalten) mit vier Elementen, Kopieren von sechs Elementen vom Anfang des Arrays würde beispielsweise alle vier Elemente der ersten Zeile (oder Spalte) und die ersten beiden Elemente der zweiten Zeile (oder Spalte) kopieren.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>To start copying from the second element of the third row (or column), <ph id="ph1">`sourceIndex`</ph> must be the upper bound of the first row (or column) plus the length of the second row (or column) plus two.</source>
          <target state="translated">Zu kopierende aus dem zweiten Element der dritten Zeile (oder Spalte) <ph id="ph1">`sourceIndex`</ph> muss die obere Grenze der ersten Zeile (oder Spalte) plus 2 plus die Länge der zweiten Zeile (oder Spalte) sein.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> overlap, this method behaves as if the original values of <ph id="ph3">`sourceArray`</ph> were preserved in a temporary location before <ph id="ph4">`destinationArray`</ph> is overwritten.</source>
          <target state="translated">Wenn <ph id="ph1">`sourceArray`</ph> und <ph id="ph2">`destinationArray`</ph> überschneiden, die diese Methode verhält sich wie die ursprünglichen Werte der <ph id="ph3">`sourceArray`</ph> beibehalten wurden, in ein temporäres Verzeichnis vor <ph id="ph4">`destinationArray`</ph> überschrieben wird.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>[C++]</source>
          <target state="translated">[C++]</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>This method is equivalent to the standard C/C++ function <ph id="ph1">`memmove`</ph>, not <ph id="ph2">`memcpy`</ph>.</source>
          <target state="translated">Diese Methode entspricht der C/C++-Standardfunktion <ph id="ph1">`memmove`</ph>, nicht <ph id="ph2">`memcpy`</ph>.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The arrays can be reference-type arrays or value-type arrays.</source>
          <target state="translated">Die Arrays können Verweistyp-Arrays oder Werttyp Arrays sein.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> are both reference-type arrays or are both arrays of type <ph id="ph3">&lt;xref:System.Object&gt;</ph>, a shallow copy is performed.</source>
          <target state="translated">Wenn <ph id="ph1">`sourceArray`</ph> und <ph id="ph2">`destinationArray`</ph> Verweistyp-Arrays sind oder werden beide Arrays des Typs <ph id="ph3">&lt;xref:System.Object&gt;</ph>, eine flache Kopie ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A shallow copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is a new <ph id="ph2">&lt;xref:System.Array&gt;</ph> containing references to the same elements as the original <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Eine flache Kopie von einer <ph id="ph1">&lt;xref:System.Array&gt;</ph> ist ein neues <ph id="ph2">&lt;xref:System.Array&gt;</ph> enthält Verweise auf die gleichen Elemente wie die ursprüngliche <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The elements themselves or anything referenced by the elements are not copied.</source>
          <target state="translated">Die Elemente selbst oder einem beliebigen Element verwiesen wird, durch die Elemente werden nicht kopiert.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>In contrast, a deep copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">Im Gegensatz dazu eine tiefe Kopie von einer <ph id="ph1">&lt;xref:System.Array&gt;</ph> kopiert die Elemente und alles, was auf die Elemente direkt oder indirekt verweist.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>If this method throws an exception while copying, the <ph id="ph1">`destinationArray`</ph> remains unchanged; therefore, <ph id="ph2">&lt;xref:System.Array.ConstrainedCopy%2A&gt;</ph> can be used within a constrained execution region (<ph id="ph3">&lt;xref:System.Runtime.ConstrainedExecution.Cer&gt;</ph>).</source>
          <target state="translated">Wenn diese Methode eine während des Kopiervorgangs Ausnahme der <ph id="ph1">`destinationArray`</ph> unverändert; deshalb <ph id="ph2">&lt;xref:System.Array.ConstrainedCopy%2A&gt;</ph> innerhalb einer eingeschränkten Ausführungsbereich verwendet werden kann (<ph id="ph3">&lt;xref:System.Runtime.ConstrainedExecution.Cer&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>) Vorgang, wobei <ph id="ph2">`n`</ph> ist <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> have different ranks.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> und <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> sind von unterschiedlichem Rang.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> type is neither the same as nor derived from the <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> type.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph>-Typ entspricht weder dem <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>-Typ, noch wird er von diesem abgeleitet.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>At least one element in <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> cannot be cast to the type of <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated">Mindestens ein Element im <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> kann nicht in den Typ des <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>s umgewandelt werden.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph> is less than the lower bound of the first dimension of <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph> ist kleiner als die untere Grenze der ersten Dimension von <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="destinationIndex" /&gt;</ph> is less than the lower bound of the first dimension of <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationIndex" /&gt;</ph> ist kleiner als die untere Grenze der ersten Dimension von <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements from <ph id="ph2">&lt;paramref name="sourceIndex" /&gt;</ph> to the end of <ph id="ph3">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> ist größer als die Anzahl der Elemente vom <ph id="ph2">&lt;paramref name="sourceIndex" /&gt;</ph> bis zum Ende des <ph id="ph3">&lt;paramref name="sourceArray" /&gt;</ph>s.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements from <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> to the end of <ph id="ph3">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> ist größer als die Anzahl der Elemente vom <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> bis zum Ende des <ph id="ph3">&lt;paramref name="destinationArray" /&gt;</ph>s.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The type of the elements of the source array.</source>
          <target state="translated">Der Typ der Elemente des Quellarrays.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The type of the elements of the target array.</source>
          <target state="translated">Der Typ der Elemente des Zielarrays.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to convert to a target type.</source>
          <target state="translated">Das eindimensionale nullbasierte <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>, das in einen Zieltyp konvertiert werden soll.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>A <ph id="ph1">&lt;see cref="T:System.Converter`2" /&gt;</ph> that converts each element from one type to another type.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Converter`2" /&gt;</ph>, der jedes Element von einem Typ in einen anderen Typ konvertiert.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>Converts an array of one type to an array of another type.</source>
          <target state="translated">Konvertiert ein Array des einen Typs in ein Array eines anderen Typs.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>An array of the target type containing the converted elements from the source array.</source>
          <target state="translated">Ein Array des Zieltyps, das die konvertierten Elemente aus dem Quellarray enthält.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The <ph id="ph1">&lt;xref:System.Converter%602&gt;</ph> is a delegate to a method that converts an object to the target type.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Converter%602&gt;</ph> ist ein Delegat für eine Methode, die ein Objekt in den Zieltyp konvertiert.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Converter%602&gt;</ph>, and the converted elements are saved in the new array.</source>
          <target state="translated">Die Elemente der <ph id="ph1">`array`</ph> einzeln übergeben werden, um die <ph id="ph2">&lt;xref:System.Converter%602&gt;</ph>, und die konvertierten Elemente im neuen Array gespeichert werden.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The source <ph id="ph1">`array`</ph> remains unchanged.</source>
          <target state="translated">Die Quelle <ph id="ph1">`array`</ph> bleibt unverändert.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>)-Vorgang, in dem <ph id="ph2">`n`</ph> ist die <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> von <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The following code example defines a method named <ph id="ph1">`PointFToPoint`</ph> that converts a <ph id="ph2">&lt;xref:System.Drawing.PointF&gt;</ph> structure to a <ph id="ph3">&lt;xref:System.Drawing.Point&gt;</ph> structure.</source>
          <target state="translated">Das folgende Codebeispiel definiert eine Methode namens <ph id="ph1">`PointFToPoint`</ph> , konvertiert ein <ph id="ph2">&lt;xref:System.Drawing.PointF&gt;</ph> -Struktur in eine <ph id="ph3">&lt;xref:System.Drawing.Point&gt;</ph> Struktur.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The example then creates an array of <ph id="ph1">&lt;xref:System.Drawing.PointF&gt;</ph> structures, creates a <ph id="ph2">`Converter&lt;PointF, Point&gt;`</ph> delegate (<ph id="ph3">`Converter(Of PointF, Point)`</ph> in Visual Basic) to represent the <ph id="ph4">`PointFToPoint`</ph> method, and passes the delegate to the <ph id="ph5">&lt;xref:System.Array.ConvertAll%2A&gt;</ph> method.</source>
          <target state="translated">Im Beispiel wird ein Array von erstellt <ph id="ph1">&lt;xref:System.Drawing.PointF&gt;</ph> um Datenstrukturen handelt, erstellt eine <ph id="ph2">`Converter&lt;PointF, Point&gt;`</ph> delegieren (<ph id="ph3">`Converter(Of PointF, Point)`</ph> in Visual Basic) zur Darstellung der <ph id="ph4">`PointFToPoint`</ph> -Methode, und übergibt den Delegaten an die <ph id="ph5">&lt;xref:System.Array.ConvertAll%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>The <ph id="ph1">&lt;xref:System.Array.ConvertAll%2A&gt;</ph> method passes each element of the input list to the <ph id="ph2">`PointFToPoint`</ph> method and puts the converted elements into a new list of <ph id="ph3">&lt;xref:System.Drawing.Point&gt;</ph> structures.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.ConvertAll%2A&gt;</ph> Methode übergibt jedes Element der Eingabeliste an die <ph id="ph2">`PointFToPoint`</ph> Methode und legt die konvertierten Elemente in eine neue Liste mit <ph id="ph3">&lt;xref:System.Drawing.Point&gt;</ph> Strukturen.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>Both lists are displayed.</source>
          <target state="translated">Beide Listen werden angezeigt.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})">
          <source><ph id="ph1">&lt;paramref name="converter" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="converter" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Copies a range of elements in one <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to another <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> and performs type casting and boxing as required.</source>
          <target state="translated">Kopiert einen Bereich von Elementen eines <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> in ein anderes <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> und führt ggf. Typumwandlungen und Boxing durch.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the data to copy.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>, das die zu kopierenden Daten enthält.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that receives the data.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>, das die Daten empfängt.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>A 32-bit integer that represents the number of elements to copy.</source>
          <target state="translated">Eine 32-Bit-Ganzzahl, die die Anzahl der zu kopierenden Elemente darstellt.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>Copies a range of elements from an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> starting at the first element and pastes them into another <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> starting at the first element.</source>
          <target state="translated">Kopiert einen mit dem ersten Element beginnenden Elementbereich eines <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> und fügt ihn ab dem ersten Element in ein anderes <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> ein.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>The length is specified as a 32-bit integer.</source>
          <target state="translated">Die Länge wird als 32-Bit-Ganzzahl angegeben.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>The <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> parameters must have the same number of dimensions.</source>
          <target state="translated">Die <ph id="ph1">`sourceArray`</ph> und <ph id="ph2">`destinationArray`</ph> Parameter müssen die gleiche Anzahl von Dimensionen aufweisen.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>In addition, <ph id="ph1">`destinationArray`</ph> must already have been dimensioned and must have a sufficient number of elements to accommodate the copied data.</source>
          <target state="translated">Darüber hinaus <ph id="ph1">`destinationArray`</ph> muss bereits haben wurde dimensioniert und muss eine ausreichende Anzahl von Elementen, die die kopierten Daten aufzunehmen.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end to end.</source>
          <target state="translated">Beim Kopieren zwischen mehrdimensionalen Arrays verhält sich das Array wie ein langes eindimensionales Array, in denen Zeilen (oder Spalten) konzeptionell End-to-End angeordnet sind.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</source>
          <target state="translated">Wenn ein Array drei Zeilen (oder Spalten) mit vier Elementen, Kopieren von sechs Elementen vom Anfang des Arrays würde beispielsweise alle vier Elemente der ersten Zeile (oder Spalte) und die ersten beiden Elemente der zweiten Zeile (oder Spalte) kopieren.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> overlap, this method behaves as if the original values of <ph id="ph3">`sourceArray`</ph> were preserved in a temporary location before <ph id="ph4">`destinationArray`</ph> is overwritten.</source>
          <target state="translated">Wenn <ph id="ph1">`sourceArray`</ph> und <ph id="ph2">`destinationArray`</ph> überschneiden, die diese Methode verhält sich wie die ursprünglichen Werte der <ph id="ph3">`sourceArray`</ph> beibehalten wurden, in ein temporäres Verzeichnis vor <ph id="ph4">`destinationArray`</ph> überschrieben wird.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>[C++]</source>
          <target state="translated">[C++]</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>This method is equivalent to the standard C/C++ function <ph id="ph1">`memmove`</ph>, not <ph id="ph2">`memcpy`</ph>.</source>
          <target state="translated">Diese Methode entspricht der C/C++-Standardfunktion <ph id="ph1">`memmove`</ph>, nicht <ph id="ph2">`memcpy`</ph>.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>The arrays can be reference-type arrays or value-type arrays.</source>
          <target state="translated">Die Arrays können Verweistyp-Arrays oder Werttyp Arrays sein.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>Type downcasting is performed, as required.</source>
          <target state="translated">Es erfolgt eine Umwandlung des Typs, wie erforderlich.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</source>
          <target state="translated">Beim Kopieren von einem Referenztyp Array in ein Array von Werttyp wird jedes Element mittels Unboxing zurückkonvertiert und kopiert.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>When copying from a value-type array to a reference-type array, each element is boxed and then copied.</source>
          <target state="translated">Wenn von einem Werttyp Array in ein Array von Verweistypen zu kopieren, wird jedes Element geschachtelt und kopiert.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>When copying from a reference-type or value-type array to an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array, an <ph id="ph2">&lt;xref:System.Object&gt;</ph> is created to hold each value or reference and then copied.</source>
          <target state="translated">Beim Kopieren aus einem Array-Verweistyp oder Werttyp in einen <ph id="ph1">&lt;xref:System.Object&gt;</ph> Array, ein <ph id="ph2">&lt;xref:System.Object&gt;</ph> erstellt, um jeden Wert oder Verweis aufzunehmen und anschließend kopiert wird.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>When copying from an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array to a reference-type or value-type array and the assignment is not possible, an <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">Beim Kopieren aus einer <ph id="ph1">&lt;xref:System.Object&gt;</ph> Array in ein Array-Verweistyp oder Werttyp und die Zuweisung ist nicht möglich, eine <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> ausgelöst wird.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> are both reference-type arrays or are both arrays of type <ph id="ph3">&lt;xref:System.Object&gt;</ph>, a shallow copy is performed.</source>
          <target state="translated">Wenn <ph id="ph1">`sourceArray`</ph> und <ph id="ph2">`destinationArray`</ph> Verweistyp-Arrays sind oder werden beide Arrays des Typs <ph id="ph3">&lt;xref:System.Object&gt;</ph>, eine flache Kopie ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>A shallow copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is a new <ph id="ph2">&lt;xref:System.Array&gt;</ph> containing references to the same elements as the original <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Eine flache Kopie von einer <ph id="ph1">&lt;xref:System.Array&gt;</ph> ist ein neues <ph id="ph2">&lt;xref:System.Array&gt;</ph> enthält Verweise auf die gleichen Elemente wie die ursprüngliche <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>The elements themselves or anything referenced by the elements are not copied.</source>
          <target state="translated">Die Elemente selbst oder einem beliebigen Element verwiesen wird, durch die Elemente werden nicht kopiert.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>In contrast, a deep copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">Im Gegensatz dazu eine tiefe Kopie von einer <ph id="ph1">&lt;xref:System.Array&gt;</ph> kopiert die Elemente und alles, was auf die Elemente direkt oder indirekt verweist.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>An <ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if the arrays are of incompatible types.</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> wird ausgelöst, wenn die Arrays von inkompatiblen Typen sind.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>Type compatibility is defined as follows:</source>
          <target state="translated">Typkompatibilität ist wie folgt definiert:</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>A type is compatible with itself.</source>
          <target state="translated">Ein Typ ist mit sich selbst kompatibel.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>A value type is compatible with <ph id="ph1">&lt;xref:System.Object&gt;</ph> and with an interface type implemented by that value type.</source>
          <target state="translated">Ein Werttyp ist kompatibel mit <ph id="ph1">&lt;xref:System.Object&gt;</ph> und mit einem Schnittstellentyp, der durch diesen Werttyp implementiert.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>A value type is considered connected to an interface only if it implements that interface directly.</source>
          <target state="translated">Ein Werttyp gilt nur, wenn sie diese Schnittstelle, direkt implementiert mit einer Schnittstelle verbunden.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>Disconnected types are not compatible.</source>
          <target state="translated">Nicht verbundene Typen sind nicht kompatibel.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</source>
          <target state="translated">Zwei systeminterne (vordefinierte) Werttypen sind kompatibel, wenn kopieren aus einer Datenquelle in den Zieltyp eine erweiternde Konvertierung ist.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>A widening conversion never loses information, whereas a narrowing conversion can lose information.</source>
          <target state="translated">Nie eine erweiternde Konvertierung verliert Informationen an, während eine einschränkende Konvertierung Informationen verloren gehen kann.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</source>
          <target state="translated">Z. B. eine erweiternde Konvertierung ist eine 32-Bit-Ganzzahl mit Vorzeichen in eine 64-Bit-Ganzzahl mit Vorzeichen zu konvertieren, und konvertieren eine 64-Bit-Ganzzahl mit Vorzeichen in eine 32-Bit-Ganzzahl mit Vorzeichen ist eine einschränkende Konvertierung.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zu Konvertierungen finden Sie unter <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>A nonintrinsic (user-defined) value type is compatible only with itself.</source>
          <target state="translated">Ein systeminterner (Benutzerdefiniert) Werttyp ist nur mit sich selbst kompatibel.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>Enumerations have an implicit conversion to <ph id="ph1">&lt;xref:System.Enum&gt;</ph> and to their underlying type.</source>
          <target state="translated">Enumerationen verfügen über eine implizite Konvertierung in <ph id="ph1">&lt;xref:System.Enum&gt;</ph> und ihren zugrunde liegenden Typ.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>If every element in <ph id="ph1">`sourceArray`</ph> requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in <ph id="ph2">`destinationArray`</ph>, an <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">Wenn jedes Element in <ph id="ph1">`sourceArray`</ph> eine Umwandlung erfordert (z. B. von einer Basisklasse in einer abgeleiteten Klasse oder von einer Schnittstelle zu einem Objekt) und einem oder mehreren Elementen können nicht in den entsprechenden Typ umgewandelt werden <ph id="ph2">`destinationArray`</ph>, wird eine <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> ausgelöst wird.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>If this method throws an exception while copying, the state of <ph id="ph1">`destinationArray`</ph> is undefined.</source>
          <target state="translated">Wenn diese Methode eine Ausnahme während des Kopiervorgangs, des Status des <ph id="ph1">`destinationArray`</ph> ist nicht definiert.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>) Vorgang, wobei <ph id="ph2">`n`</ph> ist <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> have different ranks.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> und <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> sind von unterschiedlichem Rang.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> are of incompatible types.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> und <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> weisen inkompatible Typen auf.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>At least one element in <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> cannot be cast to the type of <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated">Mindestens ein Element in <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> kann nicht in den <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>-Typ umgewandelt werden.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements in <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> ist größer als die Anzahl von Elementen in <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements in <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> ist größer als die Anzahl von Elementen in <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the data to copy.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>, das die zu kopierenden Daten enthält.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that receives the data.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>, das die Daten empfängt.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>A 64-bit integer that represents the number of elements to copy.</source>
          <target state="translated">Eine 64-Bit-Ganzzahl, die die Anzahl der zu kopierenden Elemente darstellt.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>The integer must be between zero and <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>, inclusive.</source>
          <target state="translated">Die Ganzzahl muss zwischen 0 (null) und einschließlich <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> liegen.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>Copies a range of elements from an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> starting at the first element and pastes them into another <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> starting at the first element.</source>
          <target state="translated">Kopiert einen mit dem ersten Element beginnenden Elementbereich eines <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> und fügt ihn ab dem ersten Element in ein anderes <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> ein.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>The length is specified as a 64-bit integer.</source>
          <target state="translated">Die Länge wird als 64-Bit-Ganzzahl angegeben.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>The <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> parameters must have the same number of dimensions.</source>
          <target state="translated">Die <ph id="ph1">`sourceArray`</ph> und <ph id="ph2">`destinationArray`</ph> Parameter müssen die gleiche Anzahl von Dimensionen aufweisen.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>In addition, <ph id="ph1">`destinationArray`</ph> must already have been dimensioned and must have a sufficient number of elements to accommodate the copied data.</source>
          <target state="translated">Darüber hinaus <ph id="ph1">`destinationArray`</ph> muss bereits haben wurde dimensioniert und muss eine ausreichende Anzahl von Elementen, die die kopierten Daten aufzunehmen.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end to end.</source>
          <target state="translated">Beim Kopieren zwischen mehrdimensionalen Arrays verhält sich das Array wie ein langes eindimensionales Array, in denen Zeilen (oder Spalten) konzeptionell End-to-End angeordnet sind.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</source>
          <target state="translated">Wenn ein Array drei Zeilen (oder Spalten) mit vier Elementen, Kopieren von sechs Elementen vom Anfang des Arrays würde beispielsweise alle vier Elemente der ersten Zeile (oder Spalte) und die ersten beiden Elemente der zweiten Zeile (oder Spalte) kopieren.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> overlap, this method behaves as if the original values of <ph id="ph3">`sourceArray`</ph> were preserved in a temporary location before <ph id="ph4">`destinationArray`</ph> is overwritten.</source>
          <target state="translated">Wenn <ph id="ph1">`sourceArray`</ph> und <ph id="ph2">`destinationArray`</ph> überschneiden, die diese Methode verhält sich wie die ursprünglichen Werte der <ph id="ph3">`sourceArray`</ph> beibehalten wurden, in ein temporäres Verzeichnis vor <ph id="ph4">`destinationArray`</ph> überschrieben wird.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>[C++]</source>
          <target state="translated">[C++]</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>This method is equivalent to the standard C/C++ function <ph id="ph1">`memmove`</ph>, not <ph id="ph2">`memcpy`</ph>.</source>
          <target state="translated">Diese Methode entspricht der C/C++-Standardfunktion <ph id="ph1">`memmove`</ph>, nicht <ph id="ph2">`memcpy`</ph>.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>The arrays can be reference-type arrays or value-type arrays.</source>
          <target state="translated">Die Arrays können Verweistyp-Arrays oder Werttyp Arrays sein.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>Type downcasting is performed, as required.</source>
          <target state="translated">Es erfolgt eine Umwandlung des Typs, wie erforderlich.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</source>
          <target state="translated">Beim Kopieren von einem Referenztyp Array in ein Array von Werttyp wird jedes Element mittels Unboxing zurückkonvertiert und kopiert.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>When copying from a value-type array to a reference-type array, each element is boxed and then copied.</source>
          <target state="translated">Wenn von einem Werttyp Array in ein Array von Verweistypen zu kopieren, wird jedes Element geschachtelt und kopiert.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>When copying from a reference-type or value-type array to an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array, an <ph id="ph2">&lt;xref:System.Object&gt;</ph> is created to hold each value or reference and then copied.</source>
          <target state="translated">Beim Kopieren aus einem Array-Verweistyp oder Werttyp in einen <ph id="ph1">&lt;xref:System.Object&gt;</ph> Array, ein <ph id="ph2">&lt;xref:System.Object&gt;</ph> erstellt, um jeden Wert oder Verweis aufzunehmen und anschließend kopiert wird.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>When copying from an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array to a reference-type or value-type array and the assignment is not possible, an <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">Beim Kopieren aus einer <ph id="ph1">&lt;xref:System.Object&gt;</ph> Array in ein Array-Verweistyp oder Werttyp und die Zuweisung ist nicht möglich, eine <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> ausgelöst wird.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> are both reference-type arrays or are both arrays of type <ph id="ph3">&lt;xref:System.Object&gt;</ph>, a shallow copy is performed.</source>
          <target state="translated">Wenn <ph id="ph1">`sourceArray`</ph> und <ph id="ph2">`destinationArray`</ph> Verweistyp-Arrays sind oder werden beide Arrays des Typs <ph id="ph3">&lt;xref:System.Object&gt;</ph>, eine flache Kopie ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>A shallow copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is a new <ph id="ph2">&lt;xref:System.Array&gt;</ph> containing references to the same elements as the original <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Eine flache Kopie von einer <ph id="ph1">&lt;xref:System.Array&gt;</ph> ist ein neues <ph id="ph2">&lt;xref:System.Array&gt;</ph> enthält Verweise auf die gleichen Elemente wie die ursprüngliche <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>The elements themselves or anything referenced by the elements are not copied.</source>
          <target state="translated">Die Elemente selbst oder einem beliebigen Element verwiesen wird, durch die Elemente werden nicht kopiert.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>In contrast, a deep copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">Im Gegensatz dazu eine tiefe Kopie von einer <ph id="ph1">&lt;xref:System.Array&gt;</ph> kopiert die Elemente und alles, was auf die Elemente direkt oder indirekt verweist.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>An <ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if the arrays are of incompatible types.</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> wird ausgelöst, wenn die Arrays von inkompatiblen Typen sind.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>Type compatibility is defined as follows:</source>
          <target state="translated">Typkompatibilität ist wie folgt definiert:</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>A type is compatible with itself.</source>
          <target state="translated">Ein Typ ist mit sich selbst kompatibel.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>A value type is compatible with <ph id="ph1">&lt;xref:System.Object&gt;</ph> and with an interface type implemented by that value type.</source>
          <target state="translated">Ein Werttyp ist kompatibel mit <ph id="ph1">&lt;xref:System.Object&gt;</ph> und mit einem Schnittstellentyp, der durch diesen Werttyp implementiert.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>A value type is considered connected to an interface only if it implements that interface directly.</source>
          <target state="translated">Ein Werttyp gilt nur, wenn sie diese Schnittstelle, direkt implementiert mit einer Schnittstelle verbunden.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>Disconnected types are not compatible.</source>
          <target state="translated">Nicht verbundene Typen sind nicht kompatibel.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</source>
          <target state="translated">Zwei systeminterne (vordefinierte) Werttypen sind kompatibel, wenn kopieren aus einer Datenquelle in den Zieltyp eine erweiternde Konvertierung ist.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>A widening conversion never loses information, whereas a narrowing conversion can lose information.</source>
          <target state="translated">Nie eine erweiternde Konvertierung verliert Informationen an, während eine einschränkende Konvertierung Informationen verloren gehen kann.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</source>
          <target state="translated">Z. B. eine erweiternde Konvertierung ist eine 32-Bit-Ganzzahl mit Vorzeichen in eine 64-Bit-Ganzzahl mit Vorzeichen zu konvertieren, und konvertieren eine 64-Bit-Ganzzahl mit Vorzeichen in eine 32-Bit-Ganzzahl mit Vorzeichen ist eine einschränkende Konvertierung.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zu Konvertierungen finden Sie unter <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>A nonintrinsic (user-defined) value type is compatible only with itself.</source>
          <target state="translated">Ein systeminterner (Benutzerdefiniert) Werttyp ist nur mit sich selbst kompatibel.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>Enumerations have an implicit conversion to <ph id="ph1">&lt;xref:System.Enum&gt;</ph> and to their underlying type.</source>
          <target state="translated">Enumerationen verfügen über eine implizite Konvertierung in <ph id="ph1">&lt;xref:System.Enum&gt;</ph> und ihren zugrunde liegenden Typ.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>If every element in <ph id="ph1">`sourceArray`</ph> requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in <ph id="ph2">`destinationArray`</ph>, an <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">Wenn jedes Element in <ph id="ph1">`sourceArray`</ph> eine Umwandlung erfordert (z. B. von einer Basisklasse in einer abgeleiteten Klasse oder von einer Schnittstelle zu einem Objekt) und einem oder mehreren Elementen können nicht in den entsprechenden Typ umgewandelt werden <ph id="ph2">`destinationArray`</ph>, wird eine <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> ausgelöst wird.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>If this method throws an exception while copying, the state of <ph id="ph1">`destinationArray`</ph> is undefined.</source>
          <target state="translated">Wenn diese Methode eine Ausnahme während des Kopiervorgangs, des Status des <ph id="ph1">`destinationArray`</ph> ist nicht definiert.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>) Vorgang, wobei <ph id="ph2">`n`</ph> ist <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> have different ranks.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> und <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> sind von unterschiedlichem Rang.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> are of incompatible types.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> und <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> weisen inkompatible Typen auf.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>At least one element in <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> cannot be cast to the type of <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated">Mindestens ein Element im <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> kann nicht in den Typ des <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>s umgewandelt werden.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than 0 or greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> ist kleiner als 0 oder größer als <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements in <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> ist größer als die Anzahl von Elementen in <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements in <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> ist größer als die Anzahl von Elementen in <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the data to copy.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>, das die zu kopierenden Daten enthält.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the index in the <bpt id="p1">&lt;c&gt;</bpt>sourceArray<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">Eine 32-Bit-Ganzzahl, die den Index im <bpt id="p1">&lt;c&gt;</bpt>sourceArray<ept id="p1">&lt;/c&gt;</ept> angibt, ab dem kopiert werden soll.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that receives the data.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>, das die Daten empfängt.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the index in the <bpt id="p1">&lt;c&gt;</bpt>destinationArray<ept id="p1">&lt;/c&gt;</ept> at which storing begins.</source>
          <target state="translated">Eine 32-Bit-Ganzzahl, die den Index im <bpt id="p1">&lt;c&gt;</bpt>destinationArray<ept id="p1">&lt;/c&gt;</ept> angibt, ab dem gespeichert werden soll.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the number of elements to copy.</source>
          <target state="translated">Eine 32-Bit-Ganzzahl, die die Anzahl der zu kopierenden Elemente darstellt.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Copies a range of elements from an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> starting at the specified source index and pastes them to another <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> starting at the specified destination index.</source>
          <target state="translated">Kopiert einen beim angegebenen Quellindex beginnenden Elementbereich aus einem <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> und fügt ihn ab dem angegebenen Zielindex in ein anderes <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> ein.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The length and the indexes are specified as 32-bit integers.</source>
          <target state="translated">Die Länge und die Indizes werden als 32-Bit-Ganzzahlen angegeben.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> parameters must have the same number of dimensions.</source>
          <target state="translated">Die <ph id="ph1">`sourceArray`</ph> und <ph id="ph2">`destinationArray`</ph> Parameter müssen die gleiche Anzahl von Dimensionen aufweisen.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>In addition, <ph id="ph1">`destinationArray`</ph> must already have been dimensioned and must have a sufficient number of elements starting from the <ph id="ph2">`destinationIndex`</ph> position to accommodate the copied data.</source>
          <target state="translated">Darüber hinaus <ph id="ph1">`destinationArray`</ph> muss bereits haben wurde dimensioniert und muss eine ausreichende Anzahl von Elementen, beginnend mit der <ph id="ph2">`destinationIndex`</ph> Position, um die kopierten Daten aufzunehmen.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end-to-end.</source>
          <target state="translated">Beim Kopieren zwischen mehrdimensionalen Arrays verhält sich das Array wie ein langes eindimensionales Array, in denen Zeilen (oder Spalten) konzeptionell End-to-End-angeordnet sind.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</source>
          <target state="translated">Wenn ein Array drei Zeilen (oder Spalten) mit vier Elementen, Kopieren von sechs Elementen vom Anfang des Arrays würde beispielsweise alle vier Elemente der ersten Zeile (oder Spalte) und die ersten beiden Elemente der zweiten Zeile (oder Spalte) kopieren.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>To start copying from the second element of the third row (or column), <ph id="ph1">`sourceIndex`</ph> must be the upper bound of the first row (or column) plus the length of the second row (or column) plus two.</source>
          <target state="translated">Zu kopierende aus dem zweiten Element der dritten Zeile (oder Spalte) <ph id="ph1">`sourceIndex`</ph> muss die obere Grenze der ersten Zeile (oder Spalte) plus 2 plus die Länge der zweiten Zeile (oder Spalte) sein.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> overlap, this method behaves as if the original values of <ph id="ph3">`sourceArray`</ph> were preserved in a temporary location before <ph id="ph4">`destinationArray`</ph> is overwritten.</source>
          <target state="translated">Wenn <ph id="ph1">`sourceArray`</ph> und <ph id="ph2">`destinationArray`</ph> überschneiden, die diese Methode verhält sich wie die ursprünglichen Werte der <ph id="ph3">`sourceArray`</ph> beibehalten wurden, in ein temporäres Verzeichnis vor <ph id="ph4">`destinationArray`</ph> überschrieben wird.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>[C++]</source>
          <target state="translated">[C++]</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>This method is equivalent to the standard C/C++ function <ph id="ph1">`memmove`</ph>, not <ph id="ph2">`memcpy`</ph>.</source>
          <target state="translated">Diese Methode entspricht der C/C++-Standardfunktion <ph id="ph1">`memmove`</ph>, nicht <ph id="ph2">`memcpy`</ph>.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The arrays can be reference-type arrays or value-type arrays.</source>
          <target state="translated">Die Arrays können Verweistyp-Arrays oder Werttyp Arrays sein.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Type downcasting is performed, as required.</source>
          <target state="translated">Es erfolgt eine Umwandlung des Typs, wie erforderlich.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</source>
          <target state="translated">Beim Kopieren von einem Referenztyp Array in ein Array von Werttyp wird jedes Element mittels Unboxing zurückkonvertiert und kopiert.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>When copying from a value-type array to a reference-type array, each element is boxed and then copied.</source>
          <target state="translated">Wenn von einem Werttyp Array in ein Array von Verweistypen zu kopieren, wird jedes Element geschachtelt und kopiert.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>When copying from a reference-type or value-type array to an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array, an <ph id="ph2">&lt;xref:System.Object&gt;</ph> is created to hold each value or reference and then copied.</source>
          <target state="translated">Beim Kopieren aus einem Array-Verweistyp oder Werttyp in einen <ph id="ph1">&lt;xref:System.Object&gt;</ph> Array, ein <ph id="ph2">&lt;xref:System.Object&gt;</ph> erstellt, um jeden Wert oder Verweis aufzunehmen und anschließend kopiert wird.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>When copying from an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array to a reference-type or value-type array and the assignment is not possible, an <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">Beim Kopieren aus einer <ph id="ph1">&lt;xref:System.Object&gt;</ph> Array in ein Array-Verweistyp oder Werttyp und die Zuweisung ist nicht möglich, eine <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> ausgelöst wird.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> are both reference-type arrays or are both arrays of type <ph id="ph3">&lt;xref:System.Object&gt;</ph>, a shallow copy is performed.</source>
          <target state="translated">Wenn <ph id="ph1">`sourceArray`</ph> und <ph id="ph2">`destinationArray`</ph> Verweistyp-Arrays sind oder werden beide Arrays des Typs <ph id="ph3">&lt;xref:System.Object&gt;</ph>, eine flache Kopie ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A shallow copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is a new <ph id="ph2">&lt;xref:System.Array&gt;</ph> containing references to the same elements as the original <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Eine flache Kopie von einer <ph id="ph1">&lt;xref:System.Array&gt;</ph> ist ein neues <ph id="ph2">&lt;xref:System.Array&gt;</ph> enthält Verweise auf die gleichen Elemente wie die ursprüngliche <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The elements themselves or anything referenced by the elements are not copied.</source>
          <target state="translated">Die Elemente selbst oder einem beliebigen Element verwiesen wird, durch die Elemente werden nicht kopiert.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>In contrast, a deep copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">Im Gegensatz dazu eine tiefe Kopie von einer <ph id="ph1">&lt;xref:System.Array&gt;</ph> kopiert die Elemente und alles, was auf die Elemente direkt oder indirekt verweist.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>An <ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if the arrays are of incompatible types.</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> wird ausgelöst, wenn die Arrays von inkompatiblen Typen sind.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Type compatibility is defined as follows:</source>
          <target state="translated">Typkompatibilität ist wie folgt definiert:</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A type is compatible with itself.</source>
          <target state="translated">Ein Typ ist mit sich selbst kompatibel.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A value type is compatible with <ph id="ph1">&lt;xref:System.Object&gt;</ph> and with an interface type implemented by that value type.</source>
          <target state="translated">Ein Werttyp ist kompatibel mit <ph id="ph1">&lt;xref:System.Object&gt;</ph> und mit einem Schnittstellentyp, der durch diesen Werttyp implementiert.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A value type is considered connected to an interface only if it implements that interface directly.</source>
          <target state="translated">Ein Werttyp gilt nur, wenn sie diese Schnittstelle, direkt implementiert mit einer Schnittstelle verbunden.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Disconnected types are not compatible.</source>
          <target state="translated">Nicht verbundene Typen sind nicht kompatibel.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</source>
          <target state="translated">Zwei systeminterne (vordefinierte) Werttypen sind kompatibel, wenn kopieren aus einer Datenquelle in den Zieltyp eine erweiternde Konvertierung ist.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A widening conversion never loses information, whereas a narrowing conversion can lose information.</source>
          <target state="translated">Nie eine erweiternde Konvertierung verliert Informationen an, während eine einschränkende Konvertierung Informationen verloren gehen kann.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</source>
          <target state="translated">Z. B. eine erweiternde Konvertierung ist eine 32-Bit-Ganzzahl mit Vorzeichen in eine 64-Bit-Ganzzahl mit Vorzeichen zu konvertieren, und konvertieren eine 64-Bit-Ganzzahl mit Vorzeichen in eine 32-Bit-Ganzzahl mit Vorzeichen ist eine einschränkende Konvertierung.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zu Konvertierungen finden Sie unter <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>A nonintrinsic (user-defined) value type is compatible only with itself.</source>
          <target state="translated">Ein systeminterner (Benutzerdefiniert) Werttyp ist nur mit sich selbst kompatibel.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>Enumerations have an implicit conversion to <ph id="ph1">&lt;xref:System.Enum&gt;</ph> and to their underlying type.</source>
          <target state="translated">Enumerationen verfügen über eine implizite Konvertierung in <ph id="ph1">&lt;xref:System.Enum&gt;</ph> und ihren zugrunde liegenden Typ.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>If every element in <ph id="ph1">`sourceArray`</ph> requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in <ph id="ph2">`destinationArray`</ph>, an <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">Wenn jedes Element in <ph id="ph1">`sourceArray`</ph> eine Umwandlung erfordert (z. B. von einer Basisklasse in einer abgeleiteten Klasse oder von einer Schnittstelle zu einem Objekt) und einem oder mehreren Elementen können nicht in den entsprechenden Typ umgewandelt werden <ph id="ph2">`destinationArray`</ph>, wird eine <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> ausgelöst wird.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>If this method throws an exception while copying, the state of <ph id="ph1">`destinationArray`</ph> is undefined.</source>
          <target state="translated">Wenn diese Methode eine Ausnahme während des Kopiervorgangs, des Status des <ph id="ph1">`destinationArray`</ph> ist nicht definiert.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>) Vorgang, wobei <ph id="ph2">`n`</ph> ist <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>The following code example shows how to copy from one <ph id="ph1">&lt;xref:System.Array&gt;</ph> of type <ph id="ph2">&lt;xref:System.Object&gt;</ph> to another <ph id="ph3">&lt;xref:System.Array&gt;</ph> of type integer.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie von einem kopieren <ph id="ph1">&lt;xref:System.Array&gt;</ph> des Typs <ph id="ph2">&lt;xref:System.Object&gt;</ph> in eine andere <ph id="ph3">&lt;xref:System.Array&gt;</ph> vom Typ Integer.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> have different ranks.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> und <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> sind von unterschiedlichem Rang.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> are of incompatible types.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> und <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> weisen inkompatible Typen auf.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>At least one element in <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> cannot be cast to the type of <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated">Mindestens ein Element im <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> kann nicht in den Typ des <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>s umgewandelt werden.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph> is less than the lower bound of the first dimension of <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph> ist kleiner als die untere Grenze der ersten Dimension von <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="destinationIndex" /&gt;</ph> is less than the lower bound of the first dimension of <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationIndex" /&gt;</ph> ist kleiner als die untere Grenze der ersten Dimension von <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements from <ph id="ph2">&lt;paramref name="sourceIndex" /&gt;</ph> to the end of <ph id="ph3">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> ist größer als die Anzahl der Elemente vom <ph id="ph2">&lt;paramref name="sourceIndex" /&gt;</ph> bis zum Ende des <ph id="ph3">&lt;paramref name="sourceArray" /&gt;</ph>s.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements from <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> to the end of <ph id="ph3">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> ist größer als die Anzahl der Elemente vom <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> bis zum Ende des <ph id="ph3">&lt;paramref name="destinationArray" /&gt;</ph>s.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the data to copy.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>, das die zu kopierenden Daten enthält.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the index in the <bpt id="p1">&lt;c&gt;</bpt>sourceArray<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">Eine 64-Bit-Ganzzahl, die den Index im <bpt id="p1">&lt;c&gt;</bpt>sourceArray<ept id="p1">&lt;/c&gt;</ept> angibt, ab dem kopiert werden soll.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that receives the data.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>, das die Daten empfängt.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the index in the <bpt id="p1">&lt;c&gt;</bpt>destinationArray<ept id="p1">&lt;/c&gt;</ept> at which storing begins.</source>
          <target state="translated">Eine 64-Bit-Ganzzahl, die den Index im <bpt id="p1">&lt;c&gt;</bpt>destinationArray<ept id="p1">&lt;/c&gt;</ept> angibt, ab dem gespeichert werden soll.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the number of elements to copy.</source>
          <target state="translated">Eine 64-Bit-Ganzzahl, die die Anzahl der zu kopierenden Elemente darstellt.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The integer must be between zero and <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>, inclusive.</source>
          <target state="translated">Die Ganzzahl muss zwischen 0 (null) und einschließlich <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> liegen.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>Copies a range of elements from an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> starting at the specified source index and pastes them to another <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> starting at the specified destination index.</source>
          <target state="translated">Kopiert einen beim angegebenen Quellindex beginnenden Elementbereich aus einem <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> und fügt ihn ab dem angegebenen Zielindex in ein anderes <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> ein.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The length and the indexes are specified as 64-bit integers.</source>
          <target state="translated">Die Länge und die Indizes werden als 64-Bit-Ganzzahlen angegeben.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> parameters must have the same number of dimensions.</source>
          <target state="translated">Die <ph id="ph1">`sourceArray`</ph> und <ph id="ph2">`destinationArray`</ph> Parameter müssen die gleiche Anzahl von Dimensionen aufweisen.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>In addition, <ph id="ph1">`destinationArray`</ph> must already have been dimensioned and must have a sufficient number of elements starting from the <ph id="ph2">`destinationIndex`</ph> position to accommodate the copied data.</source>
          <target state="translated">Darüber hinaus <ph id="ph1">`destinationArray`</ph> muss bereits haben wurde dimensioniert und muss eine ausreichende Anzahl von Elementen, beginnend mit der <ph id="ph2">`destinationIndex`</ph> Position, um die kopierten Daten aufzunehmen.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end-to-end.</source>
          <target state="translated">Beim Kopieren zwischen mehrdimensionalen Arrays verhält sich das Array wie ein langes eindimensionales Array, in denen Zeilen (oder Spalten) konzeptionell End-to-End-angeordnet sind.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</source>
          <target state="translated">Wenn ein Array drei Zeilen (oder Spalten) mit vier Elementen, Kopieren von sechs Elementen vom Anfang des Arrays würde beispielsweise alle vier Elemente der ersten Zeile (oder Spalte) und die ersten beiden Elemente der zweiten Zeile (oder Spalte) kopieren.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>To start copying from the second element of the third row (or column), <ph id="ph1">`sourceIndex`</ph> must be the upper bound of the first row (or column) plus the length of the second row (or column) plus two.</source>
          <target state="translated">Zu kopierende aus dem zweiten Element der dritten Zeile (oder Spalte) <ph id="ph1">`sourceIndex`</ph> muss die obere Grenze der ersten Zeile (oder Spalte) plus 2 plus die Länge der zweiten Zeile (oder Spalte) sein.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> overlap, this method behaves as if the original values of <ph id="ph3">`sourceArray`</ph> were preserved in a temporary location before <ph id="ph4">`destinationArray`</ph> is overwritten.</source>
          <target state="translated">Wenn <ph id="ph1">`sourceArray`</ph> und <ph id="ph2">`destinationArray`</ph> überschneiden, die diese Methode verhält sich wie die ursprünglichen Werte der <ph id="ph3">`sourceArray`</ph> beibehalten wurden, in ein temporäres Verzeichnis vor <ph id="ph4">`destinationArray`</ph> überschrieben wird.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>[C++]</source>
          <target state="translated">[C++]</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>This method is equivalent to the standard C/C++ function <ph id="ph1">`memmove`</ph>, not <ph id="ph2">`memcpy`</ph>.</source>
          <target state="translated">Diese Methode entspricht der C/C++-Standardfunktion <ph id="ph1">`memmove`</ph>, nicht <ph id="ph2">`memcpy`</ph>.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The arrays can be reference-type arrays or value-type arrays.</source>
          <target state="translated">Die Arrays können Verweistyp-Arrays oder Werttyp Arrays sein.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>Type downcasting is performed, as required.</source>
          <target state="translated">Es erfolgt eine Umwandlung des Typs, wie erforderlich.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</source>
          <target state="translated">Beim Kopieren von einem Referenztyp Array in ein Array von Werttyp wird jedes Element mittels Unboxing zurückkonvertiert und kopiert.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>When copying from a value-type array to a reference-type array, each element is boxed and then copied.</source>
          <target state="translated">Wenn von einem Werttyp Array in ein Array von Verweistypen zu kopieren, wird jedes Element geschachtelt und kopiert.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>When copying from a reference-type or value-type array to an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array, an <ph id="ph2">&lt;xref:System.Object&gt;</ph> is created to hold each value or reference and then copied.</source>
          <target state="translated">Beim Kopieren aus einem Array-Verweistyp oder Werttyp in einen <ph id="ph1">&lt;xref:System.Object&gt;</ph> Array, ein <ph id="ph2">&lt;xref:System.Object&gt;</ph> erstellt, um jeden Wert oder Verweis aufzunehmen und anschließend kopiert wird.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>When copying from an <ph id="ph1">&lt;xref:System.Object&gt;</ph> array to a reference-type or value-type array and the assignment is not possible, an <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">Beim Kopieren aus einer <ph id="ph1">&lt;xref:System.Object&gt;</ph> Array in ein Array-Verweistyp oder Werttyp und die Zuweisung ist nicht möglich, eine <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph> ausgelöst wird.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>If <ph id="ph1">`sourceArray`</ph> and <ph id="ph2">`destinationArray`</ph> are both reference-type arrays or are both arrays of type <ph id="ph3">&lt;xref:System.Object&gt;</ph>, a shallow copy is performed.</source>
          <target state="translated">Wenn <ph id="ph1">`sourceArray`</ph> und <ph id="ph2">`destinationArray`</ph> Verweistyp-Arrays sind oder werden beide Arrays des Typs <ph id="ph3">&lt;xref:System.Object&gt;</ph>, eine flache Kopie ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A shallow copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> is a new <ph id="ph2">&lt;xref:System.Array&gt;</ph> containing references to the same elements as the original <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Eine flache Kopie von einer <ph id="ph1">&lt;xref:System.Array&gt;</ph> ist ein neues <ph id="ph2">&lt;xref:System.Array&gt;</ph> enthält Verweise auf die gleichen Elemente wie die ursprüngliche <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The elements themselves or anything referenced by the elements are not copied.</source>
          <target state="translated">Die Elemente selbst oder einem beliebigen Element verwiesen wird, durch die Elemente werden nicht kopiert.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>In contrast, a deep copy of an <ph id="ph1">&lt;xref:System.Array&gt;</ph> copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">Im Gegensatz dazu eine tiefe Kopie von einer <ph id="ph1">&lt;xref:System.Array&gt;</ph> kopiert die Elemente und alles, was auf die Elemente direkt oder indirekt verweist.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>An <ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if the arrays are of incompatible types.</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> wird ausgelöst, wenn die Arrays von inkompatiblen Typen sind.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>Type compatibility is defined as follows:</source>
          <target state="translated">Typkompatibilität ist wie folgt definiert:</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A type is compatible with itself.</source>
          <target state="translated">Ein Typ ist mit sich selbst kompatibel.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A value type is compatible with <ph id="ph1">&lt;xref:System.Object&gt;</ph> and with an interface type implemented by that value type.</source>
          <target state="translated">Ein Werttyp ist kompatibel mit <ph id="ph1">&lt;xref:System.Object&gt;</ph> und mit einem Schnittstellentyp, der durch diesen Werttyp implementiert.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A value type is considered connected to an interface only if it implements that interface directly.</source>
          <target state="translated">Ein Werttyp gilt nur, wenn sie diese Schnittstelle, direkt implementiert mit einer Schnittstelle verbunden.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>Disconnected types are not compatible.</source>
          <target state="translated">Nicht verbundene Typen sind nicht kompatibel.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</source>
          <target state="translated">Zwei systeminterne (vordefinierte) Werttypen sind kompatibel, wenn kopieren aus einer Datenquelle in den Zieltyp eine erweiternde Konvertierung ist.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A widening conversion never loses information, whereas a narrowing conversion can lose information.</source>
          <target state="translated">Nie eine erweiternde Konvertierung verliert Informationen an, während eine einschränkende Konvertierung Informationen verloren gehen kann.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</source>
          <target state="translated">Z. B. eine erweiternde Konvertierung ist eine 32-Bit-Ganzzahl mit Vorzeichen in eine 64-Bit-Ganzzahl mit Vorzeichen zu konvertieren, und konvertieren eine 64-Bit-Ganzzahl mit Vorzeichen in eine 32-Bit-Ganzzahl mit Vorzeichen ist eine einschränkende Konvertierung.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zu Konvertierungen finden Sie unter <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>A nonintrinsic (user-defined) value type is compatible only with itself.</source>
          <target state="translated">Ein systeminterner (Benutzerdefiniert) Werttyp ist nur mit sich selbst kompatibel.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>Enumerations have an implicit conversion to <ph id="ph1">&lt;xref:System.Enum&gt;</ph> and to their underlying type.</source>
          <target state="translated">Enumerationen verfügen über eine implizite Konvertierung in <ph id="ph1">&lt;xref:System.Enum&gt;</ph> und ihren zugrunde liegenden Typ.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>If every element in <ph id="ph1">`sourceArray`</ph> requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in <ph id="ph2">`destinationArray`</ph>, an <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">Wenn jedes Element in <ph id="ph1">`sourceArray`</ph> eine Umwandlung erfordert (z. B. von einer Basisklasse in einer abgeleiteten Klasse oder von einer Schnittstelle zu einem Objekt) und einem oder mehreren Elementen können nicht in den entsprechenden Typ umgewandelt werden <ph id="ph2">`destinationArray`</ph>, wird eine <ph id="ph3">&lt;xref:System.InvalidCastException&gt;</ph> ausgelöst wird.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>If this method throws an exception while copying, the state of <ph id="ph1">`destinationArray`</ph> is undefined.</source>
          <target state="translated">Wenn diese Methode eine Ausnahme während des Kopiervorgangs, des Status des <ph id="ph1">`destinationArray`</ph> ist nicht definiert.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>) Vorgang, wobei <ph id="ph2">`n`</ph> ist <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>The following code example shows how to copy from one <ph id="ph1">&lt;xref:System.Array&gt;</ph> of type <ph id="ph2">&lt;xref:System.Object&gt;</ph> to another <ph id="ph3">&lt;xref:System.Array&gt;</ph> of type integer.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie von einem kopieren <ph id="ph1">&lt;xref:System.Array&gt;</ph> des Typs <ph id="ph2">&lt;xref:System.Object&gt;</ph> in eine andere <ph id="ph3">&lt;xref:System.Array&gt;</ph> vom Typ Integer.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationArray" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> have different ranks.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> und <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> sind von unterschiedlichem Rang.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> and <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> are of incompatible types.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> und <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph> weisen inkompatible Typen auf.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>At least one element in <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> cannot be cast to the type of <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated">Mindestens ein Element im <ph id="ph1">&lt;paramref name="sourceArray" /&gt;</ph> kann nicht in den Typ des <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>s umgewandelt werden.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph> liegt außerhalb des Bereichs der gültigen Indizes für das <ph id="ph2">&lt;paramref name="sourceArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="destinationIndex" /&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationIndex" /&gt;</ph> liegt außerhalb des Bereichs der gültigen Indizes für das <ph id="ph2">&lt;paramref name="destinationArray" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than 0 or greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> ist kleiner als 0 oder größer als <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements from <ph id="ph2">&lt;paramref name="sourceIndex" /&gt;</ph> to the end of <ph id="ph3">&lt;paramref name="sourceArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> ist größer als die Anzahl der Elemente vom <ph id="ph2">&lt;paramref name="sourceIndex" /&gt;</ph> bis zum Ende des <ph id="ph3">&lt;paramref name="sourceArray" /&gt;</ph>s.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements from <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> to the end of <ph id="ph3">&lt;paramref name="destinationArray" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> ist größer als die Anzahl der Elemente vom <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> bis zum Ende des <ph id="ph3">&lt;paramref name="destinationArray" /&gt;</ph>s.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Copies all the elements of the current one-dimensional array to the specified one-dimensional array.</source>
          <target state="translated">Kopiert alle Elemente des aktuellen eindimensionalen Arrays in das angegebene eindimensionale Array.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The one-dimensional array that is the destination of the elements copied from the current array.</source>
          <target state="translated">Das eindimensionale Array, das das Ziel der aus dem aktuellen Array kopierten Elemente ist.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>A 32-bit integer that represents the index in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">Eine 32-Bit-Ganzzahl, die den Index im <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> angibt, ab dem kopiert werden soll.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>Copies all the elements of the current one-dimensional array to the specified one-dimensional array starting at the specified destination array index.</source>
          <target state="translated">Kopiert alle Elemente des aktuellen eindimensionalen Arrays in das angegebene eindimensionale Array, beginnend am angegebenen Index des Zielarrays.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The index is specified as a 32-bit integer.</source>
          <target state="translated">Der Index wird als 32-Bit-Ganzzahl angegeben.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>This method copies all the elements of the current array instance to the <ph id="ph1">`array`</ph> destination array, starting at index <ph id="ph2">`index`</ph>.</source>
          <target state="translated">Diese Methode kopiert alle Elemente der aktuellen Arrayinstanz mit den <ph id="ph1">`array`</ph> Zielarray, beginnend am Index <ph id="ph2">`index`</ph>.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The <ph id="ph1">`array`</ph> destination array must already have been dimensioned and must have a sufficient number of elements to accommodate the copied elements.</source>
          <target state="translated">Die <ph id="ph1">`array`</ph> Zielarray muss bereits haben wurde dimensioniert und muss eine ausreichende Anzahl von Elementen, die der kopierten Elemente aufzunehmen.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>Otherwise, the method throws an exception.</source>
          <target state="translated">Andernfalls löst die Methode eine Ausnahme aus.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>This method supports the <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> interface.</source>
          <target state="translated">Diese Methode unterstützt die <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> Schnittstelle.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>If implementing <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> is not explicitly required, use <ph id="ph2">&lt;xref:System.Array.Copy%2A&gt;</ph> to avoid an extra indirection.</source>
          <target state="translated">Wenn implementieren <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> wird nicht explizit erforderlich ist, verwenden <ph id="ph2">&lt;xref:System.Array.Copy%2A&gt;</ph> um einen zusätzlichen Dereferenzierung zu vermeiden.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>If this method throws an exception while copying, the state of <ph id="ph1">`array`</ph> is undefined.</source>
          <target state="translated">Wenn diese Methode eine Ausnahme während des Kopiervorgangs, des Status des <ph id="ph1">`array`</ph> ist nicht definiert.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>.It performs a shallow copy only.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>) Vorgang, wobei <ph id="ph2">`n`</ph> ist <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>. Sie führt nur eine flache Kopie.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The following code example shows how to copy an <ph id="ph1">&lt;xref:System.Array&gt;</ph> to another <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht das Kopieren einer <ph id="ph1">&lt;xref:System.Array&gt;</ph> in eine andere <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The following code example shows how to copy an <ph id="ph1">&lt;xref:System.Array&gt;</ph> to another <ph id="ph2">&lt;xref:System.Array&gt;</ph> with a nonzero lower bound.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht das Kopieren einer <ph id="ph1">&lt;xref:System.Array&gt;</ph> in eine andere <ph id="ph2">&lt;xref:System.Array&gt;</ph> und eine Untergrenze ungleich NULL.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>Note that the entire source <ph id="ph1">&lt;xref:System.Array&gt;</ph> is copied, including empty elements that overwrite existing elements in the target <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Beachten Sie, dass die gesamte Quelle <ph id="ph1">&lt;xref:System.Array&gt;</ph> kopiert wird, einschließlich leere Elemente, die vorhandenen Elemente in das Ziel überschrieben <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ist kleiner als die untere <ph id="ph2">&lt;paramref name="array" /&gt;</ph>-Grenze.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The number of elements in the source array is greater than the available number of elements from <ph id="ph1">&lt;paramref name="index" /&gt;</ph> to the end of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Die Anzahl der Elemente im Quellarray ist größer als die verfügbare Anzahl der Elemente vom <ph id="ph1">&lt;paramref name="index" /&gt;</ph> bis zum Ende des Ziel-<ph id="ph2">&lt;paramref name="array" /&gt;</ph>s.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The type of the source <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> cannot be cast automatically to the type of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Der Typ des Quell-<ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>s kann nicht automatisch in den Typ des Ziel<ph id="ph2">&lt;paramref name="array" /&gt;</ph>s umgewandelt werden.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>The source array is multidimensional.</source>
          <target state="translated">Das Quellarray ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int32)">
          <source>At least one element in the source <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> cannot be cast to the type of destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Mindestens ein Element im Quell-<ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> kann nicht in den Typ des Ziel<ph id="ph2">&lt;paramref name="array" /&gt;</ph>s umgewandelt werden.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The one-dimensional array that is the destination of the elements copied from the current array.</source>
          <target state="translated">Das eindimensionale Array, das das Ziel der aus dem aktuellen Array kopierten Elemente ist.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>A 64-bit integer that represents the index in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">Eine 64-Bit-Ganzzahl, die den Index im <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> angibt, ab dem kopiert werden soll.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>Copies all the elements of the current one-dimensional array to the specified one-dimensional array starting at the specified destination array index.</source>
          <target state="translated">Kopiert alle Elemente des aktuellen eindimensionalen Arrays in das angegebene eindimensionale Array, beginnend am angegebenen Index des Zielarrays.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The index is specified as a 64-bit integer.</source>
          <target state="translated">Der Index wird als 64-Bit-Ganzzahl angegeben.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>This method copies all the elements of the current array instance to the <ph id="ph1">`array`</ph> destination array, starting at index <ph id="ph2">`index`</ph>.</source>
          <target state="translated">Diese Methode kopiert alle Elemente der aktuellen Arrayinstanz mit den <ph id="ph1">`array`</ph> Zielarray, beginnend am Index <ph id="ph2">`index`</ph>.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The <ph id="ph1">`array`</ph> destination array must already have been dimensioned and must have a sufficient number of elements to accommodate the copied elements.</source>
          <target state="translated">Die <ph id="ph1">`array`</ph> Zielarray muss bereits haben wurde dimensioniert und muss eine ausreichende Anzahl von Elementen, die der kopierten Elemente aufzunehmen.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>Otherwise, the method throws an exception.</source>
          <target state="translated">Andernfalls löst die Methode eine Ausnahme aus.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>This method supports the <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> interface.</source>
          <target state="translated">Diese Methode unterstützt die <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> Schnittstelle.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>If implementing <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> is not explicitly required, use <ph id="ph2">&lt;xref:System.Array.Copy%2A&gt;</ph> to avoid an extra indirection.</source>
          <target state="translated">Wenn implementieren <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> wird nicht explizit erforderlich ist, verwenden <ph id="ph2">&lt;xref:System.Array.Copy%2A&gt;</ph> um einen zusätzlichen Dereferenzierung zu vermeiden.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>If this method throws an exception while copying, the state of <ph id="ph1">`array`</ph> is undefined.</source>
          <target state="translated">Wenn diese Methode eine Ausnahme während des Kopiervorgangs, des Status des <ph id="ph1">`array`</ph> ist nicht definiert.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>.It performs a shallow copy only.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>) Vorgang, wobei <ph id="ph2">`n`</ph> ist <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>. Sie führt nur eine flache Kopie.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The following code example shows how to copy an <ph id="ph1">&lt;xref:System.Array&gt;</ph> to another <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht das Kopieren einer <ph id="ph1">&lt;xref:System.Array&gt;</ph> in eine andere <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The following code example shows how to copy an <ph id="ph1">&lt;xref:System.Array&gt;</ph> to another <ph id="ph2">&lt;xref:System.Array&gt;</ph> with a nonzero lower bound.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht das Kopieren einer <ph id="ph1">&lt;xref:System.Array&gt;</ph> in eine andere <ph id="ph2">&lt;xref:System.Array&gt;</ph> und eine Untergrenze ungleich NULL.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>Note that the entire source <ph id="ph1">&lt;xref:System.Array&gt;</ph> is copied, including empty elements that overwrite existing elements in the target <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Beachten Sie, dass die gesamte Quelle <ph id="ph1">&lt;xref:System.Array&gt;</ph> kopiert wird, einschließlich leere Elemente, die vorhandenen Elemente in das Ziel überschrieben <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> liegt außerhalb des Bereichs der gültigen Indizes für <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The number of elements in the source array is greater than the available number of elements from <ph id="ph1">&lt;paramref name="index" /&gt;</ph> to the end of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Die Anzahl der Elemente im Quellarray ist größer als die verfügbare Anzahl der Elemente vom <ph id="ph1">&lt;paramref name="index" /&gt;</ph> bis zum Ende des Ziel-<ph id="ph2">&lt;paramref name="array" /&gt;</ph>s.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The type of the source <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> cannot be cast automatically to the type of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Der Typ des Quell-<ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>s kann nicht automatisch in den Typ des Ziel-<ph id="ph2">&lt;paramref name="array" /&gt;</ph>s umgewandelt werden.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>The source <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated">Das Quell-<ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.Array.CopyTo(System.Array,System.Int64)">
          <source>At least one element in the source <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> cannot be cast to the type of destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Mindestens ein Element im Quell-<ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> kann nicht in den Typ des Ziel<ph id="ph2">&lt;paramref name="array" /&gt;</ph>s umgewandelt werden.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> class.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>-Klasse.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> des zu erstellenden <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>The size of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Die Größe des zu erstellenden <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>Creates a one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> and length, with zero-based indexing.</source>
          <target state="translated">Erstellt ein eindimensionales <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> der angegebenen Länge und vom angegebenen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> mit nullbasierter Indizierung.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>A new one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> with the specified length, using zero-based indexing.</source>
          <target state="translated">Ein neues eindimensionales <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> der angegebenen Länge und vom angegebenen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> mit nullbasierter Indizierung.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>Unlike most classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> provides the <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> method, instead of public constructors, to allow for late bound access.</source>
          <target state="translated">Im Gegensatz zu den meisten Klassen <ph id="ph1">&lt;xref:System.Array&gt;</ph> bietet die <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> -Methode, statt öffentliche Konstruktoren, um spät gebundener Zugriff zu ermöglichen.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>Reference-type elements are initialized to <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Verweistyp-Elemente werden mit initialisiert <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>Value-type elements are initialized to zero.</source>
          <target state="translated">Werttyp Elemente werden mit 0 (null) initialisiert.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>) Vorgang, wobei <ph id="ph2">`n`</ph> ist <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>The following code example shows how to create and initialize a one-dimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie erstellt und initialisiert ein eindimensionales <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> ist kein gültiger <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not supported.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> wird nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>For example, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> is not supported.</source>
          <target state="translated">Beispielsweise wird <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> ist ein offener generischer Typ.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> des zu erstellenden <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>An array of 32-bit integers that represent the size of each dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Ein Array von 32-Bit-Ganzzahlen, das die Größe der einzelnen Dimensionen des zu erstellenden <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> darstellt.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>Creates a multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> and dimension lengths, with zero-based indexing.</source>
          <target state="translated">Erstellt ein mehrdimensionales <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> vom angegebenen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>The dimension lengths are specified in an array of 32-bit integers.</source>
          <target state="translated">Die Längen der Dimension werden in einem Array von 32-Bit-Ganzzahlen angegeben.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>A new multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> with the specified length for each dimension, using zero-based indexing.</source>
          <target state="translated">Ein neues mehrdimensionales <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> vom angegebenen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>Unlike most classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> provides the <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> method, instead of public constructors, to allow for late bound access.</source>
          <target state="translated">Im Gegensatz zu den meisten Klassen <ph id="ph1">&lt;xref:System.Array&gt;</ph> bietet die <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> -Methode, statt öffentliche Konstruktoren, um spät gebundener Zugriff zu ermöglichen.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>The number of elements in the <ph id="ph1">`lengths`</ph> array must equal the number of dimensions in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Die Anzahl der Elemente in der <ph id="ph1">`lengths`</ph> Array muss gleich der Anzahl der Dimensionen im neuen <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>Each element of the <ph id="ph1">`lengths`</ph> array must specify the length of the corresponding dimension in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Jedes Element der <ph id="ph1">`lengths`</ph> Array muss die Länge der entsprechenden Dimension angeben, in der neuen <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>Reference-type elements are initialized to <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Verweistyp-Elemente werden mit initialisiert <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>Value-type elements are initialized to zero.</source>
          <target state="translated">Werttyp Elemente werden mit 0 (null) initialisiert.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the product of all values in <ph id="ph3">`lengths`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>) Vorgang, wobei <ph id="ph2">`n`</ph> ist das Produkt aller Werte in <ph id="ph3">`lengths`</ph>.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>The following code example shows how to create and initialize a multidimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie zum Erstellen und initialisieren Sie ein mehrdimensionales <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> ist kein gültiger <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>The <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> array contains less than one element.</source>
          <target state="translated">Das <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph>-Array enthält weniger als ein Element.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not supported.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> wird nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>For example, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> is not supported.</source>
          <target state="translated">Beispielsweise wird <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> ist ein offener generischer Typ.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[])">
          <source>Any value in <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> is less than zero.</source>
          <target state="translated">Irgendein Wert in <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> ist kleiner als 0 (null).</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> des zu erstellenden <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>An array of 64-bit integers that represent the size of each dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Ein Array von 64-Bit-Ganzzahlen, das die Größe der einzelnen Dimensionen des zu erstellenden <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> darstellt.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>Each integer in the array must be between zero and <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>, inclusive.</source>
          <target state="translated">Jede Ganzzahl im Array muss zwischen 0 (null) und <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> (einschließlich) liegen.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>Creates a multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> and dimension lengths, with zero-based indexing.</source>
          <target state="translated">Erstellt ein mehrdimensionales <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> vom angegebenen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>The dimension lengths are specified in an array of 64-bit integers.</source>
          <target state="translated">Die Längen der Dimension werden in einem Array von 64-Bit-Ganzzahlen angegeben.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>A new multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> with the specified length for each dimension, using zero-based indexing.</source>
          <target state="translated">Ein neues mehrdimensionales <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> vom angegebenen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>Unlike most classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> provides the <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> method, instead of public constructors, to allow for late bound access.</source>
          <target state="translated">Im Gegensatz zu den meisten Klassen <ph id="ph1">&lt;xref:System.Array&gt;</ph> bietet die <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> -Methode, statt öffentliche Konstruktoren, um spät gebundener Zugriff zu ermöglichen.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>The number of elements in the <ph id="ph1">`lengths`</ph> array must equal the number of dimensions in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Die Anzahl der Elemente in der <ph id="ph1">`lengths`</ph> Array muss gleich der Anzahl der Dimensionen im neuen <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>Each element of the <ph id="ph1">`lengths`</ph> array must specify the length of the corresponding dimension in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Jedes Element der <ph id="ph1">`lengths`</ph> Array muss die Länge der entsprechenden Dimension angeben, in der neuen <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>Reference-type elements are initialized to <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Verweistyp-Elemente werden mit initialisiert <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>Value-type elements are initialized to zero.</source>
          <target state="translated">Werttyp Elemente werden mit 0 (null) initialisiert.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the product of all values in <ph id="ph3">`lengths`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>) Vorgang, wobei <ph id="ph2">`n`</ph> ist das Produkt aller Werte in <ph id="ph3">`lengths`</ph>.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>The following code example shows how to create and initialize a multidimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie zum Erstellen und initialisieren Sie ein mehrdimensionales <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> ist kein gültiger <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>The <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> array contains less than one element.</source>
          <target state="translated">Das <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph>-Array enthält weniger als ein Element.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not supported.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> wird nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>For example, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> is not supported.</source>
          <target state="translated">Beispielsweise wird <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> ist ein offener generischer Typ.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int64[])">
          <source>Any value in <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> is less than zero or greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Jeder Wert in <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> ist kleiner als 0 (null) oder größer als <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> des zu erstellenden <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>The size of the first dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Die Größe der ersten Dimension des zu erstellenden <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>The size of the second dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Die Größe der zweiten Dimension des zu erstellenden <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>Creates a two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> and dimension lengths, with zero-based indexing.</source>
          <target state="translated">Erstellt ein zweidimensionales <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> vom angegebenen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>A new two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> with the specified length for each dimension, using zero-based indexing.</source>
          <target state="translated">Ein neues zweidimensionales <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> vom angegebenen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>Unlike most classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> provides the <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> method, instead of public constructors, to allow for late bound access.</source>
          <target state="translated">Im Gegensatz zu den meisten Klassen <ph id="ph1">&lt;xref:System.Array&gt;</ph> bietet die <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> -Methode, statt öffentliche Konstruktoren, um spät gebundener Zugriff zu ermöglichen.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>Reference-type elements are initialized to <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Verweistyp-Elemente werden mit initialisiert <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>Value-type elements are initialized to zero.</source>
          <target state="translated">Werttyp Elemente werden mit 0 (null) initialisiert.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the product of <ph id="ph3">`length1`</ph> and <ph id="ph4">`length2`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>) Vorgang, wobei <ph id="ph2">`n`</ph> ist das Produkt der <ph id="ph3">`length1`</ph> und <ph id="ph4">`length2`</ph>.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>The following code example shows how to create and initialize a two-dimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie zum Erstellen und initialisieren Sie ein zweidimensionales <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> ist kein gültiger <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not supported.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> wird nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>For example, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> is not supported.</source>
          <target state="translated">Beispielsweise wird <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> ist ein offener generischer Typ.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length1" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length1" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length2" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length2" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> des zu erstellenden <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>A one-dimensional array that contains the size of each dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Ein eindimensionales Array mit den Größen aller Dimensionen des zu erstellenden <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>A one-dimensional array that contains the lower bound (starting index) of each dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Ein eindimensionales Array mit der unteren Grenze (Startindex) für jede Dimension des zu erstellenden <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Creates a multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> and dimension lengths, with the specified lower bounds.</source>
          <target state="translated">Erstellt ein mehrdimensionales <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> vom angegebenen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> mit der für jede Dimension angegebenen Länge und Untergrenze.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>A new multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> with the specified length and lower bound for each dimension.</source>
          <target state="translated">Ein neues mehrdimensionales <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> vom angegebenen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> mit der für jede Dimension angegebenen Länge und Untergrenze.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Unlike most classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> provides the <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> method, instead of public constructors, to allow for late bound access.</source>
          <target state="translated">Im Gegensatz zu den meisten Klassen <ph id="ph1">&lt;xref:System.Array&gt;</ph> bietet die <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> -Methode, statt öffentliche Konstruktoren, um spät gebundener Zugriff zu ermöglichen.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>The <ph id="ph1">`lengths`</ph> and <ph id="ph2">`lowerBounds`</ph> arrays must have the same number of elements.</source>
          <target state="translated">Die <ph id="ph1">`lengths`</ph> und <ph id="ph2">`lowerBounds`</ph> Arrays müssen die gleiche Anzahl von Elementen aufweisen.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>The number of elements in the <ph id="ph1">`lengths`</ph> array must equal the number of dimensions in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Die Anzahl der Elemente in der <ph id="ph1">`lengths`</ph> Array muss gleich der Anzahl der Dimensionen im neuen <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Each element of the <ph id="ph1">`lengths`</ph> array must specify the length of the corresponding dimension in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Jedes Element der <ph id="ph1">`lengths`</ph> Array muss die Länge der entsprechenden Dimension angeben, in der neuen <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Each element of the <ph id="ph1">`lowerBounds`</ph> array must specify the lower bound of the corresponding dimension in the new <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Jedes Element der <ph id="ph1">`lowerBounds`</ph> Array muss die untere Grenze der entsprechenden Dimension angeben, in der neuen <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Generally, the .NET Framework class library and many programming languages do not handle nonzero lower bounds.</source>
          <target state="translated">Der .NET Framework-Klassenbibliothek und viele Programmiersprachen unterstützen im Allgemeinen nicht von ungleich unteren Grenzen.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Reference-type elements are initialized to <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Verweistyp-Elemente werden mit initialisiert <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Value-type elements are initialized to zero.</source>
          <target state="translated">Werttyp Elemente werden mit 0 (null) initialisiert.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the product of all values in <ph id="ph3">`lengths`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>) Vorgang, wobei <ph id="ph2">`n`</ph> ist das Produkt aller Werte in <ph id="ph3">`lengths`</ph>.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>The following code example shows how to create and initialize a multidimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph> with specified lower bounds.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie zum Erstellen und initialisieren Sie ein mehrdimensionales <ph id="ph1">&lt;xref:System.Array&gt;</ph> mit der angegebenen Untergrenze.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="lowerBounds" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="lowerBounds" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> ist kein gültiger <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>The <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> array contains less than one element.</source>
          <target state="translated">Das <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph>-Array enthält kein Element.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>The <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> and <ph id="ph2">&lt;paramref name="lowerBounds" /&gt;</ph> arrays do not contain the same number of elements.</source>
          <target state="translated">Das <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph>- und das <ph id="ph2">&lt;paramref name="lowerBounds" /&gt;</ph>-Array enthalten nicht dieselbe Anzahl von Elementen.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not supported.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> wird nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>For example, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> is not supported.</source>
          <target state="translated">Beispielsweise wird <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> ist ein offener generischer Typ.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Any value in <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> is less than zero.</source>
          <target state="translated">Irgendein Wert in <ph id="ph1">&lt;paramref name="lengths" /&gt;</ph> ist kleiner als 0 (null).</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])">
          <source>Any value in <ph id="ph1">&lt;paramref name="lowerBounds" /&gt;</ph> is very large, such that the sum of a dimension's lower bound and length is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Irgendein Wert in <ph id="ph1">&lt;paramref name="lowerBounds" /&gt;</ph> ist sehr groß, so dass die Summe aus Untergrenze und Länge einer Dimension größer ist als <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> des zu erstellenden <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>The size of the first dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Die Größe der ersten Dimension des zu erstellenden <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>The size of the second dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Die Größe der zweiten Dimension des zu erstellenden <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>The size of the third dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to create.</source>
          <target state="translated">Die Größe der dritten Dimension des zu erstellenden <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>Creates a three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> and dimension lengths, with zero-based indexing.</source>
          <target state="translated">Erstellt ein dreidimensionales <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> vom angegebenen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>A new three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> with the specified length for each dimension, using zero-based indexing.</source>
          <target state="translated">Ein neues dreidimensionales <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> vom angegebenen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>Unlike most classes, <ph id="ph1">&lt;xref:System.Array&gt;</ph> provides the <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> method, instead of public constructors, to allow for late bound access.</source>
          <target state="translated">Im Gegensatz zu den meisten Klassen <ph id="ph1">&lt;xref:System.Array&gt;</ph> bietet die <ph id="ph2">&lt;xref:System.Array.CreateInstance%2A&gt;</ph> -Methode, statt öffentliche Konstruktoren, um spät gebundener Zugriff zu ermöglichen.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>Reference-type elements are initialized to <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Verweistyp-Elemente werden mit initialisiert <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>Value-type elements are initialized to zero.</source>
          <target state="translated">Werttyp Elemente werden mit 0 (null) initialisiert.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the product of <ph id="ph3">`length1`</ph>, <ph id="ph4">`length2`</ph>, and <ph id="ph5">`length3`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>) Vorgang, wobei <ph id="ph2">`n`</ph> ist das Produkt der <ph id="ph3">`length1`</ph>, <ph id="ph4">`length2`</ph>, und <ph id="ph5">`length3`</ph>.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>The following code example shows how to create and initialize a three-dimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie zum Erstellen und initialisieren Sie ein dreidimensionales <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> ist kein gültiger <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is not supported.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> wird nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>For example, <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> is not supported.</source>
          <target state="translated">Beispielsweise wird <ph id="ph1">&lt;see cref="T:System.Void" /&gt;</ph> nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="elementType" /&gt;</ph> ist ein offener generischer Typ.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length1" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length1" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length2" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length2" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" uid="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length3" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length3" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Empty``1">
          <source>The type of the elements of the array.</source>
          <target state="translated">Der Typ der Elemente des Arrays.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" uid="M:System.Array.Empty``1">
          <source>Returns an empty array.</source>
          <target state="translated">Gibt ein leeres Array zurück.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" uid="M:System.Array.Empty``1">
          <source>Returns an empty <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Gibt ein leeres <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Der Typ der Elemente des Arrays.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Das zu durchsuchende eindimensionale und nullbasierte <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the elements to search for.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph>, das die Bedingungen für die Elemente definiert, nach denen gesucht werden soll.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>Determines whether the specified array contains elements that match the conditions defined by the specified predicate.</source>
          <target state="translated">Bestimmt, ob das angegebene Array Elemente enthält, die mit den vom angegebenen Prädikat definierten Bedingungen übereinstimmen.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="array" /&gt;</ph> contains one or more elements that match the conditions defined by the specified predicate; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;paramref name="array" /&gt;</ph> mindestens ein Element enthält, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> ist ein Delegat an eine Methode, die zurückgibt <ph id="ph2">`true`</ph> an das Objekt übergeben sie die Bedingungen definiert, die im Delegaten übereinstimmt.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, and processing is stopped when a match is found.</source>
          <target state="translated">Die Elemente der <ph id="ph1">`array`</ph> einzeln übergeben werden, um die <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, und die Verarbeitung wird beendet, wenn eine Übereinstimmung gefunden wird.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> delegate explicitly.</source>
          <target state="translated">In c# und Visual Basic, ist es nicht erforderlich, erstellen Sie die <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> explizit zu delegieren.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Diese Sprachen leiten den richtigen Delegaten aus Kontext und automatisch zu erstellen.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>)-Vorgang, in dem <ph id="ph2">`n`</ph> ist die <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> von <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The following example specifies the match conditions for the <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> method usinglambda expressions to check whether a planet starts with a given letter or whether the planet is found on the given array.</source>
          <target state="translated">Im folgenden Beispiel wird die übereinstimmungsbedingungen für die <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> Methode Usinglambda Ausdrücke, um zu überprüfen, ob ein Planet mit einem bestimmten Buchstaben beginnt, oder gibt an, ob der Planet auf dem angegebenen Array gefunden wird.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> method to indicate whether any names in a string array begin with a specified character.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> Methode, um anzugeben, ob alle Namen in einem Zeichenfolgenarray mit dem angegebenen Zeichen beginnen.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The example instantiates a <ph id="ph1">`StringSearcher`</ph> object by passing the string to search for to its class constructor.</source>
          <target state="translated">Im Beispiel wird instanziiert einen <ph id="ph1">`StringSearcher`</ph> Objekt, indem Sie die zu suchende Zeichenfolge an den Klassenkonstruktor übergeben.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">`StringSearcher.StartsWith`</ph> method has same signature as the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegate.</source>
          <target state="translated">Die <ph id="ph1">`StringSearcher.StartsWith`</ph> Methode hat die gleiche Signatur wie die <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegieren.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>When the <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> method is called, each member of the array is passed to the delegate until it returns <ph id="ph2">`true`</ph> or iterates all the elements in the array.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> -Methode aufgerufen wird, wird jedes Element des Arrays an den Delegaten übergeben, bis zurückgegeben <ph id="ph2">`true`</ph> oder alle Elemente im Array durchläuft.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>You can also use a lambda expression rather than explicitly define a method whose signature corresponds to that of the delegate.</source>
          <target state="translated">Sie können auch einen Lambda-Ausdruck verwenden, anstatt explizit definiert eine Methode, deren Signatur entspricht, der den Delegaten.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>The following example replaces the <ph id="ph1">`StringSearcher`</ph> class and its <ph id="ph2">`StartsWith`</ph> method with a lambda expression.</source>
          <target state="translated">Im folgende Beispiel ersetzt die <ph id="ph1">`StringSearcher`</ph> Klasse und ihre <ph id="ph2">`StartsWith`</ph> Methode mit einem Lambdaausdruck.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" uid="M:System.Array.Exists``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Der Typ der Elemente des Arrays.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The one-dimensional, zero-based array to search.</source>
          <target state="translated">Das zu durchsuchende eindimensionale und nullbasierte Array.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The predicate that defines the conditions of the element to search for.</source>
          <target state="translated">Das Prädikat, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the first occurrence within the entire <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt das erste Vorkommen im gesamten <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The first element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type <ph id="ph1">&lt;paramref name="T" /&gt;</ph>.</source>
          <target state="translated">Das erste Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, sofern vorhanden, andernfalls der Standardwert für den Typ <ph id="ph1">&lt;paramref name="T" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method or a lambda expression that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate or lambda expression.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> ist ein Delegat einer Methode oder einen Lambda-Ausdruck, der zurückgibt <ph id="ph2">`true`</ph> an das Objekt übergeben sie die Bedingungen der Delegat oder Lambda-Ausdruck übereinstimmt.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, starting with the first element and ending with the last element.</source>
          <target state="translated">Die Elemente der <ph id="ph1">`array`</ph> einzeln übergeben werden, um die <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, beginnend mit dem ersten Element und endend mit dem letzten Element.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>Processing is stopped when a match is found.</source>
          <target state="translated">Die Verarbeitung wird beendet, wenn eine Übereinstimmung gefunden wird.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>)-Vorgang, in dem <ph id="ph2">`n`</ph> ist die <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> von <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The following example uses a <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> delegate with the <ph id="ph2">&lt;xref:System.Array.Find%2A&gt;</ph> generic method to search an array of <ph id="ph3">&lt;xref:System.Drawing.Point&gt;</ph> structures.</source>
          <target state="translated">Im folgenden Beispiel wird eine <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> mit Delegieren der <ph id="ph2">&lt;xref:System.Array.Find%2A&gt;</ph> generischen Methode ein Array von Suchen <ph id="ph3">&lt;xref:System.Drawing.Point&gt;</ph> Strukturen.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The method the delegate represents, <ph id="ph1">`ProductGT10`</ph>, returns <ph id="ph2">`true`</ph> if the product of the X and Y fields is greater than 100,000.</source>
          <target state="translated">Die Methode, die der Delegat darstellt, <ph id="ph1">`ProductGT10`</ph>, gibt <ph id="ph2">`true`</ph> , wenn das Produkt der X- und Y-Felder größer als 100.000 ist.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph> method calls the delegate for each element of the array, returning the first point that meets the test condition.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph> Methode ruft den Delegaten für jedes Element des Arrays zurückgeben des ersten Punkts, der die testbedingung erfüllt.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>Visual Basic and C# users do not have to create the delegate explicitly or specify the type argument of the generic method.</source>
          <target state="translated">Visual Basic- und C#-Benutzer keine explizit den Delegaten zu erstellen, oder geben Sie das Typargument der aufgerufenen generischen Methode.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The compilers determine the necessary types from the method arguments you supply.</source>
          <target state="translated">Die Compiler bestimmen die erforderlichen Typen über die Argumente der Methode, die Sie angeben.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>Rather than explicitly defining a method with the necessary signature, instantiating a <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> delegate, and passing the delegate to the <ph id="ph2">&lt;xref:System.Array.Find%2A&gt;</ph> method, it is customary to use a lambda expression.</source>
          <target state="translated">Anstatt explizit definiert eine Methode mit der Signatur, Instanziieren einer <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> delegieren und das Übergeben der Delegat, der die <ph id="ph2">&lt;xref:System.Array.Find%2A&gt;</ph> -Methode, ist es üblich, einen Lambda-Ausdruck verwenden.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>The following example is identical to the previous one, except that it uses a lambda expression as the <ph id="ph1">`match`</ph> argument.</source>
          <target state="translated">Das folgende Beispiel ist identisch mit der vorherigen Ansicht identisch, jedoch einen Lambdaausdruck als verwendet den <ph id="ph1">`match`</ph> Argument.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" uid="M:System.Array.Find``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Der Typ der Elemente des Arrays.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Das zu durchsuchende eindimensionale und nullbasierte <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the elements to search for.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph>, das die Bedingungen für die Elemente definiert, nach denen gesucht werden soll.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>Retrieves all the elements that match the conditions defined by the specified predicate.</source>
          <target state="translated">Ruft alle Elemente ab, die die vom angegebenen Prädikat definierten Bedingungen erfüllen.</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>An <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> containing all the elements that match the conditions defined by the specified predicate, if found; otherwise, an empty <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> mit allen Elementen, die die durch das angegebene Prädikat angegebenen Bedingungen erfüllen, sofern gefunden, andernfalls ein leeres <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> ist ein Delegat an eine Methode, die zurückgibt <ph id="ph2">`true`</ph> an das Objekt übergeben sie die Bedingungen definiert, die im Delegaten übereinstimmt.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, and the elements that match the conditions are saved in the returned array.</source>
          <target state="translated">Die Elemente der <ph id="ph1">`array`</ph> einzeln übergeben werden, um die <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, und Elemente, die Bedingungen erfüllen, werden im zurückgegebenen Array gespeichert.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>)-Vorgang, in dem <ph id="ph2">`n`</ph> ist die <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> von <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The following example creates an array of 50 random numbers with values that can range from 0 to 1,000.</source>
          <target state="translated">Das folgende Beispiel erstellt ein Array von 50 zufälligen Zahlen mit Werten, die zwischen 0 und 1000 liegen können.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>It then calls the <ph id="ph1">&lt;xref:System.Array.FindAll%2A&gt;</ph> method with a lambda expression that returns the values that range from 300 to 600.</source>
          <target state="translated">Er ruft dann die <ph id="ph1">&lt;xref:System.Array.FindAll%2A&gt;</ph> Methode mit einem Lambda-Ausdruck, der die Werte von 300 auf 600 dieses Bereichs zurückgibt.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>Note that the lambda expression is passed a parameter named <ph id="ph1">`x`</ph>;  this represents the individual array member that is passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
          <target state="translated">Beachten Sie, dass der Lambda-Ausdruck einen Parameter namens übergeben wird <ph id="ph1">`x`</ph>;  Dies stellt der einzelnen Arraymember, die an die <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>Also note that the local <ph id="ph1">`lBound`</ph> and <ph id="ph2">`uBound`</ph> variables are accessible within the lambda expression.</source>
          <target state="translated">Beachten Sie, dass die lokale <ph id="ph1">`lBound`</ph> und <ph id="ph2">`uBound`</ph> Variablen innerhalb der Lambda-Ausdruck zugegriffen werden.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.FindLast%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Array.FindAll%2A&gt;</ph> generic methods.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.FindLast%2A&gt;</ph>, und <ph id="ph3">&lt;xref:System.Array.FindAll%2A&gt;</ph> generische Methoden.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">Ein Array von Zeichenfolgen wird erstellt, 8, Dinosauriernamen enthält, von denen zwei (an Position 1 und 5) mit "Saurus" enden.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">Das Codebeispiel definiert auch eine Prädikat Search-Methode, die mit dem Namen <ph id="ph1">`EndsWithSaurus`</ph>, der einen Zeichenfolgenparameter akzeptiert und einen booleschen Wert zurückgibt, der angibt, ob die Eingabezeichenfolge "Saurus" endet.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph> generic method traverses the array from the beginning, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph> generische Methode durchläuft das Array von Anfang an und übergibt die einzelnen Elemente an die <ph id="ph2">`EndsWithSaurus`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element "Amargasaurus".</source>
          <target state="translated">Die Suche angehalten wird, wenn die <ph id="ph1">`EndsWithSaurus`</ph> -Methode zurückkehrt <ph id="ph2">`true`</ph> für das Element "Amargasaurus".</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">In c# und Visual Basic, ist es nicht erforderlich, erstellen Sie die <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegieren (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explizit.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Diese Sprachen leiten den richtigen Delegaten aus Kontext und automatisch zu erstellen.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLast%2A&gt;</ph> generic method is used to search the array backward from the end.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.FindLast%2A&gt;</ph> generische Methode wird verwendet, um das Array aus dem Ende rückwärts zu suchen.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>It finds the element "Dilophosaurus" at position 5.</source>
          <target state="translated">Es sucht nach dem Element "Dilophosaurus" an Position 5.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindAll%2A&gt;</ph> generic method is used to return an array containing all the elements that end in "saurus".</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.FindAll%2A&gt;</ph> generische Methode wird verwendet, um ein Array mit allen Elementen, die auf "Saurus" enden zurückgeben.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The elements are displayed.</source>
          <target state="translated">Die Elemente werden angezeigt.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>The code example also demonstrates the <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> generic methods.</source>
          <target state="translated">Im Codebeispiel wird veranschaulicht, die auch die <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> generische Methoden.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" uid="M:System.Array.FindAll``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Searches for an element that matches the conditions defined by a specified predicate, and returns the zero-based index of the first occurrence within an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> or a portion of it.</source>
          <target state="translated">Sucht nach einem Element, das die durch das angegebene Prädikat angegebenen Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens in einem <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> oder einem Teil daraus zurück.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Der Typ der Elemente des Arrays.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Das zu durchsuchende eindimensionale und nullbasierte <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the element to search for.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph>, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the entire <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens im gesamten <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The zero-based index of the first occurrence of an element that matches the conditions defined by <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, if found; otherwise, -1.</source>
          <target state="translated">Der nullbasierte Index des ersten Vorkommens eines Elements, das mit den durch <ph id="ph1">&lt;paramref name="match" /&gt;</ph> definierten Bedingungen übereinstimmt, sofern gefunden; andernfalls -1.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched forward starting at the first element and ending at the last element.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array&gt;</ph> vorwärts beginnend mit dem ersten Element und endet beim letzten Element durchsucht wird.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> ist ein Delegat an eine Methode, die zurückgibt <ph id="ph2">`true`</ph> an das Objekt übergeben sie die Bedingungen definiert, die im Delegaten übereinstimmt.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
          <target state="translated">Die Elemente der <ph id="ph1">`array`</ph> einzeln übergeben werden, um die <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>)-Vorgang, in dem <ph id="ph2">`n`</ph> ist die <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> von <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The following code example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Array.FindIndex%2A&gt;</ph> generic method.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, alle drei Überladungen, der die <ph id="ph1">&lt;xref:System.Array.FindIndex%2A&gt;</ph> generische Methode.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">Ein Array von Zeichenfolgen wird erstellt, 8, Dinosauriernamen enthält, von denen zwei (an Position 1 und 5) mit "Saurus" enden.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">Das Codebeispiel definiert auch eine Prädikat Search-Methode, die mit dem Namen <ph id="ph1">`EndsWithSaurus`</ph>, der einen Zeichenfolgenparameter akzeptiert und einen booleschen Wert zurückgibt, der angibt, ob die Eingabezeichenfolge "Saurus" endet.</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload traverses the array from the beginning, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> methodenüberladung durchläuft das Array von Anfang an und übergibt die einzelnen Elemente an die <ph id="ph2">`EndsWithSaurus`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element at position 1.</source>
          <target state="translated">Die Suche angehalten wird, wenn die <ph id="ph1">`EndsWithSaurus`</ph> -Methode zurückkehrt <ph id="ph2">`true`</ph> für das Element an der Position 1.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">In c# und Visual Basic, ist es nicht erforderlich, erstellen Sie die <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegieren (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explizit.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Diese Sprachen leiten den richtigen Delegaten aus Kontext und automatisch zu erstellen.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the array beginning at position 2 and continuing to the end of the array.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> methodenüberladung wird verwendet, um das Array, beginnend an Position 2 und bis zum Ende des Arrays zu fortfahren zu suchen.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>It finds the element at position 5.</source>
          <target state="translated">Er findet das Element an Position 5.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the range of three elements beginning at position 2.</source>
          <target state="translated">Schließlich die <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> methodenüberladung dient zum Suchen des Bereichs von drei Elementen, die an Position 2 ab.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>It returns –1 because there are no dinosaur names in that range that end with "saurus".</source>
          <target state="translated">Es gibt-1 zurück, da es sind keine Dinosauriernamen in diesem Bereich an, die mit "Saurus" enden.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Der Typ der Elemente des Arrays.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Das zu durchsuchende eindimensionale und nullbasierte <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The zero-based starting index of the search.</source>
          <target state="translated">Der nullbasierte Startindex für die Suche.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the element to search for.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph>, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that extends from the specified index to the last element.</source>
          <target state="translated">Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens innerhalb des Bereichs von Elementen im <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> zurück, der vom angegebenen Index bis zum letzten Element reicht.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The zero-based index of the first occurrence of an element that matches the conditions defined by <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, if found; otherwise, -1.</source>
          <target state="translated">Der nullbasierte Index des ersten Vorkommens eines Elements, das mit den durch <ph id="ph1">&lt;paramref name="match" /&gt;</ph> definierten Bedingungen übereinstimmt, sofern gefunden; andernfalls -1.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched forward starting at <ph id="ph2">`startIndex`</ph> and ending at the last element.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array&gt;</ph> vorwärts beginnenden durchsucht <ph id="ph2">`startIndex`</ph> beginnt und mit dem letzten Element.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> ist ein Delegat an eine Methode, die zurückgibt <ph id="ph2">`true`</ph> an das Objekt übergeben sie die Bedingungen definiert, die im Delegaten übereinstimmt.</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
          <target state="translated">Die Elemente der <ph id="ph1">`array`</ph> einzeln übergeben werden, um die <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from <ph id="ph3">`startIndex`</ph> to the end of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>)-Vorgang, in dem <ph id="ph2">`n`</ph> ist die Anzahl von Elementen aus <ph id="ph3">`startIndex`</ph> bis zum Ende des <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The following code example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Array.FindIndex%2A&gt;</ph> generic method.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, alle drei Überladungen, der die <ph id="ph1">&lt;xref:System.Array.FindIndex%2A&gt;</ph> generische Methode.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">Ein Array von Zeichenfolgen wird erstellt, 8, Dinosauriernamen enthält, von denen zwei (an Position 1 und 5) mit "Saurus" enden.</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">Das Codebeispiel definiert auch eine Prädikat Search-Methode, die mit dem Namen <ph id="ph1">`EndsWithSaurus`</ph>, der einen Zeichenfolgenparameter akzeptiert und einen booleschen Wert zurückgibt, der angibt, ob die Eingabezeichenfolge "Saurus" endet.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload traverses the array from the beginning, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> methodenüberladung durchläuft das Array von Anfang an und übergibt die einzelnen Elemente an die <ph id="ph2">`EndsWithSaurus`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element at position 1.</source>
          <target state="translated">Die Suche angehalten wird, wenn die <ph id="ph1">`EndsWithSaurus`</ph> -Methode zurückkehrt <ph id="ph2">`true`</ph> für das Element an der Position 1.</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">In c# und Visual Basic, ist es nicht erforderlich, erstellen Sie die <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegieren (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explizit.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Diese Sprachen leiten den richtigen Delegaten aus Kontext und automatisch zu erstellen.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the array beginning at position 2 and continuing to the end of the array.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> methodenüberladung wird verwendet, um das Array, beginnend an Position 2 und bis zum Ende des Arrays zu fortfahren zu suchen.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>It finds the element at position 5.</source>
          <target state="translated">Er findet das Element an Position 5.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the range of three elements beginning at position 2.</source>
          <target state="translated">Schließlich die <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> methodenüberladung dient zum Suchen des Bereichs von drei Elementen, die an Position 2 ab.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>It returns –1 because there are no dinosaur names in that range that end with "saurus".</source>
          <target state="translated">Es gibt-1 zurück, da es sind keine Dinosauriernamen in diesem Bereich an, die mit "Saurus" enden.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> liegt außerhalb des Bereichs der gültigen Indizes für <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Der Typ der Elemente des Arrays.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Das zu durchsuchende eindimensionale und nullbasierte <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The zero-based starting index of the search.</source>
          <target state="translated">Der nullbasierte Startindex für die Suche.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The number of elements in the section to search.</source>
          <target state="translated">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the element to search for.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph>, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that starts at the specified index and contains the specified number of elements.</source>
          <target state="translated">Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens innerhalb des Bereichs von Elementen im <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> zurück, der am angegebenen Index beginnt und die angegebene Anzahl von Elementen umfasst.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The zero-based index of the first occurrence of an element that matches the conditions defined by <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, if found; otherwise, -1.</source>
          <target state="translated">Der nullbasierte Index des ersten Vorkommens eines Elements, das mit den durch <ph id="ph1">&lt;paramref name="match" /&gt;</ph> definierten Bedingungen übereinstimmt, sofern gefunden; andernfalls -1.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched forward starting at <ph id="ph2">`startIndex`</ph> and ending at <ph id="ph3">`startIndex`</ph> plus <ph id="ph4">`count`</ph> minus 1, if <ph id="ph5">`count`</ph> is greater than 0.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array&gt;</ph> vorwärts beginnenden durchsucht <ph id="ph2">`startIndex`</ph> und endet bei <ph id="ph3">`startIndex`</ph> plus <ph id="ph4">`count`</ph> minus 1, wenn <ph id="ph5">`count`</ph> ist größer als 0.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> ist ein Delegat an eine Methode, die zurückgibt <ph id="ph2">`true`</ph> an das Objekt übergeben sie die Bedingungen definiert, die im Delegaten übereinstimmt.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
          <target state="translated">Die Elemente der <ph id="ph1">`array`</ph> einzeln übergeben werden, um die <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>) Vorgang, wobei <ph id="ph2">`n`</ph> ist <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The following code example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Array.FindIndex%2A&gt;</ph> generic method.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, alle drei Überladungen, der die <ph id="ph1">&lt;xref:System.Array.FindIndex%2A&gt;</ph> generische Methode.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">Ein Array von Zeichenfolgen wird erstellt, 8, Dinosauriernamen enthält, von denen zwei (an Position 1 und 5) mit "Saurus" enden.</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">Das Codebeispiel definiert auch eine Prädikat Search-Methode, die mit dem Namen <ph id="ph1">`EndsWithSaurus`</ph>, der einen Zeichenfolgenparameter akzeptiert und einen booleschen Wert zurückgibt, der angibt, ob die Eingabezeichenfolge "Saurus" endet.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload traverses the array from the beginning, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> methodenüberladung durchläuft das Array von Anfang an und übergibt die einzelnen Elemente an die <ph id="ph2">`EndsWithSaurus`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element at position 1.</source>
          <target state="translated">Die Suche angehalten wird, wenn die <ph id="ph1">`EndsWithSaurus`</ph> -Methode zurückkehrt <ph id="ph2">`true`</ph> für das Element an der Position 1.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">In c# und Visual Basic, ist es nicht erforderlich, erstellen Sie die <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegieren (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explizit.</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Diese Sprachen leiten den richtigen Delegaten aus Kontext und automatisch zu erstellen.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the array beginning at position 2 and continuing to the end of the array.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> methodenüberladung wird verwendet, um das Array, beginnend an Position 2 und bis zum Ende des Arrays zu fortfahren zu suchen.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>It finds the element at position 5.</source>
          <target state="translated">Er findet das Element an Position 5.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the range of three elements beginning at position 2.</source>
          <target state="translated">Schließlich die <ph id="ph1">&lt;xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> methodenüberladung dient zum Suchen des Bereichs von drei Elementen, die an Position 2 ab.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>It returns –1 because there are no dinosaur names in that range that end with "saurus".</source>
          <target state="translated">Es gibt-1 zurück, da es sind keine Dinosauriernamen in diesem Bereich an, die mit "Saurus" enden.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> liegt außerhalb des Bereichs der gültigen Indizes für <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" uid="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> und <ph id="ph2">&lt;paramref name="count" /&gt;</ph> geben keinen gültigen Abschnitt im <ph id="ph3">&lt;paramref name="array" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Der Typ der Elemente des Arrays.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Das zu durchsuchende eindimensionale und nullbasierte <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the element to search for.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph>, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the last occurrence within the entire <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt das letzte Vorkommen im gesamten <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The last element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type <ph id="ph1">&lt;paramref name="T" /&gt;</ph>.</source>
          <target state="translated">Das letzte Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, sofern vorhanden, andernfalls der Standardwert für den Typ <ph id="ph1">&lt;paramref name="T" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> ist ein Delegat an eine Methode, die zurückgibt <ph id="ph2">`true`</ph> an das Objekt übergeben sie die Bedingungen definiert, die im Delegaten übereinstimmt.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, moving backward in the <ph id="ph3">&lt;xref:System.Array&gt;</ph>, starting with the last element and ending with the first element.</source>
          <target state="translated">Die Elemente der <ph id="ph1">`array`</ph> werden einzeln an übergeben der <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, die Navigation rückwärts in die <ph id="ph3">&lt;xref:System.Array&gt;</ph>, beginnend mit dem letzten Element und endend mit dem ersten Element.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>Processing is stopped when a match is found.</source>
          <target state="translated">Die Verarbeitung wird beendet, wenn eine Übereinstimmung gefunden wird.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>)-Vorgang, in dem <ph id="ph2">`n`</ph> ist die <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> von <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.FindLast%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Array.FindAll%2A&gt;</ph> generic methods.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.FindLast%2A&gt;</ph>, und <ph id="ph3">&lt;xref:System.Array.FindAll%2A&gt;</ph> generische Methoden.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">Ein Array von Zeichenfolgen wird erstellt, 8, Dinosauriernamen enthält, von denen zwei (an Position 1 und 5) mit "Saurus" enden.</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">Das Codebeispiel definiert auch eine Prädikat Search-Methode, die mit dem Namen <ph id="ph1">`EndsWithSaurus`</ph>, der einen Zeichenfolgenparameter akzeptiert und einen booleschen Wert zurückgibt, der angibt, ob die Eingabezeichenfolge "Saurus" endet.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph> generic method traverses the array from the beginning, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.Find%2A&gt;</ph> generische Methode durchläuft das Array von Anfang an und übergibt die einzelnen Elemente an die <ph id="ph2">`EndsWithSaurus`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element "Amargasaurus".</source>
          <target state="translated">Die Suche angehalten wird, wenn die <ph id="ph1">`EndsWithSaurus`</ph> -Methode zurückkehrt <ph id="ph2">`true`</ph> für das Element "Amargasaurus".</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the<ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">In c# und Visual Basic, ist es nicht erforderlich, erstellen Sie die<ph id="ph1">`Predicate&lt;string&gt;`</ph> delegieren (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explizit.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Diese Sprachen leiten den richtigen Delegaten aus Kontext und automatisch zu erstellen.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLast%2A&gt;</ph> generic method is used to search the array backward from the end.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.FindLast%2A&gt;</ph> generische Methode wird verwendet, um das Array aus dem Ende rückwärts zu suchen.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>It finds the element "Dilophosaurus" at position 5.</source>
          <target state="translated">Es sucht nach dem Element "Dilophosaurus" an Position 5.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindAll%2A&gt;</ph> generic method is used to return an array containing all the elements that end in "saurus".</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.FindAll%2A&gt;</ph> generische Methode wird verwendet, um ein Array mit allen Elementen, die auf "Saurus" enden zurückgeben.</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The elements are displayed.</source>
          <target state="translated">Die Elemente werden angezeigt.</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>The code example also demonstrates the <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> generic methods.</source>
          <target state="translated">Im Codebeispiel wird veranschaulicht, die auch die <ph id="ph1">&lt;xref:System.Array.Exists%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> generische Methoden.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" uid="M:System.Array.FindLast``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Searches for an element that matches the conditions defined by a specified predicate, and returns the zero-based index of the last occurrence within an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> or a portion of it.</source>
          <target state="translated">Sucht nach einem Element, das die durch das angegebene Prädikat angegebenen Bedingungen erfüllt, und gibt den nullbasierten Index des letzten Vorkommens in einem <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> oder einem Teil daraus zurück.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Der Typ der Elemente des Arrays.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Das zu durchsuchende eindimensionale und nullbasierte <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the element to search for.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph>, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the entire <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des letzten Vorkommens im gesamten <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The zero-based index of the last occurrence of an element that matches the conditions defined by <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Der nullbasierte Index des letzten Vorkommnisses eines Elements, das mit den durch <ph id="ph1">&lt;paramref name="match" /&gt;</ph> definierten Bedingungen übereinstimmt, sofern gefunden, andernfalls –1.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at the last element and ending at the first element.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array&gt;</ph> rückwärts beginnend mit dem letzten Element und endet mit dem ersten Element gesucht wird.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> ist ein Delegat an eine Methode, die zurückgibt <ph id="ph2">`true`</ph> an das Objekt übergeben sie die Bedingungen definiert, die im Delegaten übereinstimmt.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
          <target state="translated">Die Elemente der <ph id="ph1">`array`</ph> einzeln übergeben werden, um die <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>)-Vorgang, in dem <ph id="ph2">`n`</ph> ist die <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> von <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The following code example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Array.FindLastIndex%2A&gt;</ph> generic method.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, alle drei Überladungen, der die <ph id="ph1">&lt;xref:System.Array.FindLastIndex%2A&gt;</ph> generische Methode.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">Ein Array von Zeichenfolgen wird erstellt, 8, Dinosauriernamen enthält, von denen zwei (an Position 1 und 5) mit "Saurus" enden.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">Das Codebeispiel definiert auch eine Prädikat Search-Methode, die mit dem Namen <ph id="ph1">`EndsWithSaurus`</ph>, der einen Zeichenfolgenparameter akzeptiert und einen booleschen Wert zurückgibt, der angibt, ob die Eingabezeichenfolge "Saurus" endet.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload traverses the array backward from the end, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> methodenüberladung durchläuft das Array, die nach hinten vom Ende, übergibt jedes Element an der <ph id="ph2">`EndsWithSaurus`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element at position 5.</source>
          <target state="translated">Die Suche angehalten wird, wenn die <ph id="ph1">`EndsWithSaurus`</ph> -Methode zurückkehrt <ph id="ph2">`true`</ph> für das Element an Position 5.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">In c# und Visual Basic, ist es nicht erforderlich, erstellen Sie die <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegieren (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explizit.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Diese Sprachen leiten den richtigen Delegaten aus Kontext und automatisch zu erstellen.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the array beginning at position 4 and continuing backward to the beginning of the array.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> methodenüberladung wird verwendet, um das Array, beginnend an Position 4 und zu fortfahren rückwärts zum Anfang des Arrays zu suchen.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>It finds the element at position 1.</source>
          <target state="translated">Er findet das Element an der Position 1.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the range of three elements beginning at position 4 and working backward (that is, elements 4, 3, and 2).</source>
          <target state="translated">Schließlich die <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> methodenüberladung wird verwendet, um den Bereich von drei Elementen beginnend an Position 4 und rückwärts arbeiten (d. h. die Elemente 4, 3 und 2) suchen.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>It returns –1 because there are no dinosaur names in that range that end with "saurus".</source>
          <target state="translated">Es gibt-1 zurück, da es sind keine Dinosauriernamen in diesem Bereich an, die mit "Saurus" enden.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Der Typ der Elemente des Arrays.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Das zu durchsuchende eindimensionale und nullbasierte <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The zero-based starting index of the backward search.</source>
          <target state="translated">Der nullbasierte Startindex für die Rückwärtssuche.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the element to search for.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph>, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that extends from the first element to the specified index.</source>
          <target state="translated">Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des letzten Vorkommens innerhalb des Bereichs von Elementen im <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> zurück, der vom ersten Element bis zum angegeben Index reicht.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The zero-based index of the last occurrence of an element that matches the conditions defined by <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Der nullbasierte Index des letzten Vorkommnisses eines Elements, das mit den durch <ph id="ph1">&lt;paramref name="match" /&gt;</ph> definierten Bedingungen übereinstimmt, sofern gefunden, andernfalls –1.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at the first element.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array&gt;</ph> ist der gesuchte Rückwärtsrichtung <ph id="ph2">`startIndex`</ph> beginnt und mit dem ersten Element.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> ist ein Delegat an eine Methode, die zurückgibt <ph id="ph2">`true`</ph> an das Objekt übergeben sie die Bedingungen definiert, die im Delegaten übereinstimmt.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
          <target state="translated">Die Elemente der <ph id="ph1">`array`</ph> einzeln übergeben werden, um die <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from the beginning of <ph id="ph3">`array`</ph> to <ph id="ph4">`startIndex`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>)-Vorgang, in dem <ph id="ph2">`n`</ph> ist die Anzahl der Elemente vom Anfang des <ph id="ph3">`array`</ph> auf <ph id="ph4">`startIndex`</ph>.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The following code example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Array.FindLastIndex%2A&gt;</ph> generic method.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, alle drei Überladungen, der die <ph id="ph1">&lt;xref:System.Array.FindLastIndex%2A&gt;</ph> generische Methode.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">Ein Array von Zeichenfolgen wird erstellt, 8, Dinosauriernamen enthält, von denen zwei (an Position 1 und 5) mit "Saurus" enden.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">Das Codebeispiel definiert auch eine Prädikat Search-Methode, die mit dem Namen <ph id="ph1">`EndsWithSaurus`</ph>, der einen Zeichenfolgenparameter akzeptiert und einen booleschen Wert zurückgibt, der angibt, ob die Eingabezeichenfolge "Saurus" endet.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload traverses the array backward from the end, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> methodenüberladung durchläuft das Array, die nach hinten vom Ende, übergibt jedes Element an der <ph id="ph2">`EndsWithSaurus`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element at position 5.</source>
          <target state="translated">Die Suche angehalten wird, wenn die <ph id="ph1">`EndsWithSaurus`</ph> -Methode zurückkehrt <ph id="ph2">`true`</ph> für das Element an Position 5.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">In c# und Visual Basic, ist es nicht erforderlich, erstellen Sie die <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegieren (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explizit.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Diese Sprachen leiten den richtigen Delegaten aus Kontext und automatisch zu erstellen.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the array beginning at position 4 and continuing backward to the beginning of the array.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> methodenüberladung wird verwendet, um das Array, beginnend an Position 4 und zu fortfahren rückwärts zum Anfang des Arrays zu suchen.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>It finds the element at position 1.</source>
          <target state="translated">Er findet das Element an der Position 1.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the range of three elements beginning at position 4 and working backward (that is, elements 4, 3, and 2).</source>
          <target state="translated">Schließlich die <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> methodenüberladung wird verwendet, um den Bereich von drei Elementen beginnend an Position 4 und rückwärts arbeiten (d. h. die Elemente 4, 3 und 2) suchen.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>It returns –1 because there are no dinosaur names in that range that end with "saurus".</source>
          <target state="translated">Es gibt-1 zurück, da es sind keine Dinosauriernamen in diesem Bereich an, die mit "Saurus" enden.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> liegt außerhalb des Bereichs der gültigen Indizes für <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Der Typ der Elemente des Arrays.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Das zu durchsuchende eindimensionale und nullbasierte <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The zero-based starting index of the backward search.</source>
          <target state="translated">Der nullbasierte Startindex für die Rückwärtssuche.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The number of elements in the section to search.</source>
          <target state="translated">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> that defines the conditions of the element to search for.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph>, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the specified number of elements and ends at the specified index.</source>
          <target state="translated">Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens innerhalb des Bereichs von Elementen im <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> zurück, der die angegebene Anzahl von Elementen umfasst und am angegebenen Index endet.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The zero-based index of the last occurrence of an element that matches the conditions defined by <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Der nullbasierte Index des letzten Vorkommnisses eines Elements, das mit den durch <ph id="ph1">&lt;paramref name="match" /&gt;</ph> definierten Bedingungen übereinstimmt, sofern gefunden, andernfalls –1.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at <ph id="ph3">`startIndex`</ph> minus <ph id="ph4">`count`</ph> plus 1, if <ph id="ph5">`count`</ph> is greater than 0.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array&gt;</ph> ist der gesuchte Rückwärtsrichtung <ph id="ph2">`startIndex`</ph> und endet bei <ph id="ph3">`startIndex`</ph> minus <ph id="ph4">`count`</ph> plus 1, wenn <ph id="ph5">`count`</ph> ist größer als 0.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> ist ein Delegat an eine Methode, die zurückgibt <ph id="ph2">`true`</ph> an das Objekt übergeben sie die Bedingungen definiert, die im Delegaten übereinstimmt.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</source>
          <target state="translated">Die Elemente der <ph id="ph1">`array`</ph> einzeln übergeben werden, um die <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>) Vorgang, wobei <ph id="ph2">`n`</ph> ist <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The following code example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Array.FindLastIndex%2A&gt;</ph> generic method.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, alle drei Überladungen, der die <ph id="ph1">&lt;xref:System.Array.FindLastIndex%2A&gt;</ph> generische Methode.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">Ein Array von Zeichenfolgen wird erstellt, 8, Dinosauriernamen enthält, von denen zwei (an Position 1 und 5) mit "Saurus" enden.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The code example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">Das Codebeispiel definiert auch eine Prädikat Search-Methode, die mit dem Namen <ph id="ph1">`EndsWithSaurus`</ph>, der einen Zeichenfolgenparameter akzeptiert und einen booleschen Wert zurückgibt, der angibt, ob die Eingabezeichenfolge "Saurus" endet.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload traverses the array backward from the end, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> methodenüberladung durchläuft das Array, die nach hinten vom Ende, übergibt jedes Element an der <ph id="ph2">`EndsWithSaurus`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph> for the element at position 5.</source>
          <target state="translated">Die Suche angehalten wird, wenn die <ph id="ph1">`EndsWithSaurus`</ph> -Methode zurückkehrt <ph id="ph2">`true`</ph> für das Element an Position 5.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">In c# und Visual Basic, ist es nicht erforderlich, erstellen Sie die <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegieren (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explizit.</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Diese Sprachen leiten den richtigen Delegaten aus Kontext und automatisch zu erstellen.</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the array beginning at position 4 and continuing backward to the beginning of the array.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> methodenüberladung wird verwendet, um das Array, beginnend an Position 4 und zu fortfahren rückwärts zum Anfang des Arrays zu suchen.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>It finds the element at position 1.</source>
          <target state="translated">Er findet das Element an der Position 1.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> method overload is used to search the range of three elements beginning at position 4 and working backward (that is, elements 4, 3, and 2).</source>
          <target state="translated">Schließlich die <ph id="ph1">&lt;xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29&gt;</ph> methodenüberladung wird verwendet, um den Bereich von drei Elementen beginnend an Position 4 und rückwärts arbeiten (d. h. die Elemente 4, 3 und 2) suchen.</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>It returns –1 because there are no dinosaur names in that range that end with "saurus".</source>
          <target state="translated">Es gibt-1 zurück, da es sind keine Dinosauriernamen in diesem Bereich an, die mit "Saurus" enden.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> liegt außerhalb des Bereichs der gültigen Indizes für <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" uid="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> und <ph id="ph2">&lt;paramref name="count" /&gt;</ph> geben keinen gültigen Abschnitt im <ph id="ph3">&lt;paramref name="array" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Der Typ der Elemente des Arrays.</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> on whose elements the action is to be performed.</source>
          <target state="translated">Das eindimensionale nullbasierte <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>, für dessen Elemente die Aktion ausgeführt werden soll.</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Action`1" /&gt;</ph> to perform on each element of <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="T:System.Action`1" /&gt;</ph>, die für jedes Element von <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> ausgeführt werden soll.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>Performs the specified action on each element of the specified array.</source>
          <target state="translated">Führt die angegebene Aktion für jedes Element des angegebenen Arrays aus.</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Action%601&gt;</ph> is a delegate to a method that performs an action on the object passed to it.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Action%601&gt;</ph> ein Delegaten an eine Methode, die eine Aktion, für das Objekt ausführt übergeben wird.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Action%601&gt;</ph>.</source>
          <target state="translated">Die Elemente der <ph id="ph1">`array`</ph> einzeln übergeben werden, um die <ph id="ph2">&lt;xref:System.Action%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>)-Vorgang, in dem <ph id="ph2">`n`</ph> ist die <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> von <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>The following example shows how to use <ph id="ph1">&lt;xref:System.Array.ForEach%2A&gt;</ph> to display the squares of each element in an integer array.</source>
          <target state="translated">Das folgende Beispiel zeigt, wie Sie <ph id="ph1">&lt;xref:System.Array.ForEach%2A&gt;</ph> Quadrate der jedes Element in ein Array von Ganzzahlen angezeigt.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" uid="M:System.Array.ForEach``1(``0[],System.Action{``0})">
          <source><ph id="ph1">&lt;paramref name="action" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="action" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" uid="M:System.Array.GetEnumerator">
          <source>Returns an <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> for the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Gibt einen <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> für das <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" uid="M:System.Array.GetEnumerator">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> for the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> für das <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>[Visual Basic, C#]</source>
          <target state="translated">[Visual Basic, c#]</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in C++, <ph id="ph3">`For Each`</ph> in Visual Basic) hides the complexity of the enumerators.</source>
          <target state="translated">Die <ph id="ph1">`foreach`</ph> -Anweisung der Programmiersprache c# (<ph id="ph2">`for each`</ph> in C++ <ph id="ph3">`For Each`</ph> in Visual Basic) verbirgt die Komplexität der Enumeratoren.</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended, instead of directly manipulating the enumerator.</source>
          <target state="translated">Daher empfiehlt es sich, <ph id="ph1">`foreach`</ph> zu verwenden und den Enumerator nicht direkt zu ändern.</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
          <target state="translated">Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
          <target state="translated">Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> also brings the enumerator back to this position.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> setzt den Enumerator ebenfalls auf diese Position zurück.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>At this position, <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">An dieser Position ist <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> nicht definiert.</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>Therefore, you must call <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> to advance the enumerator to the first element of the collection before reading the value of <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</source>
          <target state="translated">Daher muss der Enumerator durch einen Aufruf von <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> auf das erste Element der Auflistung gesetzt werden, bevor der Wert von <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> gelesen werden kann.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> returns the same object until either <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> gibt solange dasselbe Objekt zurück, bis <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> sets <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the next element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> legt <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> auf das nächste Element fest.</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>If <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passes the end of the collection, the enumerator is positioned after the last element in the collection and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> übergibt am Ende der Auflistung der Enumerator hinter dem letzten Element in der Auflistung positioniert ist und <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> gibt <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>When the enumerator is at this position, subsequent calls to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> also return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Wenn der Enumerator ist an dieser Position ist nachfolgende Aufrufe <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> auch zurückgeben <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>If the last call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returned <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">Wenn der letzte Aufruf <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> zurückgegebene <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> ist nicht definiert.</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>To set <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the first element of the collection again, you can call <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> followed by <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</source>
          <target state="translated">Um <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> wieder auf das erste Element der Auflistung festzulegen, können Sie <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> gefolgt von <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> aufrufen.</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
          <target state="translated">Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist.</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</source>
          <target state="translated">Werden an der Auflistung Änderungen wie z. B. Hinzufügen, Bearbeiten oder Entfernen von Elementen vorgenommen, verliert der Enumerator unwiederbringlich seine Gültigkeit und sein Verhalten ist nicht definiert.</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread safe procedure.</source>
          <target state="translated">Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung. Daher ist die Enumeration einer Auflistung systemintern keine threadsichere Prozedur.</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</source>
          <target state="translated">Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</source>
          <target state="translated">Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Diese Methode ist ein o(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetEnumerator">
          <source>The following code example shows how to use <ph id="ph1">&lt;xref:System.Array.GetEnumerator%2A&gt;</ph> to list the elements of an array.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie <ph id="ph1">&lt;xref:System.Array.GetEnumerator%2A&gt;</ph> zum Auflisten der Elemente eines Arrays.</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" uid="M:System.Array.GetLength(System.Int32)">
          <source>A zero-based dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> whose length needs to be determined.</source>
          <target state="translated">Eine nullbasierte Dimension des <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>, deren Länge bestimmt werden soll.</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" uid="M:System.Array.GetLength(System.Int32)">
          <source>Gets a 32-bit integer that represents the number of elements in the specified dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ruft eine 32-Bit-Ganzzahl ab, die die Anzahl der Elemente in der angegebenen Dimension des <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> angibt.</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" uid="M:System.Array.GetLength(System.Int32)">
          <source>A 32-bit integer that represents the number of elements in the specified dimension.</source>
          <target state="translated">Eine 32-Bit-Ganzzahl, die die Anzahl der Elemente in der angegebenen Dimension angibt.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLength(System.Int32)">
          <source>An example of <ph id="ph1">&lt;xref:System.Array.GetLength%2A&gt;</ph> is <ph id="ph2">`GetLength(0)`</ph>, which returns the number of elements in the first dimension of the <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Ein Beispiel für <ph id="ph1">&lt;xref:System.Array.GetLength%2A&gt;</ph> ist <ph id="ph2">`GetLength(0)`</ph>, womit die Anzahl der Elemente in der ersten Dimension von der <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLength(System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Diese Methode ist ein o(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLength(System.Int32)">
          <source>The following example shows how to use <ph id="ph1">&lt;xref:System.Array.GetLength%2A&gt;</ph> to display the dimensions of two arrays with different ranks.</source>
          <target state="translated">Das folgende Beispiel zeigt, wie Sie <ph id="ph1">&lt;xref:System.Array.GetLength%2A&gt;</ph> anzuzeigenden Dimensionen von zwei Arrays mit unterschiedlichem Rang.</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" uid="M:System.Array.GetLength(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" uid="M:System.Array.GetLength(System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" uid="M:System.Array.GetLength(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is equal to or greater than <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> ist größer oder gleich <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" uid="M:System.Array.GetLongLength(System.Int32)">
          <source>A zero-based dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> whose length needs to be determined.</source>
          <target state="translated">Eine nullbasierte Dimension des <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>, deren Länge bestimmt werden soll.</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" uid="M:System.Array.GetLongLength(System.Int32)">
          <source>Gets a 64-bit integer that represents the number of elements in the specified dimension of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ruft eine 64-Bit-Ganzzahl ab, die die Anzahl der Elemente in der angegebenen Dimension des <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> angibt.</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" uid="M:System.Array.GetLongLength(System.Int32)">
          <source>A 64-bit integer that represents the number of elements in the specified dimension.</source>
          <target state="translated">Eine 64-Bit-Ganzzahl, die die Anzahl der Elemente in der angegebenen Dimension angibt.</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLongLength(System.Int32)">
          <source>An example of <ph id="ph1">&lt;xref:System.Array.GetLongLength%2A&gt;</ph> is <ph id="ph2">`GetLongLength(0)`</ph>, which returns the number of elements in the first dimension of the <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Ein Beispiel für <ph id="ph1">&lt;xref:System.Array.GetLongLength%2A&gt;</ph> ist <ph id="ph2">`GetLongLength(0)`</ph>, womit die Anzahl der Elemente in der ersten Dimension von der <ph id="ph3">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLongLength(System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Diese Methode ist ein o(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" uid="M:System.Array.GetLongLength(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" uid="M:System.Array.GetLongLength(System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" uid="M:System.Array.GetLongLength(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is equal to or greater than <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> ist größer oder gleich <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>A zero-based dimension of the array whose starting index needs to be determined.</source>
          <target state="translated">Eine nullbasierte Dimension des Arrays, dessen Startindex bestimmt werden soll.</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>Gets the index of the first element of the specified dimension in the array.</source>
          <target state="translated">Ruft den Index des ersten Elements der angegebenen Dimension im Array ab.</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>The index of the first element of the specified dimension in the array.</source>
          <target state="translated">Der Index des ersten Elements der angegebenen Dimension im Array.</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source><ph id="ph1">`GetLowerBound(0)`</ph> returns the starting index of the first dimension of the array, and <ph id="ph2">`GetLowerBound(Rank - 1)`</ph> returns the starting index of the last dimension of the array.</source>
          <target state="translated"><ph id="ph1">`GetLowerBound(0)`</ph> Der Startindex der ersten Dimension des Arrays zurückgibt und <ph id="ph2">`GetLowerBound(Rank - 1)`</ph> gibt den Startindex der letzten Dimension des Arrays zurück.</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> method always returns a value that indicates the index of the lower bound of the array, even if the array is empty.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> -Methode wird immer einen Wert, der der Index, der die untere Grenze des Arrays, gibt zurück, selbst wenn das Array leer ist.</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>Note that, although most arrays in the .NET Framework are zero-based (that is, the <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> method returns zero for each dimension of an array), the .NET Framework does support arrays that are not zero-based.</source>
          <target state="translated">Beachten Sie, dass, obwohl die meisten Arrays in .NET Framework nullbasiert sind (d. h. die <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> Methode gibt 0 (null) für jede Dimension eines Arrays zurück), .NET Framework unterstützt Arrays, die nicht nullbasiert sind.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>Such arrays can be created with the <ph id="ph1">&lt;xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29&gt;</ph> method, and can also be returned from unmanaged code.</source>
          <target state="translated">Solche Arrays erstellt werden können, mit der <ph id="ph1">&lt;xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29&gt;</ph> -Methode, und auch von nicht verwaltetem Code zurückgegeben werden kann.</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Diese Methode ist ein o(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods to display the bounds of a one-dimensional and two-dimensional array and to display the values of their array elements.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> Methoden, um die Grenzen eines eindimensionale und zweidimensionale Arrays anzuzeigen und um die Werte der entsprechenden Arrayelemente anzuzeigen.</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" uid="M:System.Array.GetLowerBound(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is equal to or greater than <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> ist größer oder gleich <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source>A zero-based dimension of the array whose upper bound needs to be determined.</source>
          <target state="translated">Eine nullbasierte Dimension des Arrays, dessen obere Grenze bestimmt werden soll.</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source>Gets the index of the last element of the specified dimension in the array.</source>
          <target state="translated">Ruft den Index des letzten Elements der angegebenen Dimension im Array ab.</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source>The index of the last element of the specified dimension in the array, or -1 if the specified dimension is empty.</source>
          <target state="translated">Der Index des letzten Elements in der angegebenen Dimension im Array oder -1, wenn die angegebene Dimension leer ist.</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source><ph id="ph1">`GetUpperBound(0)`</ph> returns the last index in the first dimension of the array, and <ph id="ph2">`GetUpperBound(Rank - 1)`</ph> returns the last index of the last dimension of the array.</source>
          <target state="translated"><ph id="ph1">`GetUpperBound(0)`</ph> den letzten Index der ersten Dimension des Arrays zurückgibt und <ph id="ph2">`GetUpperBound(Rank - 1)`</ph> den letzten Index der letzten Dimension des Arrays zurückgibt.</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Diese Methode ist ein o(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods to display the bounds of a one-dimensional and two-dimensional array and to display the values of their array elements.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> Methoden, um die Grenzen eines eindimensionale und zweidimensionale Arrays anzuzeigen und um die Werte der entsprechenden Arrayelemente anzuzeigen.</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" uid="M:System.Array.GetUpperBound(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> is equal to or greater than <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="dimension" /&gt;</ph> ist größer oder gleich <ph id="ph2">&lt;see cref="P:System.Array.Rank" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Gets the value of the specified element in the current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ruft den Wert des angegebenen Elements im aktuellen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32)">
          <source>A 32-bit integer that represents the position of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Eine 32-Bit-Ganzzahl, die die Position des abzurufenden <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>-Elements darstellt.</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32)">
          <source>Gets the value at the specified position in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ruft den Wert an der angegebenen Position des eindimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32)">
          <source>The index is specified as a 32-bit integer.</source>
          <target state="translated">Der Index wird als 32-Bit-Ganzzahl angegeben.</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32)">
          <source>The value at the specified position in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Der Wert an der angegebenen Position des eindimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether the value of <ph id="ph3">`index`</ph> is out of bounds.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> Methoden können bestimmen, ob der Wert des <ph id="ph3">`index`</ph> ist außerhalb des gültigen Bereichs.</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Diese Methode ist ein o(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie zum Festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array.</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly one dimension.</source>
          <target state="translated">Das aktuelle <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> hat nicht genau eine Dimension.</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is outside the range of valid indexes for the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> liegt außerhalb des Bereichs der gültigen Indizes für das aktuelle <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32[])">
          <source>A one-dimensional array of 32-bit integers that represent the indexes specifying the position of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Ein eindimensionales Array von 32-Bit-Ganzzahlen, das die Indizes darstellt, die die Position des abzurufenden <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>-Elements angeben.</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32[])">
          <source>Gets the value at the specified position in the multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ruft den Wert an der angegebenen Position des mehrdimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32[])">
          <source>The indexes are specified as an array of 32-bit integers.</source>
          <target state="translated">Die Indizes werden als ein Array von 32-Bit-Ganzzahlen angegeben.</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32[])">
          <source>The value at the specified position in the multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Der Wert an der angegebenen Position des mehrdimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32[])">
          <source>The number of elements in <ph id="ph1">`indices`</ph> must equal the number of dimensions in the <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Die Anzahl der Elemente im <ph id="ph1">`indices`</ph> muss gleich der Anzahl der Dimensionen in der <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32[])">
          <source>All elements in the <ph id="ph1">`indices`</ph> array must collectively specify the position of the desired element in the multidimensional <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Alle Elemente in der <ph id="ph1">`indices`</ph> Array geben muss zusammen die Position des gewünschten Elements des mehrdimensionalen <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> Methoden können bestimmen, ob einer der Indizes außerhalb des gültigen Bereichs.</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32[])">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Diese Methode ist ein o(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32[])">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie zum Festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array.</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indices" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32[])">
          <source>The number of dimensions in the current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> is not equal to the number of elements in <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>.</source>
          <target state="translated">Die Anzahl der Dimensionen im aktuellen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> ist nicht gleich der Anzahl der Elemente von <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32[])">
          <source>Any element in <ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ein Element von <ph id="ph1">&lt;paramref name="indices" /&gt;</ph> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64)">
          <source>A 64-bit integer that represents the position of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Eine 64-Bit-Ganzzahl, die die Position des abzurufenden <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>-Elements darstellt.</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64)">
          <source>Gets the value at the specified position in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ruft den Wert an der angegebenen Position des eindimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64)">
          <source>The index is specified as a 64-bit integer.</source>
          <target state="translated">Der Index wird als 64-Bit-Ganzzahl angegeben.</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64)">
          <source>The value at the specified position in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Der Wert an der angegebenen Position des eindimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether the value of <ph id="ph3">`index`</ph> is out of bounds.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> Methoden können bestimmen, ob der Wert des <ph id="ph3">`index`</ph> ist außerhalb des gültigen Bereichs.</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Diese Methode ist ein o(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie zum Festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array.</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly one dimension.</source>
          <target state="translated">Das aktuelle <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> hat nicht genau eine Dimension.</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is outside the range of valid indexes for the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> liegt außerhalb des Bereichs der gültigen Indizes für das aktuelle <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64[])">
          <source>A one-dimensional array of 64-bit integers that represent the indexes specifying the position of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Ein eindimensionales Array von 64-Bit-Ganzzahlen, das die Indizes darstellt, die die Position des abzurufenden <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>-Elements angeben.</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64[])">
          <source>Gets the value at the specified position in the multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ruft den Wert an der angegebenen Position des mehrdimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64[])">
          <source>The indexes are specified as an array of 64-bit integers.</source>
          <target state="translated">Die Indizes werden als ein Array von 64-Bit-Ganzzahlen angegeben.</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64[])">
          <source>The value at the specified position in the multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Der Wert an der angegebenen Position des mehrdimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64[])">
          <source>The number of elements in <ph id="ph1">`indices`</ph> must equal the number of dimensions in the <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Die Anzahl der Elemente im <ph id="ph1">`indices`</ph> muss gleich der Anzahl der Dimensionen in der <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64[])">
          <source>All elements in the <ph id="ph1">`indices`</ph> array must collectively specify the position of the desired element in the multidimensional <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Alle Elemente in der <ph id="ph1">`indices`</ph> Array geben muss zusammen die Position des gewünschten Elements des mehrdimensionalen <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> Methoden können bestimmen, ob einer der Indizes außerhalb des gültigen Bereichs.</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64[])">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Diese Methode ist ein o(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64[])">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie zum Festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array.</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indices" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64[])">
          <source>The number of dimensions in the current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> is not equal to the number of elements in <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>.</source>
          <target state="translated">Die Anzahl der Dimensionen im aktuellen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> ist nicht gleich der Anzahl der Elemente von <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64[])">
          <source>Any element in <ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ein Element von <ph id="ph1">&lt;paramref name="indices" /&gt;</ph> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Eine 32-Bit-Ganzzahl, die den Index für die erste Dimension des abzurufenden <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>-Elements darstellt.</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Eine 32-Bit-Ganzzahl, die den Index für die zweite Dimension des abzurufenden <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>-Elements darstellt.</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>Gets the value at the specified position in the two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ruft den Wert an der angegebenen Position des zweidimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>The indexes are specified as 32-bit integers.</source>
          <target state="translated">Die Indizes werden als 32-Bit-Ganzzahlen angegeben.</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>The value at the specified position in the two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Der Wert an der angegebenen Position des zweidimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> Methoden können bestimmen, ob einer der Indizes außerhalb des gültigen Bereichs.</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Diese Methode ist ein o(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie zum Festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array.</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly two dimensions.</source>
          <target state="translated">Das aktuelle <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> hat nicht genau zwei Dimensionen.</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32)">
          <source>Either <ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Eine 64-Bit-Ganzzahl, die den Index für die erste Dimension des abzurufenden <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>-Elements darstellt.</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Eine 64-Bit-Ganzzahl, die den Index für die zweite Dimension des abzurufenden <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>-Elements darstellt.</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>Gets the value at the specified position in the two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ruft den Wert an der angegebenen Position des zweidimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>The indexes are specified as 64-bit integers.</source>
          <target state="translated">Die Indizes werden als 64-Bit-Ganzzahlen angegeben.</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>The value at the specified position in the two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Der Wert an der angegebenen Position des zweidimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> Methoden können bestimmen, ob einer der Indizes außerhalb des gültigen Bereichs.</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Diese Methode ist ein o(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie zum Festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array.</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly two dimensions.</source>
          <target state="translated">Das aktuelle <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> hat nicht genau zwei Dimensionen.</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64)">
          <source>Either <ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Eine 32-Bit-Ganzzahl, die den Index für die erste Dimension des abzurufenden <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>-Elements darstellt.</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Eine 32-Bit-Ganzzahl, die den Index für die zweite Dimension des abzurufenden <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>-Elements darstellt.</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the third-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Eine 32-Bit-Ganzzahl, die den Index für die dritte Dimension des abzurufenden <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>-Elements darstellt.</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>Gets the value at the specified position in the three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ruft den Wert an der angegebenen Position des dreidimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>The indexes are specified as 32-bit integers.</source>
          <target state="translated">Die Indizes werden als 32-Bit-Ganzzahlen angegeben.</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>The value at the specified position in the three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Der Wert an der angegebenen Position des dreidimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> Methoden können bestimmen, ob einer der Indizes außerhalb des gültigen Bereichs.</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Diese Methode ist ein o(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie zum Festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array.</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly three dimensions.</source>
          <target state="translated">Das aktuelle <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> hat nicht genau drei Dimensionen.</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> or <ph id="ph3">&lt;paramref name="index3" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> oder <ph id="ph3">&lt;paramref name="index3" /&gt;</ph> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Eine 64-Bit-Ganzzahl, die den Index für die erste Dimension des abzurufenden <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>-Elements darstellt.</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Eine 64-Bit-Ganzzahl, die den Index für die zweite Dimension des abzurufenden <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>-Elements darstellt.</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the third-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to get.</source>
          <target state="translated">Eine 64-Bit-Ganzzahl, die den Index für die dritte Dimension des abzurufenden <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>-Elements darstellt.</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>Gets the value at the specified position in the three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ruft den Wert an der angegebenen Position des dreidimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>The indexes are specified as 64-bit integers.</source>
          <target state="translated">Die Indizes werden als 64-Bit-Ganzzahlen angegeben.</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>The value at the specified position in the three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Der Wert an der angegebenen Position des dreidimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> Methoden können bestimmen, ob einer der Indizes außerhalb des gültigen Bereichs.</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Diese Methode ist ein o(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie zum Festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array.</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly three dimensions.</source>
          <target state="translated">Das aktuelle <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> hat nicht genau drei Dimensionen.</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" uid="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> or <ph id="ph3">&lt;paramref name="index3" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> oder <ph id="ph3">&lt;paramref name="index3" /&gt;</ph> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Searches for the specified object and returns the index of its first occurrence in a one-dimensional array or in a range of elements in the array.</source>
          <target state="translated">Sucht das angegebene Objekt und gibt den Index seines ersten Auftretens in einem eindimensionalen Array oder in einem Elementbereich im Array zurück.</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>The one-dimensional array to search.</source>
          <target state="translated">Das zu durchsuchende eindimensionale Array.</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Das in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> zu suchende Objekt.</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>Searches for the specified object and returns the index of its first occurrence in a one-dimensional array.</source>
          <target state="translated">Sucht nach dem angegebenen Objekt und gibt den Index des ersten Vorkommens in einem eindimensionalen Array zurück.</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>The index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if found; otherwise, the lower bound of the array minus 1.</source>
          <target state="translated">Der Index des ersten Vorkommens von <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, sofern gefunden, andernfalls die untere Grenze des Arrays minus 1.</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>This method searches all the elements of a one-dimensional arrayfor <ph id="ph1">`value`</ph>.</source>
          <target state="translated">Diese Methode sucht alle Elemente in einem eindimensionalen Arrayfor <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>To determine whether <ph id="ph1">`value`</ph> exists in <ph id="ph2">`array`</ph>, the method performs an equality comparison by calling each element's <ph id="ph3">`Equals`</ph> method until it finds a match.</source>
          <target state="translated">Um zu bestimmen, ob <ph id="ph1">`value`</ph> vorhanden ist, <ph id="ph2">`array`</ph>, die Methode führt einen Gleichheitsvergleich durch Aufrufen des Elements <ph id="ph3">`Equals`</ph> Methode, bis eine Übereinstimmung gefunden wird.</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>This means that if the element overrides the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method, that override is called.</source>
          <target state="translated">Dies bedeutet, dass, wenn das Element überschreibt die <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> Methode, die Außerkraftsetzung wird aufgerufen.</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>Because most arrays have a lower bound of zero, this method generally returns –1 if<ph id="ph1">`value`</ph> isn’t found.</source>
          <target state="translated">Da die meisten Arrays auf eine unteren Grenze von 0 (null) haben, in der Regel bei Rückgabe dieser Methode – 1<ph id="ph1">`value`</ph> nicht gefunden.</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>In the rare case that the lower bound of the array is equal to <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph>(0x80000000) and <ph id="ph2">`value`</ph> isn’t found, this method returns <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> (0x7FFFFFFF).</source>
          <target state="translated">In dem seltenen Fall, die die untere Grenze des Arrays entspricht <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph>(0 x 80000000) und <ph id="ph2">`value`</ph> nicht gefunden wird, gibt diese Methode <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> (0x7FFFFFFF).</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>)-Vorgang, in dem <ph id="ph2">`n`</ph> ist die <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> von <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source>The example calls the following three overloads of the <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> method to find the index of a string in a string array:</source>
          <target state="translated">Im Beispiel wird die folgenden drei Überladungen der <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> Methode, um den Index einer Zeichenfolge in einem Zeichenfolgenarray zu ermitteln:</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29&gt;</ph>, to determine the first occurrence of the string "the" in a string array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29&gt;</ph>, um zu bestimmen, das erste Vorkommen der Zeichenfolge "the" in ein Zeichenfolgenarray.</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29&gt;</ph>, to determine the first occurrence of the string "the" in the fourth to the last elements of a string array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29&gt;</ph>, um zu bestimmen, das erste Vorkommen der Zeichenfolge "the" in das vierte an die letzten Elemente eines Zeichenfolgenarrays.</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, to determine the first occurrence of the string "the" in a string array from the element that follows the last successful match to the end of the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, um zu bestimmen, das erste Vorkommen der Zeichenfolge "the" in einer Zeichenfolge array, aus dem Element, das am Ende des Arrays die letzte erfolgreiche Übereinstimmung folgt.</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>The one-dimensional array to search.</source>
          <target state="translated">Das zu durchsuchende eindimensionale Array.</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Das in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> zu suchende Objekt.</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>The starting index of the search.</source>
          <target state="translated">Der Startindex für die Suche.</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>0 (zero) is valid in an empty array.</source>
          <target state="translated">0 (null) ist in einem leeren Array gültig.</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of its first occurrence.</source>
          <target state="translated">Sucht das angegebene Objekt in einem Elementbereich eines eindimensionalen Arrays und gibt den Index seines ersten Auftretens zurück.</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>The range extends from a specified index to the end of the array.</source>
          <target state="translated">Der Bereich erstreckt sich von einem angegebenen Index bis zum Ende des Arrays.</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>The index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, if it’s found, within the range of elements in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> that extends from <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> to the last element; otherwise, the lower bound of the array minus 1.</source>
          <target state="translated">Der Index des ersten Vorkommens von <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, sofern gefunden, innerhalb des Bereichs von Elementen in <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, der sich von <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> bis zum letzten Element erstreckt, andernfalls die untere Grenze des Arrays minus 1.</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>This method searches a one-dimensional array from the element at index <ph id="ph1">`startIndex`</ph> to the last element.</source>
          <target state="translated">Diese Methode sucht ein eindimensionales Array, aus dem Element am Index <ph id="ph1">`startIndex`</ph> bis zum letzten Element.</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>To determine whether <ph id="ph1">`value`</ph> exists in <ph id="ph2">`array`</ph>, the method performs an equality comparison by calling the <ph id="ph3">`Equals`</ph> method of every element until it finds a match.</source>
          <target state="translated">Um zu bestimmen, ob <ph id="ph1">`value`</ph> vorhanden ist, <ph id="ph2">`array`</ph>, die Methode führt einen Gleichheitsvergleich durch Aufrufen der <ph id="ph3">`Equals`</ph> Methode jedes Elements, bis eine Übereinstimmung gefunden wird.</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>This means that if the element overrides the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method, that override is called.</source>
          <target state="translated">Dies bedeutet, dass, wenn das Element überschreibt die <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> Methode, die Außerkraftsetzung wird aufgerufen.</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>Because most arrays have a lower bound of zero, this method generally returns –1 if <ph id="ph1">`value`</ph> isn’t found.</source>
          <target state="translated">Da die meisten Arrays auf eine unteren Grenze von 0 (null) haben, in der Regel bei Rückgabe dieser Methode – 1 <ph id="ph1">`value`</ph> nicht gefunden.</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>In the rare case that the lower bound of the array is equal to <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph>(0x80000000) and <ph id="ph2">`value`</ph> isn’t found, this method returns <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> (0x7FFFFFFF).</source>
          <target state="translated">In dem seltenen Fall, die die untere Grenze des Arrays entspricht <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph>(0 x 80000000) und <ph id="ph2">`value`</ph> nicht gefunden wird, gibt diese Methode <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> (0x7FFFFFFF).</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> equals <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>,the method returns -1.</source>
          <target state="translated">Wenn <ph id="ph1">`startIndex`</ph> gleich <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, die Methode gibt-1 zurück.</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> is greater than <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, the method throws an <ph id="ph3">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">`startIndex`</ph> ist größer als <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, löst die Methode eine <ph id="ph3">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from <ph id="ph3">`startIndex`</ph> to the end of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>)-Vorgang, in dem <ph id="ph2">`n`</ph> ist die Anzahl von Elementen aus <ph id="ph3">`startIndex`</ph> bis zum Ende des <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source>The example calls the following three overloads of the <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> method to find the index of a string in a string array:</source>
          <target state="translated">Im Beispiel wird die folgenden drei Überladungen der <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> Methode, um den Index einer Zeichenfolge in einem Zeichenfolgenarray zu ermitteln:</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29&gt;</ph>, to determine the first occurrence of the string "the" in a string array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29&gt;</ph>, um zu bestimmen, das erste Vorkommen der Zeichenfolge "the" in ein Zeichenfolgenarray.</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29&gt;</ph>, to determine the first occurrence of the string "the" in the fourth to the last elements of a string array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29&gt;</ph>, um zu bestimmen, das erste Vorkommen der Zeichenfolge "the" in das vierte an die letzten Elemente eines Zeichenfolgenarrays.</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, to determine the first occurrence of the string "the" in a string array from the element that follows the last successful match to the end of the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, um zu bestimmen, das erste Vorkommen der Zeichenfolge "the" in einer Zeichenfolge array, aus dem Element, das am Ende des Arrays die letzte erfolgreiche Übereinstimmung folgt.</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> liegt außerhalb des Bereichs der gültigen Indizes für <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The one-dimensional array to search.</source>
          <target state="translated">Das zu durchsuchende eindimensionale Array.</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Das in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> zu suchende Objekt.</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The starting index of the search.</source>
          <target state="translated">Der Startindex für die Suche.</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>0 (zero) is valid in an empty array.</source>
          <target state="translated">0 (null) ist in einem leeren Array gültig.</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The number of elements to search.</source>
          <target state="translated">Die Anzahl der zu suchenden Elemente.</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of ifs first occurrence.</source>
          <target state="translated">Sucht das angegebene Objekt in einem Bereich von Elementen eines eindimensionalen Arrays und gibt den Index des ersten Vorkommens zurück.</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The range extends from a specified index for a specified number of elements.</source>
          <target state="translated">Der Bereich erstreckt sich von einem angegebenen Index für eine angegebene Anzahl von Elementen.</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, if it’s found in the <ph id="ph2">&lt;paramref name="array" /&gt;</ph> from index <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> to <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph><ph id="ph5"> + </ph><ph id="ph6">&lt;paramref name="count" /&gt;</ph> - 1; otherwise, the lower bound of the array minus 1.</source>
          <target state="translated">Der Index des ersten Vorkommens von <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, sofern gefunden im <ph id="ph2">&lt;paramref name="array" /&gt;</ph> vom <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>-Index bis <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph><ph id="ph5"> + </ph><ph id="ph6">&lt;paramref name="count" /&gt;</ph> – 1; andernfalls die untere Grenze des Arrays minus 1.</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>This method searches the elements of a one-dimensional arrayfrom <ph id="ph1">`startIndex`</ph> to <ph id="ph2">`startIndex`</ph> plus <ph id="ph3">`count`</ph> minus 1, if <ph id="ph4">`count`</ph> is greater than 0.</source>
          <target state="translated">Diese Methode sucht die Elemente einer eindimensionalen Arrayfrom <ph id="ph1">`startIndex`</ph> auf <ph id="ph2">`startIndex`</ph> plus <ph id="ph3">`count`</ph> minus 1, wenn <ph id="ph4">`count`</ph> ist größer als 0.</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>To determine whether <ph id="ph1">`value`</ph> exists in <ph id="ph2">`array`</ph>, the method performs an equality comparison by calling the <ph id="ph3">`Equals`</ph> method of every element until it finds a match.</source>
          <target state="translated">Um zu bestimmen, ob <ph id="ph1">`value`</ph> vorhanden ist, <ph id="ph2">`array`</ph>, die Methode führt einen Gleichheitsvergleich durch Aufrufen der <ph id="ph3">`Equals`</ph> Methode jedes Elements, bis eine Übereinstimmung gefunden wird.</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>This means that if the element overrides the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method, that override is called.</source>
          <target state="translated">Dies bedeutet, dass, wenn das Element überschreibt die <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> Methode, die Außerkraftsetzung wird aufgerufen.</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>Becausemost arrays have a lower bound of zero, this method generally returns –1 when <ph id="ph1">`value`</ph> isn’t found.</source>
          <target state="translated">Becausemost Arrays haben eine untere Grenze von 0 (null), gibt diese Methode in der Regel – 1 bei <ph id="ph1">`value`</ph> nicht gefunden.</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>In the rare case that the lower bound of the array is equal to <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> (0x80000000) and <ph id="ph2">`value`</ph> isn’t found, this method returns <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> (0x7FFFFFFF).</source>
          <target state="translated">In dem seltenen Fall, die die untere Grenze des Arrays entspricht <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> (0 x 80000000) und <ph id="ph2">`value`</ph> nicht gefunden wird, gibt diese Methode <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> (0x7FFFFFFF).</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`startindex`</ph> equals <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, the method returns -1.</source>
          <target state="translated">Wenn <ph id="ph1">`startindex`</ph> gleich <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, die Methode gibt-1 zurück.</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> is greater than <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, the method throws an <ph id="ph3">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">`startIndex`</ph> ist größer als <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, löst die Methode eine <ph id="ph3">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>) Vorgang, wobei <ph id="ph2">`n`</ph> ist <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The example calls the following three overloads of the <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> method to find the index of a string in a string array:</source>
          <target state="translated">Im Beispiel wird die folgenden drei Überladungen der <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> Methode, um den Index einer Zeichenfolge in einem Zeichenfolgenarray zu ermitteln:</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29&gt;</ph>, to determine the first occurrence of the string "the" in a string array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29&gt;</ph>, um zu bestimmen, das erste Vorkommen der Zeichenfolge "the" in ein Zeichenfolgenarray.</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29&gt;</ph>, to determine the first occurrence of the string "the" in the fourth to the last elements of a string array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29&gt;</ph>, um zu bestimmen, das erste Vorkommen der Zeichenfolge "the" in das vierte an die letzten Elemente eines Zeichenfolgenarrays.</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, to determine the first occurrence of the string "the" in a string array from the element that follows the last successful match to the end of the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, um zu bestimmen, das erste Vorkommen der Zeichenfolge "the" in einer Zeichenfolge array, aus dem Element, das am Ende des Arrays die letzte erfolgreiche Übereinstimmung folgt.</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>To determine the value of the <ph id="ph1">`count`</ph> argument, it subtracts the upper bound of the array from the starting index and adds one.</source>
          <target state="translated">Zum Bestimmen des Werts von der <ph id="ph1">`count`</ph> Argument, es subtrahiert die obere Grenze des Arrays aus den startIndex und hinzugefügt.</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> liegt außerhalb des Bereichs der gültigen Indizes für <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> und <ph id="ph2">&lt;paramref name="count" /&gt;</ph> geben keinen gültigen Abschnitt in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Der Typ der Elemente des Arrays.</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>The one-dimensional, zero-based array to search.</source>
          <target state="translated">Das zu durchsuchende eindimensionale und nullbasierte Array.</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Das in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> zu suchende Objekt.</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>Searches for the specified object and returns the index of its first occurrence in a one-dimensional array.</source>
          <target state="translated">Sucht nach dem angegebenen Objekt und gibt den Index des ersten Vorkommens in einem eindimensionalen Array zurück.</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>The zero-based index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in the entire <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Der nullbasierte Index des ersten Vorkommens von <ph id="ph1">&lt;paramref name="value" /&gt;</ph> im gesamten <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, sofern gefunden, andernfalls -1.</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>This method searches all the elements of a one-dimensional array for <ph id="ph1">`value`</ph>.</source>
          <target state="translated">Diese Methode sucht alle Elemente eines eindimensionalen Arrays für <ph id="ph1">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>To determine whether <ph id="ph1">`value`</ph> exists in <ph id="ph2">`array`</ph>, the method performs an equality comparison by calling the <ph id="ph3">`T.Equals`</ph> method on every element.</source>
          <target state="translated">Um zu bestimmen, ob <ph id="ph1">`value`</ph> vorhanden ist, <ph id="ph2">`array`</ph>, die Methode führt einen Gleichheitsvergleich durch Aufrufen der <ph id="ph3">`T.Equals`</ph> -Methode für jedes Element.</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>This means that if <ph id="ph1">`T`</ph> overrides the <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> method, that override is called.</source>
          <target state="translated">Dies bedeutet, dass bei <ph id="ph1">`T`</ph> überschreibt die <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> Methode, die Außerkraftsetzung wird aufgerufen.</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>)-Vorgang, in dem <ph id="ph2">`n`</ph> ist die <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> von <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>The following example demonstrates all three generic overloads of the <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">Das folgende Beispiel zeigt alle drei generische Überladung von der <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</source>
          <target state="translated">Ein Array von Zeichenfolgen wird mit einem Eintrag erstellt, die an die Indexposition 0 und Indexposition 5 zweimal angezeigt wird.</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>The <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> method overload searches the array from the beginning, and finds the first occurrence of the string.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> -methodenüberladung, durchsucht das Array ab und sucht das erste Vorkommen der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>The <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> method overload is used to search the array beginning with index location 3 and continuing to the end of the array, and finds the second occurrence of the string.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> methodenüberladung wird verwendet, um das Array, beginnend mit Indexposition 3 und bis zum Ende des Arrays zu fortfahren zu suchen, und sucht das zweite Vorkommen der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to search a range of two entries, beginning at index location two; it returns –1 because there are no instances of the search string in that range.</source>
          <target state="translated">Schließlich die <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> methodenüberladung wird verwendet, um einen Bereich mit zwei Einträgen, beginnend bei Indexposition zwei suchen; es gibt-1 zurück, da keine Instanzen der Suchzeichenfolge in diesem Bereich vorhanden sind.</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Der Typ der Elemente des Arrays.</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The one-dimensional, zero-based array to search.</source>
          <target state="translated">Das zu durchsuchende eindimensionale und nullbasierte Array.</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Das in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> zu suchende Objekt.</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The zero-based starting index of the search.</source>
          <target state="translated">Der nullbasierte Startindex für die Suche.</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>0 (zero) is valid in an empty array.</source>
          <target state="translated">0 (null) ist in einem leeren Array gültig.</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>Searches for the specified object in a range of elements of a one dimensional array, and returns the index of its first occurrence.</source>
          <target state="translated">Sucht das angegebene Objekt in einem Bereich von Elementen eines eindimensionalen Arrays und gibt den Index des ersten Vorkommens zurück.</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The range extends from a specified index to the end of the array.</source>
          <target state="translated">Der Bereich erstreckt sich von einem angegebenen Index bis zum Ende des Arrays.</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The zero-based index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> that extends from <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> to the last element, if found; otherwise, –1.</source>
          <target state="translated">Der nullbasierte Index des ersten Vorkommens von <ph id="ph1">&lt;paramref name="value" /&gt;</ph> innerhalb des Bereichs von Elementen in <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, der sich von <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> bis zum letzten Element erstreckt, sofern gefunden, andernfalls –1.</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>This method searches a one-dimensional array from the element at <ph id="ph1">`startIndex`</ph> to the end of the array.</source>
          <target state="translated">Diese Methode sucht ein eindimensionales Array, aus das Element am <ph id="ph1">`startIndex`</ph> bis zum Ende des Arrays.</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>To determine whether <ph id="ph1">`value`</ph> exists in <ph id="ph2">`array`</ph>, the method performs an equality comparison by calling the <ph id="ph3">`T.Equals`</ph> method on every element.</source>
          <target state="translated">Um zu bestimmen, ob <ph id="ph1">`value`</ph> vorhanden ist, <ph id="ph2">`array`</ph>, die Methode führt einen Gleichheitsvergleich durch Aufrufen der <ph id="ph3">`T.Equals`</ph> -Methode für jedes Element.</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>This means that if <ph id="ph1">`T`</ph> overrides the <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> method, that override is called.</source>
          <target state="translated">Dies bedeutet, dass bei <ph id="ph1">`T`</ph> überschreibt die <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> Methode, die Außerkraftsetzung wird aufgerufen.</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> equals <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph>,the method returns -1.If <ph id="ph3">`startIndex`</ph> is greater than <ph id="ph4">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, the method throws an <ph id="ph5">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">`startIndex`</ph> gleich <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph>, der Methodenrückgabe - 1.If <ph id="ph3">`startIndex`</ph> ist größer als <ph id="ph4">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, löst die Methode eine <ph id="ph5">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from <ph id="ph3">`startIndex`</ph> to the end of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>)-Vorgang, in dem <ph id="ph2">`n`</ph> ist die Anzahl von Elementen aus <ph id="ph3">`startIndex`</ph> bis zum Ende des <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The following example demonstrates all three generic overloads of the <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">Das folgende Beispiel zeigt alle drei generische Überladung von der <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</source>
          <target state="translated">Ein Array von Zeichenfolgen wird mit einem Eintrag erstellt, die an die Indexposition 0 und Indexposition 5 zweimal angezeigt wird.</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> method overload searches the array from the beginning, and finds the first occurrence of the string.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> -methodenüberladung, durchsucht das Array ab und sucht das erste Vorkommen der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> method overload is used to search the array beginning with index location 3 and continuing to the end of the array, and finds the second occurrence of the string.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> methodenüberladung wird verwendet, um das Array, beginnend mit Indexposition 3 und bis zum Ende des Arrays zu fortfahren zu suchen, und sucht das zweite Vorkommen der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to search a range of two entries, beginning at index location two; it returns –1 because there are no instances of the search string in that range.</source>
          <target state="translated">Schließlich die <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> methodenüberladung wird verwendet, um einen Bereich mit zwei Einträgen, beginnend bei Indexposition zwei suchen; es gibt-1 zurück, da keine Instanzen der Suchzeichenfolge in diesem Bereich vorhanden sind.</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> liegt außerhalb des Bereichs der gültigen Indizes für <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Der Typ der Elemente des Arrays.</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The one-dimensional, zero-based array to search.</source>
          <target state="translated">Das zu durchsuchende eindimensionale und nullbasierte Array.</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Das in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> zu suchende Objekt.</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The zero-based starting index of the search.</source>
          <target state="translated">Der nullbasierte Startindex für die Suche.</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>0 (zero) is valid in an empty array.</source>
          <target state="translated">0 (null) ist in einem leeren Array gültig.</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The number of elements in the section to search.</source>
          <target state="translated">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of its first occurrence.</source>
          <target state="translated">Sucht das angegebene Objekt in einem Elementbereich eines eindimensionalen Arrays und gibt den Index seines ersten Auftretens zurück.</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The range extends from a specified index for a specified number of elements.</source>
          <target state="translated">Der Bereich erstreckt sich von einem angegebenen Index für eine angegebene Anzahl von Elementen.</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The zero-based index of the first occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> that starts at <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> and contains the number of elements specified in <ph id="ph4">&lt;paramref name="count" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Der nullbasierte Index des ersten Vorkommens von <ph id="ph1">&lt;paramref name="value" /&gt;</ph> innerhalb des Bereichs von Elementen in <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, der am <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> beginnt und die durch <ph id="ph4">&lt;paramref name="count" /&gt;</ph> angegebene Anzahl von Elementen enthält, sofern gefunden, andernfalls –1.</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>This method searchesthe elements of a one-dimensional array from <ph id="ph1">`startIndex`</ph> to <ph id="ph2">`startIndex`</ph> plus <ph id="ph3">`count`</ph> minus 1, if <ph id="ph4">`count`</ph> is greater than 0.</source>
          <target state="translated">Diese Methode Searchesthe Elemente eines eindimensionalen Arrays von <ph id="ph1">`startIndex`</ph> auf <ph id="ph2">`startIndex`</ph> plus <ph id="ph3">`count`</ph> minus 1, wenn <ph id="ph4">`count`</ph> ist größer als 0.</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>To determine whether <ph id="ph1">`value`</ph> exists in <ph id="ph2">`array`</ph>, the method performs an equality comparison by calling the <ph id="ph3">`T.Equals`</ph> method on every element.</source>
          <target state="translated">Um zu bestimmen, ob <ph id="ph1">`value`</ph> vorhanden ist, <ph id="ph2">`array`</ph>, die Methode führt einen Gleichheitsvergleich durch Aufrufen der <ph id="ph3">`T.Equals`</ph> -Methode für jedes Element.</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>This means that if <ph id="ph1">`T`</ph> overrides the <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> method, that override is called.</source>
          <target state="translated">Dies bedeutet, dass bei <ph id="ph1">`T`</ph> überschreibt die <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> Methode, die Außerkraftsetzung wird aufgerufen.</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> equals <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, the method returns -1.</source>
          <target state="translated">Wenn <ph id="ph1">`startIndex`</ph> gleich <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, die Methode gibt-1 zurück.</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> is greater than <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, the method throws an <ph id="ph3">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">`startIndex`</ph> ist größer als <ph id="ph2">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph>, löst die Methode eine <ph id="ph3">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>) Vorgang, wobei <ph id="ph2">`n`</ph> ist <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The following example demonstrates all three generic overloads of the <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">Das folgende Beispiel zeigt alle drei generische Überladung von der <ph id="ph1">&lt;xref:System.Array.IndexOf%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</source>
          <target state="translated">Ein Array von Zeichenfolgen wird mit einem Eintrag erstellt, die an die Indexposition 0 und Indexposition 5 zweimal angezeigt wird.</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> method overload searches the array from the beginning, and finds the first occurrence of the string.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> -methodenüberladung, durchsucht das Array ab und sucht das erste Vorkommen der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> method overload is used to search the array beginning with index location 3 and continuing to the end of the array, and finds the second occurrence of the string.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> methodenüberladung wird verwendet, um das Array, beginnend mit Indexposition 3 und bis zum Ende des Arrays zu fortfahren zu suchen, und sucht das zweite Vorkommen der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to search a range of two entries, beginning at index location two; it returns –1 because there are no instances of the search string in that range.</source>
          <target state="translated">Schließlich die <ph id="ph1">&lt;xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> methodenüberladung wird verwendet, um einen Bereich mit zwei Einträgen, beginnend bei Indexposition zwei suchen; es gibt-1 zurück, da keine Instanzen der Suchzeichenfolge in diesem Bereich vorhanden sind.</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> liegt außerhalb des Bereichs der gültigen Indizes für <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" uid="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> und <ph id="ph2">&lt;paramref name="count" /&gt;</ph> geben keinen gültigen Abschnitt im <ph id="ph3">&lt;paramref name="array" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" uid="M:System.Array.Initialize">
          <source>Initializes every element of the value-type <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> by calling the default constructor of the value type.</source>
          <target state="translated">Initialisiert jedes Element des Werttyp-<ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> durch einen Aufruf des Standardkonstruktors für den Werttyp.</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Initialize">
          <source>This method is designed to help compilers support value-type arrays; most users do not need this method.</source>
          <target state="translated">Diese Methode soll helfen, Compiler Werttyp Arrays unterstützen; Die meisten Benutzer benötigen diese Methode nicht.</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Initialize">
          <source>It must not be used on reference-type arrays.</source>
          <target state="translated">Es muss nicht auf den Verweistyp-Arrays verwendet werden.</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Initialize">
          <source>If the <ph id="ph1">&lt;xref:System.Array&gt;</ph> is not a value-type <ph id="ph2">&lt;xref:System.Array&gt;</ph> or if the value type does not have a default constructor, the <ph id="ph3">&lt;xref:System.Array&gt;</ph> is not modified.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Array&gt;</ph> ist es sich nicht um ein Werttyp <ph id="ph2">&lt;xref:System.Array&gt;</ph> oder der Werttyp keinen Standardkonstruktor besitzt die <ph id="ph3">&lt;xref:System.Array&gt;</ph> wird nicht geändert.</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Initialize">
          <source>The value-type <ph id="ph1">&lt;xref:System.Array&gt;</ph> can have any lower bound and any number of dimensions.</source>
          <target state="translated">Der Werttyp <ph id="ph1">&lt;xref:System.Array&gt;</ph> untere Grenze und eine beliebige Anzahl von Dimensionen aufweisen.</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Initialize">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>) Vorgang, wobei <ph id="ph2">`n`</ph> ist <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Initialize">
          <source>You can use this method only on value types that have constructors; however, value types that are native to C# do not have constructors.</source>
          <target state="translated">Sie können diese Methode nur für Werttypen, die über Konstruktoren verfügen. jedoch sind Werttypen, die vom einheitlichen Modus zum c# sind keine Konstruktoren aufweisen.</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" uid="P:System.Array.IsFixedSize">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> has a fixed size.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob das <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> eine feste Größe aufweist.</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsFixedSize">
          <source>This property is always <ph id="ph1">&lt;see langword="true" /&gt;</ph> for all arrays.</source>
          <target state="translated">Diese Eigenschaft ist für alle Arrays immer <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsFixedSize">
          <source><ph id="ph1">&lt;xref:System.Array&gt;</ph> implements the <ph id="ph2">&lt;xref:System.Array.IsFixedSize%2A&gt;</ph> property because it is required by the <ph id="ph3">&lt;xref:System.Collections.IList?displayProperty=nameWithType&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> implementiert die <ph id="ph2">&lt;xref:System.Array.IsFixedSize%2A&gt;</ph> Eigenschaft, da er erforderlich ist der <ph id="ph3">&lt;xref:System.Collections.IList?displayProperty=nameWithType&gt;</ph> Schnittstelle.</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsFixedSize">
          <source>An array with a fixed size does not allow the addition or removal of elements after the array is created, but it allows the modification of existing elements.</source>
          <target state="translated">Ein Array mit fester Größe lässt das Hinzufügen oder Entfernen von Elementen nach dem das Array erstellt wird, die Änderung von vorhandenen Elementen können jedoch nicht zu.</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsFixedSize">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" uid="P:System.Array.IsReadOnly">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> is read-only.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob das <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> schreibgeschützt ist.</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsReadOnly">
          <source>This property is always <ph id="ph1">&lt;see langword="false" /&gt;</ph> for all arrays.</source>
          <target state="translated">Diese Eigenschaft ist für alle Arrays immer <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsReadOnly">
          <source><ph id="ph1">&lt;xref:System.Array&gt;</ph> implements the <ph id="ph2">&lt;xref:System.Array.IsReadOnly%2A&gt;</ph> property because it is required by the <ph id="ph3">&lt;xref:System.Collections.IList?displayProperty=nameWithType&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> implementiert die <ph id="ph2">&lt;xref:System.Array.IsReadOnly%2A&gt;</ph> Eigenschaft, da er erforderlich ist der <ph id="ph3">&lt;xref:System.Collections.IList?displayProperty=nameWithType&gt;</ph> Schnittstelle.</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsReadOnly">
          <source>An array that is read-only does not allow the addition, removal, or modification of elements after the array is created.</source>
          <target state="translated">Ein Array, das ist schreibgeschützt und lässt das Hinzufügen, entfernen oder Ändern von Elementen nach dem wird das Array erstellt nicht zu.</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsReadOnly">
          <source>If you require a read-only collection, use a <ph id="ph1">&lt;xref:System.Collections&gt;</ph> class that implements the <ph id="ph2">&lt;xref:System.Collections.IList?displayProperty=nameWithType&gt;</ph> interface.</source>
          <target state="translated">Wenn Sie eine schreibgeschützte Auflistung benötigen, verwenden Sie eine <ph id="ph1">&lt;xref:System.Collections&gt;</ph> Klasse, die implementiert die <ph id="ph2">&lt;xref:System.Collections.IList?displayProperty=nameWithType&gt;</ph> Schnittstelle.</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsReadOnly">
          <source>If you cast or convert an array to an <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> interface object, the <ph id="ph2">&lt;xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType&gt;</ph> property returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Wenn Sie umgewandelt oder ein Array konvertiert, ein <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> Schnittstellenobjekt, die <ph id="ph2">&lt;xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType&gt;</ph> -Eigenschaft gibt <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsReadOnly">
          <source>However, if you cast or convert an array to a <ph id="ph1">&lt;xref:System.Collections.Generic.IList%601&gt;</ph> interface, the <ph id="ph2">`IsReadOnly`</ph> property returns <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Jedoch umgewandelt oder konvertiert ein Array an eine <ph id="ph1">&lt;xref:System.Collections.Generic.IList%601&gt;</ph> -Schnittstelle, die <ph id="ph2">`IsReadOnly`</ph> -Eigenschaft gibt <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsReadOnly">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" uid="P:System.Array.IsSynchronized">
          <source>Gets a value indicating whether access to the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> is synchronized (thread safe).</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob der Zugriff auf die <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> synchronisiert (threadsicher) ist.</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>This property is always <ph id="ph1">&lt;see langword="false" /&gt;</ph> for all arrays.</source>
          <target state="translated">Diese Eigenschaft ist für alle Arrays immer <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source><ph id="ph1">&lt;xref:System.Array&gt;</ph> implements the <ph id="ph2">&lt;xref:System.Array.IsSynchronized%2A&gt;</ph> property because it is required by the <ph id="ph3">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array&gt;</ph> implementiert die <ph id="ph2">&lt;xref:System.Array.IsSynchronized%2A&gt;</ph> Eigenschaft, da er erforderlich ist der <ph id="ph3">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> Schnittstelle.</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>.NET Framework classes based on <ph id="ph1">&lt;xref:System.Array&gt;</ph> provide their own synchronized version of the collection using the <ph id="ph2">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">.NET Framework-Klassen basierend auf <ph id="ph1">&lt;xref:System.Array&gt;</ph> bieten eigene synchronisierte Version der Auflistung unter Verwendung der <ph id="ph2">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>Classes that use arrays can also implement their own synchronization using the <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">Klassen, die Arrays verwenden, können auch implementieren ihre eigenen Synchronisierung über die <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>The synchronizing code must perform operations on the <ph id="ph1">`SyncRoot`</ph> of the collection, not directly on the collection.</source>
          <target state="translated">Im Synchronisierungscode führen Vorgänge für die <ph id="ph1">`SyncRoot`</ph> der Auflistung, nicht direkt für die Auflistung.</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>This ensures proper operation of collections that are derived from other objects.</source>
          <target state="translated">Dies gewährleistet die einwandfreie Funktion von Auflistungen, die von anderen Objekten abgeleitet sind.</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the collection.</source>
          <target state="translated">Insbesondere verwaltet er die ordnungsgemäße Synchronisierung mit anderen Threads, die gleichzeitig die Auflistung eventuell.</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>Note that some implementations of <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> might return the <ph id="ph2">&lt;xref:System.Array&gt;</ph> itself.</source>
          <target state="translated">Beachten Sie, dass einige Implementierungen von <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> möglicherweise zurück, die <ph id="ph2">&lt;xref:System.Array&gt;</ph> selbst.</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>Enumerating through a collection is intrinsically not a thread safe procedure.</source>
          <target state="translated">Einer Auflistung ist systemintern keine threadsichere Prozedur.</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst.</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.IsSynchronized">
          <source>The following code example shows how to lock an array during the entire enumeration by using the <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie ein Array während der gesamten Enumeration sperren, mit der <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Returns the index of the last occurrence of a value in a one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> or in a portion of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Gibt den Index des letzten Vorkommens eines Werts in einem eindimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> oder in einem Teil des <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Das zu durchsuchende eindimensionale <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Das in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> zu suchende Objekt.</target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>Searches for the specified object and returns the index of the last occurrence within the entire one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Sucht nach dem angegebenen Objekt und gibt den Index des letzten Vorkommens innerhalb des gesamten eindimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>The index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the entire <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if found; otherwise, the lower bound of the array minus 1.</source>
          <target state="translated">Der Index des letzten Vorkommens von <ph id="ph1">&lt;paramref name="value" /&gt;</ph> im gesamten <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, sofern gefunden, andernfalls die untere Grenze des Arrays - 1.</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>The one-dimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at the last element and ending at the first element.</source>
          <target state="translated">Das eindimensionale <ph id="ph1">&lt;xref:System.Array&gt;</ph> rückwärts beginnend mit dem letzten Element und endet mit dem ersten Element gesucht wird.</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>The elements are compared to the specified value using the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Die Elemente mit dem angegebenen Wert verglichen werden die <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>If the element type is a nonintrinsic (user-defined) type, the <ph id="ph1">`Equals`</ph> implementation of that type is used.</source>
          <target state="translated">Wenn der Elementtyp ein systeminterner (Benutzerdefiniert) handelt, ist die <ph id="ph1">`Equals`</ph> Implementierung dieses Typs verwendet.</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>Since most arrays will have a lower bound of zero, this method would generally return –1 when <ph id="ph1">`value`</ph> is not found.</source>
          <target state="translated">Da die meisten Arrays mit eine unteren Grenze von 0 (null) hat, würden diese Methode in der Regel bei – 1 zurück <ph id="ph1">`value`</ph> wurde nicht gefunden.</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>In the rare case that the lower bound of the array is equal to <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">`value`</ph> is not found, this method returns <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>, which is <ph id="ph4">`System.Int32.MinValue - 1`</ph>.</source>
          <target state="translated">In dem seltenen Fall, die die untere Grenze des Arrays entspricht <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> und <ph id="ph2">`value`</ph> nicht gefunden wird, gibt diese Methode <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>, also <ph id="ph4">`System.Int32.MinValue - 1`</ph>.</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>)-Vorgang, in dem <ph id="ph2">`n`</ph> ist die <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> von <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>In the .NET Framework version 2.0, this method uses the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">&lt;xref:System.Array&gt;</ph> to determine whether the <ph id="ph4">&lt;xref:System.Object&gt;</ph> specified by the <ph id="ph5">`value`</ph> parameter exists.</source>
          <target state="translated">In .NET Framework, Version 2.0, diese Methode verwendet die <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> Methoden der <ph id="ph3">&lt;xref:System.Array&gt;</ph> um zu bestimmen, ob der <ph id="ph4">&lt;xref:System.Object&gt;</ph> gemäß der <ph id="ph5">`value`</ph> Parameter vorhanden ist.</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`value`</ph><ph id="ph4">&lt;xref:System.Object&gt;</ph> itself.</source>
          <target state="translated">In früheren Versionen von .NET Framework-diese Entscheidung wurde versucht, mithilfe der <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> Methoden die <ph id="ph3">`value`</ph> <ph id="ph4">&lt;xref:System.Object&gt;</ph> selbst.</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph2">`item`</ph> parameter on the objects in the collection.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> Methoden der <ph id="ph2">`item`</ph> Parameter für die Objekte in der Auflistung.</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source>The following code example shows how to determine the index of the last occurrence of a specified element in an array.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie den Index des letzten Vorkommens eines angegebenen Elements in einem Array zu bestimmen.</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Das zu durchsuchende eindimensionale <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Das in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> zu suchende Objekt.</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>The starting index of the backward search.</source>
          <target state="translated">Der Startindex für die Rückwärtssuche.</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>Searches for the specified object and returns the index of the last occurrence within the range of elements in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that extends from the first element to the specified index.</source>
          <target state="translated">Sucht nach dem angegebenen Objekt und gibt den Index des letzten Vorkommens innerhalb des Bereichs von Elementen im eindimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> zurück, der sich vom ersten Element bis zum angegebenen Index erstreckt.</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>The index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> that extends from the first element to <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, if found; otherwise, the lower bound of the array minus 1.</source>
          <target state="translated">Der Index des letzten Vorkommens von <ph id="ph1">&lt;paramref name="value" /&gt;</ph> innerhalb des Bereichs von Elementen in <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, der sich vom ersten Element bis zu <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> erstreckt, sofern gefunden, andernfalls die untere Grenze des Arrays - 1.</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at the first element.</source>
          <target state="translated">Das eindimensionale <ph id="ph1">&lt;xref:System.Array&gt;</ph> ist der gesuchte Rückwärtsrichtung <ph id="ph2">`startIndex`</ph> beginnt und mit dem ersten Element.</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>The elements are compared to the specified value using the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Die Elemente mit dem angegebenen Wert verglichen werden die <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>If the element type is a nonintrinsic (user-defined) type, the <ph id="ph1">`Equals`</ph> implementation of that type is used.</source>
          <target state="translated">Wenn der Elementtyp ein systeminterner (Benutzerdefiniert) handelt, ist die <ph id="ph1">`Equals`</ph> Implementierung dieses Typs verwendet.</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>Since most arrays will have a lower bound of zero, this method would generally return –1 when <ph id="ph1">`value`</ph> is not found.</source>
          <target state="translated">Da die meisten Arrays mit eine unteren Grenze von 0 (null) hat, würden diese Methode in der Regel bei – 1 zurück <ph id="ph1">`value`</ph> wurde nicht gefunden.</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>In the rare case that the lower bound of the array is equal to <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">`value`</ph> is not found, this method returns <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>, which is <ph id="ph4">`System.Int32.MinValue - 1`</ph>.</source>
          <target state="translated">In dem seltenen Fall, die die untere Grenze des Arrays entspricht <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> und <ph id="ph2">`value`</ph> nicht gefunden wird, gibt diese Methode <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>, also <ph id="ph4">`System.Int32.MinValue - 1`</ph>.</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from the beginning of <ph id="ph3">`array`</ph> to <ph id="ph4">`startIndex`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>)-Vorgang, in dem <ph id="ph2">`n`</ph> ist die Anzahl der Elemente vom Anfang des <ph id="ph3">`array`</ph> auf <ph id="ph4">`startIndex`</ph>.</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>In the .NET Framework version 2.0, this method uses the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">&lt;xref:System.Array&gt;</ph> to determine whether the <ph id="ph4">&lt;xref:System.Object&gt;</ph> specified by the <ph id="ph5">`value`</ph> parameter exists.</source>
          <target state="translated">In .NET Framework, Version 2.0, diese Methode verwendet die <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> Methoden der <ph id="ph3">&lt;xref:System.Array&gt;</ph> um zu bestimmen, ob der <ph id="ph4">&lt;xref:System.Object&gt;</ph> gemäß der <ph id="ph5">`value`</ph> Parameter vorhanden ist.</target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`value`</ph><ph id="ph4">&lt;xref:System.Object&gt;</ph> itself.</source>
          <target state="translated">In früheren Versionen von .NET Framework-diese Entscheidung wurde versucht, mithilfe der <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> Methoden die <ph id="ph3">`value`</ph> <ph id="ph4">&lt;xref:System.Object&gt;</ph> selbst.</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source>The following code example shows how to determine the index of the last occurrence of a specified element in an array.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie den Index des letzten Vorkommens eines angegebenen Elements in einem Array zu bestimmen.</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> liegt außerhalb des Bereichs der gültigen Indizes für <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Das zu durchsuchende eindimensionale <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Das in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> zu suchende Objekt.</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The starting index of the backward search.</source>
          <target state="translated">Der Startindex für die Rückwärtssuche.</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The number of elements in the section to search.</source>
          <target state="translated">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>Searches for the specified object and returns the index of the last occurrence within the range of elements in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the specified number of elements and ends at the specified index.</source>
          <target state="translated">Sucht nach dem angegebenen Objekt und gibt den Index des letzten Vorkommens innerhalb des Bereichs von Elementen im eindimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> zurück, der die angegebene Anzahl von Elementen enthält und am angegebenen Index endet.</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> that contains the number of elements specified in <ph id="ph3">&lt;paramref name="count" /&gt;</ph> and ends at <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph>, if found; otherwise, the lower bound of the array minus 1.</source>
          <target state="translated">Der Index des letzten Vorkommens von <ph id="ph1">&lt;paramref name="value" /&gt;</ph> im Bereich von Elementen in <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, der die durch <ph id="ph3">&lt;paramref name="count" /&gt;</ph> angegebene Anzahl von Elementen enthält und sich bis zu <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph> erstreckt, sofern gefunden, andernfalls die untere Grenze des Arrays - 1.</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at <ph id="ph3">`startIndex`</ph> minus <ph id="ph4">`count`</ph> plus 1, if <ph id="ph5">`count`</ph> is greater than 0.</source>
          <target state="translated">Das eindimensionale <ph id="ph1">&lt;xref:System.Array&gt;</ph> ist der gesuchte Rückwärtsrichtung <ph id="ph2">`startIndex`</ph> und endet bei <ph id="ph3">`startIndex`</ph> minus <ph id="ph4">`count`</ph> plus 1, wenn <ph id="ph5">`count`</ph> ist größer als 0.</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The elements are compared to the specified value using the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Die Elemente mit dem angegebenen Wert verglichen werden die <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>If the element type is a nonintrinsic (user-defined) type, the<ph id="ph1">`Equals`</ph> implementation of that type is used.</source>
          <target state="translated">Wenn der Elementtyp ein systeminterner (Benutzerdefiniert) handelt, ist die<ph id="ph1">`Equals`</ph> Implementierung dieses Typs verwendet.</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>Since most arrays will have a lower bound of zero, this method would generally return –1 when <ph id="ph1">`value`</ph> is not found.</source>
          <target state="translated">Da die meisten Arrays mit eine unteren Grenze von 0 (null) hat, würden diese Methode in der Regel bei – 1 zurück <ph id="ph1">`value`</ph> wurde nicht gefunden.</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>In the rare case that the lower bound of the array is equal to <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">`value`</ph> is not found, this method returns <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>, which is <ph id="ph4">`System.Int32.MinValue - 1`</ph>.</source>
          <target state="translated">In dem seltenen Fall, die die untere Grenze des Arrays entspricht <ph id="ph1">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> und <ph id="ph2">`value`</ph> nicht gefunden wird, gibt diese Methode <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>, also <ph id="ph4">`System.Int32.MinValue - 1`</ph>.</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>) Vorgang, wobei <ph id="ph2">`n`</ph> ist <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>In the .NET Framework version 2.0, this method uses the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">&lt;xref:System.Array&gt;</ph> to determine whether the <ph id="ph4">&lt;xref:System.Object&gt;</ph> specified by the <ph id="ph5">`value`</ph> parameter exists.</source>
          <target state="translated">In .NET Framework, Version 2.0, diese Methode verwendet die <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> Methoden der <ph id="ph3">&lt;xref:System.Array&gt;</ph> um zu bestimmen, ob der <ph id="ph4">&lt;xref:System.Object&gt;</ph> gemäß der <ph id="ph5">`value`</ph> Parameter vorhanden ist.</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>In the earlier versions of the .NET Framework, this determination was made by using the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> methods of the <ph id="ph3">`value`</ph><ph id="ph4">&lt;xref:System.Object&gt;</ph> itself.</source>
          <target state="translated">In früheren Versionen von .NET Framework-diese Entscheidung wurde versucht, mithilfe der <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.IComparable.CompareTo%2A&gt;</ph> Methoden die <ph id="ph3">`value`</ph> <ph id="ph4">&lt;xref:System.Object&gt;</ph> selbst.</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>The following code example shows how to determine the index of the last occurrence of a specified element in an array.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie den Index des letzten Vorkommens eines angegebenen Elements in einem Array zu bestimmen.</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>Note that the <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> method is a backward search; therefore, <ph id="ph2">`count`</ph> must be less than or equal to (<ph id="ph3">`startIndex`</ph> minus the lower bound of the array plus 1).</source>
          <target state="translated">Beachten Sie, dass die <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> Methode ist eine Rückwärtssuche daher <ph id="ph2">`count`</ph> muss kleiner als oder gleich sein (<ph id="ph3">`startIndex`</ph> minus die untere Grenze des Arrays plus 1).</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> liegt außerhalb des Bereichs der gültigen Indizes für <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> und <ph id="ph2">&lt;paramref name="count" /&gt;</ph> geben keinen gültigen Abschnitt in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Der Typ der Elemente des Arrays.</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Das zu durchsuchende eindimensionale und nullbasierte <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Das in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> zu suchende Objekt.</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>Searches for the specified object and returns the index of the last occurrence within the entire <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Sucht nach dem angegebenen Objekt und gibt den Index des letzten Vorkommens innerhalb des gesamten <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The zero-based index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the entire <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Der nullbasierte Index des letzten Vorkommens von <ph id="ph1">&lt;paramref name="value" /&gt;</ph> in der gesamten <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, sofern gefunden, andernfalls –1.</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at the last element and ending at the first element.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array&gt;</ph> rückwärts beginnend mit dem letzten Element und endet mit dem ersten Element gesucht wird.</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The elements are compared to the specified value using the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Die Elemente mit dem angegebenen Wert verglichen werden die <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>If the element type is a nonintrinsic (user-defined) type, the <ph id="ph1">`Equals`</ph> implementation of that type is used.</source>
          <target state="translated">Wenn der Elementtyp ein systeminterner (Benutzerdefiniert) handelt, ist die <ph id="ph1">`Equals`</ph> Implementierung dieses Typs verwendet.</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>)-Vorgang, in dem <ph id="ph2">`n`</ph> ist die <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> von <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The following code example demonstrates all three generic overloads of the <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> method.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, alle drei generische Überladung von der <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</source>
          <target state="translated">Ein Array von Zeichenfolgen wird mit einem Eintrag erstellt, die an die Indexposition 0 und Indexposition 5 zweimal angezeigt wird.</target>       </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> method overload searches the entire array from the end, and finds the second occurrence of the string.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> methodenüberladung sucht das gesamte Array vom Ende aus, und sucht das zweite Vorkommen der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>The <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> method overload is used to search the array backward beginning with index location 3 and continuing to the beginning of the array, and finds the first occurrence of the string.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> methodenüberladung wird verwendet, um die Abwärtskompatibilität Array, beginnend mit Indexposition 3 und auf den Anfang des Arrays zu fortfahren durchsuchen und sucht das erste Vorkommen der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to search a range of four entries, beginning at index location 4 and extending backward (that is, it searches the items at locations 4, 3, 2, and 1); this search returns –1 because there are no instances of the search string in that range.</source>
          <target state="translated">Schließlich die <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> methodenüberladung wird verwendet, um einen Bereich von vier Einträge, beginnend bei Indexposition 4 und rückwärts erweitern suchen (d. h. er sucht die Elemente an Stellen 4, 3, 2 und 1); diese Suche wird – 1 zurückgegeben, da keine Instanzen der Suche vorhanden sind die Zeichenfolge in diesem Bereich.</target>       </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Der Typ der Elemente des Arrays.</target>       </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Das zu durchsuchende eindimensionale und nullbasierte <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Das in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> zu suchende Objekt.</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The zero-based starting index of the backward search.</source>
          <target state="translated">Der nullbasierte Startindex für die Rückwärtssuche.</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>Searches for the specified object and returns the index of the last occurrence within the range of elements in the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that extends from the first element to the specified index.</source>
          <target state="translated">Sucht nach dem angegebenen Objekt und gibt den Index des letzten Vorkommens innerhalb des Bereichs von Elementen im <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> zurück, der sich vom ersten Element bis zum angegebenen Index erstreckt.</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The zero-based index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> that extends from the first element to <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Der nullbasierte Index des letzten Vorkommens von <ph id="ph1">&lt;paramref name="value" /&gt;</ph> innerhalb des Bereichs von Elementen in <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, der sich vom ersten Element bis zu <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> erstreckt, sofern gefunden, andernfalls –1.</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at the first element.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array&gt;</ph> ist der gesuchte Rückwärtsrichtung <ph id="ph2">`startIndex`</ph> beginnt und mit dem ersten Element.</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The elements are compared to the specified value using the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Die Elemente mit dem angegebenen Wert verglichen werden die <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>If the element type is a nonintrinsic (user-defined) type, the <ph id="ph1">`Equals`</ph> implementation of that type is used.</source>
          <target state="translated">Wenn der Elementtyp ein systeminterner (Benutzerdefiniert) handelt, ist die <ph id="ph1">`Equals`</ph> Implementierung dieses Typs verwendet.</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of elements from the beginning of <ph id="ph3">`array`</ph> to <ph id="ph4">`startIndex`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>)-Vorgang, in dem <ph id="ph2">`n`</ph> ist die Anzahl der Elemente vom Anfang des <ph id="ph3">`array`</ph> auf <ph id="ph4">`startIndex`</ph>.</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The following code example demonstrates all three generic overloads of the <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> method.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, alle drei generische Überladung von der <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</source>
          <target state="translated">Ein Array von Zeichenfolgen wird mit einem Eintrag erstellt, die an die Indexposition 0 und Indexposition 5 zweimal angezeigt wird.</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> method overload searches the entire array from the end, and finds the second occurrence of the string.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> methodenüberladung sucht das gesamte Array vom Ende aus, und sucht das zweite Vorkommen der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> method overload is used to search the array backward beginning with index location 3 and continuing to the beginning of the array, and finds the first occurrence of the string.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> methodenüberladung wird verwendet, um die Abwärtskompatibilität Array, beginnend mit Indexposition 3 und auf den Anfang des Arrays zu fortfahren durchsuchen und sucht das erste Vorkommen der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to search a range of four entries, beginning at index location 4 and extending backward (that is, it searches the items at locations 4, 3, 2, and 1); this search returns –1 because there are no instances of the search string in that range.</source>
          <target state="translated">Schließlich die <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> methodenüberladung wird verwendet, um einen Bereich von vier Einträge, beginnend bei Indexposition 4 und rückwärts erweitern suchen (d. h. er sucht die Elemente an Stellen 4, 3, 2 und 1); diese Suche wird – 1 zurückgegeben, da keine Instanzen der Suche vorhanden sind die Zeichenfolge in diesem Bereich.</target>       </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> liegt außerhalb des Bereichs der gültigen Indizes für <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Der Typ der Elemente des Arrays.</target>       </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to search.</source>
          <target state="translated">Das zu durchsuchende eindimensionale und nullbasierte <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The object to locate in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Das in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> zu suchende Objekt.</target>       </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The zero-based starting index of the backward search.</source>
          <target state="translated">Der nullbasierte Startindex für die Rückwärtssuche.</target>       </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The number of elements in the section to search.</source>
          <target state="translated">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</target>       </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>Searches for the specified object and returns the index of the last occurrence within the range of elements in the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the specified number of elements and ends at the specified index.</source>
          <target state="translated">Sucht nach dem angegebenen Objekt und gibt den Index des letzten Vorkommens innerhalb des Bereichs von Elementen im <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> zurück, der die angegebene Anzahl von Elementen enthält und am angegebenen Index endet.</target>       </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The zero-based index of the last occurrence of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> within the range of elements in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> that contains the number of elements specified in <ph id="ph3">&lt;paramref name="count" /&gt;</ph> and ends at <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Der nullbasierte Index des letzten Vorkommens von <ph id="ph1">&lt;paramref name="value" /&gt;</ph> innerhalb des Bereichs von Elementen in der <ph id="ph2">&lt;paramref name="array" /&gt;</ph>, der die durch <ph id="ph3">&lt;paramref name="count" /&gt;</ph> angegebene Anzahl von Elementen enthält und am <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph> endet, sofern gefunden, andernfalls –1.</target>       </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at <ph id="ph3">`startIndex`</ph> minus <ph id="ph4">`count`</ph> plus 1, if <ph id="ph5">`count`</ph> is greater than 0.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array&gt;</ph> ist der gesuchte Rückwärtsrichtung <ph id="ph2">`startIndex`</ph> und endet bei <ph id="ph3">`startIndex`</ph> minus <ph id="ph4">`count`</ph> plus 1, wenn <ph id="ph5">`count`</ph> ist größer als 0.</target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The elements are compared to the specified value using the <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Die Elemente mit dem angegebenen Wert verglichen werden die <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>If the element type is a nonintrinsic (user-defined) type, the <ph id="ph1">`Equals`</ph> implementation of that type is used.</source>
          <target state="translated">Wenn der Elementtyp ein systeminterner (Benutzerdefiniert) handelt, ist die <ph id="ph1">`Equals`</ph> Implementierung dieses Typs verwendet.</target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`count`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>) Vorgang, wobei <ph id="ph2">`n`</ph> ist <ph id="ph3">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The following code example demonstrates all three generic overloads of the <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> method.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, alle drei generische Überladung von der <ph id="ph1">&lt;xref:System.Array.LastIndexOf%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</source>
          <target state="translated">Ein Array von Zeichenfolgen wird mit einem Eintrag erstellt, die an die Indexposition 0 und Indexposition 5 zweimal angezeigt wird.</target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> method overload searches the entire array from the end, and finds the second occurrence of the string.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> methodenüberladung sucht das gesamte Array vom Ende aus, und sucht das zweite Vorkommen der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> method overload is used to search the array backward beginning with index location 3 and continuing to the beginning of the array, and finds the first occurrence of the string.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29&gt;</ph> methodenüberladung wird verwendet, um die Abwärtskompatibilität Array, beginnend mit Indexposition 3 und auf den Anfang des Arrays zu fortfahren durchsuchen und sucht das erste Vorkommen der Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to search a range of four entries, beginning at index location 4 and extending backward (that is, it searches the items at locations 4, 3, 2, and 1); this search returns –1 because there are no instances of the search string in that range.</source>
          <target state="translated">Schließlich die <ph id="ph1">&lt;xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> methodenüberladung wird verwendet, um einen Bereich von vier Einträge, beginnend bei Indexposition 4 und rückwärts erweitern suchen (d. h. er sucht die Elemente an Stellen 4, 3, 2 und 1); diese Suche wird – 1 zurückgegeben, da keine Instanzen der Suche vorhanden sind die Zeichenfolge in diesem Bereich.</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> liegt außerhalb des Bereichs der gültigen Indizes für <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" uid="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> und <ph id="ph2">&lt;paramref name="count" /&gt;</ph> geben keinen gültigen Abschnitt im <ph id="ph3">&lt;paramref name="array" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" uid="P:System.Array.Length">
          <source>Gets the total number of elements in all the dimensions of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ruft die Gesamtanzahl der Elemente in allen Dimensionen im <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Length">
          <source>The total number of elements in all the dimensions of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>; zero if there are no elements in the array.</source>
          <target state="translated">Die Gesamtanzahl der Elemente in allen Dimensionen die <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>; 0 (null), wenn keine Elemente im Array vorhanden sind.</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Length">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Length">
          <source>The following example uses the                                 <ph id="ph1">&lt;xref:System.Array.Length%2A&gt;</ph> property to get the total number of elements in an array.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.Array.Length%2A&gt;</ph> Eigenschaft, um die Gesamtanzahl der Elemente in einem Array abzurufen.</target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Length">
          <source>It also uses the                                 <ph id="ph1">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> method to determine the number of elements in each dimension of a multidimensional array.</source>
          <target state="translated">Darüber hinaus verwendet die <ph id="ph1">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> Methode, um die Anzahl der Elemente in jeder Dimension eines mehrdimensionalen Arrays festzulegen.</target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" uid="P:System.Array.Length">
          <source>The array is multidimensional and contains more than <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> elements.</source>
          <target state="translated">Das Array ist mehrdimensional und enthält mehr als <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>-Elemente.</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" uid="P:System.Array.LongLength">
          <source>Gets a 64-bit integer that represents the total number of elements in all the dimensions of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ruft eine 64-Bit-Ganzzahl ab, die die Gesamtanzahl der Elemente in allen Dimensionen des <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> angibt.</target>       </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.LongLength">
          <source>A 64-bit integer that represents the total number of elements in all the dimensions of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Eine 64-Bit-Ganzzahl, die die Gesamtanzahl der Elemente in allen Dimensionen des <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> angibt.</target>       </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.LongLength">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" uid="P:System.Array.Rank">
          <source>Gets the rank (number of dimensions) of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ruft der Rang (Anzahl der Dimensionen) des <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" uid="P:System.Array.Rank">
          <source>For example, a one-dimensional array returns 1, a two-dimensional array returns 2, and so on.</source>
          <target state="translated">Ein eindimensionales Array gibt z. B. 1 zurück, ein zweidimensionales Array gibt 2 zurück usw.</target>       </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Rank">
          <source>The rank (number of dimensions) of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Der Rang (Anzahl der Dimensionen) des <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Rank">
          <source>For example, the Visual Basic code</source>
          <target state="translated">Z. B. Visual Basic-code</target>       </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Rank">
          <source>and the C# code</source>
          <target state="translated">und der C#-code</target>       </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Rank">
          <source>create an array of three dimensions with a <ph id="ph1">&lt;xref:System.Array.Rank%2A&gt;</ph> property whose value is 3.</source>
          <target state="translated">erstellt ein Array von drei Dimensionen mit einer <ph id="ph1">&lt;xref:System.Array.Rank%2A&gt;</ph> Eigenschaft, deren Wert 3.</target>       </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Rank">
          <source>A jagged array (an array of arrays) is a one-dimensional array; the value of its <ph id="ph1">&lt;xref:System.Array.Rank%2A&gt;</ph> property is 1.</source>
          <target state="translated">Ein verzweigtes Array (ein Array aus Arrays) ist ein eindimensionales Array. der Wert von dessen <ph id="ph1">&lt;xref:System.Array.Rank%2A&gt;</ph> Eigenschaft ist 1.</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Rank">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.Rank">
          <source>The following example initializes a one-dimensional array, a two-dimensional array, and a jagged array, and retrieves the <ph id="ph1">&lt;xref:System.Array.Rank%2A&gt;</ph> property of each.</source>
          <target state="translated">Im folgenden Beispiel initialisiert ein eindimensionales Array, ein zweidimensionales Array und ein verzweigtes Array und ruft die <ph id="ph1">&lt;xref:System.Array.Rank%2A&gt;</ph> jeder Eigenschaft.</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Der Typ der Elemente des Arrays.</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>The one-dimensional, zero-based array to resize, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> to create a new array with the specified size.</source>
          <target state="translated">Das eindimensionale nullbasierte Array, dessen Größe geändert werden soll, oder <ph id="ph1">&lt;see langword="null" /&gt;</ph>, um ein neues Array mit der angegebenen Größe zu erstellen.</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>The size of the new array.</source>
          <target state="translated">Die Größe des neuen Arrays.</target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>Changes the number of elements of a one-dimensional array to the specified new size.</source>
          <target state="translated">Ändert die Anzahl der Elemente eines eindimensionalen Arrays in die angegebene neue Größe.</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>This method allocates a new array with the specified size, copies elements from the old array to the new one, and then replaces the old array with the new one.</source>
          <target state="translated">Diese Methode weist ein neues Array mit der angegebenen Größe, Elemente aus dem alten Array in das neue Projekt kopiert und ersetzt dann das alte Array mit den neuen Wert.</target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source><ph id="ph1">`array`</ph> must be a one-dimensional array.</source>
          <target state="translated"><ph id="ph1">`array`</ph> ein eindimensionales Array muss sein.</target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>If <ph id="ph1">`array`</ph> is <ph id="ph2">`null`</ph>, this method creates a new array with the specified size.</source>
          <target state="translated">Wenn <ph id="ph1">`array`</ph> ist <ph id="ph2">`null`</ph>, diese Methode erstellt ein neues Array mit der angegebenen Größe.</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>If <ph id="ph1">`newSize`</ph> is greater than the <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph> of the old array, a new array is allocated and all the elements are copied from the old array to the new one.</source>
          <target state="translated">Wenn <ph id="ph1">`newSize`</ph> ist größer als die <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph> des alten Arrays wird ein neues Array zugeordnet und alle Elemente werden aus dem alten Array in das neue Projekt kopiert.</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>If <ph id="ph1">`newSize`</ph> is less than the <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph> of the old array, a new array is allocated and elements are copied from the old array to the new one until the new one is filled; the rest of the elements in the old array are ignored.</source>
          <target state="translated">Wenn <ph id="ph1">`newSize`</ph> ist kleiner als das <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph> des alten Arrays wird ein neues Array zugeordnet und Elemente werden aus dem alten Array in das neue Projekt kopiert, bis das neue Array aufgefüllt wird; die übrigen Elemente im alten Array werden ignoriert.</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>If <ph id="ph1">`newSize`</ph> is equal to the <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph> of the old array, this method does nothing.</source>
          <target state="translated">Wenn <ph id="ph1">`newSize`</ph> ist gleich der <ph id="ph2">&lt;xref:System.Array.Length%2A&gt;</ph> des alten Arrays wird diese Methode keine Aktion ausgeführt.</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`newSize`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>) Vorgang, wobei <ph id="ph2">`n`</ph> ist <ph id="ph3">`newSize`</ph>.</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.Resize%2A&gt;</ph> method resizes a one-dimensional array only.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.Resize%2A&gt;</ph> Methode wird nur ein eindimensionales Array.</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array&gt;</ph> class does not include a method for resizing multi-dimensional arrays.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array&gt;</ph> Klasse eine Methode zum Ändern der Größe von mehrdimensionalen Arrays nicht einschließt.</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>To do this, you must either provide your own code or call a special-purpose method in a third-party library.</source>
          <target state="translated">Zu diesem Zweck müssen Sie Ihren eigenen Code bereitstellen oder eine spezielle Methode in einer Bibliothek eines Drittanbieters aufrufen.</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>The following code illustrates one possible implementation for a method that resizes an array of <bpt id="p1">*</bpt>n<ept id="p1">*</ept> dimensions.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht eine mögliche Implementierung für eine Methode, ein Array von der Größe der <bpt id="p1">*</bpt>n<ept id="p1">*</ept> Dimensionen.</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source>The following example shows how resizing affects the array.</source>
          <target state="translated">Das folgende Beispiel zeigt, wie Ändern der Größe des Arrays auswirkt.</target>       </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" uid="M:System.Array.Resize``1(``0[]@,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="newSize" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="newSize" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Reverses the order of the elements in a one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> or in a portion of the <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Kehrt die Reihenfolge der Elemente in einem eindimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> oder in einen Teil des <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> um.</target>       </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to reverse.</source>
          <target state="translated">Das umzukehrende eindimensionale <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array)">
          <source>Reverses the sequence of the elements in the entire one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Kehrt die Reihenfolge der Elemente im gesamten eindimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> um.</target>       </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array)">
          <source>After a call to this method, the element at <ph id="ph1">`myArray[i]`</ph>, where <ph id="ph2">`i`</ph> is any index in the array, moves to <ph id="ph3">`myArray[j]`</ph>, where <ph id="ph4">`j`</ph> equals <ph id="ph5">`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`</ph>.</source>
          <target state="translated">Nach dem Aufruf dieser Methode das Element am <ph id="ph1">`myArray[i]`</ph>, wobei <ph id="ph2">`i`</ph> ein Index im Array ist, verschiebt <ph id="ph3">`myArray[j]`</ph>, wobei <ph id="ph4">`j`</ph> gleich <ph id="ph5">`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`</ph>.</target>       </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>)-Vorgang, in dem <ph id="ph2">`n`</ph> ist die <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> von <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array)">
          <source>As the following example shows, the <ph id="ph1">&lt;xref:System.Array.Reverse%2A&gt;</ph> method can be used to reverse a jagged array.</source>
          <target state="translated">Wie im folgenden Beispiel wird gezeigt, die <ph id="ph1">&lt;xref:System.Array.Reverse%2A&gt;</ph> Methode kann verwendet werden, um ein verzweigtes Array umzukehren.</target>       </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array)">
          <source>It initializes a jagged array with one element for each month of the current year in the current culture's calendar.</source>
          <target state="translated">Initialisiert ein verzweigtes Array mit einem Element für jeden Monat des aktuellen Jahrs in der aktuellen Kultur dar.</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array)">
          <source>Each element contains an array with as many elements as that month has days.</source>
          <target state="translated">Jedes Element enthält ein Array mit beliebig viele Elemente, die diesen Monat Tage hat.</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array)">
          <source>The example displays the contents of the array, calls the <ph id="ph1">&lt;xref:System.Array.Reverse%2A&gt;</ph> method, and then displays the contents of the reversed array.</source>
          <target state="translated">Das Beispiel zeigt den Inhalt des Arrays, ruft die <ph id="ph1">&lt;xref:System.Array.Reverse%2A&gt;</ph> -Methode, und dann den Inhalt des umgekehrten Arrays.</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array)">
          <source>The following code example shows how to reverse the sort of the values in an <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie die Reihenfolge der Werte in umgekehrt ein <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to reverse.</source>
          <target state="translated">Das umzukehrende eindimensionale <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>The starting index of the section to reverse.</source>
          <target state="translated">Der Startindex des umzukehrenden Abschnitts.</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>The number of elements in the section to reverse.</source>
          <target state="translated">Die Anzahl der Elemente im umzukehrenden Abschnitt.</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>Reverses the sequence of the elements in a range of elements in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Kehrt die Reihenfolge der Elemente in einem Bereich von Elementen im eindimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> um.</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>After a call to this method, the element at <ph id="ph1">`myArray[i]`</ph>, where <ph id="ph2">`i`</ph> is any index in the array, moves to <ph id="ph3">`myArray[j]`</ph>, where <ph id="ph4">`j`</ph> equals <ph id="ph5">`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`</ph>.</source>
          <target state="translated">Nach dem Aufruf dieser Methode das Element am <ph id="ph1">`myArray[i]`</ph>, wobei <ph id="ph2">`i`</ph> ein Index im Array ist, verschiebt <ph id="ph3">`myArray[j]`</ph>, wobei <ph id="ph4">`j`</ph> gleich <ph id="ph5">`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`</ph>.</target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.Reverse%2A&gt;</ph> method can be used to reverse a jagged array.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.Reverse%2A&gt;</ph> Methode kann verwendet werden, um ein verzweigtes Array umzukehren.</target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is <ph id="ph3">`length`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>) Vorgang, wobei <ph id="ph2">`n`</ph> ist <ph id="ph3">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>The following code example shows how to reverse the sort of the values in a range of elements in an <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie die Sortierreihenfolge der Werte in einem Bereich der Elemente im umzukehrenden ein <ph id="ph1">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ist kleiner als die untere <ph id="ph2">&lt;paramref name="array" /&gt;</ph>-Grenze.</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" uid="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> und <ph id="ph2">&lt;paramref name="length" /&gt;</ph> geben keinen gültigen Bereich im <ph id="ph3">&lt;paramref name="array" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Sets the specified element in the current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to the specified value.</source>
          <target state="translated">Legt das angegebene Element im aktuellen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> auf den angegebenen Wert fest.</target>       </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>The new value for the specified element.</source>
          <target state="translated">Der neue Wert für das angegebene Element.</target>       </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>A 32-bit integer that represents the position of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">Eine 32-Bit-Ganzzahl, die die Position des festzulegenden <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>-Elements darstellt.</target>       </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>Sets a value to the element at the specified position in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Legt das Element an der angegebenen Position des eindimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> auf einen Wert fest.</target>       </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>The index is specified as a 32-bit integer.</source>
          <target state="translated">Der Index wird als 32-Bit-Ganzzahl angegeben.</target>       </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether the value of <ph id="ph3">`index`</ph> is out of bounds.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> Methoden können bestimmen, ob der Wert des <ph id="ph3">`index`</ph> ist außerhalb des gültigen Bereichs.</target>       </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zu Konvertierungen finden Sie unter <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Diese Methode ist ein o(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> zugewiesen <ph id="ph2">`null`</ph> auf ein Element eines Arrays von Werttypen, werden alle Felder des Elements auf 0 (null) initialisiert.</target>       </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">Der Wert des Elements ist kein null-Verweis und kann nicht durch Suchen nach einem null-Verweis gefunden werden.</target>       </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie zum Festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array.</target>       </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly one dimension.</source>
          <target state="translated">Das aktuelle <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> hat nicht genau eine Dimension.</target>       </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> kann nicht in den Elementtyp des aktuellen <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> umgewandelt werden.</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is outside the range of valid indexes for the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> liegt außerhalb des Bereichs der gültigen Indizes für das aktuelle <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>The new value for the specified element.</source>
          <target state="translated">Der neue Wert für das angegebene Element.</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>A one-dimensional array of 32-bit integers that represent the indexes specifying the position of the element to set.</source>
          <target state="translated">Ein eindimensionales Array von 32-Bit-Ganzzahlen, das die Indizes darstellt, die die Position des festzulegenden Elements angeben.</target>       </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>Sets a value to the element at the specified position in the multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Legt das Element an der angegebenen Position des mehrdimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> auf einen Wert fest.</target>       </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>The indexes are specified as an array of 32-bit integers.</source>
          <target state="translated">Die Indizes werden als ein Array von 32-Bit-Ganzzahlen angegeben.</target>       </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>The number of elements in <ph id="ph1">`indices`</ph> must equal the number of dimensions in the <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Die Anzahl der Elemente im <ph id="ph1">`indices`</ph> muss gleich der Anzahl der Dimensionen in der <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>All elements in the <ph id="ph1">`indices`</ph> array must collectively specify the position of the desired element in the multidimensional <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Alle Elemente in der <ph id="ph1">`indices`</ph> Array geben muss zusammen die Position des gewünschten Elements des mehrdimensionalen <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the values in the <ph id="ph3">`indices`</ph> array is out of bounds.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> Methoden können bestimmen, ob die Werte in der <ph id="ph3">`indices`</ph> Array ist außerhalb des gültigen Bereichs.</target>       </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zu Konvertierungen finden Sie unter <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Diese Methode ist ein o(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> zugewiesen <ph id="ph2">`null`</ph> auf ein Element eines Arrays von Werttypen, werden alle Felder des Elements auf 0 (null) initialisiert.</target>       </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">Der Wert des Elements ist kein null-Verweis und kann nicht durch Suchen nach einem null-Verweis gefunden werden.</target>       </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie zum Festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array.</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indices" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>The number of dimensions in the current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> is not equal to the number of elements in <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>.</source>
          <target state="translated">Die Anzahl der Dimensionen im aktuellen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> ist nicht gleich der Anzahl der Elemente von <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> kann nicht in den Elementtyp des aktuellen <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> umgewandelt werden.</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32[])">
          <source>Any element in <ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ein Element von <ph id="ph1">&lt;paramref name="indices" /&gt;</ph> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>The new value for the specified element.</source>
          <target state="translated">Der neue Wert für das angegebene Element.</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>A 64-bit integer that represents the position of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">Eine 64-Bit-Ganzzahl, die die Position des festzulegenden <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>-Elements darstellt.</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>Sets a value to the element at the specified position in the one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Legt das Element an der angegebenen Position des eindimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> auf einen Wert fest.</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>The index is specified as a 64-bit integer.</source>
          <target state="translated">Der Index wird als 64-Bit-Ganzzahl angegeben.</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether the value of <ph id="ph3">`index`</ph> is out of bounds.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> Methoden können bestimmen, ob der Wert des <ph id="ph3">`index`</ph> ist außerhalb des gültigen Bereichs.</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zu Konvertierungen finden Sie unter <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Diese Methode ist ein o(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> zugewiesen <ph id="ph2">`null`</ph> auf ein Element eines Arrays von Werttypen, werden alle Felder des Elements auf 0 (null) initialisiert.</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">Der Wert des Elements ist kein null-Verweis und kann nicht durch Suchen nach einem null-Verweis gefunden werden.</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie zum Festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array.</target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly one dimension.</source>
          <target state="translated">Das aktuelle <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> hat nicht genau eine Dimension.</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> kann nicht in den Elementtyp des aktuellen <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> umgewandelt werden.</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is outside the range of valid indexes for the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> liegt außerhalb des Bereichs der gültigen Indizes für das aktuelle <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>The new value for the specified element.</source>
          <target state="translated">Der neue Wert für das angegebene Element.</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>A one-dimensional array of 64-bit integers that represent the indexes specifying the position of the element to set.</source>
          <target state="translated">Ein eindimensionales Array von 64-Bit-Ganzzahlen, das die Indizes darstellt, die die Position des festzulegenden Elements angeben.</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>Sets a value to the element at the specified position in the multidimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Legt das Element an der angegebenen Position des mehrdimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> auf einen Wert fest.</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>The indexes are specified as an array of 64-bit integers.</source>
          <target state="translated">Die Indizes werden als ein Array von 64-Bit-Ganzzahlen angegeben.</target>       </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>The number of elements in <ph id="ph1">`indices`</ph> must equal the number of dimensions in the <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Die Anzahl der Elemente im <ph id="ph1">`indices`</ph> muss gleich der Anzahl der Dimensionen in der <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>All elements in the <ph id="ph1">`indices`</ph> array must collectively specify the position of the desired element in the multidimensional <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Alle Elemente in der <ph id="ph1">`indices`</ph> Array geben muss zusammen die Position des gewünschten Elements des mehrdimensionalen <ph id="ph2">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the values in the <ph id="ph3">`indices`</ph> array is out of bounds.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> Methoden können bestimmen, ob die Werte in der <ph id="ph3">`indices`</ph> Array ist außerhalb des gültigen Bereichs.</target>       </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zu Konvertierungen finden Sie unter <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Diese Methode ist ein o(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> zugewiesen <ph id="ph2">`null`</ph> auf ein Element eines Arrays von Werttypen, werden alle Felder des Elements auf 0 (null) initialisiert.</target>       </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">Der Wert des Elements ist kein null-Verweis und kann nicht durch Suchen nach einem null-Verweis gefunden werden.</target>       </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie zum Festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array.</target>       </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indices" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>The number of dimensions in the current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> is not equal to the number of elements in <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>.</source>
          <target state="translated">Die Anzahl der Dimensionen im aktuellen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> ist nicht gleich der Anzahl der Elemente von <ph id="ph2">&lt;paramref name="indices" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> kann nicht in den Elementtyp des aktuellen <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> umgewandelt werden.</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64[])">
          <source>Any element in <ph id="ph1">&lt;paramref name="indices" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ein Element von <ph id="ph1">&lt;paramref name="indices" /&gt;</ph> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>The new value for the specified element.</source>
          <target state="translated">Der neue Wert für das angegebene Element.</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">Eine 32-Bit-Ganzzahl, die den Index für die erste Dimension des festzulegenden <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>-Elements darstellt.</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">Eine 32-Bit-Ganzzahl, die den Index für die zweite Dimension des festzulegenden <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>-Elements darstellt.</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>Sets a value to the element at the specified position in the two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Legt das Element an der angegebenen Position des zweidimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> auf einen Wert fest.</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>The indexes are specified as 32-bit integers.</source>
          <target state="translated">Die Indizes werden als 32-Bit-Ganzzahlen angegeben.</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> Methoden können bestimmen, ob einer der Indizes außerhalb des gültigen Bereichs.</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zu Konvertierungen finden Sie unter <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Diese Methode ist ein o(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> zugewiesen <ph id="ph2">`null`</ph> auf ein Element eines Arrays von Werttypen, werden alle Felder des Elements auf 0 (null) initialisiert.</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">Der Wert des Elements ist kein null-Verweis und kann nicht durch Suchen nach einem null-Verweis gefunden werden.</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie zum Festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array.</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly two dimensions.</source>
          <target state="translated">Das aktuelle <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> hat nicht genau zwei Dimensionen.</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> kann nicht in den Elementtyp des aktuellen <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> umgewandelt werden.</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)">
          <source>Either <ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>The new value for the specified element.</source>
          <target state="translated">Der neue Wert für das angegebene Element.</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">Eine 64-Bit-Ganzzahl, die den Index für die erste Dimension des festzulegenden <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>-Elements darstellt.</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">Eine 64-Bit-Ganzzahl, die den Index für die zweite Dimension des festzulegenden <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>-Elements darstellt.</target>       </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>Sets a value to the element at the specified position in the two-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Legt das Element an der angegebenen Position des zweidimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> auf einen Wert fest.</target>       </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>The indexes are specified as 64-bit integers.</source>
          <target state="translated">Die Indizes werden als 64-Bit-Ganzzahlen angegeben.</target>       </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> Methoden können bestimmen, ob einer der Indizes außerhalb des gültigen Bereichs.</target>       </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zu Konvertierungen finden Sie unter <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Diese Methode ist ein o(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> zugewiesen <ph id="ph2">`null`</ph> auf ein Element eines Arrays von Werttypen, werden alle Felder des Elements auf 0 (null) initialisiert.</target>       </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">Der Wert des Elements ist kein null-Verweis und kann nicht durch Suchen nach einem null-Verweis gefunden werden.</target>       </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie zum Festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array.</target>       </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly two dimensions.</source>
          <target state="translated">Das aktuelle <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> hat nicht genau zwei Dimensionen.</target>       </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> kann nicht in den Elementtyp des aktuellen <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> umgewandelt werden.</target>       </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)">
          <source>Either <ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>The new value for the specified element.</source>
          <target state="translated">Der neue Wert für das angegebene Element.</target>       </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">Eine 32-Bit-Ganzzahl, die den Index für die erste Dimension des festzulegenden <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>-Elements darstellt.</target>       </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">Eine 32-Bit-Ganzzahl, die den Index für die zweite Dimension des festzulegenden <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>-Elements darstellt.</target>       </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>A 32-bit integer that represents the third-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">Eine 32-Bit-Ganzzahl, die den Index für die dritte Dimension des festzulegenden <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>-Elements darstellt.</target>       </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>Sets a value to the element at the specified position in the three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Legt das Element an der angegebenen Position des dreidimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> auf einen Wert fest.</target>       </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>The indexes are specified as 32-bit integers.</source>
          <target state="translated">Die Indizes werden als 32-Bit-Ganzzahlen angegeben.</target>       </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> Methoden können bestimmen, ob einer der Indizes außerhalb des gültigen Bereichs.</target>       </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zu Konvertierungen finden Sie unter <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Diese Methode ist ein o(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> zugewiesen <ph id="ph2">`null`</ph> auf ein Element eines Arrays von Werttypen, werden alle Felder des Elements auf 0 (null) initialisiert.</target>       </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">Der Wert des Elements ist kein null-Verweis und kann nicht durch Suchen nach einem null-Verweis gefunden werden.</target>       </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie zum Festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array.</target>       </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly three dimensions.</source>
          <target state="translated">Das aktuelle <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> hat nicht genau drei Dimensionen.</target>       </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> kann nicht in den Elementtyp des aktuellen <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> umgewandelt werden.</target>       </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> or <ph id="ph3">&lt;paramref name="index3" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> oder <ph id="ph3">&lt;paramref name="index3" /&gt;</ph> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>The new value for the specified element.</source>
          <target state="translated">Der neue Wert für das angegebene Element.</target>       </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the first-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">Eine 64-Bit-Ganzzahl, die den Index für die erste Dimension des festzulegenden <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>-Elements darstellt.</target>       </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the second-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">Eine 64-Bit-Ganzzahl, die den Index für die zweite Dimension des festzulegenden <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>-Elements darstellt.</target>       </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>A 64-bit integer that represents the third-dimension index of the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> element to set.</source>
          <target state="translated">Eine 64-Bit-Ganzzahl, die den Index für die dritte Dimension des festzulegenden <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>-Elements darstellt.</target>       </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>Sets a value to the element at the specified position in the three-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Legt das Element an der angegebenen Position des dreidimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> auf einen Wert fest.</target>       </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>The indexes are specified as 64-bit integers.</source>
          <target state="translated">Die Indizes werden als 64-Bit-Ganzzahlen angegeben.</target>       </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> methods can determine whether any of the indexes is out of bounds.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.GetLowerBound%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A&gt;</ph> Methoden können bestimmen, ob einer der Indizes außerhalb des gültigen Bereichs.</target>       </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>For more information about conversions, see <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zu Konvertierungen finden Sie unter <ph id="ph1">&lt;xref:System.Convert&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Diese Methode ist ein o(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>If <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> is used to assign <ph id="ph2">`null`</ph> to an element of an array of value types, all fields of the element are initialized to zero.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Array.SetValue%2A&gt;</ph> zugewiesen <ph id="ph2">`null`</ph> auf ein Element eines Arrays von Werttypen, werden alle Felder des Elements auf 0 (null) initialisiert.</target>       </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>The value of the element is not a null reference, and cannot be found by searching for a null reference.</source>
          <target state="translated">Der Wert des Elements ist kein null-Verweis und kann nicht durch Suchen nach einem null-Verweis gefunden werden.</target>       </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie zum Festlegen und Abrufen eines bestimmten Werts in ein eindimensionales oder mehrdimensionales Array.</target>       </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly three dimensions.</source>
          <target state="translated">Das aktuelle <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> hat nicht genau drei Dimensionen.</target>       </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> cannot be cast to the element type of the current <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> kann nicht in den Elementtyp des aktuellen <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> umgewandelt werden.</target>       </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" uid="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="index1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> or <ph id="ph3">&lt;paramref name="index3" /&gt;</ph> is outside the range of valid indexes for the corresponding dimension of the current <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="index2" /&gt;</ph> oder <ph id="ph3">&lt;paramref name="index3" /&gt;</ph> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve" uid="T:System.Array">
          <source>Sorts the elements in a one-dimensional array.</source>
          <target state="translated">Sortiert die Elemente in einem eindimensionalen Array.</target>       </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort.</source>
          <target state="translated">Das zu sortierende eindimensionale <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array)">
          <source>Sorts the elements in an entire one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element of the <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Sortiert die Elemente in einem ganzen eindimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> mithilfe der <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph>-Implementierung jedes Elements des <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>Each element of <ph id="ph1">`array`</ph> must implement the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other element in <ph id="ph3">`array`</ph>.</source>
          <target state="translated">Jedes Element der <ph id="ph1">`array`</ph> implementieren müssen die <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> Schnittstelle kann Vergleiche mit jedem anderen Element im <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.</target>       </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Diese Methode verwendet die introspective Sortieralgorithmus (Introsort) wie folgt aus:</target>       </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Wenn die Partitionsgröße Elemente weniger als 16 ist, verwendet eine <bpt id="p1">[</bpt>einfügen sortieren<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Überschreitet die Anzahl der Partitionen 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, wobei <bpt id="p2">*</bpt>N<ept id="p2">*</ept> ist der Bereich des Eingabearrays, verwendet er eine <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">Andernfalls wird eine <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Diese Implementierung führt eine instabile Sortierung. Das heißt, wenn zwei Elemente gleich sind, kann deren Reihenfolge nicht beibehalten werden.</target>       </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente, die gleich sind.</target>       </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Für Arrays, die mithilfe von Algorithmen Heapsort und Quicksort im schlimmsten Fall sortiert sind, ist diese Methode eine O (<ph id="ph1">`n`</ph> Protokoll <ph id="ph2">`n`</ph>)-Vorgang, in dem <ph id="ph3">`n`</ph> ist die <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> von <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>The following code example shows how to sort the values in an <ph id="ph1">&lt;xref:System.Array&gt;</ph> using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie zum Sortieren der Werte in einer <ph id="ph1">&lt;xref:System.Array&gt;</ph> mithilfe des Standardcomparers und einem benutzerdefinierten Vergleich, der die Sortierreihenfolge umgekehrt.</target>       </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array)">
          <source>Note that the result might vary depending on the current <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated">Beachten Sie, die das Ergebnis, abhängig von der aktuellen variieren kann <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array)">
          <source>One or more elements in <ph id="ph1">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated">Mindestens ein Element in <ph id="ph1">&lt;paramref name="array" /&gt;</ph> implementiert die <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph>-Schnittstelle nicht.</target>       </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated">Das eindimensionale <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> mit den zu sortierenden Schlüsseln.</target>       </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to each of the keys in the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Das eindimensionale <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> mit den Elementen, die den jeweiligen Schlüsseln im <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> entsprechen.</target>       </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to sort only the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph>, wenn nur das <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> sortiert werden soll.</target>       </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>Sorts a pair of one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each key.</source>
          <target state="translated">Sortiert ein Paar von eindimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>-Objekten (das eine enthält die Schlüssel und das andere die entsprechenden Werte) nach den Schlüsseln im ersten <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> und verwendet dabei die <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph>-Implementierung jedes Schlüssels.</target>       </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Jeder Schlüssel in der <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> verfügt über ein entsprechendes Element in der <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">Wenn ein Schlüssel positioniert wird, bei der Sortierung, des entsprechenden Elements in der <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> auf ähnliche Weise neu angeordnet.</target>       </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Aus diesem Grund die <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> sortiert wird, gemäß der Anordnung der entsprechenden Schlüssel in der <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other key.</source>
          <target state="translated">Jeder Schlüssel in der <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> implementieren müssen die <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> Schnittstelle, um mit jedem anderen Schlüssel verglichen werden kann.</target>       </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">Sie können sortieren, wenn es mehr Elemente als Schlüssel sind, aber die Elemente, die ohne entsprechenden Schlüssel werden nicht sortiert.</target>       </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Wenn es sich um mehrere Schlüssel als Elemente können nicht sortiert werden; Dies löst dies einen <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.</target>       </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Diese Methode verwendet die introspective Sortieralgorithmus (Introsort) wie folgt aus:</target>       </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Wenn die Partitionsgröße Elemente weniger als 16 ist, verwendet eine <bpt id="p1">[</bpt>einfügen sortieren<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Überschreitet die Anzahl der Partitionen 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, wobei <bpt id="p2">*</bpt>N<ept id="p2">*</ept> ist der Bereich des Eingabearrays, verwendet er eine <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">Andernfalls wird eine <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Diese Implementierung führt eine instabile Sortierung. Das heißt, wenn zwei Elemente gleich sind, kann deren Reihenfolge nicht beibehalten werden.</target>       </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente, die gleich sind.</target>       </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`keys`</ph>.</source>
          <target state="translated">Für Arrays, die mithilfe von Algorithmen Heapsort und Quicksort im schlimmsten Fall sortiert sind, ist diese Methode eine O (<ph id="ph1">`n`</ph> Protokoll <ph id="ph2">`n`</ph>)-Vorgang, in dem <ph id="ph3">`n`</ph> ist die <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> von <ph id="ph5">`keys`</ph>.</target>       </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>The following example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values.</source>
          <target state="translated">Im folgende Beispiel wird das Sortieren von zwei verknüpften Arrays, wobei das erste Array enthält die Schlüssel und das zweite Array enthält die Werte, veranschaulicht.</target>       </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>Sorts are done using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">Sortierungen erfolgen mithilfe des Standardcomparers und einem benutzerdefinierten Vergleich, der die Sortierreihenfolge umgekehrt.</target>       </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>Note that the result might vary depending on the current <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated">Beachten Sie, die das Ergebnis, abhängig von der aktuellen variieren kann <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>The <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated">Das <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>The <ph id="ph1">&lt;paramref name="items" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated">Das <ph id="ph1">&lt;paramref name="items" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> ist nicht <ph id="ph2">&lt;see langword="null" /&gt;</ph>, und die Länge von <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> ist größer als die Länge von <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array)">
          <source>One or more elements in the <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated">Mindestens ein Element im <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> implementiert die <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph>-Schnittstelle nicht.</target>       </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>The one-dimensional array to sort.</source>
          <target state="translated">Das zu sortierende eindimensionale Array.</target>       </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>The implementation to use when comparing elements.</source>
          <target state="translated">Die Implementierung, die beim Vergleich von Elementen verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph>, wenn die <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph>-Implementierung des jeweiligen Elements verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Sorts the elements in a one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>.</source>
          <target state="translated">Sortiert die Elemente in einem eindimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> mithilfe des angegebenen <ph id="ph2">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each element of <ph id="ph3">`array`</ph> must implement the <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other element in <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">`comparer`</ph> ist <ph id="ph2">`null`</ph>, jedes Element der <ph id="ph3">`array`</ph> implementieren müssen die <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> Schnittstelle kann Vergleiche mit jedem anderen Element im <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.</target>       </trans-unit>
        <trans-unit id="1825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Diese Methode verwendet die introspective Sortieralgorithmus (Introsort) wie folgt aus:</target>       </trans-unit>
        <trans-unit id="1826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Wenn die Partitionsgröße Elemente weniger als 16 ist, verwendet eine <bpt id="p1">[</bpt>einfügen sortieren<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="1827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Überschreitet die Anzahl der Partitionen 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, wobei <bpt id="p2">*</bpt>N<ept id="p2">*</ept> ist der Bereich des Eingabearrays, verwendet er eine <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="1828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">Andernfalls wird eine <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="1829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Diese Implementierung führt eine instabile Sortierung. Das heißt, wenn zwei Elemente gleich sind, kann deren Reihenfolge nicht beibehalten werden.</target>       </trans-unit>
        <trans-unit id="1830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente, die gleich sind.</target>       </trans-unit>
        <trans-unit id="1831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Für Arrays, die mithilfe von Algorithmen Heapsort und Quicksort im schlimmsten Fall sortiert sind, ist diese Methode eine O (<ph id="ph1">`n`</ph> Protokoll <ph id="ph2">`n`</ph>)-Vorgang, in dem <ph id="ph3">`n`</ph> ist die <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> von <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1832" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>The .NET Framework includes predefined <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementations listed in the following table.</source>
          <target state="translated">.NET Framework enthält vordefinierte <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> Implementierungen in der folgenden Tabelle aufgeführt.</target>       </trans-unit>
        <trans-unit id="1833" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Implementation</source>
          <target state="translated">Implementierung</target>       </trans-unit>
        <trans-unit id="1834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Description</source>
          <target state="translated">Beschreibung </target>       </trans-unit>
        <trans-unit id="1835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Compares any two objects, but performs a case-insensitive comparison of strings.</source>
          <target state="translated">Vergleicht zwei Objekte, jedoch führt einen Vergleich Groß-/Kleinschreibung der Zeichenfolgen.</target>       </trans-unit>
        <trans-unit id="1836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the current culture.</source>
          <target state="translated">Vergleicht zwei Objekte mithilfe der Sortierkonventionen der aktuellen Kultur an.</target>       </trans-unit>
        <trans-unit id="1837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the invariant culture.</source>
          <target state="translated">Vergleicht zwei Objekte mithilfe der Sortierkonventionen der invarianten Kultur.</target>       </trans-unit>
        <trans-unit id="1838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Compares two objects of type <ph id="ph1">`T`</ph> by using the type's default sort order.</source>
          <target state="translated">Vergleicht zwei Objekte des Typs <ph id="ph1">`T`</ph> mithilfe von Standard-Sortierreihenfolge des Typs.</target>       </trans-unit>
        <trans-unit id="1839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>You can also support custom comparisons by providing an instance of your own <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation to the <ph id="ph2">`comparer`</ph> parameter.</source>
          <target state="translated">Sie können auch benutzerdefinierte Vergleiche unterstützen, indem Sie eine eigene Instanz bereitgestellt <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> -Implementierung, die die <ph id="ph2">`comparer`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="1840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>The example does this by defining a <ph id="ph1">`ReverseComparer`</ph> class that reverses the default sort order for instances of a type and performs case-insensitive string comparison.</source>
          <target state="translated">Im Beispiel wird dies durch die Definition einer <ph id="ph1">`ReverseComparer`</ph> -Klasse, die die Standardsortierreihenfolge für kehrt Instanzen eines Typs und Zeichenfolgenvergleich führt.</target>       </trans-unit>
        <trans-unit id="1841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>The following example sorts the values in a string arrayby using the default comparer.</source>
          <target state="translated">Das folgende Beispiel sortiert die Werte in einer Zeichenfolge Arrayby mithilfe des Standardcomparers.</target>       </trans-unit>
        <trans-unit id="1842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>It also defines a custom <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation named <ph id="ph2">`ReverseComparer`</ph> that reverses an object's default sort order while performing a case-insensitive string comparison.</source>
          <target state="translated">Er definiert außerdem eine benutzerdefinierte <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> -Implementierung mit dem Namen <ph id="ph2">`ReverseComparer`</ph> , die ein Objekt Standard-Sortierreihenfolge beim Ausführen einer eines Zeichenfolgenvergleichs kehrt.</target>       </trans-unit>
        <trans-unit id="1843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Note that the output might vary depending on the current culture.</source>
          <target state="translated">Beachten Sie, dass die Ausgabe abhängig von der aktuellen Kultur variieren kann.</target>       </trans-unit>
        <trans-unit id="1844" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1845" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="1846" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>, und mindestens ein Element in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> implementiert die <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph>-Schnittstelle nicht.</target>       </trans-unit>
        <trans-unit id="1847" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">Die Implementierung von <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> hat einen Fehler während der Sortierung verursacht.</target>       </trans-unit>
        <trans-unit id="1848" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Beispielsweise gibt <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</target>       </trans-unit>
        <trans-unit id="1849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">Der .NET Framework 4 und früheren Versionen wird nur den Quicksort-Algorithmus verwendet.</target>       </trans-unit>
        <trans-unit id="1850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">QuickSort identifiziert ungültige Vergleiche in einigen Situationen, in dem der Sortiervorgang löst, ein <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> Ausnahme und löst eine <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> Ausnahme an den Aufrufer.</target>       </trans-unit>
        <trans-unit id="1851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, es ist möglich, dass ausgelöst, das zuvor Sortiervorgänge hat <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> eine Ausnahme wird nicht ausgelöst werden, da die Einfügung sortieren und Heapsort Algorithmen ein ungültiger Vergleich nicht erkennen.</target>       </trans-unit>
        <trans-unit id="1852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Collections.IComparer)">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">Dies gilt meistens, für Arrays mit weniger als 16 Elementen.</target>       </trans-unit>
        <trans-unit id="1853" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated">Das eindimensionale <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> mit den zu sortierenden Schlüsseln.</target>       </trans-unit>
        <trans-unit id="1854" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to each of the keys in the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Das eindimensionale <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> mit den Elementen, die den jeweiligen Schlüsseln im <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> entsprechen.</target>       </trans-unit>
        <trans-unit id="1855" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1856" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to sort only the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph>, wenn nur das <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> sortiert werden soll.</target>       </trans-unit>
        <trans-unit id="1857" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>-Implementierung, die beim Vergleich von Elementen verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="1858" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1859" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph>, wenn die <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph>-Implementierung des jeweiligen Elements verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="1860" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Sorts a pair of one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph3">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>.</source>
          <target state="translated">Sortiert ein Paar von eindimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>-Objekten (das eine enthält die Schlüssel und das andere die entsprechenden Werte) nach den Schlüsseln im ersten <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> und verwendet dabei den angegebenen <ph id="ph3">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Jeder Schlüssel in der <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> verfügt über ein entsprechendes Element in der <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">Wenn ein Schlüssel positioniert wird, bei der Sortierung, des entsprechenden Elements in der <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> auf ähnliche Weise neu angeordnet.</target>       </trans-unit>
        <trans-unit id="1863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Aus diesem Grund die <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> sortiert wird, gemäß der Anordnung der entsprechenden Schlüssel in der <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each key in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph5">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other key.</source>
          <target state="translated">Wenn <ph id="ph1">`comparer`</ph> ist <ph id="ph2">`null`</ph>, die jeweils-Schlüssel in der <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph> implementieren müssen die <ph id="ph5">&lt;xref:System.IComparable&gt;</ph> Schnittstelle, um mit jedem anderen Schlüssel verglichen werden kann.</target>       </trans-unit>
        <trans-unit id="1865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">Sie können sortieren, wenn es mehr Elemente als Schlüssel sind, aber die Elemente, die ohne entsprechenden Schlüssel werden nicht sortiert.</target>       </trans-unit>
        <trans-unit id="1866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Wenn es sich um mehrere Schlüssel als Elemente können nicht sortiert werden; Dies löst dies einen <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.</target>       </trans-unit>
        <trans-unit id="1868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The .NET Framework includes predefined <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementations listed in the following table.</source>
          <target state="translated">.NET Framework enthält vordefinierte <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> Implementierungen in der folgenden Tabelle aufgeführt.</target>       </trans-unit>
        <trans-unit id="1869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Implementation</source>
          <target state="translated">Implementierung</target>       </trans-unit>
        <trans-unit id="1870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Description</source>
          <target state="translated">Beschreibung </target>       </trans-unit>
        <trans-unit id="1871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Compares any two objects, but performs a case-insensitive comparison of strings.</source>
          <target state="translated">Vergleicht zwei Objekte, jedoch führt einen Vergleich Groß-/Kleinschreibung der Zeichenfolgen.</target>       </trans-unit>
        <trans-unit id="1872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the current culture.</source>
          <target state="translated">Vergleicht zwei Objekte mithilfe der Sortierkonventionen der aktuellen Kultur an.</target>       </trans-unit>
        <trans-unit id="1873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the invariant culture.</source>
          <target state="translated">Vergleicht zwei Objekte mithilfe der Sortierkonventionen der invarianten Kultur.</target>       </trans-unit>
        <trans-unit id="1874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Compares two objects of type <ph id="ph1">`T`</ph> by using the type's default sort order.</source>
          <target state="translated">Vergleicht zwei Objekte des Typs <ph id="ph1">`T`</ph> mithilfe von Standard-Sortierreihenfolge des Typs.</target>       </trans-unit>
        <trans-unit id="1875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>You can also support custom comparisons by providing an instance of your own <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation to the <ph id="ph2">`comparer`</ph> parameter.</source>
          <target state="translated">Sie können auch benutzerdefinierte Vergleiche unterstützen, indem Sie eine eigene Instanz bereitgestellt <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> -Implementierung, die die <ph id="ph2">`comparer`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="1876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The example does this by defining an <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation that reverses the default sort order and performs case-insensitive string comparison.</source>
          <target state="translated">Im Beispiel wird dies durch die Definition einer <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> Implementierung, kehrt die Standardsortierreihenfolge und Zeichenfolgenvergleich ausführt.</target>       </trans-unit>
        <trans-unit id="1877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Diese Methode verwendet die introspective Sortieralgorithmus (Introsort) wie folgt aus:</target>       </trans-unit>
        <trans-unit id="1878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Wenn die Partitionsgröße Elemente weniger als 16 ist, verwendet eine <bpt id="p1">[</bpt>einfügen sortieren<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="1879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Überschreitet die Anzahl der Partitionen 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, wobei <bpt id="p2">*</bpt>N<ept id="p2">*</ept> ist der Bereich des Eingabearrays, verwendet er eine <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="1880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">Andernfalls wird eine <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="1881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Diese Implementierung führt eine instabile Sortierung. Das heißt, wenn zwei Elemente gleich sind, kann deren Reihenfolge nicht beibehalten werden.</target>       </trans-unit>
        <trans-unit id="1882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente, die gleich sind.</target>       </trans-unit>
        <trans-unit id="1883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`keys`</ph>.</source>
          <target state="translated">Für Arrays, die mithilfe von Algorithmen Heapsort und Quicksort im schlimmsten Fall sortiert sind, ist diese Methode eine O (<ph id="ph1">`n`</ph> Protokoll <ph id="ph2">`n`</ph>)-Vorgang, in dem <ph id="ph3">`n`</ph> ist die <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> von <ph id="ph5">`keys`</ph>.</target>       </trans-unit>
        <trans-unit id="1884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The following example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values.</source>
          <target state="translated">Im folgende Beispiel wird das Sortieren von zwei verknüpften Arrays, wobei das erste Array enthält die Schlüssel und das zweite Array enthält die Werte, veranschaulicht.</target>       </trans-unit>
        <trans-unit id="1885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Sorts are done using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">Sortierungen erfolgen mithilfe des Standardcomparers und einem benutzerdefinierten Vergleich, der die Sortierreihenfolge umgekehrt.</target>       </trans-unit>
        <trans-unit id="1886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Note that the result might vary depending on the current <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated">Beachten Sie, die das Ergebnis, abhängig von der aktuellen variieren kann <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1887" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1888" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated">Das <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="1889" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1890" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;paramref name="items" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated">Das <ph id="ph1">&lt;paramref name="items" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="1891" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> ist nicht <ph id="ph2">&lt;see langword="null" /&gt;</ph>, und die Länge von <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> ist größer als die Länge von <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1892" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1893" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">Die Implementierung von <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> hat einen Fehler während der Sortierung verursacht.</target>       </trans-unit>
        <trans-unit id="1894" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Beispielsweise gibt <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</target>       </trans-unit>
        <trans-unit id="1895" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>, und mindestens ein Element im <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> implementiert die <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph>-Schnittstelle nicht.</target>       </trans-unit>
        <trans-unit id="1896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">Der .NET Framework 4 und früheren Versionen wird nur den Quicksort-Algorithmus verwendet.</target>       </trans-unit>
        <trans-unit id="1897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">QuickSort identifiziert ungültige Vergleiche in einigen Situationen, in dem der Sortiervorgang löst, ein <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> Ausnahme und löst eine <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> Ausnahme an den Aufrufer.</target>       </trans-unit>
        <trans-unit id="1898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previouslythrew <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, becausethe insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, es ist möglich, die Sortiervorgänge, Previouslythrew <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> eine Ausnahme wird nicht ausgelöst werden, da die Einfügung sortieren und Heapsort Algorithmen ein ungültiger Vergleich nicht erkennen.</target>       </trans-unit>
        <trans-unit id="1899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">Dies gilt meistens, für Arrays mit weniger als 16 Elementen.</target>       </trans-unit>
        <trans-unit id="1900" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort.</source>
          <target state="translated">Das zu sortierende eindimensionale <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1901" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>The starting index of the range to sort.</source>
          <target state="translated">Der Startindex des zu sortierenden Bereichs.</target>       </trans-unit>
        <trans-unit id="1902" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">Die Anzahl der Elemente im zu sortierenden Bereich.</target>       </trans-unit>
        <trans-unit id="1903" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>Sorts the elements in a range of elements in a one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element of the <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Sortiert die Elemente in einem Bereich von Elementen in einem eindimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> mithilfe der <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph>-Implementierung jedes Elements des <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>Each element within the specified range of elements in <ph id="ph1">`array`</ph> must implement the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other element in <ph id="ph3">`array`</ph>.</source>
          <target state="translated">Jedes Element innerhalb des angegebenen Bereichs von Elementen in <ph id="ph1">`array`</ph> implementieren müssen die <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> Schnittstelle kann Vergleiche mit jedem anderen Element im <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.</target>       </trans-unit>
        <trans-unit id="1906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Diese Methode verwendet die introspective Sortieralgorithmus (Introsort) wie folgt aus:</target>       </trans-unit>
        <trans-unit id="1907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Wenn die Partitionsgröße Elemente weniger als 16 ist, verwendet eine <bpt id="p1">[</bpt>einfügen sortieren<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="1908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Überschreitet die Anzahl der Partitionen 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, wobei <bpt id="p2">*</bpt>N<ept id="p2">*</ept> ist der Bereich des Eingabearrays, verwendet er eine <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="1909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">Andernfalls wird eine <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="1910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Diese Implementierung führt eine instabile Sortierung. Das heißt, wenn zwei Elemente gleich sind, kann deren Reihenfolge nicht beibehalten werden.</target>       </trans-unit>
        <trans-unit id="1911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente, die gleich sind.</target>       </trans-unit>
        <trans-unit id="1912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">Für Arrays, die mithilfe von Algorithmen Heapsort und Quicksort im schlimmsten Fall sortiert sind, ist diese Methode eine O (<ph id="ph1">`n`</ph> Protokoll <ph id="ph2">`n`</ph>) Vorgang, wobei <ph id="ph3">`n`</ph> ist <ph id="ph4">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="1913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>The following code example shows how to sort the values in an <ph id="ph1">&lt;xref:System.Array&gt;</ph> using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie zum Sortieren der Werte in einer <ph id="ph1">&lt;xref:System.Array&gt;</ph> mithilfe des Standardcomparers und einem benutzerdefinierten Vergleich, der die Sortierreihenfolge umgekehrt.</target>       </trans-unit>
        <trans-unit id="1914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>Note that the result might vary depending on the current <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated">Beachten Sie, die das Ergebnis, abhängig von der aktuellen variieren kann <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1915" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1916" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="1917" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ist kleiner als die untere <ph id="ph2">&lt;paramref name="array" /&gt;</ph>-Grenze.</target>       </trans-unit>
        <trans-unit id="1918" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1919" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="1920" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> und <ph id="ph2">&lt;paramref name="length" /&gt;</ph> geben keinen gültigen Bereich im <ph id="ph3">&lt;paramref name="array" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="1921" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32)">
          <source>One or more elements in <ph id="ph1">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated">Mindestens ein Element in <ph id="ph1">&lt;paramref name="array" /&gt;</ph> implementiert die <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph>-Schnittstelle nicht.</target>       </trans-unit>
        <trans-unit id="1922" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated">Das eindimensionale <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> mit den zu sortierenden Schlüsseln.</target>       </trans-unit>
        <trans-unit id="1923" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to each of the keys in the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Das eindimensionale <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> mit den Elementen, die den jeweiligen Schlüsseln im <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> entsprechen.</target>       </trans-unit>
        <trans-unit id="1924" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1925" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to sort only the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph>, wenn nur das <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> sortiert werden soll.</target>       </trans-unit>
        <trans-unit id="1926" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>The starting index of the range to sort.</source>
          <target state="translated">Der Startindex des zu sortierenden Bereichs.</target>       </trans-unit>
        <trans-unit id="1927" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">Die Anzahl der Elemente im zu sortierenden Bereich.</target>       </trans-unit>
        <trans-unit id="1928" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>Sorts a range of elements in a pair of one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each key.</source>
          <target state="translated">Sortiert einen Bereich von Elementen in einem Paar von eindimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>-Objekten (das eine enthält die Schlüssel und das andere die entsprechenden Werte) nach den Schlüsseln im ersten <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> und verwendet dabei die <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph>-Implementierung jedes Schlüssels.</target>       </trans-unit>
        <trans-unit id="1929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Jeder Schlüssel in der <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> verfügt über ein entsprechendes Element in der <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">Wenn ein Schlüssel positioniert wird, bei der Sortierung, des entsprechenden Elements in der <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> auf ähnliche Weise neu angeordnet.</target>       </trans-unit>
        <trans-unit id="1931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Aus diesem Grund die <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> sortiert wird, gemäß der Anordnung der entsprechenden Schlüssel in der <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>Each key within the specified range of elements in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other key.</source>
          <target state="translated">Jeder Schlüssel innerhalb des angegebenen Bereichs von Elementen in der <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> implementieren müssen die <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> Schnittstelle, um mit jedem anderen Schlüssel verglichen werden kann.</target>       </trans-unit>
        <trans-unit id="1933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">Sie können sortieren, wenn es mehr Elemente als Schlüssel sind, aber die Elemente, die ohne entsprechenden Schlüssel werden nicht sortiert.</target>       </trans-unit>
        <trans-unit id="1934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Wenn es sich um mehrere Schlüssel als Elemente können nicht sortiert werden; Dies löst dies einen <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.</target>       </trans-unit>
        <trans-unit id="1936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Diese Methode verwendet die introspective Sortieralgorithmus (Introsort) wie folgt aus:</target>       </trans-unit>
        <trans-unit id="1937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Wenn die Partitionsgröße Elemente weniger als 16 ist, verwendet eine <bpt id="p1">[</bpt>einfügen sortieren<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="1938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Überschreitet die Anzahl der Partitionen 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, wobei <bpt id="p2">*</bpt>N<ept id="p2">*</ept> ist der Bereich des Eingabearrays, verwendet er eine <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="1939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">Andernfalls wird eine <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="1940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Diese Implementierung führt eine instabile Sortierung. Das heißt, wenn zwei Elemente gleich sind, kann deren Reihenfolge nicht beibehalten werden.</target>       </trans-unit>
        <trans-unit id="1941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente, die gleich sind.</target>       </trans-unit>
        <trans-unit id="1942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">Für Arrays, die mithilfe von Algorithmen Heapsort und Quicksort im schlimmsten Fall sortiert sind, ist diese Methode eine O (<ph id="ph1">`n`</ph> Protokoll <ph id="ph2">`n`</ph>) Vorgang, wobei <ph id="ph3">`n`</ph> ist <ph id="ph4">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="1943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>The following code example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values.</source>
          <target state="translated">Im folgenden Codebeispiel wird das Sortieren von zwei verknüpften Arrays, wobei das erste Array enthält die Schlüssel und das zweite Array enthält die Werte, veranschaulicht.</target>       </trans-unit>
        <trans-unit id="1944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>Sorts are done using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">Sortierungen erfolgen mithilfe des Standardcomparers und einem benutzerdefinierten Vergleich, der die Sortierreihenfolge umgekehrt.</target>       </trans-unit>
        <trans-unit id="1945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>Note that the result might vary depending on the current <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated">Beachten Sie, die das Ergebnis, abhängig von der aktuellen variieren kann <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1946" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1947" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated">Das <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="1948" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1949" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="items" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated">Das <ph id="ph1">&lt;paramref name="items" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="1950" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="keys" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ist kleiner als die untere <ph id="ph2">&lt;paramref name="keys" /&gt;</ph>-Grenze.</target>       </trans-unit>
        <trans-unit id="1951" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1952" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="1953" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> ist nicht <ph id="ph2">&lt;see langword="null" /&gt;</ph>, und die Länge von <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> ist größer als die Länge von <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1954" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1955" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> und <ph id="ph2">&lt;paramref name="length" /&gt;</ph> geben keinen gültigen Bereich im <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="1956" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1957" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="index" /&gt;</ph> and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph5">&lt;paramref name="items" /&gt;</ph><ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> ist nicht <ph id="ph2">&lt;see langword="null" /&gt;</ph>, und <ph id="ph3">&lt;paramref name="index" /&gt;</ph> und <ph id="ph4">&lt;paramref name="length" /&gt;</ph> geben keinen gültigen Bereich im <ph id="ph5">&lt;paramref name="items" /&gt;</ph><ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="1958" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)">
          <source>One or more elements in the <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated">Mindestens ein Element im <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> implementiert die <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph>-Schnittstelle nicht.</target>       </trans-unit>
        <trans-unit id="1959" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort.</source>
          <target state="translated">Das zu sortierende eindimensionale <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1960" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The starting index of the range to sort.</source>
          <target state="translated">Der Startindex des zu sortierenden Bereichs.</target>       </trans-unit>
        <trans-unit id="1961" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">Die Anzahl der Elemente im zu sortierenden Bereich.</target>       </trans-unit>
        <trans-unit id="1962" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>-Implementierung, die beim Vergleich von Elementen verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="1963" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1964" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph>, wenn die <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph>-Implementierung des jeweiligen Elements verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="1965" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Sorts the elements in a range of elements in a one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>.</source>
          <target state="translated">Sortiert die Elemente in einem Bereich von Elementen in einem eindimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> mithilfe dem angegebenen <ph id="ph2">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each element within the specified range of elements in <ph id="ph3">`array`</ph> must implement the <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other element in <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">`comparer`</ph> ist <ph id="ph2">`null`</ph>, jedes Element innerhalb des angegebenen Bereichs von Elementen in <ph id="ph3">`array`</ph> implementieren müssen die <ph id="ph4">&lt;xref:System.IComparable&gt;</ph> Schnittstelle kann Vergleiche mit jedem anderen Element im <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="1967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.</target>       </trans-unit>
        <trans-unit id="1968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The .NET Framework includes predefined <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementations listed in the following table.</source>
          <target state="translated">.NET Framework enthält vordefinierte <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> Implementierungen in der folgenden Tabelle aufgeführt.</target>       </trans-unit>
        <trans-unit id="1969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Implementation</source>
          <target state="translated">Implementierung</target>       </trans-unit>
        <trans-unit id="1970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Description</source>
          <target state="translated">Beschreibung </target>       </trans-unit>
        <trans-unit id="1971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares any two objects, but performs a case-insensitive comparison of strings.</source>
          <target state="translated">Vergleicht zwei Objekte, jedoch führt einen Vergleich Groß-/Kleinschreibung der Zeichenfolgen.</target>       </trans-unit>
        <trans-unit id="1972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the current culture.</source>
          <target state="translated">Vergleicht zwei Objekte mithilfe der Sortierkonventionen der aktuellen Kultur an.</target>       </trans-unit>
        <trans-unit id="1973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the invariant culture.</source>
          <target state="translated">Vergleicht zwei Objekte mithilfe der Sortierkonventionen der invarianten Kultur.</target>       </trans-unit>
        <trans-unit id="1974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares two objects of type <ph id="ph1">`T`</ph> by using the type's default sort order.</source>
          <target state="translated">Vergleicht zwei Objekte des Typs <ph id="ph1">`T`</ph> mithilfe von Standard-Sortierreihenfolge des Typs.</target>       </trans-unit>
        <trans-unit id="1975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>You can also support custom comparisons by providing an instance of your own <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation to the <ph id="ph2">`comparer`</ph> parameter.</source>
          <target state="translated">Sie können auch benutzerdefinierte Vergleiche unterstützen, indem Sie eine eigene Instanz bereitgestellt <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> -Implementierung, die die <ph id="ph2">`comparer`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="1976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The example does this by defining a <ph id="ph1">`ReverseComparer`</ph> class that reverses the default sort order for instances of a type and performs case-insensitive string comparison.</source>
          <target state="translated">Im Beispiel wird dies durch die Definition einer <ph id="ph1">`ReverseComparer`</ph> -Klasse, die die Standardsortierreihenfolge für kehrt Instanzen eines Typs und Zeichenfolgenvergleich führt.</target>       </trans-unit>
        <trans-unit id="1977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Diese Methode verwendet die introspective Sortieralgorithmus (Introsort) wie folgt aus:</target>       </trans-unit>
        <trans-unit id="1978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Wenn die Partitionsgröße Elemente weniger als 16 ist, verwendet eine <bpt id="p1">[</bpt>einfügen sortieren<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="1979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Überschreitet die Anzahl der Partitionen 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, wobei <bpt id="p2">*</bpt>N<ept id="p2">*</ept> ist der Bereich des Eingabearrays, verwendet er eine <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="1980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">Andernfalls wird eine <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="1981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Diese Implementierung führt eine instabile Sortierung. Das heißt, wenn zwei Elemente gleich sind, kann deren Reihenfolge nicht beibehalten werden.</target>       </trans-unit>
        <trans-unit id="1982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente, die gleich sind.</target>       </trans-unit>
        <trans-unit id="1983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">Für Arrays, die mithilfe von Algorithmen Heapsort und Quicksort im schlimmsten Fall sortiert sind, ist diese Methode eine O (<ph id="ph1">`n`</ph> Protokoll <ph id="ph2">`n`</ph>) Vorgang, wobei <ph id="ph3">`n`</ph> ist <ph id="ph4">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="1984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The following code example shows how to sort the values in an <ph id="ph1">&lt;xref:System.Array&gt;</ph> using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie zum Sortieren der Werte in einer <ph id="ph1">&lt;xref:System.Array&gt;</ph> mithilfe des Standardcomparers und einem benutzerdefinierten Vergleich, der die Sortierreihenfolge umgekehrt.</target>       </trans-unit>
        <trans-unit id="1985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Note that the result might vary depending on the current <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated">Beachten Sie, die das Ergebnis, abhängig von der aktuellen variieren kann <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1986" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1987" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="1988" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ist kleiner als die untere <ph id="ph2">&lt;paramref name="array" /&gt;</ph>-Grenze.</target>       </trans-unit>
        <trans-unit id="1989" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1990" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="1991" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> und <ph id="ph2">&lt;paramref name="length" /&gt;</ph> geben keinen gültigen Bereich im <ph id="ph3">&lt;paramref name="array" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="1992" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1993" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">Die Implementierung von <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> hat einen Fehler während der Sortierung verursacht.</target>       </trans-unit>
        <trans-unit id="1994" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Beispielsweise gibt <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</target>       </trans-unit>
        <trans-unit id="1995" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>, und mindestens ein Element in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> implementiert die <ph id="ph4">&lt;see cref="T:System.IComparable" /&gt;</ph>-Schnittstelle nicht.</target>       </trans-unit>
        <trans-unit id="1996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">Der .NET Framework 4 und früheren Versionen wird nur den Quicksort-Algorithmus verwendet.</target>       </trans-unit>
        <trans-unit id="1997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">QuickSort identifiziert ungültige Vergleiche in einigen Situationen, in dem der Sortiervorgang löst, ein <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> Ausnahme und löst eine <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> Ausnahme an den Aufrufer.</target>       </trans-unit>
        <trans-unit id="1998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, es ist möglich, dass ausgelöst, das zuvor Sortiervorgänge hat <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> eine Ausnahme wird nicht ausgelöst werden, da die Einfügung sortieren und Heapsort Algorithmen ein ungültiger Vergleich nicht erkennen.</target>       </trans-unit>
        <trans-unit id="1999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">Dies gilt meistens, für Arrays mit weniger als 16 Elementen.</target>       </trans-unit>
        <trans-unit id="2000" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated">Das eindimensionale <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> mit den zu sortierenden Schlüsseln.</target>       </trans-unit>
        <trans-unit id="2001" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to each of the keys in the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Das eindimensionale <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> mit den Elementen, die den jeweiligen Schlüsseln im <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> entsprechen.</target>       </trans-unit>
        <trans-unit id="2002" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2003" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to sort only the <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph>, wenn nur das <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> sortiert werden soll.</target>       </trans-unit>
        <trans-unit id="2004" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The starting index of the range to sort.</source>
          <target state="translated">Der Startindex des zu sortierenden Bereichs.</target>       </trans-unit>
        <trans-unit id="2005" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">Die Anzahl der Elemente im zu sortierenden Bereich.</target>       </trans-unit>
        <trans-unit id="2006" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>-Implementierung, die beim Vergleich von Elementen verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="2007" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2008" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph> implementation of each element.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph>, wenn die <ph id="ph2">&lt;see cref="T:System.IComparable" /&gt;</ph>-Implementierung des jeweiligen Elements verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="2009" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Sorts a range of elements in a pair of one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph3">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>.</source>
          <target state="translated">Sortiert einen Bereich von Elementen in einem Paar von eindimensionalen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>-Objekten (das eine enthält die Schlüssel und das andere die entsprechenden Werte) nach den Schlüsseln im ersten <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> und verwendet dabei den angegebenen <ph id="ph3">&lt;see cref="T:System.Collections.IComparer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Jeder Schlüssel in der <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> verfügt über ein entsprechendes Element in der <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">Wenn ein Schlüssel positioniert wird, bei der Sortierung, des entsprechenden Elements in der <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> auf ähnliche Weise neu angeordnet.</target>       </trans-unit>
        <trans-unit id="2012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Aus diesem Grund die <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> sortiert wird, gemäß der Anordnung der entsprechenden Schlüssel in der <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each key within the specified range of elements in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph5">&lt;xref:System.IComparable&gt;</ph> interface to be capable of comparisons with every other key.</source>
          <target state="translated">Wenn <ph id="ph1">`comparer`</ph> ist <ph id="ph2">`null`</ph>, jeden Schlüssel innerhalb des angegebenen Bereichs von Elementen in der <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph> implementieren müssen die <ph id="ph5">&lt;xref:System.IComparable&gt;</ph> Schnittstelle, um mit jedem anderen Schlüssel verglichen werden kann.</target>       </trans-unit>
        <trans-unit id="2014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">Sie können sortieren, wenn es mehr Elemente als Schlüssel sind, aber die Elemente, die ohne entsprechenden Schlüssel werden nicht sortiert.</target>       </trans-unit>
        <trans-unit id="2015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Wenn es sich um mehrere Schlüssel als Elemente können nicht sortiert werden; Dies löst dies einen <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.</target>       </trans-unit>
        <trans-unit id="2017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The .NET Framework includes predefined <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementations listed in the following table.</source>
          <target state="translated">.NET Framework enthält vordefinierte <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> Implementierungen in der folgenden Tabelle aufgeführt.</target>       </trans-unit>
        <trans-unit id="2018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Implementation</source>
          <target state="translated">Implementierung</target>       </trans-unit>
        <trans-unit id="2019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Description</source>
          <target state="translated">Beschreibung </target>       </trans-unit>
        <trans-unit id="2020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares any two objects, but performs a case-insensitive comparison of strings.</source>
          <target state="translated">Vergleicht zwei Objekte, jedoch führt einen Vergleich Groß-/Kleinschreibung der Zeichenfolgen.</target>       </trans-unit>
        <trans-unit id="2021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the current culture.</source>
          <target state="translated">Vergleicht zwei Objekte mithilfe der Sortierkonventionen der aktuellen Kultur an.</target>       </trans-unit>
        <trans-unit id="2022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares any two objects by using the sorting conventions of the invariant culture.</source>
          <target state="translated">Vergleicht zwei Objekte mithilfe der Sortierkonventionen der invarianten Kultur.</target>       </trans-unit>
        <trans-unit id="2023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Compares two objects of type <ph id="ph1">`T`</ph> by using the type's default sort order.</source>
          <target state="translated">Vergleicht zwei Objekte des Typs <ph id="ph1">`T`</ph> mithilfe von Standard-Sortierreihenfolge des Typs.</target>       </trans-unit>
        <trans-unit id="2024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>You can also support custom comparisons by providing an instance of your own <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation to the <ph id="ph2">`comparer`</ph> parameter.</source>
          <target state="translated">Sie können auch benutzerdefinierte Vergleiche unterstützen, indem Sie eine eigene Instanz bereitgestellt <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> -Implementierung, die die <ph id="ph2">`comparer`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="2025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The example does this by defining a custom <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> implementation that reverses the default sort order and performs case-insensitive string comparison.</source>
          <target state="translated">Im Beispiel wird dies durch die Definition einer benutzerdefiniertes <ph id="ph1">&lt;xref:System.Collections.IComparer&gt;</ph> Implementierung, kehrt die Standardsortierreihenfolge und Zeichenfolgenvergleich ausführt.</target>       </trans-unit>
        <trans-unit id="2026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Diese Methode verwendet die introspective Sortieralgorithmus (Introsort) wie folgt aus:</target>       </trans-unit>
        <trans-unit id="2027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Wenn die Partitionsgröße Elemente weniger als 16 ist, verwendet eine <bpt id="p1">[</bpt>einfügen sortieren<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="2028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Überschreitet die Anzahl der Partitionen 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, wobei <bpt id="p2">*</bpt>N<ept id="p2">*</ept> ist der Bereich des Eingabearrays, verwendet er eine <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="2029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">Andernfalls wird eine <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="2030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Diese Implementierung führt eine instabile Sortierung. Das heißt, wenn zwei Elemente gleich sind, kann deren Reihenfolge nicht beibehalten werden.</target>       </trans-unit>
        <trans-unit id="2031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente, die gleich sind.</target>       </trans-unit>
        <trans-unit id="2032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">Für Arrays, die mithilfe von Algorithmen Heapsort und Quicksort im schlimmsten Fall sortiert sind, ist diese Methode eine O (<ph id="ph1">`n`</ph> Protokoll <ph id="ph2">`n`</ph>) Vorgang, wobei <ph id="ph3">`n`</ph> ist <ph id="ph4">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="2033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The following code example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values.</source>
          <target state="translated">Im folgenden Codebeispiel wird das Sortieren von zwei verknüpften Arrays, wobei das erste Array enthält die Schlüssel und das zweite Array enthält die Werte, veranschaulicht.</target>       </trans-unit>
        <trans-unit id="2034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Sorts are done using the default comparer and a custom comparer that reverses the sort order.</source>
          <target state="translated">Sortierungen erfolgen mithilfe des Standardcomparers und einem benutzerdefinierten Vergleich, der die Sortierreihenfolge umgekehrt.</target>       </trans-unit>
        <trans-unit id="2035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Note that the result might vary depending on the current <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated">Beachten Sie, die das Ergebnis, abhängig von der aktuellen variieren kann <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2036" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2037" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated">Das <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="2038" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2039" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The <ph id="ph1">&lt;paramref name="items" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> is multidimensional.</source>
          <target state="translated">Das <ph id="ph1">&lt;paramref name="items" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="2040" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="keys" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ist kleiner als die untere <ph id="ph2">&lt;paramref name="keys" /&gt;</ph>-Grenze.</target>       </trans-unit>
        <trans-unit id="2041" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2042" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="2043" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the lower bound of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> does not match the lower bound of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> ist nicht <ph id="ph2">&lt;see langword="null" /&gt;</ph>, und die untere Grenze von <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> entspricht nicht der unteren Grenze von <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2044" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2045" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> ist nicht <ph id="ph2">&lt;see langword="null" /&gt;</ph>, und die Länge von <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> ist größer als die Länge von <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2046" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2047" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> und <ph id="ph2">&lt;paramref name="length" /&gt;</ph> geben keinen gültigen Bereich im <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="2048" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2049" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="index" /&gt;</ph> and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph5">&lt;paramref name="items" /&gt;</ph><ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> ist nicht <ph id="ph2">&lt;see langword="null" /&gt;</ph>, und <ph id="ph3">&lt;paramref name="index" /&gt;</ph> und <ph id="ph4">&lt;paramref name="length" /&gt;</ph> geben keinen gültigen Bereich im <ph id="ph5">&lt;paramref name="items" /&gt;</ph><ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="2050" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2051" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">Die Implementierung von <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> hat einen Fehler während der Sortierung verursacht.</target>       </trans-unit>
        <trans-unit id="2052" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Beispielsweise gibt <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</target>       </trans-unit>
        <trans-unit id="2053" translate="yes" xml:space="preserve" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>, und mindestens ein Element im <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> implementiert die <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph>-Schnittstelle nicht.</target>       </trans-unit>
        <trans-unit id="2054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">Der .NET Framework 4 und früheren Versionen wird nur den Quicksort-Algorithmus verwendet.</target>       </trans-unit>
        <trans-unit id="2055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">QuickSort identifiziert ungültige Vergleiche in einigen Situationen, in dem der Sortiervorgang löst, ein <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> Ausnahme und löst eine <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> Ausnahme an den Aufrufer.</target>       </trans-unit>
        <trans-unit id="2056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, es ist möglich, dass ausgelöst, das zuvor Sortiervorgänge hat <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> eine Ausnahme wird nicht ausgelöst werden, da die Einfügung sortieren und Heapsort Algorithmen ein ungültiger Vergleich nicht erkennen.</target>       </trans-unit>
        <trans-unit id="2057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">Dies gilt meistens, für Arrays mit weniger als 16 Elementen.</target>       </trans-unit>
        <trans-unit id="2058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>The type of the elements of the array.</source>
          <target state="translated">Der Typ der Elemente des Arrays.</target>       </trans-unit>
        <trans-unit id="2059" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[])">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort.</source>
          <target state="translated">Das zu sortierende eindimensionale und nullbasierte <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2060" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[])">
          <source>Sorts the elements in an entire <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each element of the <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Sortiert die Elemente in einem ganzen <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> mithilfe der Implementierung der generischen <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph>-Schnittstelle jedes Elements des <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>Each element of <ph id="ph1">`array`</ph> must implement the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other element in <ph id="ph3">`array`</ph>.</source>
          <target state="translated">Jedes Element der <ph id="ph1">`array`</ph> implementieren müssen die <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> generische Schnittstelle kann Vergleiche mit jedem anderen Element im <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.</target>       </trans-unit>
        <trans-unit id="2063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Diese Methode verwendet die introspective Sortieralgorithmus (Introsort) wie folgt aus:</target>       </trans-unit>
        <trans-unit id="2064" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Wenn die Partitionsgröße Elemente weniger als 16 ist, verwendet eine <bpt id="p1">[</bpt>einfügen sortieren<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="2065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Überschreitet die Anzahl der Partitionen 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, wobei <bpt id="p2">*</bpt>N<ept id="p2">*</ept> ist der Bereich des Eingabearrays, verwendet er eine <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="2066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">Andernfalls wird eine <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="2067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Diese Implementierung führt eine instabile Sortierung. Das heißt, wenn zwei Elemente gleich sind, kann deren Reihenfolge nicht beibehalten werden.</target>       </trans-unit>
        <trans-unit id="2068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente, die gleich sind.</target>       </trans-unit>
        <trans-unit id="2069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Für Arrays, die mithilfe von Algorithmen Heapsort und Quicksort im schlimmsten Fall sortiert sind, ist diese Methode eine O (<ph id="ph1">`n`</ph> Protokoll <ph id="ph2">`n`</ph>)-Vorgang, in dem <ph id="ph3">`n`</ph> ist die <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> von <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%29&gt;</ph> generic method overload and the <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> generic method overload.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%29&gt;</ph> generischen methodenüberladung und die <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> generischen methodenüberladung.</target>       </trans-unit>
        <trans-unit id="2071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>An array of strings is created, in no particular order.</source>
          <target state="translated">Ein Array von Zeichenfolgen wird erstellt, ohne bestimmte Reihenfolge.</target>       </trans-unit>
        <trans-unit id="2072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>The array is displayed, sorted, and displayed again.</source>
          <target state="translated">Das Array wird angezeigt, sortiert und erneut angezeigt.</target>       </trans-unit>
        <trans-unit id="2073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>The calls to the <ph id="ph1">&lt;xref:System.Array.Sort%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</source>
          <target state="translated">Die Aufrufe an die <ph id="ph1">&lt;xref:System.Array.Sort%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> generische Methoden nicht suchen alle Aufrufe an ihre nicht generischen Entsprechungen unterscheiden, da Visual Basic, c# und C++ den Typ des vom Typ des ersten Arguments der generischen Typparameter abgeleitet werden.</target>       </trans-unit>
        <trans-unit id="2074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Bei Verwendung der <bpt id="p1">[</bpt>Ildasm.exe (IL-Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> um die Microsoft intermediate Language (MSIL) zu untersuchen, sehen Sie, dass die generischen Methoden aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="2075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> generic method overload is then used to search for two strings, one that is not in the array and one that is.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29&gt;</ph> generischen methodenüberladung wird dann verwendet, um zwei Zeichenfolgen zu suchen, ist eine, die nicht in das Array und eine ist.</target>       </trans-unit>
        <trans-unit id="2076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>The array and the return value of the <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> method are passed to the <ph id="ph2">`ShowWhere`</ph> generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array.</source>
          <target state="translated">Das Array und den Rückgabewert der <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> an die Methode übergeben werden die <ph id="ph2">`ShowWhere`</ph> generische Methode, die den Indexwert zeigt an, wenn die Zeichenfolge gefunden wird, und andernfalls die Elemente die Suchzeichenfolge fallen würde zwischen wären im Array.</target>       </trans-unit>
        <trans-unit id="2077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[])">
          <source>The index is negative if the string is not n the array, so the <ph id="ph1">`ShowWhere`</ph> method takes the bitwise complement (the ~ operator in C# and Visual C++, <ph id="ph2">`Xor`</ph> -1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</source>
          <target state="translated">Der Index ist negativ, wenn die Zeichenfolge nicht n ist das Array daher die <ph id="ph1">`ShowWhere`</ph> Methode nimmt das bitweise Komplement (den ~ Operator in c# und Visual C++ <ph id="ph2">`Xor`</ph> -1 in Visual Basic) um den Index des ersten Elements in der Liste zu erhalten, die größer ist als die Suche d NG.</target>       </trans-unit>
        <trans-unit id="2078" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[])">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2079" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[])">
          <source>One or more elements in <ph id="ph1">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Mindestens ein Element in <ph id="ph1">&lt;paramref name="array" /&gt;</ph> implementiert die generische <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph>-Schnittstelle nicht.</target>       </trans-unit>
        <trans-unit id="2080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Der Typ der Elemente des Arrays.</target>       </trans-unit>
        <trans-unit id="2081" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The one-dimensional, zero-base <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort</source>
          <target state="translated">Das zu sortierende eindimensionale und nullbasierte <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2082" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface implementation to use when comparing elements, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each element.</source>
          <target state="translated">Die Implementierung der generischen <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph>-Schnittstelle, die für den Vergleich von Elementen verwendet werden soll, oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, um die Implementierung der generischen <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph>-Schnittstelle der einzelnen Elemente zu verwenden.</target>       </trans-unit>
        <trans-unit id="2083" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>Sorts the elements in an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Sortiert die Elementen in einem <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> mit der angegebenen generischen <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph>-Schnittstelle.</target>       </trans-unit>
        <trans-unit id="2084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each element of <ph id="ph3">`array`</ph> must implement the <ph id="ph4">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other element in <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">`comparer`</ph> ist <ph id="ph2">`null`</ph>, jedes Element der <ph id="ph3">`array`</ph> implementieren müssen die <ph id="ph4">&lt;xref:System.IComparable%601&gt;</ph> generische Schnittstelle kann Vergleiche mit jedem anderen Element im <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.</target>       </trans-unit>
        <trans-unit id="2086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Diese Methode verwendet die introspective Sortieralgorithmus (Introsort) wie folgt aus:</target>       </trans-unit>
        <trans-unit id="2087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Wenn die Partitionsgröße Elemente weniger als 16 ist, verwendet eine <bpt id="p1">[</bpt>einfügen sortieren<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="2088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Überschreitet die Anzahl der Partitionen 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, wobei <bpt id="p2">*</bpt>N<ept id="p2">*</ept> ist der Bereich des Eingabearrays, verwendet er eine <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="2089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">Andernfalls wird eine <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="2090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Diese Implementierung führt eine instabile Sortierung. Das heißt, wenn zwei Elemente gleich sind, kann deren Reihenfolge nicht beibehalten werden.</target>       </trans-unit>
        <trans-unit id="2091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente, die gleich sind.</target>       </trans-unit>
        <trans-unit id="2092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Für Arrays, die mithilfe von Algorithmen Heapsort und Quicksort im schlimmsten Fall sortiert sind, ist diese Methode eine O (<ph id="ph1">`n`</ph> Protokoll <ph id="ph2">`n`</ph>)-Vorgang, in dem <ph id="ph3">`n`</ph> ist die <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> von <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload and the <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generischen methodenüberladung und die <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generischen methodenüberladung.</target>       </trans-unit>
        <trans-unit id="2094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">Im Codebeispiel wird einen alternativer Vergleich für Zeichenfolgen, die mit dem Namen definiert <ph id="ph1">`ReverseCompare`</ph>, implementiert die <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generische Schnittstelle.</target>       </trans-unit>
        <trans-unit id="2095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">Der Vergleich ruft die <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> -Methode, die Reihenfolge der verglichenen Elemente umkehren, sodass Zeichenfolgen hoch zu niedrig anstelle von niedrig zu hoch sortieren.</target>       </trans-unit>
        <trans-unit id="2096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The array is displayed, sorted, and displayed again.</source>
          <target state="translated">Das Array wird angezeigt, sortiert und erneut angezeigt.</target>       </trans-unit>
        <trans-unit id="2097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>Arrays must be sorted in order to use the <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> method.</source>
          <target state="translated">Arrays müssen sortiert werden, um mithilfe der <ph id="ph1">&lt;xref:System.Array.BinarySearch%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The calls to the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</source>
          <target state="translated">Die Aufrufe an die <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> und <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generische Methoden nicht suchen alle Aufrufe an ihre nicht generischen Entsprechungen unterscheiden, da Visual Basic, c# und C++ den Typ des vom Typ des ersten Arguments der generischen Typparameter abgeleitet werden.</target>       </trans-unit>
        <trans-unit id="2099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Bei Verwendung der <bpt id="p1">[</bpt>Ildasm.exe (IL-Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> um die Microsoft intermediate Language (MSIL) zu untersuchen, sehen Sie, dass die generischen Methoden aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="2100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload is then used to search for two strings, one that is not in the array and one that is.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generischen methodenüberladung wird dann verwendet, um zwei Zeichenfolgen zu suchen, ist eine, die nicht in das Array und eine ist.</target>       </trans-unit>
        <trans-unit id="2101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The array and the return value of the <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> method are passed to the <ph id="ph2">`ShowWhere`</ph> generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array.</source>
          <target state="translated">Das Array und den Rückgabewert der <ph id="ph1">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> an die Methode übergeben werden die <ph id="ph2">`ShowWhere`</ph> generische Methode, die den Indexwert zeigt an, wenn die Zeichenfolge gefunden wird, und andernfalls die Elemente die Suchzeichenfolge fallen würde zwischen wären im Array.</target>       </trans-unit>
        <trans-unit id="2102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The index is negative if the string is not n the array, so the <ph id="ph1">`ShowWhere`</ph> method takes the bitwise complement (the ~ operator in C# and Visual C++, <ph id="ph2">`Xor`</ph> -1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</source>
          <target state="translated">Der Index ist negativ, wenn die Zeichenfolge nicht n ist das Array daher die <ph id="ph1">`ShowWhere`</ph> Methode nimmt das bitweise Komplement (den ~ Operator in c# und Visual C++ <ph id="ph2">`Xor`</ph> -1 in Visual Basic) um den Index des ersten Elements in der Liste zu erhalten, die größer ist als die Suche d NG.</target>       </trans-unit>
        <trans-unit id="2103" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2104" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>, und mindestens ein Element in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> implementiert die generische <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph>-Schnittstelle nicht.</target>       </trans-unit>
        <trans-unit id="2105" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">Die Implementierung von <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> hat einen Fehler während der Sortierung verursacht.</target>       </trans-unit>
        <trans-unit id="2106" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Beispielsweise gibt <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</target>       </trans-unit>
        <trans-unit id="2107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">Der .NET Framework 4 und früheren Versionen wird nur den Quicksort-Algorithmus verwendet.</target>       </trans-unit>
        <trans-unit id="2108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">QuickSort identifiziert ungültige Vergleiche in einigen Situationen, in dem der Sortiervorgang löst, ein <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> Ausnahme und löst eine <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> Ausnahme an den Aufrufer.</target>       </trans-unit>
        <trans-unit id="2109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, es ist möglich, dass ausgelöst, das zuvor Sortiervorgänge hat <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> eine Ausnahme wird nicht ausgelöst werden, da die Einfügung sortieren und Heapsort Algorithmen ein ungültiger Vergleich nicht erkennen.</target>       </trans-unit>
        <trans-unit id="2110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">Dies gilt meistens, für Arrays mit weniger als 16 Elementen.</target>       </trans-unit>
        <trans-unit id="2111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Der Typ der Elemente des Arrays.</target>       </trans-unit>
        <trans-unit id="2112" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort</source>
          <target state="translated">Das zu sortierende eindimensionale und nullbasierte <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2113" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Comparison`1" /&gt;</ph> to use when comparing elements.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="T:System.Comparison`1" /&gt;</ph>, die beim Vergleich von Elementen verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="2114" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>Sorts the elements in an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Comparison`1" /&gt;</ph>.</source>
          <target state="translated">Sortiert die Elemente in einem <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> mithilfe der angegebenen <ph id="ph2">&lt;see cref="T:System.Comparison`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.</target>       </trans-unit>
        <trans-unit id="2116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>This method uses introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Diese Methode verwendet introspective Sortieralgorithmus (Introsort) wie folgt aus:</target>       </trans-unit>
        <trans-unit id="2117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Wenn die Partitionsgröße Elemente weniger als 16 ist, verwendet eine <bpt id="p1">[</bpt>einfügen sortieren<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="2118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Überschreitet die Anzahl der Partitionen 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, wobei <bpt id="p2">*</bpt>N<ept id="p2">*</ept> ist der Bereich des Eingabearrays, verwendet er eine <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="2119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">Andernfalls wird eine <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="2120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Diese Implementierung führt eine instabile Sortierung. Das heißt, wenn zwei Elemente gleich sind, kann deren Reihenfolge nicht beibehalten werden.</target>       </trans-unit>
        <trans-unit id="2121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente, die gleich sind.</target>       </trans-unit>
        <trans-unit id="2122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Für Arrays, die mithilfe von Algorithmen Heapsort und Quicksort im schlimmsten Fall sortiert sind, ist diese Methode eine O (<ph id="ph1">`n`</ph> Protokoll <ph id="ph2">`n`</ph>)-Vorgang, in dem <ph id="ph3">`n`</ph> ist die <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> von <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29&gt;</ph> method overload.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29&gt;</ph> -methodenüberladung.</target>       </trans-unit>
        <trans-unit id="2124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The code example defines an alternative comparison method for strings, named <ph id="ph1">`CompareDinosByLength`</ph>.</source>
          <target state="translated">Das Codebeispiel definiert eine alternative Vergleichsmethode für Zeichenfolgen, die mit dem Namen <ph id="ph1">`CompareDinosByLength`</ph>.</target>       </trans-unit>
        <trans-unit id="2125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>This method works as follows: First, the comparandsare tested for<ph id="ph1">`null`</ph>, and a null reference is treated as less than a non-null.</source>
          <target state="translated">Diese Methode funktioniert wie folgt: zunächst die Comparandsare getestet für<ph id="ph1">`null`</ph>, und ein null-Verweis als kleiner als ein Wert ungleich Null behandelt wird.</target>       </trans-unit>
        <trans-unit id="2126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>Second, the string lengths are compared, and the longer string is deemed to be greater.</source>
          <target state="translated">Zweitens die Zeichenfolgenlängen verglichen werden, und die Zeichenfolge längere ist als größer werden.</target>       </trans-unit>
        <trans-unit id="2127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>Third, if the lengths are equal, ordinary string comparison is used.</source>
          <target state="translated">Wenn die Länge gleich sind, wird im dritten gewöhnliche Zeichenfolgenvergleich verwendet.</target>       </trans-unit>
        <trans-unit id="2128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>A array of strings is created and populated with four strings, in no particular order.</source>
          <target state="translated">Ein Array von Zeichenfolgen erstellt und mit vier Zeichenfolgen ohne bestimmte Reihenfolge aufgefüllt.</target>       </trans-unit>
        <trans-unit id="2129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The list also includes an empty string and a null reference.</source>
          <target state="translated">Die Liste enthält auch eine leere Zeichenfolge und ein null-Verweis.</target>       </trans-unit>
        <trans-unit id="2130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The list is displayed, sorted using a <ph id="ph1">&lt;xref:System.Comparison%601&gt;</ph> generic delegate representing the <ph id="ph2">`CompareDinosByLength`</ph> method, and displayed again.</source>
          <target state="translated">Die Liste wird angezeigt, sortiert, mit einem <ph id="ph1">&lt;xref:System.Comparison%601&gt;</ph> generischer Delegat darstellt der <ph id="ph2">`CompareDinosByLength`</ph> -Methode, und erneut angezeigt.</target>       </trans-unit>
        <trans-unit id="2131" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2132" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2133" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source><ph id="ph1">&lt;paramref name="comparison" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparison" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2134" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparison" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">Die Implementierung von <ph id="ph1">&lt;paramref name="comparison" /&gt;</ph> hat einen Fehler während der Sortierung verursacht.</target>       </trans-unit>
        <trans-unit id="2135" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>For example, <ph id="ph1">&lt;paramref name="comparison" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Beispielsweise gibt <ph id="ph1">&lt;paramref name="comparison" /&gt;</ph> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</target>       </trans-unit>
        <trans-unit id="2136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">Der .NET Framework 4 und früheren Versionen wird nur den Quicksort-Algorithmus verwendet.</target>       </trans-unit>
        <trans-unit id="2137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">QuickSort identifiziert ungültige Vergleiche in einigen Situationen, in dem der Sortiervorgang löst, ein <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> Ausnahme und löst eine <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> Ausnahme an den Aufrufer.</target>       </trans-unit>
        <trans-unit id="2138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, es ist möglich, dass ausgelöst, das zuvor Sortiervorgänge hat <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> eine Ausnahme wird nicht ausgelöst werden, da die Einfügung sortieren und Heapsort Algorithmen ein ungültiger Vergleich nicht erkennen.</target>       </trans-unit>
        <trans-unit id="2139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Comparison{``0})">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">Dies gilt meistens, für Arrays mit weniger als 16 Elementen.</target>       </trans-unit>
        <trans-unit id="2140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The type of the elements of the array.</source>
          <target state="translated">Der Typ der Elemente des Arrays.</target>       </trans-unit>
        <trans-unit id="2141" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort</source>
          <target state="translated">Das zu sortierende eindimensionale und nullbasierte <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2142" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The starting index of the range to sort.</source>
          <target state="translated">Der Startindex des zu sortierenden Bereichs.</target>       </trans-unit>
        <trans-unit id="2143" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">Die Anzahl der Elemente im zu sortierenden Bereich.</target>       </trans-unit>
        <trans-unit id="2144" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>Sorts the elements in a range of elements in an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each element of the <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Sortiert die Elemente in einem Bereich von Elementen in einem <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> mithilfe der Implementierung der generischen <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph>-Schnittstelle jedes Elements des <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>Each element within the specified range of elements in <ph id="ph1">`array`</ph> must implement the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other element in <ph id="ph3">`array`</ph>.</source>
          <target state="translated">Jedes Element innerhalb des angegebenen Bereichs von Elementen in <ph id="ph1">`array`</ph> implementieren müssen die <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> generische Schnittstelle kann Vergleiche mit jedem anderen Element im <ph id="ph3">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.</target>       </trans-unit>
        <trans-unit id="2147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Diese Methode verwendet die introspective Sortieralgorithmus (Introsort) wie folgt aus:</target>       </trans-unit>
        <trans-unit id="2148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Wenn die Partitionsgröße Elemente weniger als 16 ist, verwendet eine <bpt id="p1">[</bpt>einfügen sortieren<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="2149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Überschreitet die Anzahl der Partitionen 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, wobei <bpt id="p2">*</bpt>N<ept id="p2">*</ept> ist der Bereich des Eingabearrays, verwendet er eine <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="2150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">Andernfalls wird eine <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="2151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Diese Implementierung führt eine instabile Sortierung. Das heißt, wenn zwei Elemente gleich sind, kann deren Reihenfolge nicht beibehalten werden.</target>       </trans-unit>
        <trans-unit id="2152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente, die gleich sind.</target>       </trans-unit>
        <trans-unit id="2153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">Für Arrays, die mithilfe von Algorithmen Heapsort und Quicksort im schlimmsten Fall sortiert sind, ist diese Methode eine O (<ph id="ph1">`n`</ph> Protokoll <ph id="ph2">`n`</ph>) Vorgang, wobei <ph id="ph3">`n`</ph> ist <ph id="ph4">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="2154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> generic method overload and the <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload for sorting a range in an array.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> generischen methodenüberladung und die <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generischen methodenüberladung für einen Bereich in einem Array zu sortieren.</target>       </trans-unit>
        <trans-unit id="2155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">Im Codebeispiel wird einen alternativer Vergleich für Zeichenfolgen, die mit dem Namen definiert <ph id="ph1">`ReverseCompare`</ph>, implementiert die <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generische Schnittstelle.</target>       </trans-unit>
        <trans-unit id="2156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">Der Vergleich ruft die <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> -Methode, die Reihenfolge der verglichenen Elemente umkehren, sodass Zeichenfolgen hoch zu niedrig anstelle von niedrig zu hoch sortieren.</target>       </trans-unit>
        <trans-unit id="2157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The code example creates and displays an array of dinosaur names, consisting of three herbivores followed by three carnivores (tyrannosaurids, to be precise).</source>
          <target state="translated">Das Codebeispiel erstellt und zeigt ein Array von Dinosauriernamen, drei Pflanzenfresser und drei Fleischfresser (Tyrannosaurids, um genau zu sein).</target>       </trans-unit>
        <trans-unit id="2158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> generic method overload is used to sort the last three elements of the array, which is then displayed.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> generischen methodenüberladung wird verwendet, um die letzten drei Elemente im Array zu sortieren, der dann angezeigt wird.</target>       </trans-unit>
        <trans-unit id="2159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload is used with <ph id="ph2">`ReverseCompare`</ph> to sort the last three elements in reverse order.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generischen methodenüberladung wird verwendet, mit <ph id="ph2">`ReverseCompare`</ph> die letzten drei Elemente in umgekehrter Reihenfolge sortiert.</target>       </trans-unit>
        <trans-unit id="2160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The thoroughly confused dinosaurs are displayed again.</source>
          <target state="translated">Gründlich zu verwechseln Dinosaurier werden erneut angezeigt.</target>       </trans-unit>
        <trans-unit id="2161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>The calls to the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</source>
          <target state="translated">Die Aufrufe an die <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> und <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generische Methoden nicht suchen alle Aufrufe an ihre nicht generischen Entsprechungen unterscheiden, da Visual Basic, c# und C++ den Typ des vom Typ des ersten Arguments der generischen Typparameter abgeleitet werden.</target>       </trans-unit>
        <trans-unit id="2162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Bei Verwendung der <bpt id="p1">[</bpt>Ildasm.exe (IL-Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> um die Microsoft intermediate Language (MSIL) zu untersuchen, sehen Sie, dass die generischen Methoden aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="2163" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2164" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ist kleiner als die Untergrenze von <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2165" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2166" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="2167" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> und <ph id="ph2">&lt;paramref name="length" /&gt;</ph> geben keinen gültigen Bereich im <ph id="ph3">&lt;paramref name="array" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="2168" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)">
          <source>One or more elements in <ph id="ph1">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Mindestens ein Element in <ph id="ph1">&lt;paramref name="array" /&gt;</ph> implementiert die generische <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph>-Schnittstelle nicht.</target>       </trans-unit>
        <trans-unit id="2169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Der Typ der Elemente des Arrays.</target>       </trans-unit>
        <trans-unit id="2170" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to sort.</source>
          <target state="translated">Das zu sortierende eindimensionale und nullbasierte <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2171" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The starting index of the range to sort.</source>
          <target state="translated">Der Startindex des zu sortierenden Bereichs.</target>       </trans-unit>
        <trans-unit id="2172" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">Die Anzahl der Elemente im zu sortierenden Bereich.</target>       </trans-unit>
        <trans-unit id="2173" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface implementation to use when comparing elements, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each element.</source>
          <target state="translated">Die Implementierung der generischen <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph>-Schnittstelle, die für den Vergleich von Elementen verwendet werden soll, oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, um die Implementierung der generischen <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph>-Schnittstelle der einzelnen Elemente zu verwenden.</target>       </trans-unit>
        <trans-unit id="2174" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Sorts the elements in a range of elements in an <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Sortiert die Elemente in einem Bereich von Elementen in der <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> mithilfe der angegebenen generischen <ph id="ph2">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph>-Schnittstelle.</target>       </trans-unit>
        <trans-unit id="2175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each element within the specified range of elements in <ph id="ph3">`array`</ph> must implement the <ph id="ph4">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other element in <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">`comparer`</ph> ist <ph id="ph2">`null`</ph>, jedes Element innerhalb des angegebenen Bereichs von Elementen in <ph id="ph3">`array`</ph> implementieren müssen die <ph id="ph4">&lt;xref:System.IComparable%601&gt;</ph> generische Schnittstelle kann Vergleiche mit jedem anderen Element im <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.</target>       </trans-unit>
        <trans-unit id="2177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Diese Methode verwendet die introspective Sortieralgorithmus (Introsort) wie folgt aus:</target>       </trans-unit>
        <trans-unit id="2178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Wenn die Partitionsgröße Elemente weniger als 16 ist, verwendet eine <bpt id="p1">[</bpt>einfügen sortieren<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="2179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Überschreitet die Anzahl der Partitionen 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, wobei <bpt id="p2">*</bpt>N<ept id="p2">*</ept> ist der Bereich des Eingabearrays, verwendet er eine <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="2180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">Andernfalls wird eine <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="2181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Diese Implementierung führt eine instabile Sortierung. Das heißt, wenn zwei Elemente gleich sind, kann deren Reihenfolge nicht beibehalten werden.</target>       </trans-unit>
        <trans-unit id="2182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente, die gleich sind.</target>       </trans-unit>
        <trans-unit id="2183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">Für Arrays, die mithilfe von Algorithmen Heapsort und Quicksort im schlimmsten Fall sortiert sind, ist diese Methode eine O (<ph id="ph1">`n`</ph> Protokoll <ph id="ph2">`n`</ph>) Vorgang, wobei <ph id="ph3">`n`</ph> ist <ph id="ph4">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="2184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> generic method overload and the <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload for sorting a range in an array.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> generischen methodenüberladung und die <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generischen methodenüberladung für einen Bereich in einem Array zu sortieren.</target>       </trans-unit>
        <trans-unit id="2185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">Im Codebeispiel wird einen alternativer Vergleich für Zeichenfolgen, die mit dem Namen definiert <ph id="ph1">`ReverseCompare`</ph>, implementiert die <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generische Schnittstelle.</target>       </trans-unit>
        <trans-unit id="2186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">Der Vergleich ruft die <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> -Methode, die Reihenfolge der verglichenen Elemente umkehren, sodass Zeichenfolgen hoch zu niedrig anstelle von niedrig zu hoch sortieren.</target>       </trans-unit>
        <trans-unit id="2187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The code example creates and displays an array of dinosaur names, consisting of three herbivores followed by three carnivores (tyrannosaurids, to be precise).</source>
          <target state="translated">Das Codebeispiel erstellt und zeigt ein Array von Dinosauriernamen, drei Pflanzenfresser und drei Fleischfresser (Tyrannosaurids, um genau zu sein).</target>       </trans-unit>
        <trans-unit id="2188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> generic method overload is used to sort the last three elements of the array, which is then displayed.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> generischen methodenüberladung wird verwendet, um die letzten drei Elemente im Array zu sortieren, der dann angezeigt wird.</target>       </trans-unit>
        <trans-unit id="2189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overload is used with <ph id="ph2">`ReverseCompare`</ph> to sort the last three elements in reverse order.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generischen methodenüberladung wird verwendet, mit <ph id="ph2">`ReverseCompare`</ph> die letzten drei Elemente in umgekehrter Reihenfolge sortiert.</target>       </trans-unit>
        <trans-unit id="2190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The thoroughly confused dinosaurs are displayed again.</source>
          <target state="translated">Gründlich zu verwechseln Dinosaurier werden erneut angezeigt.</target>       </trans-unit>
        <trans-unit id="2191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The calls to the <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</source>
          <target state="translated">Die Aufrufe an die <ph id="ph1">&lt;xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> und <ph id="ph2">&lt;xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generische Methoden nicht suchen alle Aufrufe an ihre nicht generischen Entsprechungen unterscheiden, da Visual Basic, c# und C++ den Typ des vom Typ des ersten Arguments der generischen Typparameter abgeleitet werden.</target>       </trans-unit>
        <trans-unit id="2192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Bei Verwendung der <bpt id="p1">[</bpt>Ildasm.exe (IL-Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> um die Microsoft intermediate Language (MSIL) zu untersuchen, sehen Sie, dass die generischen Methoden aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="2193" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2194" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ist kleiner als die Untergrenze von <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2195" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2196" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="2197" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> und <ph id="ph2">&lt;paramref name="length" /&gt;</ph> geben keinen gültigen Bereich im <ph id="ph3">&lt;paramref name="array" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="2198" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2199" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">Die Implementierung von <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> hat einen Fehler während der Sortierung verursacht.</target>       </trans-unit>
        <trans-unit id="2200" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Beispielsweise gibt <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</target>       </trans-unit>
        <trans-unit id="2201" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> do not implement the <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>, und mindestens ein Element in <ph id="ph3">&lt;paramref name="array" /&gt;</ph> implementiert die generische <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph>-Schnittstelle nicht.</target>       </trans-unit>
        <trans-unit id="2202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">Der .NET Framework 4 und früheren Versionen wird nur den Quicksort-Algorithmus verwendet.</target>       </trans-unit>
        <trans-unit id="2203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">QuickSort identifiziert ungültige Vergleiche in einigen Situationen, in dem der Sortiervorgang löst, ein <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> Ausnahme und löst eine <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> Ausnahme an den Aufrufer.</target>       </trans-unit>
        <trans-unit id="2204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, es ist möglich, dass ausgelöst, das zuvor Sortiervorgänge hat <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> eine Ausnahme wird nicht ausgelöst werden, da die Einfügung sortieren und Heapsort Algorithmen ein ungültiger Vergleich nicht erkennen.</target>       </trans-unit>
        <trans-unit id="2205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">Dies gilt meistens, für Arrays mit weniger als 16 Elementen.</target>       </trans-unit>
        <trans-unit id="2206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The type of the elements of the key array.</source>
          <target state="translated">Der Typ der Elemente des Schlüsselarrays.</target>       </trans-unit>
        <trans-unit id="2207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The type of the elements of the items array.</source>
          <target state="translated">Der Typ der Elemente des Elementarrays.</target>       </trans-unit>
        <trans-unit id="2208" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated">Das eindimensionale nullbasierte <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> mit den zu sortierenden Schlüsseln.</target>       </trans-unit>
        <trans-unit id="2209" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to the keys in <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept>, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to sort only <bpt id="p2">&lt;c&gt;</bpt>keys<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated">Das eindimensionale nullbasierte <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>, das die den Schlüsseln in <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept> entsprechenden Elemente enthält, oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, um nur <bpt id="p2">&lt;c&gt;</bpt>keys<ept id="p2">&lt;/c&gt;</ept> zu sortieren.</target>       </trans-unit>
        <trans-unit id="2210" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>Sorts a pair of <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each key.</source>
          <target state="translated">Sortiert ein Paar von <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>-Objekten (das eine enthält die Schlüssel und das andere die entsprechenden Werte) nach den Schlüsseln im ersten <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> und verwendet dabei die Implementierung der generischen <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph>-Schnittstelle jedes Schlüssels.</target>       </trans-unit>
        <trans-unit id="2211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Jeder Schlüssel in der <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> verfügt über ein entsprechendes Element in der <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">Wenn ein Schlüssel positioniert wird, bei der Sortierung, des entsprechenden Elements in der <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> auf ähnliche Weise neu angeordnet.</target>       </trans-unit>
        <trans-unit id="2213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Aus diesem Grund die <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> sortiert wird, gemäß der Anordnung der entsprechenden Schlüssel in der <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other key.</source>
          <target state="translated">Jeder Schlüssel in der <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> implementieren müssen die <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> generischen Schnittstelle, die mit jedem anderen Schlüssel verglichen werden kann.</target>       </trans-unit>
        <trans-unit id="2215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">Sie können sortieren, wenn es mehr Elemente als Schlüssel sind, aber die Elemente, die ohne entsprechenden Schlüssel werden nicht sortiert.</target>       </trans-unit>
        <trans-unit id="2216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Wenn es sich um mehrere Schlüssel als Elemente können nicht sortiert werden; Dies löst dies einen <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.</target>       </trans-unit>
        <trans-unit id="2218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Diese Methode verwendet die introspective Sortieralgorithmus (Introsort) wie folgt aus:</target>       </trans-unit>
        <trans-unit id="2219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Wenn die Partitionsgröße Elemente weniger als 16 ist, verwendet eine <bpt id="p1">[</bpt>einfügen sortieren<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="2220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Überschreitet die Anzahl der Partitionen 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, wobei <bpt id="p2">*</bpt>N<ept id="p2">*</ept> ist der Bereich des Eingabearrays, verwendet er eine <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="2221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">Andernfalls wird eine <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="2222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Diese Implementierung führt eine instabile Sortierung. Das heißt, wenn zwei Elemente gleich sind, kann deren Reihenfolge nicht beibehalten werden.</target>       </trans-unit>
        <trans-unit id="2223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente, die gleich sind.</target>       </trans-unit>
        <trans-unit id="2224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Für Arrays, die mithilfe von Algorithmen Heapsort und Quicksort im schlimmsten Fall sortiert sind, ist diese Methode eine O (<ph id="ph1">`n`</ph> Protokoll <ph id="ph2">`n`</ph>)-Vorgang, in dem <ph id="ph3">`n`</ph> ist die <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> von <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph>, <ph id="ph3">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, and <ph id="ph4">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overloads, for sorting pairs of arrays that represent keys and values.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph>, <ph id="ph3">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, und <ph id="ph4">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> Überladungen der generischen Methode, für die Sortierung von Paaren von Arrays, die Schlüssel und Werte darstellen.</target>       </trans-unit>
        <trans-unit id="2226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">Im Codebeispiel wird einen alternativer Vergleich für Zeichenfolgen, die mit dem Namen definiert <ph id="ph1">`ReverseCompare`</ph>, implementiert die <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generische Schnittstelle.</target>       </trans-unit>
        <trans-unit id="2227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">Der Vergleich ruft die <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> -Methode, die Reihenfolge der verglichenen Elemente umkehren, sodass Zeichenfolgen hoch zu niedrig anstelle von niedrig zu hoch sortieren.</target>       </trans-unit>
        <trans-unit id="2228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values).</source>
          <target state="translated">Das Codebeispiel erstellt und zeigt ein Array von Dinosauriernamen (Schlüssel) und ein Array von ganzen Zahlen, die die maximale Länge der einzelnen Dinosaurier in Metern (Werten) darstellt.</target>       </trans-unit>
        <trans-unit id="2229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The arrays are then sorted and displayed several times:</source>
          <target state="translated">Die Arrays werden dann sortiert und mehrmals angezeigt:</target>       </trans-unit>
        <trans-unit id="2230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> overload is used to sort both arrays in order of the dinosaur names in the first array.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> Überladung wird verwendet, um beide Arrays in der Reihenfolge der Dinosauriernamen im ersten Array zu sortieren.</target>       </trans-unit>
        <trans-unit id="2231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload and an instance of <ph id="ph2">`ReverseCompare`</ph> are used to reverse the sort order of the paired arrays.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> Überladung und einer Instanz von <ph id="ph2">`ReverseCompare`</ph> werden verwendet, um die Sortierreihenfolge der gepaarten Arrays umzukehren.</target>       </trans-unit>
        <trans-unit id="2232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload is used to sort the last three elements of both arrays.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> Überladung wird verwendet, um die letzten drei Elemente beider Arrays, zu sortieren.</target>       </trans-unit>
        <trans-unit id="2233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload is used to sort the last three elements of both arrays in reverse order.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> Überladung wird verwendet, um die letzten drei Elemente beider Arrays in umgekehrter Reihenfolge zu sortieren.</target>       </trans-unit>
        <trans-unit id="2234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments.</source>
          <target state="translated">Die Aufrufe an den generischen Methoden suchen nicht anders als die Aufrufe an ihre nicht generischen Entsprechungen, da Visual Basic, c# und C++ den Typ des generischen Typparameters vom Typ der ersten beiden Argumente abgeleitet werden.</target>       </trans-unit>
        <trans-unit id="2235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Bei Verwendung der <bpt id="p1">[</bpt>Ildasm.exe (IL-Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> um die Microsoft intermediate Language (MSIL) zu untersuchen, sehen Sie, dass die generischen Methoden aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="2236" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2237" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the lower bound of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> does not match the lower bound of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> ist nicht <ph id="ph2">&lt;see langword="null" /&gt;</ph>, und die untere Grenze von <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> entspricht nicht der unteren Grenze von <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2238" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2239" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> ist nicht <ph id="ph2">&lt;see langword="null" /&gt;</ph>, und die Länge von <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> ist größer als die Länge von <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2240" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[])">
          <source>One or more elements in the <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Mindestens ein Element im <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> implementiert die generische <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph>-Schnittstelle nicht.</target>       </trans-unit>
        <trans-unit id="2241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the key array.</source>
          <target state="translated">Der Typ der Elemente des Schlüsselarrays.</target>       </trans-unit>
        <trans-unit id="2242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the items array.</source>
          <target state="translated">Der Typ der Elemente des Elementarrays.</target>       </trans-unit>
        <trans-unit id="2243" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated">Das eindimensionale nullbasierte <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> mit den zu sortierenden Schlüsseln.</target>       </trans-unit>
        <trans-unit id="2244" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to the keys in <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept>, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to sort only <bpt id="p2">&lt;c&gt;</bpt>keys<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated">Das eindimensionale nullbasierte <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>, das die den Schlüsseln in <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept> entsprechenden Elemente enthält, oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, um nur <bpt id="p2">&lt;c&gt;</bpt>keys<ept id="p2">&lt;/c&gt;</ept> zu sortieren.</target>       </trans-unit>
        <trans-unit id="2245" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface implementation to use when comparing elements, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each element.</source>
          <target state="translated">Die Implementierung der generischen <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph>-Schnittstelle, die für den Vergleich von Elementen verwendet werden soll, oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, um die Implementierung der generischen <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph>-Schnittstelle der einzelnen Elemente zu verwenden.</target>       </trans-unit>
        <trans-unit id="2246" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>Sorts a pair of <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph3">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Sortiert ein Paar von <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>-Objekten (das eine enthält die Schlüssel und das andere die entsprechenden Werte) nach den Schlüsseln im ersten <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> und verwendet dabei die angegebene generische <ph id="ph3">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph>-Schnittstelle.</target>       </trans-unit>
        <trans-unit id="2247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Jeder Schlüssel in der <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> verfügt über ein entsprechendes Element in der <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">Wenn ein Schlüssel positioniert wird, bei der Sortierung, des entsprechenden Elements in der <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> auf ähnliche Weise neu angeordnet.</target>       </trans-unit>
        <trans-unit id="2249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Aus diesem Grund die <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> sortiert wird, gemäß der Anordnung der entsprechenden Schlüssel in der <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each key in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph5">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other key.</source>
          <target state="translated">Wenn <ph id="ph1">`comparer`</ph> ist <ph id="ph2">`null`</ph>, die jeweils-Schlüssel in der <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph> implementieren müssen die <ph id="ph5">&lt;xref:System.IComparable%601&gt;</ph> generischen Schnittstelle, die mit jedem anderen Schlüssel verglichen werden kann.</target>       </trans-unit>
        <trans-unit id="2251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">Sie können sortieren, wenn es mehr Elemente als Schlüssel sind, aber die Elemente, die ohne entsprechenden Schlüssel werden nicht sortiert.</target>       </trans-unit>
        <trans-unit id="2252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Wenn es sich um mehrere Schlüssel als Elemente können nicht sortiert werden; Dies löst dies einen <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.</target>       </trans-unit>
        <trans-unit id="2254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Diese Methode verwendet die introspective Sortieralgorithmus (Introsort) wie folgt aus:</target>       </trans-unit>
        <trans-unit id="2255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Wenn die Partitionsgröße Elemente weniger als 16 ist, verwendet eine <bpt id="p1">[</bpt>einfügen sortieren<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="2256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Überschreitet die Anzahl der Partitionen 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, wobei <bpt id="p2">*</bpt>N<ept id="p2">*</ept> ist der Bereich des Eingabearrays, verwendet er eine <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="2257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">Andernfalls wird eine <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="2258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Diese Implementierung führt eine instabile Sortierung. Das heißt, wenn zwei Elemente gleich sind, kann deren Reihenfolge nicht beibehalten werden.</target>       </trans-unit>
        <trans-unit id="2259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente, die gleich sind.</target>       </trans-unit>
        <trans-unit id="2260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is the <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph5">`array`</ph>.</source>
          <target state="translated">Für Arrays, die mithilfe von Algorithmen Heapsort und Quicksort im schlimmsten Fall sortiert sind, ist diese Methode eine O (<ph id="ph1">`n`</ph> Protokoll <ph id="ph2">`n`</ph>)-Vorgang, in dem <ph id="ph3">`n`</ph> ist die <ph id="ph4">&lt;xref:System.Array.Length%2A&gt;</ph> von <ph id="ph5">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, [<ph id="ph2">\]</ph>, TValue<ph id="ph3">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;,<ph id="ph4">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, and <ph id="ph5">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overloads, for sorting pairs of arrays that represent keys and values.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, [<ph id="ph2">\]</ph>, TValue<ph id="ph3">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 &gt;,<ph id="ph4">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, und <ph id="ph5">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> Überladungen der generischen Methode, für die Sortierung von Paaren von Arrays, die Schlüssel und Werte darstellen.</target>       </trans-unit>
        <trans-unit id="2262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">Im Codebeispiel wird einen alternativer Vergleich für Zeichenfolgen, die mit dem Namen definiert <ph id="ph1">`ReverseCompare`</ph>, implementiert die <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generische Schnittstelle.</target>       </trans-unit>
        <trans-unit id="2263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">Der Vergleich ruft die <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> -Methode, die Reihenfolge der verglichenen Elemente umkehren, sodass Zeichenfolgen hoch zu niedrig anstelle von niedrig zu hoch sortieren.</target>       </trans-unit>
        <trans-unit id="2264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values).</source>
          <target state="translated">Das Codebeispiel erstellt und zeigt ein Array von Dinosauriernamen (Schlüssel) und ein Array von ganzen Zahlen, die die maximale Länge der einzelnen Dinosaurier in Metern (Werten) darstellt.</target>       </trans-unit>
        <trans-unit id="2265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The arrays are then sorted and displayed several times:</source>
          <target state="translated">Die Arrays werden dann sortiert und mehrmals angezeigt:</target>       </trans-unit>
        <trans-unit id="2266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> overload is used to sort both arrays in order of the dinosaur names in the first array.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> Überladung wird verwendet, um beide Arrays in der Reihenfolge der Dinosauriernamen im ersten Array zu sortieren.</target>       </trans-unit>
        <trans-unit id="2267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The [<ph id="ph1">\]</ph>, TValue<ph id="ph2">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt; overload and an instance of <ph id="ph3">`ReverseCompare`</ph> are used to reverse the sort order of the paired arrays.</source>
          <target state="translated">Die [<ph id="ph1">\]</ph>, TValue<ph id="ph2">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 &gt; Überladung und einer Instanz von <ph id="ph3">`ReverseCompare`</ph> werden verwendet, um die Sortierreihenfolge umzukehren der paarweise zugeordneten Arrays.</target>       </trans-unit>
        <trans-unit id="2268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload is used to sort the last three elements of both arrays.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> Überladung wird verwendet, um die letzten drei Elemente beider Arrays, zu sortieren.</target>       </trans-unit>
        <trans-unit id="2269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload is used to sort the last three elements of both arrays in reverse order.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> Überladung wird verwendet, um die letzten drei Elemente beider Arrays in umgekehrter Reihenfolge zu sortieren.</target>       </trans-unit>
        <trans-unit id="2270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments.</source>
          <target state="translated">Die Aufrufe an den generischen Methoden suchen nicht anders als die Aufrufe an ihre nicht generischen Entsprechungen, da Visual Basic, c# und C++ den Typ des generischen Typparameters vom Typ der ersten beiden Argumente abgeleitet werden.</target>       </trans-unit>
        <trans-unit id="2271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Bei Verwendung der <bpt id="p1">[</bpt>Ildasm.exe (IL-Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> um die Microsoft intermediate Language (MSIL) zu untersuchen, sehen Sie, dass die generischen Methoden aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="2272" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2273" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the lower bound of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> does not match the lower bound of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> ist nicht <ph id="ph2">&lt;see langword="null" /&gt;</ph>, und die untere Grenze von <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> entspricht nicht der unteren Grenze von <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2274" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2275" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> ist nicht <ph id="ph2">&lt;see langword="null" /&gt;</ph>, und die Länge von <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> ist größer als die Länge von <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2276" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2277" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">Die Implementierung von <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> hat einen Fehler während der Sortierung verursacht.</target>       </trans-unit>
        <trans-unit id="2278" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Beispielsweise gibt <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</target>       </trans-unit>
        <trans-unit id="2279" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph5">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>, und mindestens ein Element im <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> implementiert die generische <ph id="ph5">&lt;see cref="T:System.IComparable`1" /&gt;</ph>-Schnittstelle nicht.</target>       </trans-unit>
        <trans-unit id="2280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">Der .NET Framework 4 und früheren Versionen wird nur den Quicksort-Algorithmus verwendet.</target>       </trans-unit>
        <trans-unit id="2281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">QuickSort identifiziert ungültige Vergleiche in einigen Situationen, in dem der Sortiervorgang löst, ein <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> Ausnahme und löst eine <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> Ausnahme an den Aufrufer.</target>       </trans-unit>
        <trans-unit id="2282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, es ist möglich, dass ausgelöst, das zuvor Sortiervorgänge hat <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> eine Ausnahme wird nicht ausgelöst werden, da die Einfügung sortieren und Heapsort Algorithmen ein ungültiger Vergleich nicht erkennen.</target>       </trans-unit>
        <trans-unit id="2283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">Dies gilt meistens, für Arrays mit weniger als 16 Elementen.</target>       </trans-unit>
        <trans-unit id="2284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The type of the elements of the key array.</source>
          <target state="translated">Der Typ der Elemente des Schlüsselarrays.</target>       </trans-unit>
        <trans-unit id="2285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The type of the elements of the items array.</source>
          <target state="translated">Der Typ der Elemente des Elementarrays.</target>       </trans-unit>
        <trans-unit id="2286" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated">Das eindimensionale nullbasierte <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> mit den zu sortierenden Schlüsseln.</target>       </trans-unit>
        <trans-unit id="2287" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to the keys in <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept>, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to sort only <bpt id="p2">&lt;c&gt;</bpt>keys<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated">Das eindimensionale nullbasierte <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>, das die den Schlüsseln in <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept> entsprechenden Elemente enthält, oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, um nur <bpt id="p2">&lt;c&gt;</bpt>keys<ept id="p2">&lt;/c&gt;</ept> zu sortieren.</target>       </trans-unit>
        <trans-unit id="2288" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The starting index of the range to sort.</source>
          <target state="translated">Der Startindex des zu sortierenden Bereichs.</target>       </trans-unit>
        <trans-unit id="2289" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">Die Anzahl der Elemente im zu sortierenden Bereich.</target>       </trans-unit>
        <trans-unit id="2290" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>Sorts a range of elements in a pair of <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each key.</source>
          <target state="translated">Sortiert einen Bereich von Elementen in einem Paar von <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>-Objekten (das eine enthält die Schlüssel und das andere die entsprechenden Werte) nach den Schlüsseln im ersten <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> und verwendet dabei die Implementierung der generischen <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph>-Schnittstelle jedes Schlüssels.</target>       </trans-unit>
        <trans-unit id="2291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Jeder Schlüssel in der <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> verfügt über ein entsprechendes Element in der <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">Wenn ein Schlüssel positioniert wird, bei der Sortierung, des entsprechenden Elements in der <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> auf ähnliche Weise neu angeordnet.</target>       </trans-unit>
        <trans-unit id="2293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Aus diesem Grund die <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> sortiert wird, gemäß der Anordnung der entsprechenden Schlüssel in der <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>Each key within the specified range of elements in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other key.</source>
          <target state="translated">Jeder Schlüssel innerhalb des angegebenen Bereichs von Elementen in der <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> implementieren müssen die <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> generischen Schnittstelle, die mit jedem anderen Schlüssel verglichen werden kann.</target>       </trans-unit>
        <trans-unit id="2295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">Sie können sortieren, wenn es mehr Elemente als Schlüssel sind, aber die Elemente, die ohne entsprechenden Schlüssel werden nicht sortiert.</target>       </trans-unit>
        <trans-unit id="2296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Wenn es sich um mehrere Schlüssel als Elemente können nicht sortiert werden; Dies löst dies einen <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.</target>       </trans-unit>
        <trans-unit id="2298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Diese Methode verwendet die introspective Sortieralgorithmus (Introsort) wie folgt aus:</target>       </trans-unit>
        <trans-unit id="2299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Wenn die Partitionsgröße Elemente weniger als 16 ist, verwendet eine <bpt id="p1">[</bpt>einfügen sortieren<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="2300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Überschreitet die Anzahl der Partitionen 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, wobei <bpt id="p2">*</bpt>N<ept id="p2">*</ept> ist der Bereich des Eingabearrays, verwendet er eine <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="2301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">Andernfalls wird eine <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="2302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Diese Implementierung führt eine instabile Sortierung. Das heißt, wenn zwei Elemente gleich sind, kann deren Reihenfolge nicht beibehalten werden.</target>       </trans-unit>
        <trans-unit id="2303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente, die gleich sind.</target>       </trans-unit>
        <trans-unit id="2304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">Für Arrays, die mithilfe von Algorithmen Heapsort und Quicksort im schlimmsten Fall sortiert sind, ist diese Methode eine O (<ph id="ph1">`n`</ph> Protokoll <ph id="ph2">`n`</ph>) Vorgang, wobei <ph id="ph3">`n`</ph> ist <ph id="ph4">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="2305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph>, [<ph id="ph3">\]</ph>, TValue<ph id="ph4">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;, and <ph id="ph5">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generic method overloads, for sorting pairs of arrays that represent keys and values.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph>, [<ph id="ph3">\]</ph>, TValue<ph id="ph4">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 &gt;, und <ph id="ph5">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> generische methodenüberladungen zum Sortieren von Paaren von Arrays, die Schlüssel und Werte darstellen.</target>       </trans-unit>
        <trans-unit id="2306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">Im Codebeispiel wird einen alternativer Vergleich für Zeichenfolgen, die mit dem Namen definiert <ph id="ph1">`ReverseCompare`</ph>, implementiert die <ph id="ph2">`IComparer&lt;string&gt;`</ph> (<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generische Schnittstelle.</target>       </trans-unit>
        <trans-unit id="2307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">Der Vergleich ruft die <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> -Methode, die Reihenfolge der verglichenen Elemente umkehren, sodass Zeichenfolgen hoch zu niedrig anstelle von niedrig zu hoch sortieren.</target>       </trans-unit>
        <trans-unit id="2308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values).</source>
          <target state="translated">Das Codebeispiel erstellt und zeigt ein Array von Dinosauriernamen (Schlüssel) und ein Array von ganzen Zahlen, die die maximale Länge der einzelnen Dinosaurier in Metern (Werten) darstellt.</target>       </trans-unit>
        <trans-unit id="2309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The arrays are then sorted and displayed several times:</source>
          <target state="translated">Die Arrays werden dann sortiert und mehrmals angezeigt:</target>       </trans-unit>
        <trans-unit id="2310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> overload is used to sort both arrays in order of the dinosaur names in the first array.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> Überladung wird verwendet, um beide Arrays in der Reihenfolge der Dinosauriernamen im ersten Array zu sortieren.</target>       </trans-unit>
        <trans-unit id="2311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload and an instance of <ph id="ph2">`ReverseCompare`</ph> are used to reverse the sort order of the paired arrays.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> Überladung und einer Instanz von <ph id="ph2">`ReverseCompare`</ph> werden verwendet, um die Sortierreihenfolge der gepaarten Arrays umzukehren.</target>       </trans-unit>
        <trans-unit id="2312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The [<ph id="ph1">\]</ph>, TValue<ph id="ph2">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt; overload is used to sort the last three elements of both arrays.</source>
          <target state="translated">Die [<ph id="ph1">\]</ph>, TValue<ph id="ph2">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 &gt; Überladung wird verwendet, um die letzten drei Elemente beider Arrays, zu sortieren.</target>       </trans-unit>
        <trans-unit id="2313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload is used to sort the last three elements of both arrays in reverse order.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> Überladung wird verwendet, um die letzten drei Elemente beider Arrays in umgekehrter Reihenfolge zu sortieren.</target>       </trans-unit>
        <trans-unit id="2314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments.</source>
          <target state="translated">Die Aufrufe an den generischen Methoden suchen nicht anders als die Aufrufe an ihre nicht generischen Entsprechungen, da Visual Basic, c# und C++ den Typ des generischen Typparameters vom Typ der ersten beiden Argumente abgeleitet werden.</target>       </trans-unit>
        <trans-unit id="2315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Bei Verwendung der <bpt id="p1">[</bpt>Ildasm.exe (IL-Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> um die Microsoft intermediate Language (MSIL) zu untersuchen, sehen Sie, dass die generischen Methoden aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="2316" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2317" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="keys" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ist kleiner als die Untergrenze von <ph id="ph2">&lt;paramref name="keys" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2318" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2319" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="2320" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the lower bound of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> does not match the lower bound of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> ist nicht <ph id="ph2">&lt;see langword="null" /&gt;</ph>, und die untere Grenze von <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> entspricht nicht der unteren Grenze von <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2321" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2322" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> ist nicht <ph id="ph2">&lt;see langword="null" /&gt;</ph>, und die Länge von <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> ist größer als die Länge von <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2323" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2324" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> und <ph id="ph2">&lt;paramref name="length" /&gt;</ph> geben keinen gültigen Bereich im <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="2325" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2326" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="index" /&gt;</ph> and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph5">&lt;paramref name="items" /&gt;</ph><ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> ist nicht <ph id="ph2">&lt;see langword="null" /&gt;</ph>, und <ph id="ph3">&lt;paramref name="index" /&gt;</ph> und <ph id="ph4">&lt;paramref name="length" /&gt;</ph> geben keinen gültigen Bereich im <ph id="ph5">&lt;paramref name="items" /&gt;</ph><ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="2327" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)">
          <source>One or more elements in the <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Mindestens ein Element im <ph id="ph1">&lt;paramref name="keys" /&gt;</ph><ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> implementiert die generische <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph>-Schnittstelle nicht.</target>       </trans-unit>
        <trans-unit id="2328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the key array.</source>
          <target state="translated">Der Typ der Elemente des Schlüsselarrays.</target>       </trans-unit>
        <trans-unit id="2329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The type of the elements of the items array.</source>
          <target state="translated">Der Typ der Elemente des Elementarrays.</target>       </trans-unit>
        <trans-unit id="2330" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the keys to sort.</source>
          <target state="translated">Das eindimensionale nullbasierte <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> mit den zu sortierenden Schlüsseln.</target>       </trans-unit>
        <trans-unit id="2331" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that contains the items that correspond to the keys in <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept>, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to sort only <bpt id="p2">&lt;c&gt;</bpt>keys<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated">Das eindimensionale nullbasierte <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>, das die den Schlüsseln in <bpt id="p1">&lt;c&gt;</bpt>keys<ept id="p1">&lt;/c&gt;</ept> entsprechenden Elemente enthält, oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, um nur <bpt id="p2">&lt;c&gt;</bpt>keys<ept id="p2">&lt;/c&gt;</ept> zu sortieren.</target>       </trans-unit>
        <trans-unit id="2332" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The starting index of the range to sort.</source>
          <target state="translated">Der Startindex des zu sortierenden Bereichs.</target>       </trans-unit>
        <trans-unit id="2333" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The number of elements in the range to sort.</source>
          <target state="translated">Die Anzahl der Elemente im zu sortierenden Bereich.</target>       </trans-unit>
        <trans-unit id="2334" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface implementation to use when comparing elements, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to use the <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface implementation of each element.</source>
          <target state="translated">Die Implementierung der generischen <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph>-Schnittstelle, die für den Vergleich von Elementen verwendet werden soll, oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, um die Implementierung der generischen <ph id="ph3">&lt;see cref="T:System.IComparable`1" /&gt;</ph>-Schnittstelle der einzelnen Elemente zu verwenden.</target>       </trans-unit>
        <trans-unit id="2335" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Sorts a range of elements in a pair of <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> using the specified <ph id="ph3">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> generic interface.</source>
          <target state="translated">Sortiert einen Bereich von Elementen in einem Paar von <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>-Objekten (das eine enthält die Schlüssel und das andere die entsprechenden Werte) nach den Schlüsseln im ersten <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph> und verwendet dabei die angegebene generische <ph id="ph3">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph>-Schnittstelle.</target>       </trans-unit>
        <trans-unit id="2336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Each key in the <ph id="ph1">`keys`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> has a corresponding item in the <ph id="ph3">`items`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Jeder Schlüssel in der <ph id="ph1">`keys`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> verfügt über ein entsprechendes Element in der <ph id="ph3">`items`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>When a key is repositioned during the sorting, the corresponding item in the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is similarly repositioned.</source>
          <target state="translated">Wenn ein Schlüssel positioniert wird, bei der Sortierung, des entsprechenden Elements in der <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> auf ähnliche Weise neu angeordnet.</target>       </trans-unit>
        <trans-unit id="2338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Therefore, the <ph id="ph1">`items`</ph><ph id="ph2">&lt;xref:System.Array&gt;</ph> is sorted according to the arrangement of the corresponding keys in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph>.</source>
          <target state="translated">Aus diesem Grund die <ph id="ph1">`items`</ph> <ph id="ph2">&lt;xref:System.Array&gt;</ph> sortiert wird, gemäß der Anordnung der entsprechenden Schlüssel in der <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, each key within the specified range of elements in the <ph id="ph3">`keys`</ph><ph id="ph4">&lt;xref:System.Array&gt;</ph> must implement the <ph id="ph5">&lt;xref:System.IComparable%601&gt;</ph> generic interface to be capable of comparisons with every other key.</source>
          <target state="translated">Wenn <ph id="ph1">`comparer`</ph> ist <ph id="ph2">`null`</ph>, jeden Schlüssel innerhalb des angegebenen Bereichs von Elementen in der <ph id="ph3">`keys`</ph> <ph id="ph4">&lt;xref:System.Array&gt;</ph> implementieren müssen die <ph id="ph5">&lt;xref:System.IComparable%601&gt;</ph> generischen Schnittstelle, die mit jedem anderen Schlüssel verglichen werden kann.</target>       </trans-unit>
        <trans-unit id="2340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</source>
          <target state="translated">Sie können sortieren, wenn es mehr Elemente als Schlüssel sind, aber die Elemente, die ohne entsprechenden Schlüssel werden nicht sortiert.</target>       </trans-unit>
        <trans-unit id="2341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>You cannot sort if there are more keys than items; doing this throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Wenn es sich um mehrere Schlüssel als Elemente können nicht sortiert werden; Dies löst dies einen <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If the sort is not successfully completed, the results are undefined.</source>
          <target state="translated">Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.</target>       </trans-unit>
        <trans-unit id="2343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>This method uses the introspective sort (introsort) algorithm as follows:</source>
          <target state="translated">Diese Methode verwendet die introspective Sortieralgorithmus (Introsort) wie folgt aus:</target>       </trans-unit>
        <trans-unit id="2344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If the partition size is fewer than 16 elements, it uses an <bpt id="p1">[</bpt>insertion sort<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> algorithm.</source>
          <target state="translated">Wenn die Partitionsgröße Elemente weniger als 16 ist, verwendet eine <bpt id="p1">[</bpt>einfügen sortieren<ept id="p1">](https://en.wikipedia.org/wiki/Insertion_sort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="2345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If the number of partitions exceeds 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, where  <bpt id="p2">*</bpt>N<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Überschreitet die Anzahl der Partitionen 2 * Log<bpt id="p1">&lt;sup&gt;</bpt>N<ept id="p1">&lt;/sup&gt;</ept>, wobei <bpt id="p2">*</bpt>N<ept id="p2">*</ept> ist der Bereich des Eingabearrays, verwendet er eine <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="2346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Otherwise, it uses a <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> algorithm.</source>
          <target state="translated">Andernfalls wird eine <bpt id="p1">[</bpt>Quicksort<ept id="p1">](https://en.wikipedia.org/wiki/Quicksort)</ept> Algorithmus.</target>       </trans-unit>
        <trans-unit id="2347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Diese Implementierung führt eine instabile Sortierung. Das heißt, wenn zwei Elemente gleich sind, kann deren Reihenfolge nicht beibehalten werden.</target>       </trans-unit>
        <trans-unit id="2348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente, die gleich sind.</target>       </trans-unit>
        <trans-unit id="2349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<ph id="ph1">`n`</ph> log <ph id="ph2">`n`</ph>) operation, where <ph id="ph3">`n`</ph> is <ph id="ph4">`length`</ph>.</source>
          <target state="translated">Für Arrays, die mithilfe von Algorithmen Heapsort und Quicksort im schlimmsten Fall sortiert sind, ist diese Methode eine O (<ph id="ph1">`n`</ph> Protokoll <ph id="ph2">`n`</ph>) Vorgang, wobei <ph id="ph3">`n`</ph> ist <ph id="ph4">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="2350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph>, <ph id="ph3">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, and [<ph id="ph4">\]</ph>, TValue<ph id="ph5">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt; generic method overloads, for sorting pairs of arrays that represent keys and values.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph>, <ph id="ph3">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>, und [<ph id="ph4">\]</ph>, TValue<ph id="ph5">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32% 2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 &gt; Überladungen der generischen Methode, für die Sortierung von Paaren von Arrays, die Schlüssel und Werte darstellen.</target>       </trans-unit>
        <trans-unit id="2351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The code example defines an alternative comparer for strings, named <ph id="ph1">`ReverseCompare`</ph>, which implements the <ph id="ph2">`IComparer&lt;string&gt;`</ph>(<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">Im Codebeispiel wird einen alternativer Vergleich für Zeichenfolgen, die mit dem Namen definiert <ph id="ph1">`ReverseCompare`</ph>, implementiert die <ph id="ph2">`IComparer&lt;string&gt;`</ph>(<ph id="ph3">`IComparer(Of String)`</ph> in Visual Basic <ph id="ph4">`IComparer&lt;String^&gt;`</ph> in Visual C++) generische Schnittstelle.</target>       </trans-unit>
        <trans-unit id="2352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The comparer calls the <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</source>
          <target state="translated">Der Vergleich ruft die <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> -Methode, die Reihenfolge der verglichenen Elemente umkehren, sodass Zeichenfolgen hoch zu niedrig anstelle von niedrig zu hoch sortieren.</target>       </trans-unit>
        <trans-unit id="2353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values).</source>
          <target state="translated">Das Codebeispiel erstellt und zeigt ein Array von Dinosauriernamen (Schlüssel) und ein Array von ganzen Zahlen, die die maximale Länge der einzelnen Dinosaurier in Metern (Werten) darstellt.</target>       </trans-unit>
        <trans-unit id="2354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The arrays are then sorted and displayed several times:</source>
          <target state="translated">Die Arrays werden dann sortiert und mehrmals angezeigt:</target>       </trans-unit>
        <trans-unit id="2355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> overload is used to sort both arrays in order of the dinosaur names in the first array.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29&gt;</ph> Überladung wird verwendet, um beide Arrays in der Reihenfolge der Dinosauriernamen im ersten Array zu sortieren.</target>       </trans-unit>
        <trans-unit id="2356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> overload and an instance of <ph id="ph2">`ReverseCompare`</ph> are used to reverse the sort order of the paired arrays.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt;</ph> Überladung und einer Instanz von <ph id="ph2">`ReverseCompare`</ph> werden verwendet, um die Sortierreihenfolge der gepaarten Arrays umzukehren.</target>       </trans-unit>
        <trans-unit id="2357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload is used to sort the last three elements of both arrays.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> Überladung wird verwendet, um die letzten drei Elemente beider Arrays, zu sortieren.</target>       </trans-unit>
        <trans-unit id="2358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The [<ph id="ph1">\]</ph>, TValue<ph id="ph2">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29&gt; overload is used to sort the last three elements of both arrays in reverse order.</source>
          <target state="translated">Die [<ph id="ph1">\]</ph>, TValue<ph id="ph2">\&lt;</ph>xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 &gt; Überladung wird verwendet, um die letzten drei sortieren Elemente beider arrays in umgekehrter Reihenfolge.</target>       </trans-unit>
        <trans-unit id="2359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments.</source>
          <target state="translated">Die Aufrufe an den generischen Methoden suchen nicht anders als die Aufrufe an ihre nicht generischen Entsprechungen, da Visual Basic, c# und C++ den Typ des generischen Typparameters vom Typ der ersten beiden Argumente abgeleitet werden.</target>       </trans-unit>
        <trans-unit id="2360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>If you use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</source>
          <target state="translated">Bei Verwendung der <bpt id="p1">[</bpt>Ildasm.exe (IL-Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> um die Microsoft intermediate Language (MSIL) zu untersuchen, sehen Sie, dass die generischen Methoden aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="2361" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="keys" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2362" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than the lower bound of <ph id="ph2">&lt;paramref name="keys" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ist kleiner als die Untergrenze von <ph id="ph2">&lt;paramref name="keys" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2363" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2364" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="length" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="2365" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the lower bound of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> does not match the lower bound of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> ist nicht <ph id="ph2">&lt;see langword="null" /&gt;</ph>, und die untere Grenze von <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> entspricht nicht der unteren Grenze von <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2366" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2367" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the length of <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> is greater than the length of <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> ist nicht <ph id="ph2">&lt;see langword="null" /&gt;</ph>, und die Länge von <ph id="ph3">&lt;paramref name="keys" /&gt;</ph> ist größer als die Länge von <ph id="ph4">&lt;paramref name="items" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2368" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2369" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> und <ph id="ph2">&lt;paramref name="length" /&gt;</ph> geben keinen gültigen Bereich im <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="2370" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2371" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="items" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="index" /&gt;</ph> and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> do not specify a valid range in the <ph id="ph5">&lt;paramref name="items" /&gt;</ph><ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="items" /&gt;</ph> ist nicht <ph id="ph2">&lt;see langword="null" /&gt;</ph>, und <ph id="ph3">&lt;paramref name="index" /&gt;</ph> und <ph id="ph4">&lt;paramref name="length" /&gt;</ph> geben keinen gültigen Bereich im <ph id="ph5">&lt;paramref name="items" /&gt;</ph><ph id="ph6">&lt;see cref="T:System.Array" /&gt;</ph> an.</target>       </trans-unit>
        <trans-unit id="2372" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2373" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">Die Implementierung von <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> hat einen Fehler während der Sortierung verursacht.</target>       </trans-unit>
        <trans-unit id="2374" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Beispielsweise gibt <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</target>       </trans-unit>
        <trans-unit id="2375" translate="yes" xml:space="preserve" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and one or more elements in the <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> do not implement the <ph id="ph5">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>, und mindestens ein Element im <ph id="ph3">&lt;paramref name="keys" /&gt;</ph><ph id="ph4">&lt;see cref="T:System.Array" /&gt;</ph> implementiert die generische <ph id="ph5">&lt;see cref="T:System.IComparable`1" /&gt;</ph>-Schnittstelle nicht.</target>       </trans-unit>
        <trans-unit id="2376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</source>
          <target state="translated">Der .NET Framework 4 und früheren Versionen wird nur den Quicksort-Algorithmus verwendet.</target>       </trans-unit>
        <trans-unit id="2377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> exception, and throws an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> exception to the caller.</source>
          <target state="translated">QuickSort identifiziert ungültige Vergleiche in einigen Situationen, in dem der Sortiervorgang löst, ein <ph id="ph1">&lt;see cref="T:System.IndexOutOfRangeException" /&gt;</ph> Ausnahme und löst eine <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> Ausnahme an den Aufrufer.</target>       </trans-unit>
        <trans-unit id="2378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, it is possible that sorting operations that previously threw <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, es ist möglich, dass ausgelöst, das zuvor Sortiervorgänge hat <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> eine Ausnahme wird nicht ausgelöst werden, da die Einfügung sortieren und Heapsort Algorithmen ein ungültiger Vergleich nicht erkennen.</target>       </trans-unit>
        <trans-unit id="2379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
          <source>For the most part, this applies to arrays with fewer than 16 elements.</source>
          <target state="translated">Dies gilt meistens, für Arrays mit weniger als 16 Elementen.</target>       </trans-unit>
        <trans-unit id="2380" translate="yes" xml:space="preserve" uid="P:System.Array.SyncRoot">
          <source>Gets an object that can be used to synchronize access to the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ruft ein Objekt ab, mit dem der Zugriff auf <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> synchronisiert werden kann.</target>       </trans-unit>
        <trans-unit id="2381" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>An object that can be used to synchronize access to the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ein Objekt, mit dem der Zugriff auf die <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> synchronisiert werden kann.</target>       </trans-unit>
        <trans-unit id="2382" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>This property implements the <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> interface.</source>
          <target state="translated">Diese Eigenschaft implementiert die <ph id="ph1">&lt;xref:System.Collections.ICollection?displayProperty=nameWithType&gt;</ph> Schnittstelle.</target>       </trans-unit>
        <trans-unit id="2383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>.NET Framework classes based on <ph id="ph1">&lt;xref:System.Array&gt;</ph> provide their own synchronized version of the collection using the <ph id="ph2">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">.NET Framework-Klassen basierend auf <ph id="ph1">&lt;xref:System.Array&gt;</ph> bieten eigene synchronisierte Version der Auflistung unter Verwendung der <ph id="ph2">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="2384" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>Classes that use arrays can also implement their own synchronization using the <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">Klassen, die Arrays verwenden, können auch implementieren ihre eigenen Synchronisierung über die <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="2385" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>The synchronizing code must perform operations on the <ph id="ph1">`SyncRoot`</ph> of the collection, not directly on the collection.</source>
          <target state="translated">Im Synchronisierungscode führen Vorgänge für die <ph id="ph1">`SyncRoot`</ph> der Auflistung, nicht direkt für die Auflistung.</target>       </trans-unit>
        <trans-unit id="2386" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>This ensures proper operation of collections that are derived from other objects.</source>
          <target state="translated">Dies gewährleistet die einwandfreie Funktion von Auflistungen, die von anderen Objekten abgeleitet sind.</target>       </trans-unit>
        <trans-unit id="2387" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the collection.</source>
          <target state="translated">Insbesondere verwaltet er die ordnungsgemäße Synchronisierung mit anderen Threads, die gleichzeitig die Auflistung eventuell.</target>       </trans-unit>
        <trans-unit id="2388" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>Note that some implementations of <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> might return the <ph id="ph2">&lt;xref:System.Array&gt;</ph> itself.</source>
          <target state="translated">Beachten Sie, dass einige Implementierungen von <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> möglicherweise zurück, die <ph id="ph2">&lt;xref:System.Array&gt;</ph> selbst.</target>       </trans-unit>
        <trans-unit id="2389" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>Enumerating through a collection is intrinsically not a thread safe procedure.</source>
          <target state="translated">Einer Auflistung ist systemintern keine threadsichere Prozedur.</target>       </trans-unit>
        <trans-unit id="2390" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</source>
          <target state="translated">Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst.</target>       </trans-unit>
        <trans-unit id="2391" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</source>
          <target state="translated">Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.</target>       </trans-unit>
        <trans-unit id="2392" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.</target>       </trans-unit>
        <trans-unit id="2393" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.SyncRoot">
          <source>The following code example shows how to lock an array during the entire enumeration by using the <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> property.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie ein Array während der gesamten Enumeration sperren, mit der <ph id="ph1">&lt;xref:System.Array.SyncRoot%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="2394" translate="yes" xml:space="preserve" uid="P:System.Array.System#Collections#ICollection#Count">
          <source>Gets the number of elements contained in the <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>.</source>
          <target state="translated">Ruft die Anzahl der Elemente ab, die in <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> enthalten sind.</target>       </trans-unit>
        <trans-unit id="2395" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.System#Collections#ICollection#Count">
          <source>The number of elements contained in the collection.</source>
          <target state="translated">Die Anzahl der Elemente in der Auflistung.</target>       </trans-unit>
        <trans-unit id="2396" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.System#Collections#ICollection#Count">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</target>       </trans-unit>
        <trans-unit id="2397" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.System#Collections#ICollection#Count">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph> interface.</source>
          <target state="translated">Er kann nur verwendet werden, wenn die <ph id="ph1">&lt;xref:System.Array&gt;</ph>-Instanz in eine <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph>-Schnittstelle umgewandelt wird.</target>       </trans-unit>
        <trans-unit id="2398" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>The object to be added to the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">Das dem <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> hinzuzufügende Objekt.</target>       </trans-unit>
        <trans-unit id="2399" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>Calling this method always throws a <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> exception.</source>
          <target state="translated">Beim Aufrufen dieser Methode wird immer eine <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph>-Ausnahme ausgelöst.</target>       </trans-unit>
        <trans-unit id="2400" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>Adding a value to an array is not supported.</source>
          <target state="translated">Das Hinzufügen eines Werts zu einem Array wird nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="2401" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>No value is returned.</source>
          <target state="translated">Es wird kein Wert zurückgegeben.</target>       </trans-unit>
        <trans-unit id="2402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>Ordinarily, an <ph id="ph1">&lt;xref:System.Collections.IList.Add%2A?displayProperty=nameWithType&gt;</ph> implementation adds a member to a collection.</source>
          <target state="translated">Normalerweise eine <ph id="ph1">&lt;xref:System.Collections.IList.Add%2A?displayProperty=nameWithType&gt;</ph> Implementierung Fügt ein Element einer Auflistung hinzu.</target>       </trans-unit>
        <trans-unit id="2403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>However, because arrays have a fixed size (the <ph id="ph1">&lt;xref:System.Array.IsFixedSize%2A&gt;</ph> property always returns <ph id="ph2">`true`</ph>), this method always throws a <ph id="ph3">&lt;xref:System.NotSupportedException&gt;</ph> exception.</source>
          <target state="translated">Jedoch, da Arrays eine feste Größe aufweisen (die <ph id="ph1">&lt;xref:System.Array.IsFixedSize%2A&gt;</ph> -Eigenschaft gibt immer <ph id="ph2">`true`</ph>), löst diese Methode immer ein <ph id="ph3">&lt;xref:System.NotSupportedException&gt;</ph> Ausnahme.</target>       </trans-unit>
        <trans-unit id="2404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</target>       </trans-unit>
        <trans-unit id="2405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated">Er kann nur verwendet werden, wenn die <ph id="ph1">&lt;xref:System.Array&gt;</ph>-Instanz in eine <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>-Schnittstelle umgewandelt wird.</target>       </trans-unit>
        <trans-unit id="2406" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Add(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> has a fixed size.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> hat eine feste Größe.</target>       </trans-unit>
        <trans-unit id="2407" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Clear">
          <source>Removes all items from the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">Entfernt alle Elemente aus <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Clear">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</target>       </trans-unit>
        <trans-unit id="2409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Clear">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated">Er kann nur verwendet werden, wenn die <ph id="ph1">&lt;xref:System.Array&gt;</ph>-Instanz in eine <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>-Schnittstelle umgewandelt wird.</target>       </trans-unit>
        <trans-unit id="2410" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Clear">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> ist schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="2411" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Contains(System.Object)">
          <source>The object to locate in the current list.</source>
          <target state="translated">Das in der aktuellen Liste zu suchende Objekt.</target>       </trans-unit>
        <trans-unit id="2412" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Contains(System.Object)">
          <source>The element to locate can be <ph id="ph1">&lt;see langword="null" /&gt;</ph> for reference types.</source>
          <target state="translated">Das gesuchte Element kann für Referenztypen <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2413" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Contains(System.Object)">
          <source>Determines whether an element is in the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">Bestimmt, ob sich ein Element in <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> befindet.</target>       </trans-unit>
        <trans-unit id="2414" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Contains(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is found in the <ph id="ph3">&lt;see cref="T:System.Collections.IList" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn das <ph id="ph2">&lt;paramref name="value" /&gt;</ph> in der <ph id="ph3">&lt;see cref="T:System.Collections.IList" /&gt;</ph> gefunden wird, andernfalls <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Contains(System.Object)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</target>       </trans-unit>
        <trans-unit id="2416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Contains(System.Object)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated">Er kann nur verwendet werden, wenn die <ph id="ph1">&lt;xref:System.Array&gt;</ph>-Instanz in eine <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>-Schnittstelle umgewandelt wird.</target>       </trans-unit>
        <trans-unit id="2417" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#IndexOf(System.Object)">
          <source>The object to locate in the current list.</source>
          <target state="translated">Das in der aktuellen Liste zu suchende Objekt.</target>       </trans-unit>
        <trans-unit id="2418" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#IndexOf(System.Object)">
          <source>Determines the index of a specific item in the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">Bestimmt den Index eines bestimmten Elements in der <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2419" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#IndexOf(System.Object)">
          <source>The index of value if found in the list; otherwise, -1.</source>
          <target state="translated">Der Index von Wert, wenn er in der Liste gefunden wird, andernfalls -1.</target>       </trans-unit>
        <trans-unit id="2420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#IndexOf(System.Object)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</target>       </trans-unit>
        <trans-unit id="2421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#IndexOf(System.Object)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated">Er kann nur verwendet werden, wenn die <ph id="ph1">&lt;xref:System.Array&gt;</ph>-Instanz in eine <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>-Schnittstelle umgewandelt wird.</target>       </trans-unit>
        <trans-unit id="2422" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>The index at which <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> should be inserted.</source>
          <target state="translated">Der Index, an dem <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> eingefügt werden soll.</target>       </trans-unit>
        <trans-unit id="2423" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>The object to insert.</source>
          <target state="translated">Das einzufügende Objekt.</target>       </trans-unit>
        <trans-unit id="2424" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>Inserts an item to the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> at the specified index.</source>
          <target state="translated">Fügt am angegebenen Index ein Element in die <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> ein.</target>       </trans-unit>
        <trans-unit id="2425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</target>       </trans-unit>
        <trans-unit id="2426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated">Er kann nur verwendet werden, wenn die <ph id="ph1">&lt;xref:System.Array&gt;</ph>-Instanz in eine <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>-Schnittstelle umgewandelt wird.</target>       </trans-unit>
        <trans-unit id="2427" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is not a valid index in the <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ist kein gültiger Index in <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2428" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> ist schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="2429" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2430" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> has a fixed size.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> hat eine feste Größe.</target>       </trans-unit>
        <trans-unit id="2431" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is null reference in the <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> ist ein NULL-Verweis in <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2432" translate="yes" xml:space="preserve" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source>The index of the element to get or set.</source>
          <target state="translated">Der Index des abzurufenden oder festzulegenden Elements.</target>       </trans-unit>
        <trans-unit id="2433" translate="yes" xml:space="preserve" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source>Gets or sets the element at the specified index.</source>
          <target state="translated">Ruft das Element am angegebenen Index ab oder legt dieses fest.</target>       </trans-unit>
        <trans-unit id="2434" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source>The element at the specified index.</source>
          <target state="translated">Das Element am angegebenen Index.</target>       </trans-unit>
        <trans-unit id="2435" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</target>       </trans-unit>
        <trans-unit id="2436" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated">Er kann nur verwendet werden, wenn die <ph id="ph1">&lt;xref:System.Array&gt;</ph>-Instanz in eine <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>-Schnittstelle umgewandelt wird.</target>       </trans-unit>
        <trans-unit id="2437" translate="yes" xml:space="preserve" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ist kleiner als Null.</target>       </trans-unit>
        <trans-unit id="2438" translate="yes" xml:space="preserve" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2439" translate="yes" xml:space="preserve" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is equal to or greater than <ph id="ph2">&lt;see cref="P:System.Collections.ICollection.Count" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> ist größer oder gleich <ph id="ph2">&lt;see cref="P:System.Collections.ICollection.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2440" translate="yes" xml:space="preserve" uid="P:System.Array.System#Collections#IList#Item(System.Int32)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> does not have exactly one dimension.</source>
          <target state="translated">Das aktuelle <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> hat nicht genau eine Dimension.</target>       </trans-unit>
        <trans-unit id="2441" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Remove(System.Object)">
          <source>The object to remove from the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">Das aus der <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> zu entfernende Objekt.</target>       </trans-unit>
        <trans-unit id="2442" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Remove(System.Object)">
          <source>Removes the first occurrence of a specific object from the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">Entfernt das erste Vorkommen eines angegebenen Objekts aus der <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Remove(System.Object)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</target>       </trans-unit>
        <trans-unit id="2444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#Remove(System.Object)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated">Er kann nur verwendet werden, wenn die <ph id="ph1">&lt;xref:System.Array&gt;</ph>-Instanz in eine <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>-Schnittstelle umgewandelt wird.</target>       </trans-unit>
        <trans-unit id="2445" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Remove(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> ist schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="2446" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Remove(System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2447" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#Remove(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> has a fixed size.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> hat eine feste Größe.</target>       </trans-unit>
        <trans-unit id="2448" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>The index of the element to remove.</source>
          <target state="translated">Der Index des zu entfernenden Elements.</target>       </trans-unit>
        <trans-unit id="2449" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>Removes the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> item at the specified index.</source>
          <target state="translated">Entfernt das <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>-Element am angegebenen Index.</target>       </trans-unit>
        <trans-unit id="2450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</target>       </trans-unit>
        <trans-unit id="2451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> interface.</source>
          <target state="translated">Er kann nur verwendet werden, wenn die <ph id="ph1">&lt;xref:System.Array&gt;</ph>-Instanz in eine <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>-Schnittstelle umgewandelt wird.</target>       </trans-unit>
        <trans-unit id="2452" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>index is not a valid index in the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">index ist kein gültiger Index in <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2453" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> is read-only.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> ist schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="2454" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2455" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> has a fixed size.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> hat eine feste Größe.</target>       </trans-unit>
        <trans-unit id="2456" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source>The object to compare with the current instance.</source>
          <target state="translated">Das Objekt, das mit der aktuellen Instanz verglichen werden soll.</target>       </trans-unit>
        <trans-unit id="2457" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source>An object that compares the current object and <bpt id="p1">&lt;c&gt;</bpt>other<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Ein Objekt, das das aktuelle Objekt und <bpt id="p1">&lt;c&gt;</bpt>other<ept id="p1">&lt;/c&gt;</ept> vergleicht.</target>       </trans-unit>
        <trans-unit id="2458" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source>Determines whether the current collection object precedes, occurs in the same position as, or follows another object in the sort order.</source>
          <target state="translated">Bestimmt, ob das aktuelle Auflistungsobjekt in der Sortierreihenfolge vor oder nach einem anderen Objekt oder an derselben Position auftritt.</target>       </trans-unit>
        <trans-unit id="2459" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source>An integer that indicates the relationship of the current collection object to other, as shown in the following table.</source>
          <target state="translated">Eine Ganzzahl, die die Beziehung des aktuellen Auflistungsobjekts zu "other" angibt, wie in der folgenden Tabelle dargestellt.</target>       </trans-unit>
        <trans-unit id="2460" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Return value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Rückgabewert</target>       </trans-unit>
        <trans-unit id="2461" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Description</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Beschreibung</target>       </trans-unit>
        <trans-unit id="2462" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> -1</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> –1</target>       </trans-unit>
        <trans-unit id="2463" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The current instance precedes <ph id="ph3">&lt;paramref name="other" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Die aktuelle Instanz tritt vor <ph id="ph3">&lt;paramref name="other" /&gt;</ph> auf.</target>       </trans-unit>
        <trans-unit id="2464" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0 (null)</target>       </trans-unit>
        <trans-unit id="2465" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The current instance and <ph id="ph3">&lt;paramref name="other" /&gt;</ph> are equal.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Die aktuelle Instanz und <ph id="ph3">&lt;paramref name="other" /&gt;</ph> sind gleich.</target>       </trans-unit>
        <trans-unit id="2466" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 1</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 1</target>       </trans-unit>
        <trans-unit id="2467" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The current instance follows <ph id="ph3">&lt;paramref name="other" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Die aktuelle Instanz folgt auf <ph id="ph3">&lt;paramref name="other" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</target>       </trans-unit>
        <trans-unit id="2469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IStructuralComparable&gt;</ph> interface.</source>
          <target state="translated">Er kann nur verwendet werden, wenn die <ph id="ph1">&lt;xref:System.Array&gt;</ph>-Instanz in eine <ph id="ph2">&lt;xref:System.Collections.IStructuralComparable&gt;</ph>-Schnittstelle umgewandelt wird.</target>       </trans-unit>
        <trans-unit id="2470" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)">
          <source>The object to compare with the current instance.</source>
          <target state="translated">Das Objekt, das mit der aktuellen Instanz verglichen werden soll.</target>       </trans-unit>
        <trans-unit id="2471" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)">
          <source>An object that determines whether the current instance and <bpt id="p1">&lt;c&gt;</bpt>other<ept id="p1">&lt;/c&gt;</ept> are equal.</source>
          <target state="translated">Ein Objekt, das bestimmt, ob die aktuelle Instanz und <bpt id="p1">&lt;c&gt;</bpt>other<ept id="p1">&lt;/c&gt;</ept> gleich sind.</target>       </trans-unit>
        <trans-unit id="2472" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)">
          <source>Determines whether an object is equal to the current instance.</source>
          <target state="translated">Bestimmt, ob ein Objekt gleich der aktuellen Instanz ist.</target>       </trans-unit>
        <trans-unit id="2473" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the two objects are equal; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn die beiden Objekte gleich sind, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</target>       </trans-unit>
        <trans-unit id="2475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IStructuralEquatable&gt;</ph> interface.</source>
          <target state="translated">Er kann nur verwendet werden, wenn die <ph id="ph1">&lt;xref:System.Array&gt;</ph>-Instanz in eine <ph id="ph2">&lt;xref:System.Collections.IStructuralEquatable&gt;</ph>-Schnittstelle umgewandelt wird.</target>       </trans-unit>
        <trans-unit id="2476" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)">
          <source>An object that computes the hash code of the current object.</source>
          <target state="translated">Ein Objekt, das den Hashcode des aktuellen Objekts berechnet.</target>       </trans-unit>
        <trans-unit id="2477" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)">
          <source>Returns a hash code for the current instance.</source>
          <target state="translated">Gibt einen Hashcode für die aktuelle Instanz zurück.</target>       </trans-unit>
        <trans-unit id="2478" translate="yes" xml:space="preserve" uid="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)">
          <source>The hash code for the current instance.</source>
          <target state="translated">Der Hashcode für die aktuelle Instanz.</target>       </trans-unit>
        <trans-unit id="2479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</target>       </trans-unit>
        <trans-unit id="2480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Array&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IStructuralEquatable&gt;</ph> interface.</source>
          <target state="translated">Er kann nur verwendet werden, wenn die <ph id="ph1">&lt;xref:System.Array&gt;</ph>-Instanz in eine <ph id="ph2">&lt;xref:System.Collections.IStructuralEquatable&gt;</ph>-Schnittstelle umgewandelt wird.</target>       </trans-unit>
        <trans-unit id="2481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The type of the elements of the array.</source>
          <target state="translated">Der Typ der Elemente des Arrays.</target>       </trans-unit>
        <trans-unit id="2482" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The one-dimensional, zero-based <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> to check against the conditions.</source>
          <target state="translated">Das eindimensionale nullbasierte <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph>, das auf die Bedingungen geprüft werden soll.</target>       </trans-unit>
        <trans-unit id="2483" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The predicate that defines the conditions to check against the elements.</source>
          <target state="translated">Das Prädikat, das die Bedingungen definiert, auf die die Elemente geprüft werden sollen.</target>       </trans-unit>
        <trans-unit id="2484" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>Determines whether every element in the array matches the conditions defined by the specified predicate.</source>
          <target state="translated">Bestimmt, ob jedes Element im Array die vom angegebenen Prädikat definierten Bedingungen erfüllt.</target>       </trans-unit>
        <trans-unit id="2485" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if every element in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> matches the conditions defined by the specified predicate; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn jedes Element in <ph id="ph2">&lt;paramref name="array" /&gt;</ph> die vom angegebenen Prädikat definierten Bedingungen erfüllt, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2486" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>If there are no elements in the array, the return value is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Wenn es keine Elemente im Array gibt, ist der Rückgabewert <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns<ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> ist ein Delegat an eine Methode, die zurückgibt<ph id="ph2">`true`</ph> an das Objekt übergeben sie die Bedingungen definiert, die im Delegaten übereinstimmt.</target>       </trans-unit>
        <trans-unit id="2488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The elements of <ph id="ph1">`array`</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, and processing is stopped when the delegate returns <ph id="ph3">`false`</ph> for any element.</source>
          <target state="translated">Die Elemente der <ph id="ph1">`array`</ph> einzeln übergeben werden, um die <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph>, und die Verarbeitung wird beendet, wenn der Delegat zurückgegeben <ph id="ph3">`false`</ph> für ein bestimmtes Element.</target>       </trans-unit>
        <trans-unit id="2489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>This method is an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> of <ph id="ph4">`array`</ph>.</source>
          <target state="translated">Diese Methode ist eine O (<ph id="ph1">`n`</ph>)-Vorgang, in dem <ph id="ph2">`n`</ph> ist die <ph id="ph3">&lt;xref:System.Array.Length%2A&gt;</ph> von <ph id="ph4">`array`</ph>.</target>       </trans-unit>
        <trans-unit id="2490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The following example determines whether the last character of each element in a string array is a number.</source>
          <target state="translated">Im folgenden Beispiel wird bestimmt, ob das letzte Zeichen der einzelnen Elemente in einem Zeichenfolgenarray eine Zahl ist.</target>       </trans-unit>
        <trans-unit id="2491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>It creates two string arrays.</source>
          <target state="translated">Es werden zwei Zeichenfolgen-Arrays erstellt.</target>       </trans-unit>
        <trans-unit id="2492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The first arrayincludes both strings that end with alphabetic characters and strings that end with numeric characters.The second array consists only of strings that end with numeric characters.</source>
          <target state="translated">Die erste Arrayincludes beide Zeichenfolgen, die diesem Ende mit alphabetische Zeichen und Zeichenfolgen, die mit numerischen Zeichen enden. Das zweite Array besteht ausschließlich aus Zeichenfolgen, die mit numerischen Zeichen enden.</target>       </trans-unit>
        <trans-unit id="2493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The example also defines an <ph id="ph1">`EndWithANumber`</ph> method whose signature matches the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegate.</source>
          <target state="translated">Im Beispiel definiert auch eine <ph id="ph1">`EndWithANumber`</ph> Methode, deren Signatur entspricht, der <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegieren.</target>       </trans-unit>
        <trans-unit id="2494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The example passes each array to the <ph id="ph1">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> method along with a delegate that represents the <ph id="ph2">`EndsWithANumber`</ph> method.</source>
          <target state="translated">Das Beispiel übergibt jedes Array an die <ph id="ph1">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> -Methode zusammen mit einem Delegaten, der darstellt die <ph id="ph2">`EndsWithANumber`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>The following example is similar to the first, except that it passes the string array to the <ph id="ph1">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> method along with  a lambda expression that determines whether a particular array element ends with the string representation of a number.</source>
          <target state="translated">Das folgende Beispiel ist ähnlich wie die erste, außer dass das Zeichenfolgenarray übergibt, das <ph id="ph1">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> -Methode zusammen mit einem Lambda-Ausdruck, der bestimmt, ob eine bestimmte Arrayelement durch die Zeichenfolgendarstellung einer Zahl enden.</target>       </trans-unit>
        <trans-unit id="2496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>In both cases, the <ph id="ph1">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> method returns <ph id="ph2">`false`</ph> as soon as it encounters the first array element that does not end in a number.</source>
          <target state="translated">In beiden Fällen die <ph id="ph1">&lt;xref:System.Array.TrueForAll%2A&gt;</ph> -Methode zurückkehrt <ph id="ph2">`false`</ph> , sobald er das erste Arrayelement trifft, die nicht in eine Zahl endet.</target>       </trans-unit>
        <trans-unit id="2497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>Otherwise, it returns <ph id="ph1">`true`</ph> after iterating all the elements in the array.</source>
          <target state="translated">Andernfalls wird zurückgegeben <ph id="ph1">`true`</ph> nach Iteration alle Elemente im Array.</target>       </trans-unit>
        <trans-unit id="2498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>As both examples show, in C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">Analog zur Darstellung der beiden Beispielen in c# und Visual Basic, ist es nicht notwendig, erstellen Sie die <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegieren (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explizit.</target>       </trans-unit>
        <trans-unit id="2499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Diese Sprachen leiten den richtigen Delegaten aus Kontext und automatisch zu erstellen.</target>       </trans-unit>
        <trans-unit id="2500" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2501" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2502" translate="yes" xml:space="preserve" uid="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>