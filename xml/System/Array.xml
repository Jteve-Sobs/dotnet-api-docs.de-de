<Type Name="Array" FullName="System.Array">
  <Metadata><Meta Name="ms.openlocfilehash" Value="65f49786646c300ef82f43dbfdeec863c0600b7f" /><Meta Name="ms.sourcegitcommit" Value="57ccffdf8fe8e719b7e778b859bf1ca216879f31" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/28/2020" /><Meta Name="ms.locfileid" Value="87329367" /></Metadata><TypeSignature Language="C#" Value="public abstract class Array : System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Array extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="DocId" Value="T:System.Array" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Array&#xA;Implements IList, IStructuralComparable, IStructuralEquatable" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C++ CLI" Value="public ref class Array abstract : System::Collections::IList, System::Collections::IStructuralComparable, System::Collections::IStructuralEquatable" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="F#" Value="type Array = class&#xA;    interface ICollection&#xA;    interface IEnumerable&#xA;    interface IList&#xA;    interface IStructuralComparable&#xA;    interface IStructuralEquatable" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C#" Value="public abstract class Array : ICloneable, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Array extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.ICloneable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Array&#xA;Implements ICloneable, IList, IStructuralComparable, IStructuralEquatable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class Array abstract : ICloneable, System::Collections::IList, System::Collections::IStructuralComparable, System::Collections::IStructuralEquatable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type Array = class&#xA;    interface ICollection&#xA;    interface IEnumerable&#xA;    interface IList&#xA;    interface IStructuralComparable&#xA;    interface IStructuralEquatable&#xA;    interface ICloneable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="C#" Value="public abstract class Array : ICloneable, System.Collections.IList" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Array extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.ICloneable" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Array&#xA;Implements ICloneable, IList" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
  <TypeSignature Language="C++ CLI" Value="public ref class Array abstract : ICloneable, System::Collections::IList" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
  <TypeSignature Language="F#" Value="type Array = class&#xA;    interface ICloneable&#xA;    interface IList&#xA;    interface ICollection&#xA;    interface IEnumerable" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Array extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.ICloneable" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type Array = class&#xA;    interface ICloneable&#xA;    interface IList&#xA;    interface ICollection&#xA;    interface IEnumerable&#xA;    interface IStructuralComparable&#xA;    interface IStructuralEquatable" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="F#" Value="type Array = class&#xA;    interface IList&#xA;    interface ICollection&#xA;    interface IEnumerable&#xA;    interface IStructuralComparable&#xA;    interface IStructuralEquatable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="F#" Value="type Array = class&#xA;    interface ICloneable&#xA;    interface ICollection&#xA;    interface IList&#xA;    interface IEnumerable&#xA;    interface IStructuralComparable&#xA;    interface IStructuralEquatable" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.Collections.IStructuralComparable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.Collections.IStructuralEquatable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Serializable]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Serializable&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt Methoden zum Erstellen, Bearbeiten, Durchsuchen und Sortieren von Arrays bereit und ist damit Basisklasse für alle Arrays in der Common Language Runtime.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array> Klasse ist nicht Teil der <xref:System.Collections> Namespaces. Es wird jedoch immer noch als Sammlung betrachtet, da es auf der- <xref:System.Collections.IList> Schnittstelle basiert.  
  
 Die- <xref:System.Array> Klasse ist die Basisklasse für sprach Implementierungen, die Arrays unterstützen. Allerdings können nur das System und die Compiler explizit von der- <xref:System.Array> Klasse abgeleitet werden. Benutzer sollten die von der Sprache bereitgestellten Arraykonstrukte verwenden.  
  
 Ein-Element ist ein-Wert in <xref:System.Array> . Die Länge von <xref:System.Array> ist die Gesamtzahl der Elemente, die Sie enthalten kann. Die untere Grenze des ein <xref:System.Array> ist der Index des ersten Elements. Ein <xref:System.Array> kann über eine beliebige untere Grenze verfügen, hat jedoch standardmäßig eine untere Grenze von NULL. Eine andere Untergrenze kann definiert werden, wenn eine Instanz der- <xref:System.Array> Klasse mithilfe von erstellt wird <xref:System.Array.CreateInstance%2A> . Ein mehrdimensionales <xref:System.Array> kann für jede Dimension über unterschiedliche Begrenzungen verfügen. Ein Array kann maximal 32 Dimensionen aufweisen.  
  
 Im Gegensatz zu den Klassen in den- <xref:System.Collections> Namespaces <xref:System.Array> verfügt über eine festgelegte Kapazität. Um die Kapazität zu erhöhen, müssen Sie ein neues- <xref:System.Array> Objekt mit der erforderlichen Kapazität erstellen, die Elemente aus dem alten <xref:System.Array> Objekt in das neue kopieren und das alte löschen <xref:System.Array> .  

 Die Array Größe ist auf insgesamt 4 Milliarden Elemente und auf einen maximalen Index von 0x7fefffff in einer beliebigen Dimension (0x7fffffc7 für Byte Arrays und Arrays von Einzel Byte Strukturen) beschränkt.
  
 **Nur .NET Framework:** Standardmäßig beträgt die maximale Größe von <xref:System.Array> 2 Gigabyte (GB). In einer 64-Bit-Umgebung können Sie die Größenbeschränkung vermeiden, indem Sie das- `enabled` Attribut des [gcallowverylargeobjects](/dotnet/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element) -Konfigurations Elements auf `true` in der Laufzeitumgebung festlegen.
  
 Eindimensionale Arrays implementieren die <xref:System.Collections.Generic.IList%601?displayProperty=nameWithType> <xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType> <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> <xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType> <xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType> generischen Schnittstellen,, und. Die Implementierungen werden für Arrays zur Laufzeit bereitgestellt, und infolgedessen werden die generischen Schnittstellen nicht in der Deklarations Syntax für die- <xref:System.Array> Klasse angezeigt. Außerdem sind keine Referenz Themen für Schnittstellenmember verfügbar, auf die nur durch Umwandeln eines Arrays in den generischen Schnittstellentyp (explizite Schnittstellen Implementierungen) zugegriffen werden kann. Beim Umwandeln eines Arrays in eine dieser Schnittstellen ist es wichtig, dass Elemente, die Elemente hinzufügen, einfügen oder entfernen, ausgelöst werden <xref:System.NotSupportedException> .  
  
 <xref:System.Type>-Objekte stellen Informationen über Arraytyp Deklarationen bereit. <xref:System.Array>Objekte mit demselben Arraytyp haben dasselbe <xref:System.Type> Objekt gemeinsam.  
  
 <xref:System.Type.IsArray%2A?displayProperty=nameWithType>und <xref:System.Type.GetElementType%2A?displayProperty=nameWithType> geben möglicherweise nicht die erwarteten Ergebnisse zurück <xref:System.Array> , wenn ein Array in den-Typ umgewandelt wird <xref:System.Array> , ist das Ergebnis ein Objekt und kein Array. Das heißt, `typeof(System.Array).IsArray` gibt zurück `false` und `typeof(System.Array).GetElementType` gibt zurück `null` .  
  
 Die- <xref:System.Array.Copy%2A?displayProperty=nameWithType> Methode kopiert Elemente nicht nur zwischen Arrays desselben Typs, sondern auch zwischen Standard Arrays verschiedener Typen. die Typumwandlung wird automatisch verarbeitet.  
  
 Einige Methoden, z. b. <xref:System.Array.CreateInstance%2A> , <xref:System.Array.Copy%2A> ,, und, <xref:System.Array.CopyTo%2A> <xref:System.Array.GetValue%2A> <xref:System.Array.SetValue%2A> Stellen über Ladungen bereit, die ganzzahlige 64-Bit-Werte als Parameter für große Kapazitäts Arrays akzeptieren. <xref:System.Array.LongLength%2A>und <xref:System.Array.GetLongLength%2A> geben ganze Zahlen mit 64 Bit zurück, die die Länge des Arrays angeben.  
  
 Die <xref:System.Array> Sortierung der ist nicht garantiert.  Sie müssen den <xref:System.Array> vor dem Ausführen von Vorgängen sortieren (z <xref:System.Array.BinarySearch%2A> . b.), für die eine Sortierung erforderlich ist <xref:System.Array> .  
  
 Die Verwendung eines <xref:System.Array> Objekts von Zeigern in nativem Code wird nicht unterstützt und löst eine <xref:System.NotSupportedException> für mehrere Methoden aus.  
  
   
  
## Examples  

 Im folgenden Codebeispiel wird gezeigt, wie <xref:System.Array.Copy%2A?displayProperty=nameWithType> Elemente zwischen einem Array vom Typ Integer und einem Array vom Typ kopiert <xref:System.Object> .  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source.vb" id="Snippet1"::: 
  
 Im folgenden Codebeispiel wird ein erstellt und initialisiert, und die zugehörigen <xref:System.Array> Eigenschaften und deren Elemente werden angezeigt.  
  
 [!code-cpp[Classic Array Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source3.cpp#2)]
 [!code-csharp-interactive[Classic Array Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source3.cs#2)]
 [!code-vb[Classic Array Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source3.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Öffentliche statische ( <see langword="Shared" /> in Visual Basic) Member dieses Typs sind Thread sicher. Bei Instanzmembern ist die Threadsicherheit nicht gewährleistet.  
  
Diese Implementierung stellt keinen synchronisierten (Thread sicheren) Wrapper für eine bereit <see cref="T:System.Array" /> . .NET Framework Klassen, die auf basieren, <see cref="T:System.Array" /> stellen jedoch mithilfe der-Eigenschaft eine eigene synchronisierte Version der Auflistung bereit <see cref="P:System.Array.SyncRoot" /> .  
  
Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur. Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst. Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.</threadsafe>
    <altmember cref="T:System.Object" />
    <altmember cref="T:System.Type" />
    <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
    <related type="Article" href="/dotnet/csharp/programming-guide/arrays/">Arrays (C#-Programmierhandbuch)</related>
    <related type="Article" href="/dotnet/visual-basic/programming-guide/language-features/arrays/">Arrays in Visual Basic</related>
  </Docs>
  <Members>
    <Member MemberName="AsReadOnly&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!!T&gt; AsReadOnly&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.AsReadOnly``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsReadOnly(Of T) (array As T()) As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member AsReadOnly : 'T[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;" Usage="System.Array.AsReadOnly array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das eindimensionale, nullbasierte Array, das mit einem schreibgeschützten <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />-Wrapper umschlossen werden soll.</param>
        <summary>Gibt einen schreibgeschützten Wrapper für das angegebene Array zurück.</summary>
        <returns>Ein schreibgeschützter <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />-Wrapper für das angegebene Array.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um Änderungen am Array zu verhindern, machen Sie das Array nur über diesen Wrapper verfügbar.  
  
 Eine Auflistung, die schreibgeschützt ist, ist einfach eine Sammlung mit einem Wrapper, der das Ändern der Auflistung verhindert. Wenn also Änderungen an der zugrunde liegenden Auflistung vorgenommen werden, reflektiert die schreibgeschützte Auflistung diese Änderungen.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Array in einem schreibgeschützten umschlossen <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> .  
  
 [!code-cpp[System.Array.AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CPP/arrayasreadonly.cpp#1)]
 [!code-csharp[System.Array.AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CS/arrayasreadonly.cs#1)]
 [!code-vb[System.Array.AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.AsReadOnly/VB/arrayasreadonly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Durchsucht ein sortiertes eindimensionales <see cref="T:System.Array" /> mithilfe eines binären Suchalgorithmus nach einem Wert.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch (array As Array, value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * obj -&gt; int" Usage="System.Array.BinarySearch (array, value)" />
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object? value);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende sortierte eindimensionale <see cref="T:System.Array" />.</param>
        <param name="value">Das Objekt, nach dem gesucht werden soll.</param>
        <summary>Durchsucht ein ganzes sortiertes eindimensionales Array mithilfe der <see cref="T:System.IComparable" />-Schnittstelle, die von jedem Element des Arrays und durch das angegebene Objekt implementiert wird, nach einem bestimmten Element.</summary>
        <returns>Der Index des angegebenen <paramref name="value" /> im angegebenen <paramref name="array" />, sofern <paramref name="value" /> gefunden wurde, andernfalls eine negative Zahl. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> kleiner als mindestens ein Element in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <paramref name="value" /> ist. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> größer als alle Elemente in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1). Wenn diese Methode mit einem nicht sortierten <paramref name="array" /> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <paramref name="value" /> in <paramref name="array" /> vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt nicht das Suchen von Arrays, die negative Indizes enthalten. `array`muss sortiert werden, bevor diese Methode aufgerufen wird.  
  
 Wenn das den <xref:System.Array> angegebenen Wert nicht enthält, gibt die Methode eine negative Ganzzahl zurück. Sie können den bitweisen Komplement Operator (~ in c#, `Not` in Visual Basic) auf das negative Ergebnis anwenden, um einen Index zu entwickeln. Wenn dieser Index größer als die obere Grenze des Arrays ist, sind keine Elemente größer als `value` im Array. Andernfalls ist dies der Index des ersten Elements, das größer als ist `value` .  
  
 Entweder `value` oder jedes Element von `array` muss die- <xref:System.IComparable> Schnittstelle implementieren, die für Vergleiche verwendet wird. Die Elemente von `array` müssen bereits nach der von der Implementierung definierten Sortierreihenfolge in einem zunehmenden Wert sortiert werden <xref:System.IComparable> . andernfalls ist das Ergebnis möglicherweise falsch.  
  
> [!NOTE]
>  Wenn `value` die- <xref:System.IComparable> Schnittstelle nicht implementiert, werden die Elemente von `array` erst nach <xref:System.IComparable> dem Beginn der Suche getestet. Eine-Ausnahme wird ausgelöst, wenn bei der Suche ein Element gefunden wird, das nicht implementiert <xref:System.IComparable> .  
  
 Doppelte Elemente sind zulässig. Wenn <xref:System.Array> mehr als ein Element enthält, das gleich `value` ist, gibt die Methode den Index von nur einem der Vorkommen und nicht notwendigerweise der ersten zurück.  
  
 `null`kann immer mit einem beliebigen anderen Referenztyp verglichen werden. Daher generieren Vergleiche mit `null` keine Ausnahme.  
  
> [!NOTE]
>  Bei jedem getesteten Element `value` wird an die entsprechende-Implementierung weitergeleitet <xref:System.IComparable> , auch wenn `value` ist `null` . Das heißt, die- <xref:System.IComparable> Implementierung bestimmt, wie ein bestimmtes Element mit verglichen wird `null` .  
  
 Bei dieser Methode handelt es sich um einen O (log `n` )-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> von ist `array` .  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie verwendet wird, <xref:System.Array.BinarySearch%2A> um ein bestimmtes-Objekt in einem zu suchen <xref:System.Array> .  
  
> [!NOTE]
>  Das Array wird mit seinen Elementen in aufsteigender Sortierreihenfolge erstellt. Die- <xref:System.Array.BinarySearch%2A> Methode erfordert, dass das Array in aufsteigender Reihenfolge sortiert wird.  
  
 [!code-cpp[Classic Array.BinarySearch Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.BinarySearch Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CS/source.cs#1)]
 [!code-vb[Classic Array.BinarySearch Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> verfügt über einen Typ, der nicht mit den Elementen von <paramref name="array" /> kompatibel ist.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" /> implementiert nicht die <see cref="T:System.IComparable" />-Schnittstelle, und bei der Suche wird ein Element gefunden, das die <see cref="T:System.IComparable" />-Schnittstelle nicht implementiert.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value, System.Collections.IComparer comparer);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch (array As Array, value As Object, comparer As IComparer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * obj * System.Collections.IComparer -&gt; int" Usage="System.Array.BinarySearch (array, value, comparer)" />
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array? array, object value, System.Collections.IComparer comparer);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende sortierte eindimensionale <see cref="T:System.Array" />.</param>
        <param name="value">Das Objekt, nach dem gesucht werden soll.</param>
        <param name="comparer">Die <see cref="T:System.Collections.IComparer" />-Implementierung, die beim Vergleich von Elementen verwendet werden soll.  
  
Oder 
 <see langword="null" />, wenn die <see cref="T:System.IComparable" />-Implementierung des jeweiligen Elements verwendet werden soll.</param>
        <summary>Durchsucht ein ganzes sortiertes eindimensionales Array mithilfe der angegebenen <see cref="T:System.Collections.IComparer" />-Schnittstelle nach einem Wert.</summary>
        <returns>Der Index des angegebenen <paramref name="value" /> im angegebenen <paramref name="array" />, sofern <paramref name="value" /> gefunden wurde, andernfalls eine negative Zahl. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> kleiner als mindestens ein Element in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <paramref name="value" /> ist. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> größer als alle Elemente in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1). Wenn diese Methode mit einem nicht sortierten <paramref name="array" /> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <paramref name="value" /> in <paramref name="array" /> vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt nicht das Suchen von Arrays, die negative Indizes enthalten. `array`muss sortiert werden, bevor diese Methode aufgerufen wird.  
  
 Wenn das den <xref:System.Array> angegebenen Wert nicht enthält, gibt die Methode eine negative Ganzzahl zurück. Sie können den bitweisen Komplement Operator (~ in c#, `Not` in Visual Basic) auf das negative Ergebnis anwenden, um einen Index zu entwickeln. Wenn dieser Index größer als die obere Grenze des Arrays ist, sind keine Elemente größer als `value` im Array. Andernfalls ist dies der Index des ersten Elements, das größer als ist `value` .  
  
 Der Vergleich passt an, wie die Elemente verglichen werden. Beispielsweise können Sie einen <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> als Vergleichs Operator verwenden, um Zeichen folgen suchen ohne Berücksichtigung der Groß-/Kleinschreibung auszuführen.  
  
 Wenn `comparer` nicht ist `null` , werden die Elemente von unter `array` Verwendung der angegebenen-Implementierung mit dem angegebenen Wert verglichen <xref:System.Collections.IComparer> . Die Elemente von `array` müssen bereits nach der von definierten Sortierreihenfolge in einem zunehmenden Wert sortiert werden `comparer` . andernfalls ist das Ergebnis möglicherweise falsch.  
  
 Wenn `comparer` `null` den Wert hat, erfolgt der Vergleich mithilfe der-Implementierung, die <xref:System.IComparable> vom-Element selbst oder durch den angegebenen-Wert bereitgestellt wird. Die Elemente von `array` müssen bereits nach der von der Implementierung definierten Sortierreihenfolge in einem zunehmenden Wert sortiert werden <xref:System.IComparable> . andernfalls ist das Ergebnis möglicherweise falsch.  
  
> [!NOTE]
>  Wenn `comparer` ist `null` und `value` die- <xref:System.IComparable> Schnittstelle nicht implementiert, werden die Elemente von `array` erst nach <xref:System.IComparable> dem Beginn der Suche getestet. Eine-Ausnahme wird ausgelöst, wenn bei der Suche ein Element gefunden wird, das nicht implementiert <xref:System.IComparable> .  
  
 Doppelte Elemente sind zulässig. Wenn <xref:System.Array> mehr als ein Element enthält, das gleich `value` ist, gibt die Methode den Index von nur einem der Vorkommen und nicht notwendigerweise der ersten zurück.  
  
 `null`kann immer mit einem beliebigen anderen Referenztyp verglichen werden. Daher generieren Vergleiche mit `null` keine Ausnahme.  
  
> [!NOTE]
>  Bei jedem getesteten Element `value` wird an die entsprechende-Implementierung weitergeleitet <xref:System.IComparable> , auch wenn `value` ist `null` . Das heißt, die- <xref:System.IComparable> Implementierung bestimmt, wie ein bestimmtes Element mit verglichen wird `null` .  
  
 Bei dieser Methode handelt es sich um einen O (log `n` )-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> von ist `array` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparer" /> ist <see langword="null" /> und <paramref name="value" /> verfügt über einen Typ, der nicht mit den Elementen von <paramref name="array" /> kompatibel ist.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist<see langword="null" />, <paramref name="value" /> implementiert nicht die <see cref="T:System.IComparable" />-Schnittstelle, und bei der Suche wird ein Element gefunden, das die <see cref="T:System.IComparable" />-Schnittstelle nicht implementiert.</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch (array As Array, index As Integer, length As Integer, value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * int * int * obj -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value)" />
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object? value);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende sortierte eindimensionale <see cref="T:System.Array" />.</param>
        <param name="index">Der Startindex des zu durchsuchenden Bereichs.</param>
        <param name="length">Die Länge des zu durchsuchenden Bereichs.</param>
        <param name="value">Das Objekt, nach dem gesucht werden soll.</param>
        <summary>Durchsucht einen Bereich von Elementen in einem sortierten eindimensionalen Array mithilfe der <see cref="T:System.IComparable" />-Schnittstelle, die von jedem Element des Arrays und durch den angegebenen Wert implementiert wird, nach einem Wert.</summary>
        <returns>Der Index des angegebenen <paramref name="value" /> im angegebenen <paramref name="array" />, sofern <paramref name="value" /> gefunden wurde, andernfalls eine negative Zahl. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> kleiner als mindestens ein Element in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <paramref name="value" /> ist. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> größer als alle Elemente in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1). Wenn diese Methode mit einem nicht sortierten <paramref name="array" /> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <paramref name="value" /> in <paramref name="array" /> vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt nicht das Suchen von Arrays, die negative Indizes enthalten. `array`muss sortiert werden, bevor diese Methode aufgerufen wird.  
  
 Wenn das den <xref:System.Array> angegebenen Wert nicht enthält, gibt die Methode eine negative Ganzzahl zurück. Sie können den bitweisen Komplement Operator (~ in c#, `Not` in Visual Basic) auf das negative Ergebnis anwenden, um einen Index zu entwickeln. Wenn dieser Index größer als die obere Grenze des Arrays ist, sind keine Elemente größer als `value` im Array. Andernfalls ist dies der Index des ersten Elements, das größer als ist `value` .  
  
 Entweder `value` oder jedes Element von `array` muss die- <xref:System.IComparable> Schnittstelle implementieren, die für Vergleiche verwendet wird. Die Elemente von `array` müssen bereits nach der von der Implementierung definierten Sortierreihenfolge in einem zunehmenden Wert sortiert werden <xref:System.IComparable> . andernfalls ist das Ergebnis möglicherweise falsch.  
  
> [!NOTE]
>  Wenn `value` die- <xref:System.IComparable> Schnittstelle nicht implementiert, werden die Elemente von `array` erst nach <xref:System.IComparable> dem Beginn der Suche getestet. Eine-Ausnahme wird ausgelöst, wenn bei der Suche ein Element gefunden wird, das nicht implementiert <xref:System.IComparable> .  
  
 Doppelte Elemente sind zulässig. Wenn <xref:System.Array> mehr als ein Element enthält, das gleich `value` ist, gibt die Methode den Index von nur einem der Vorkommen und nicht notwendigerweise der ersten zurück.  
  
 `null`kann immer mit einem beliebigen anderen Referenztyp verglichen werden. Daher generieren Vergleiche mit `null` keine Ausnahme.  
  
> [!NOTE]
>  Bei jedem getesteten Element `value` wird an die entsprechende-Implementierung weitergeleitet <xref:System.IComparable> , auch wenn `value` ist `null` . Das heißt, die- <xref:System.IComparable> Implementierung bestimmt, wie ein bestimmtes Element mit verglichen wird `null` .  
  
 Diese Methode ist ein O (log `n` )-Vorgang, bei dem gleich `n` ist `length` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die untere <paramref name="array" />-Grenze.  
  
Oder 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="array" /> an.  
  
Oder 
 <paramref name="value" /> verfügt über einen Typ, der nicht mit den Elementen von <paramref name="array" /> kompatibel ist.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" /> implementiert nicht die <see cref="T:System.IComparable" />-Schnittstelle, und bei der Suche wird ein Element gefunden, das die <see cref="T:System.IComparable" />-Schnittstelle nicht implementiert.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value, System.Collections.IComparer comparer);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch (array As Array, index As Integer, length As Integer, value As Object, comparer As IComparer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * int * int * obj * System.Collections.IComparer -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value, comparer)" />
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array? array, int index, int length, object value, System.Collections.IComparer comparer);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende sortierte eindimensionale <see cref="T:System.Array" />.</param>
        <param name="index">Der Startindex des zu durchsuchenden Bereichs.</param>
        <param name="length">Die Länge des zu durchsuchenden Bereichs.</param>
        <param name="value">Das Objekt, nach dem gesucht werden soll.</param>
        <param name="comparer">Die <see cref="T:System.Collections.IComparer" />-Implementierung, die beim Vergleich von Elementen verwendet werden soll.  
  
Oder 
 <see langword="null" />, wenn die <see cref="T:System.IComparable" />-Implementierung des jeweiligen Elements verwendet werden soll.</param>
        <summary>Durchsucht einen Bereich von Elementen in einem sortierten eindimensionalen Array mithilfe der angegebenen <see cref="T:System.Collections.IComparer" />-Schnittstelle nach einem Wert.</summary>
        <returns>Der Index des angegebenen <paramref name="value" /> im angegebenen <paramref name="array" />, sofern <paramref name="value" /> gefunden wurde, andernfalls eine negative Zahl. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> kleiner als mindestens ein Element in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <paramref name="value" /> ist. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> größer als alle Elemente in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1). Wenn diese Methode mit einem nicht sortierten <paramref name="array" /> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <paramref name="value" /> in <paramref name="array" /> vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt nicht das Suchen von Arrays, die negative Indizes enthalten. `array`muss sortiert werden, bevor diese Methode aufgerufen wird.  
  
 Wenn das den <xref:System.Array> angegebenen Wert nicht enthält, gibt die Methode eine negative Ganzzahl zurück. Sie können den bitweisen Komplement Operator (~ in c#, `Not` in Visual Basic) auf das negative Ergebnis anwenden, um einen Index zu entwickeln. Wenn dieser Index größer als die obere Grenze des Arrays ist, sind keine Elemente größer als `value` im Array. Andernfalls ist dies der Index des ersten Elements, das größer als ist `value` .  
  
 Der Vergleich passt an, wie die Elemente verglichen werden. Beispielsweise können Sie einen <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> als Vergleichs Operator verwenden, um Zeichen folgen suchen ohne Berücksichtigung der Groß-/Kleinschreibung auszuführen.  
  
 Wenn `comparer` nicht ist `null` , werden die Elemente von unter `array` Verwendung der angegebenen-Implementierung mit dem angegebenen Wert verglichen <xref:System.Collections.IComparer> . Die Elemente von `array` müssen bereits nach der von definierten Sortierreihenfolge in einem zunehmenden Wert sortiert werden `comparer` . andernfalls ist das Ergebnis möglicherweise falsch.  
  
 Wenn `comparer` `null` den Wert hat, erfolgt der Vergleich mithilfe der-Implementierung, die <xref:System.IComparable> vom-Element selbst oder durch den angegebenen-Wert bereitgestellt wird. Die Elemente von `array` müssen bereits nach der von der Implementierung definierten Sortierreihenfolge in einem zunehmenden Wert sortiert werden <xref:System.IComparable> . andernfalls ist das Ergebnis möglicherweise falsch.  
  
> [!NOTE]
>  Wenn `comparer` ist `null` und `value` die- <xref:System.IComparable> Schnittstelle nicht implementiert, werden die Elemente von `array` erst nach <xref:System.IComparable> dem Beginn der Suche getestet. Eine-Ausnahme wird ausgelöst, wenn bei der Suche ein Element gefunden wird, das nicht implementiert <xref:System.IComparable> .  
  
 Doppelte Elemente sind zulässig. Wenn <xref:System.Array> mehr als ein Element enthält, das gleich `value` ist, gibt die Methode den Index von nur einem der Vorkommen und nicht notwendigerweise der ersten zurück.  
  
 `null`kann immer mit einem beliebigen anderen Referenztyp verglichen werden. Daher generieren Vergleiche mit `null` keine Ausnahme bei der Verwendung von <xref:System.IComparable> .  
  
> [!NOTE]
>  Bei jedem getesteten Element `value` wird an die entsprechende-Implementierung weitergeleitet <xref:System.IComparable> , auch wenn `value` ist `null` . Das heißt, die- <xref:System.IComparable> Implementierung bestimmt, wie ein bestimmtes Element mit verglichen wird `null` .  
  
 Diese Methode ist ein O (log `n` )-Vorgang, bei dem gleich `n` ist `length` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die untere <paramref name="array" />-Grenze.  
  
Oder 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="array" /> an.  
  
Oder 
 <paramref name="comparer" /> ist <see langword="null" /> und <paramref name="value" /> verfügt über einen Typ, der nicht mit den Elementen von <paramref name="array" /> kompatibel ist.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist<see langword="null" />, <paramref name="value" /> implementiert nicht die <see cref="T:System.IComparable" />-Schnittstelle, und bei der Suche wird ein Element gefunden, das die <see cref="T:System.IComparable" />-Schnittstelle nicht implementiert.</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * 'T -&gt; int" Usage="System.Array.BinarySearch (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende sortierte eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="value">Das Objekt, nach dem gesucht werden soll.</param>
        <summary>Durchsucht ein ganzes sortiertes eindimensionales Array mithilfe der generischen <see cref="T:System.IComparable`1" />-Schnittstelle, die von jedem Element des <see cref="T:System.Array" /> und vom angegebenen Objekt implementiert wird, nach einem bestimmten Element.</summary>
        <returns>Der Index des angegebenen <paramref name="value" /> im angegebenen <paramref name="array" />, sofern <paramref name="value" /> gefunden wurde, andernfalls eine negative Zahl. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> kleiner als mindestens ein Element in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <paramref name="value" /> ist. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> größer als alle Elemente in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1). Wenn diese Methode mit einem nicht sortierten <paramref name="array" /> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <paramref name="value" /> in <paramref name="array" /> vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt nicht das Suchen von Arrays, die negative Indizes enthalten. `array`muss sortiert werden, bevor diese Methode aufgerufen wird.  
  
 Wenn `array` den angegebenen Wert nicht enthält, gibt die Methode eine negative Ganzzahl zurück. Sie können den bitweisen Komplement Operator (~ in c#, `Not` in Visual Basic) auf das negative Ergebnis anwenden, um einen Index zu entwickeln. Wenn dieser Index gleich der Größe des Arrays ist, sind keine Elemente größer als `value` im Array. Andernfalls ist dies der Index des ersten Elements, das größer als ist `value` .  
  
 `T`muss die <xref:System.IComparable%601> generische-Schnittstelle implementieren, die für Vergleiche verwendet wird. Die Elemente von `array` müssen bereits nach der von der Implementierung definierten Sortierreihenfolge in einem zunehmenden Wert sortiert werden <xref:System.IComparable%601> . andernfalls ist das Ergebnis möglicherweise falsch.  
  
 Doppelte Elemente sind zulässig. Wenn <xref:System.Array> mehr als ein Element enthält, das gleich `value` ist, gibt die Methode den Index von nur einem der Vorkommen und nicht notwendigerweise der ersten zurück.  
  
 `null`kann immer mit einem beliebigen anderen Referenztyp verglichen werden. Daher generieren Vergleiche mit `null` keine Ausnahme.  
  
> [!NOTE]
>  Bei jedem getesteten Element `value` wird an die entsprechende-Implementierung weitergeleitet <xref:System.IComparable%601> , auch wenn `value` ist `null` . Das heißt, die- <xref:System.IComparable%601> Implementierung bestimmt, wie ein bestimmtes Element mit verglichen wird `null` .  
  
 Bei dieser Methode handelt es sich um einen O (log `n` )-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> von ist `array` .  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Array.Sort%60%601(%60%600[])> generische Methoden Überladung und die <xref:System.Array.BinarySearch%60%601(%60%600[],%60%600)> generische Methoden Überladung. Ein Array von Zeichen folgen wird erstellt, in keiner bestimmten Reihenfolge.  
  
 Das Array wird angezeigt, sortiert und erneut angezeigt. Arrays müssen sortiert werden, um die-Methode zu verwenden <xref:System.Array.BinarySearch%2A> .  
  
> [!NOTE]
>  Die Aufrufe der <xref:System.Array.Sort%2A> generischen-Methode und der- <xref:System.Array.BinarySearch%2A> Methode unterscheiden sich nicht von Aufrufen ihrer nicht generischen Entsprechungen, da Visual Basic, c# und C++ den Typ des generischen Typparameters vom Typ des ersten Arguments ableiten. Wenn Sie die [Ildasm.exe (IL-Disassembler)](/dotnet/framework/tools/ildasm-exe-il-disassembler) verwenden, um die MSIL (Microsoft Intermediate Language) zu überprüfen, können Sie sehen, dass die generischen Methoden aufgerufen werden.  
  
 Die <xref:System.Array.BinarySearch%60%601(%60%600[],%60%600)> generische Methoden Überladung wird dann verwendet, um nach zwei Zeichen folgen zu suchen, eine, die nicht im-Array ist, und eine, die ist. Das-Array und der Rückgabewert der- <xref:System.Array.BinarySearch%2A> Methode werden an die `ShowWhere` generische-Methode übergeben, die den Indexwert anzeigt, wenn die Zeichenfolge gefunden wird, und andernfalls die Elemente, zwischen denen die Such Zeichenfolge fällt, wenn Sie im Array vorhanden wäre. Der Index ist negativ, wenn die Zeichenfolge nicht im Array enthalten ist, sodass die `ShowWhere` Methode das bitweise Komplement (der ~-Operator in c# und Visual C++, `Xor` -1 in Visual Basic) übernimmt, um den Index des ersten Elements in der Liste zu erhalten, das größer als die Such Zeichenfolge ist.  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die generische <see cref="T:System.IComparable`1" />-Schnittstelle wird von <paramref name="T" /> nicht implementiert.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="System.Array.BinarySearch (array, value, comparer)" />
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value, System.Collections.Generic.IComparer&lt;T&gt;? comparer);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende sortierte eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="value">Das Objekt, nach dem gesucht werden soll.</param>
        <param name="comparer">Die <see cref="T:System.Collections.Generic.IComparer`1" />-Implementierung, die beim Vergleich von Elementen verwendet werden soll.  
  
Oder 
 <see langword="null" />, wenn die <see cref="T:System.IComparable`1" />-Implementierung des jeweiligen Elements verwendet werden soll.</param>
        <summary>Durchsucht ein ganzes sortiertes eindimensionales Array mithilfe der angegebenen generischen <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle nach einem Wert.</summary>
        <returns>Der Index des angegebenen <paramref name="value" /> im angegebenen <paramref name="array" />, sofern <paramref name="value" /> gefunden wurde, andernfalls eine negative Zahl. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> kleiner als mindestens ein Element in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <paramref name="value" /> ist. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> größer als alle Elemente in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1). Wenn diese Methode mit einem nicht sortierten <paramref name="array" /> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <paramref name="value" /> in <paramref name="array" /> vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt nicht das Suchen von Arrays, die negative Indizes enthalten. `array`muss sortiert werden, bevor diese Methode aufgerufen wird.  
  
 Wenn das den <xref:System.Array> angegebenen Wert nicht enthält, gibt die Methode eine negative Ganzzahl zurück. Sie können den bitweisen Komplement Operator (~ in c#, `Not` in Visual Basic) auf das negative Ergebnis anwenden, um einen Index zu entwickeln. Wenn dieser Index gleich der Größe des Arrays ist, sind keine Elemente größer als `value` im Array. Andernfalls ist dies der Index des ersten Elements, das größer als ist `value` .  
  
 Der Vergleich passt an, wie die Elemente verglichen werden. Beispielsweise können Sie einen <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> als Vergleichs Operator verwenden, um Zeichen folgen suchen ohne Berücksichtigung der Groß-/Kleinschreibung auszuführen.  
  
 Wenn `comparer` nicht ist `null` , werden die Elemente von `array` mithilfe der angegebenen <xref:System.Collections.Generic.IComparer%601> generischen Schnittstellen Implementierung mit dem angegebenen Wert verglichen. Die Elemente von `array` müssen bereits nach der von definierten Sortierreihenfolge in einem zunehmenden Wert sortiert werden `comparer` . andernfalls ist das Ergebnis möglicherweise falsch.  
  
 Wenn `comparer` `null` den Wert hat, erfolgt der Vergleich mithilfe der <xref:System.IComparable%601> von bereitgestellten generischen Schnittstellen Implementierung `T` . Die Elemente von `array` müssen bereits nach der von der Implementierung definierten Sortierreihenfolge in einem zunehmenden Wert sortiert werden <xref:System.IComparable%601> . andernfalls ist das Ergebnis möglicherweise falsch.  
  
> [!NOTE]
>  Wenn `comparer` ist `null` und `value` die <xref:System.IComparable%601> generische-Schnittstelle nicht implementiert, werden die Elemente von `array` erst nach <xref:System.IComparable%601> dem Beginn der Suche getestet. Eine-Ausnahme wird ausgelöst, wenn bei der Suche ein Element gefunden wird, das nicht implementiert <xref:System.IComparable%601> .  
  
 Doppelte Elemente sind zulässig. Wenn <xref:System.Array> mehr als ein Element enthält, das gleich `value` ist, gibt die Methode den Index von nur einem der Vorkommen und nicht notwendigerweise der ersten zurück.  
  
 `null`kann immer mit einem beliebigen anderen Referenztyp verglichen werden. Daher generieren Vergleiche mit `null` keine Ausnahme.  
  
> [!NOTE]
>  Bei jedem getesteten Element `value` wird an die entsprechende-Implementierung weitergeleitet <xref:System.IComparable%601> , auch wenn `value` ist `null` . Das heißt, die- <xref:System.IComparable%601> Implementierung bestimmt, wie ein bestimmtes Element mit verglichen wird `null` .  
  
 Bei dieser Methode handelt es sich um einen O (log `n` )-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> von ist `array` .  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Array.Sort%60%601(%60%600[],System.Collections.Generic.IComparer{%60%600})> generische Methoden Überladung und die <xref:System.Array.BinarySearch%60%601(%60%600[],%60%600,System.Collections.Generic.IComparer{%60%600})> generische Methoden Überladung.  
  
 Im Codebeispiel wird ein alternativer Vergleich für Zeichen folgen mit dem Namen definiert `ReverseCompare` , der `IComparer<string>` die `IComparer(Of String)` `IComparer<String^>` generische Schnittstelle (in Visual Basic Visual C++) implementiert. Der Vergleich Ruft die- <xref:System.String.CompareTo(System.String)> Methode auf und kehrt die Reihenfolge der Vergleichs Elemente um, sodass die Zeichen folgen nicht zu hoch, sondern zu niedrig sortiert werden.  
  
 Das Array wird angezeigt, sortiert und erneut angezeigt. Arrays müssen sortiert werden, um die-Methode zu verwenden <xref:System.Array.BinarySearch%2A> .  
  
> [!NOTE]
>  Die Aufrufe der <xref:System.Array.Sort%60%601(%60%600[],System.Collections.Generic.IComparer{%60%600})> generischen-Methode und der- <xref:System.Array.BinarySearch%60%601(%60%600[],%60%600,System.Collections.Generic.IComparer{%60%600})> Methode unterscheiden sich nicht von Aufrufen ihrer nicht generischen Entsprechungen, da Visual Basic, c# und C++ den Typ des generischen Typparameters vom Typ des ersten Arguments ableiten. Wenn Sie die [Ildasm.exe (IL-Disassembler)](/dotnet/framework/tools/ildasm-exe-il-disassembler) verwenden, um die MSIL (Microsoft Intermediate Language) zu überprüfen, können Sie sehen, dass die generischen Methoden aufgerufen werden.  
  
 Die <xref:System.Array.BinarySearch%60%601(%60%600[],%60%600,System.Collections.Generic.IComparer{%60%600})> generische Methoden Überladung wird dann verwendet, um nach zwei Zeichen folgen zu suchen, eine, die nicht im-Array ist, und eine, die ist. Das-Array und der Rückgabewert der- <xref:System.Array.BinarySearch%60%601(%60%600[],%60%600,System.Collections.Generic.IComparer{%60%600})> Methode werden an die `ShowWhere` generische-Methode übergeben, die den Indexwert anzeigt, wenn die Zeichenfolge gefunden wird, und andernfalls die Elemente, zwischen denen die Such Zeichenfolge fällt, wenn Sie im Array vorhanden wäre. Der Index ist negativ, wenn die Zeichenfolge nicht n das Array ist, sodass die `ShowWhere` Methode das bitweise Komplement (der ~-Operator in c# und Visual C++, `Xor` -1 in Visual Basic) übernimmt, um den Index des ersten Elements in der Liste zu erhalten, das größer als die Such Zeichenfolge ist.  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparer" /> ist <see langword="null" /> und <paramref name="value" /> verfügt über einen Typ, der nicht mit den Elementen von <paramref name="array" /> kompatibel ist.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" /> und <paramref name="T" /> implementiert die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * int * int * 'T -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende sortierte eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="index">Der Startindex des zu durchsuchenden Bereichs.</param>
        <param name="length">Die Länge des zu durchsuchenden Bereichs.</param>
        <param name="value">Das Objekt, nach dem gesucht werden soll.</param>
        <summary>Durchsucht einen Bereich von Elementen in einem sortierten eindimensionalen Array mithilfe der generischen <see cref="T:System.IComparable`1" />-Schnittstelle, die von jedem Element des <see cref="T:System.Array" /> und vom angegebenen Wert implementiert wird, nach einem Wert.</summary>
        <returns>Der Index des angegebenen <paramref name="value" /> im angegebenen <paramref name="array" />, sofern <paramref name="value" /> gefunden wurde, andernfalls eine negative Zahl. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> kleiner als mindestens ein Element in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <paramref name="value" /> ist. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> größer als alle Elemente in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1). Wenn diese Methode mit einem nicht sortierten <paramref name="array" /> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <paramref name="value" /> in <paramref name="array" /> vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt nicht das Suchen von Arrays, die negative Indizes enthalten. `array`muss sortiert werden, bevor diese Methode aufgerufen wird.  
  
 Wenn das Array den angegebenen Wert nicht enthält, gibt die Methode eine negative Ganzzahl zurück. Sie können den bitweisen Komplement Operator (~ in c#, `Not` in Visual Basic) auf das negative Ergebnis anwenden, um einen Index zu entwickeln. Wenn dieser Index gleich der Größe des Arrays ist, sind keine Elemente größer als `value` im Array. Andernfalls ist dies der Index des ersten Elements, das größer als ist `value` .  
  
 `T`muss die <xref:System.IComparable%601> generische-Schnittstelle implementieren, die für Vergleiche verwendet wird. Die Elemente von `array` müssen bereits nach der von der Implementierung definierten Sortierreihenfolge in einem zunehmenden Wert sortiert werden <xref:System.IComparable%601> . andernfalls ist das Ergebnis möglicherweise falsch.  
  
 Doppelte Elemente sind zulässig. Wenn <xref:System.Array> mehr als ein Element enthält, das gleich `value` ist, gibt die Methode den Index von nur einem der Vorkommen und nicht notwendigerweise der ersten zurück.  
  
 `null`kann immer mit einem beliebigen anderen Referenztyp verglichen werden. Daher generieren Vergleiche mit `null` keine Ausnahme.  
  
> [!NOTE]
>  Bei jedem getesteten Element `value` wird an die entsprechende-Implementierung weitergeleitet <xref:System.IComparable%601> , auch wenn `value` ist `null` . Das heißt, die- <xref:System.IComparable%601> Implementierung bestimmt, wie ein bestimmtes Element mit verglichen wird `null` .  
  
 Diese Methode ist ein O (log `n` )-Vorgang, bei dem gleich `n` ist `length` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die untere <paramref name="array" />-Grenze.  
  
Oder 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="array" /> an.  
  
Oder 
 <paramref name="value" /> verfügt über einen Typ, der nicht mit den Elementen von <paramref name="array" /> kompatibel ist.</exception>
        <exception cref="T:System.InvalidOperationException">Die generische <see cref="T:System.IComparable`1" />-Schnittstelle wird von <paramref name="T" /> nicht implementiert.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * int * int * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value, comparer)" />
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value, System.Collections.Generic.IComparer&lt;T&gt;? comparer);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="4" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende sortierte eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="index">Der Startindex des zu durchsuchenden Bereichs.</param>
        <param name="length">Die Länge des zu durchsuchenden Bereichs.</param>
        <param name="value">Das Objekt, nach dem gesucht werden soll.</param>
        <param name="comparer">Die <see cref="T:System.Collections.Generic.IComparer`1" />-Implementierung, die beim Vergleich von Elementen verwendet werden soll.  
  
Oder 
 <see langword="null" />, wenn die <see cref="T:System.IComparable`1" />-Implementierung des jeweiligen Elements verwendet werden soll.</param>
        <summary>Durchsucht einen Bereich von Elementen in einem sortierten eindimensionalen Array mithilfe der angegebenen generischen <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle nach einem Wert.</summary>
        <returns>Der Index des angegebenen <paramref name="value" /> im angegebenen <paramref name="array" />, sofern <paramref name="value" /> gefunden wurde, andernfalls eine negative Zahl. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> kleiner als mindestens ein Element in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <paramref name="value" /> ist. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> größer als alle Elemente in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1). Wenn diese Methode mit einem nicht sortierten <paramref name="array" /> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <paramref name="value" /> in <paramref name="array" /> vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt nicht das Suchen von Arrays, die negative Indizes enthalten. `array`muss sortiert werden, bevor diese Methode aufgerufen wird.  
  
 Wenn das Array den angegebenen Wert nicht enthält, gibt die Methode eine negative Ganzzahl zurück. Sie können den bitweisen Komplement Operator (~ in c#, `Not` in Visual Basic) auf das negative Ergebnis anwenden, um einen Index zu entwickeln. Wenn dieser Index gleich der Größe des Arrays ist, sind keine Elemente größer als `value` im Array. Andernfalls ist dies der Index des ersten Elements, das größer als ist `value` .  
  
 Der Vergleich passt an, wie die Elemente verglichen werden. Beispielsweise können Sie einen <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> als Vergleichs Operator verwenden, um Zeichen folgen suchen ohne Berücksichtigung der Groß-/Kleinschreibung auszuführen.  
  
 Wenn `comparer` nicht ist `null` , werden die Elemente von `array` mithilfe der angegebenen <xref:System.Collections.Generic.IComparer%601> generischen Schnittstellen Implementierung mit dem angegebenen Wert verglichen. Die Elemente von `array` müssen bereits nach der von definierten Sortierreihenfolge in einem zunehmenden Wert sortiert werden `comparer` . andernfalls ist das Ergebnis möglicherweise falsch.  
  
 Wenn `comparer` `null` den Wert hat, erfolgt der Vergleich mithilfe der <xref:System.IComparable%601> Implementierung der generischen-Schnittstelle für den-Typ `T` . Die Elemente von `array` müssen bereits nach der von der Implementierung definierten Sortierreihenfolge in einem zunehmenden Wert sortiert werden <xref:System.IComparable%601> . andernfalls ist das Ergebnis möglicherweise falsch.  
  
 Doppelte Elemente sind zulässig. Wenn <xref:System.Array> mehr als ein Element enthält, das gleich `value` ist, gibt die Methode den Index von nur einem der Vorkommen und nicht notwendigerweise der ersten zurück.  
  
 `null`kann immer mit einem beliebigen anderen Referenztyp verglichen werden. Daher generieren Vergleiche mit `null` keine Ausnahme bei der Verwendung von <xref:System.IComparable%601> .  
  
> [!NOTE]
>  Bei jedem getesteten Element `value` wird an die entsprechende-Implementierung weitergeleitet <xref:System.IComparable%601> , auch wenn `value` ist `null` . Das heißt, die- <xref:System.IComparable%601> Implementierung bestimmt, wie ein bestimmtes Element mit verglichen wird `null` .  
  
 Diese Methode ist ein O (log `n` )-Vorgang, bei dem gleich `n` ist `length` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die untere <paramref name="array" />-Grenze.  
  
Oder 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="array" /> an.  
  
Oder 
 <paramref name="comparer" /> ist <see langword="null" /> und <paramref name="value" /> verfügt über einen Typ, der nicht mit den Elementen von <paramref name="array" /> kompatibel ist.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und <paramref name="T" /> implementiert die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public static void Clear (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clear(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Clear (array As Array, index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Clear(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Clear : Array * int * int -&gt; unit" Usage="System.Array.Clear (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das Array, dessen Elemente gelöscht werden sollen.</param>
        <param name="index">Der Startindex für den Bereich der zu löschenden Elemente.</param>
        <param name="length">Die Anzahl der zu löschenden Elemente.</param>
        <summary>Legt einen Bereich von Elementen in einem Array mit dem Standardwert der einzelnen Elementtypen fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode setzt jedes Element in einem Array auf den Standardwert des Elementtyps zurück. Es werden Elemente von Verweis Typen (einschließlich- <xref:System.String> Elementen) auf festgelegt `null` , und es werden Elemente von Werttypen auf die in der folgenden Tabelle dargestellten Standardwerte festgelegt.  
  
|Typ|Wert|  
|----------|-----------|  
|<xref:System.Boolean>|`false`|  
|Alle numerischen ganzzahligen und Gleit Komma Typen|0 (Null)|  
|<xref:System.DateTime>|<xref:System.DateTime.MinValue?displayProperty=nameWithType>|  
|Andere Werttypen|Standardwert der Felder des Typs|  
  
 Der Bereich der gelöschten Elemente wird von Zeile zu Zeile in einem mehrdimensionalen Array umschlossen.  
  
 Diese Methode löscht nur die Werte der-Elemente. die Elemente selbst werden nicht gelöscht. Ein Array hat eine Größe mit fester Größe. Daher können Elemente nicht hinzugefügt oder entfernt werden.  
  
 Diese Methode ist ein O ( `n` )-Vorgang, bei dem gleich `n` ist `length` .  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Array.Clear%2A> -Methode verwendet, um ganzzahlige Werte in einem eindimensionalen, zweidimensionalen und dreidimensionalen Array zurückzusetzen.  
  
 [!code-csharp[System.Array.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/example.cs#1)]
 [!code-vb[System.Array.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/example.vb#1)]  
  
 Im folgenden Beispiel wird eine `TimeZoneTime` -Struktur definiert, die ein <xref:System.TimeZoneInfo> -Feld und ein- <xref:System.DateTimeOffset> Feld enthält. Anschließend wird die- <xref:System.Array.Clear%2A> Methode aufgerufen, um ein Element in einem Array von Werten mit zwei Elementen zu löschen `TimeZoneTime` . Die-Methode legt den Wert des gelöschten Elements auf den Standardwert eines <xref:System.TimeZoneInfo> -Objekts () `null` und den Standardwert eines- <xref:System.DateTimeOffset> Objekts fest, das ist <xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType> .  
  
 [!code-csharp[System.Array.Clear#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/clearstruct1.cs#2)]
 [!code-vb[System.Array.Clear#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/clearstruct1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> ist kleiner als die untere <paramref name="array" />-Grenze.  
  
Oder 
 <paramref name="length" /> ist kleiner als Null.  
  
- oder - 
Die Summe von <paramref name="index" /> und <paramref name="length" /> ist größer als die Größe des <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Clone() cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Clone();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; obj" Usage="array.Clone " FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="array.Clone " FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public virtual object Clone ();" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine flache Kopie von <see cref="T:System.Array" />.</summary>
        <returns>Eine flache Kopie von <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei einer flachen Kopie von <xref:System.Array> werden nur die Elemente der kopiert <xref:System.Array> , unabhängig davon, ob es sich um Verweis Typen oder Werttypen handelt, die Objekte, auf die die Verweise verweisen, werden jedoch nicht kopiert. Die Verweise in der neuen <xref:System.Array> zeigen auf dieselben Objekte, auf die die Verweise im ursprünglichen <xref:System.Array> zeigen.  
  
 Im Gegensatz dazu kopiert eine tiefe Kopie von <xref:System.Array> die Elemente und alle Elemente, die direkt oder indirekt von den Elementen referenziert werden.  
  
 Der Klon ist identisch mit dem <xref:System.Type> Original <xref:System.Array> .  
  
 Diese Methode ist ein O ( `n` )-Vorgang, bei dem gleich `n` ist <xref:System.Array.Length%2A> .  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> -Array geklont und das Verhalten einer flachen Kopie veranschaulicht.  
  
 [!code-cpp[System.Array.Clone#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Clone/CPP/arrayclone.cpp#1)]
 [!code-csharp[System.Array.Clone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clone/CS/arrayclone.cs#1)]
 [!code-vb[System.Array.Clone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clone/VB/arrayclone.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ConstrainedCopy">
      <MemberSignature Language="C#" Value="public static void ConstrainedCopy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConstrainedCopy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ConstrainedCopy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ConstrainedCopy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="F#" Value="static member ConstrainedCopy : Array * int * Array * int * int -&gt; unit" Usage="System.Array.ConstrainedCopy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="sourceIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destinationArray" Type="System.Array" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destinationIndex" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceArray">Das <see cref="T:System.Array" />, das die zu kopierenden Daten enthält.</param>
        <param name="sourceIndex">Eine 32-Bit-Ganzzahl, die den Index im <paramref name="sourceArray" /> angibt, ab dem kopiert werden soll.</param>
        <param name="destinationArray">Das <see cref="T:System.Array" />, das die Daten empfängt.</param>
        <param name="destinationIndex">Eine 32-Bit-Ganzzahl, die den Index im <paramref name="destinationArray" /> angibt, ab dem gespeichert werden soll.</param>
        <param name="length">Eine 32-Bit-Ganzzahl, die die Anzahl der zu kopierenden Elemente darstellt.</param>
        <summary>Kopiert einen beim angegebenen Quellindex beginnenden Elementbereich aus einem <see cref="T:System.Array" /> und fügt ihn ab dem angegebenen Zielindex in ein anderes <see cref="T:System.Array" /> ein.  Stellt sicher, dass alle Änderungen rückgängig gemacht werden, wenn der Kopiervorgang nicht vollständig abgeschlossen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `sourceArray` -Parameter und der- `destinationArray` Parameter müssen über die gleiche Anzahl von Dimensionen verfügen.  Der `sourceArray` Typ muss mit dem Typ identisch sein oder vom Typ abgeleitet werden `destinationArray` . andernfalls wird eine ausgelöst <xref:System.ArrayTypeMismatchException> .  Im Gegensatz zu <xref:System.Array.Copy%2A> <xref:System.Array.ConstrainedCopy%2A> überprüft die Kompatibilität der Array Typen, bevor ein Vorgang durchgeführt wird.  
  
 Beim Kopieren zwischen mehrdimensionalen Arrays verhält sich das Array wie ein langes eindimensionales Array, bei dem die Zeilen (oder Spalten) vom Ende bis zum Ende verankert werden. Wenn ein Array z. b. über drei Zeilen (oder Spalten) mit jeweils vier Elementen verfügt, werden beim Kopieren von sechs Elementen vom Anfang des Arrays alle vier Elemente der ersten Zeile (oder Spalte) und die ersten beiden Elemente der zweiten Zeile (oder Spalte) kopiert. Zum Starten des Kopierens vom zweiten Element der dritten Zeile (oder Spalte) `sourceIndex` muss die obere Grenze der ersten Zeile (oder Spalte) plus der Länge der zweiten Zeile (oder Spalte) plus 2 sein.  
  
 Wenn `sourceArray` und `destinationArray` sich überlappen, verhält sich diese Methode so, als ob die ursprünglichen Werte von `sourceArray` an einem temporären Speicherort beibehalten wurden, bevor über `destinationArray` schrieben wird.  
  
 [C++]  
  
 Diese Methode entspricht der standardmäßigen C/C++-Funktion `memmove` , nicht `memcpy` .  
  
 Arrays können aus Verweistyp Arrays oder Werttyp Arrays bestehen.  Wenn `sourceArray` und `destinationArray` beide als Verweistyp Arrays oder beide Arrays vom Typ sind <xref:System.Object> , wird eine flache Kopie ausgeführt. Eine flache Kopie eines <xref:System.Array> ist ein neues <xref:System.Array> , das Verweise auf dieselben Elemente wie die ursprüngliche enthält <xref:System.Array> . Die Elemente selbst oder alle Elemente, auf die von den Elementen verwiesen wird, werden nicht kopiert. Im Gegensatz dazu kopiert eine tiefe Kopie von <xref:System.Array> die Elemente und alle Elemente, die direkt oder indirekt von den Elementen referenziert werden.  
  
 Wenn diese Methode eine Ausnahme beim Kopieren auslöst, `destinationArray` bleibt unverändert <xref:System.Array.ConstrainedCopy%2A> . Daher kann in einem eingeschränkten Ausführungs Bereich () verwendet werden <xref:System.Runtime.ConstrainedExecution.Cer> .  
  
 Diese Methode ist ein O ( `n` )-Vorgang, bei dem gleich `n` ist `length` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="destinationArray" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> und <paramref name="destinationArray" /> sind von unterschiedlichem Rang.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">Der <paramref name="sourceArray" />-Typ entspricht weder dem <paramref name="destinationArray" />-Typ, noch wird er von diesem abgeleitet.</exception>
        <exception cref="T:System.InvalidCastException">Mindestens ein Element in <paramref name="sourceArray" /> kann nicht in den <paramref name="destinationArray" />-Typ umgewandelt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" /> ist kleiner als die untere Grenze der ersten Dimension von <paramref name="sourceArray" />.  
  
Oder 
 <paramref name="destinationIndex" /> ist kleiner als die untere Grenze der ersten Dimension von <paramref name="destinationArray" />.  
  
Oder 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> ist größer als die Anzahl der Elemente vom <paramref name="sourceIndex" /> bis zum Ende des <paramref name="sourceArray" />s.  
  
Oder 
 <paramref name="length" /> ist größer als die Anzahl der Elemente vom <paramref name="destinationIndex" /> bis zum Ende des <paramref name="destinationArray" />s.</exception>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.Clone" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.Cer" />
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TInput,TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput[] ConvertAll&lt;TInput,TOutput&gt; (TInput[] array, Converter&lt;TInput,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput[] ConvertAll&lt;TInput, TOutput&gt;(!!TInput[] array, class System.Converter`2&lt;!!TInput, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertAll(Of TInput, TOutput) (array As TInput(), converter As Converter(Of TInput, TOutput)) As TOutput()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput, typename TOutput&gt;&#xA; static cli::array &lt;TOutput&gt; ^ ConvertAll(cli::array &lt;TInput&gt; ^ array, Converter&lt;TInput, TOutput&gt; ^ converter);" />
      <MemberSignature Language="F#" Value="static member ConvertAll : 'Input[] * Converter&lt;'Input, 'Output&gt; -&gt; 'Output[]" Usage="System.Array.ConvertAll (array, converter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="TInput[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="converter" Type="System.Converter&lt;TInput,TOutput&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">Der Typ der Elemente des Quellarrays.</typeparam>
        <typeparam name="TOutput">Der Typ der Elemente des Zielarrays.</typeparam>
        <param name="array">Das eindimensionale nullbasierte <see cref="T:System.Array" />, das in einen Zieltyp konvertiert werden soll.</param>
        <param name="converter">Ein <see cref="T:System.Converter`2" />, der jedes Element von einem Typ in einen anderen Typ konvertiert.</param>
        <summary>Konvertiert ein Array des einen Typs in ein Array eines anderen Typs.</summary>
        <returns>Ein Array des Zieltyps, das die konvertierten Elemente aus dem Quellarray enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Converter%602> ist ein Delegat einer Methode, die ein Objekt in den Zieltyp konvertiert.  Die Elemente von `array` werden einzeln an die <xref:System.Converter%602> -Elemente, und die konvertierten Elemente werden im neuen Array gespeichert.  
  
 Die Quelle `array` bleibt unverändert.  
  
 Bei dieser Methode handelt es sich um einen O ( `n` )-Vorgang, wobei `n` der <xref:System.Array.Length%2A> von ist `array` .  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Methode mit dem Namen definiert `PointFToPoint` , die eine- <xref:System.Drawing.PointF> Struktur in eine- <xref:System.Drawing.Point> Struktur konvertiert. Im Beispiel wird dann ein Array von <xref:System.Drawing.PointF> Strukturen erstellt, ein Delegat `Converter<PointF, Point>` ( `Converter(Of PointF, Point)` in Visual Basic) erstellt, um die `PointFToPoint` Methode darzustellen, und der Delegat wird an die Methode weitergeleitet <xref:System.Array.ConvertAll%2A> . Die <xref:System.Array.ConvertAll%2A> -Methode übergibt jedes Element der Eingabeliste an die `PointFToPoint` -Methode und fügt die konvertierten Elemente in eine neue Liste von- <xref:System.Drawing.Point> Strukturen ein. Beide Listen werden angezeigt.  
  
 [!code-cpp[Array_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[Array_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_ConvertAll/cs/source.cs#1)]
 [!code-vb[Array_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="converter" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiert einen Bereich von Elementen eines <see cref="T:System.Array" /> in ein anderes <see cref="T:System.Array" /> und führt ggf. Typumwandlungen und Boxing durch.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie von einem <xref:System.Array> Typ <xref:System.Object> in einen anderen Typ vom <xref:System.Array> Typ Integer kopiert wird.  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * Array * int -&gt; unit" Usage="System.Array.Copy (sourceArray, destinationArray, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">Das <see cref="T:System.Array" />, das die zu kopierenden Daten enthält.</param>
        <param name="destinationArray">Das <see cref="T:System.Array" />, das die Daten empfängt.</param>
        <param name="length">Eine 32-Bit-Ganzzahl, die die Anzahl der zu kopierenden Elemente darstellt.</param>
        <summary>Kopiert einen mit dem ersten Element beginnenden Elementbereich eines <see cref="T:System.Array" /> und fügt ihn ab dem ersten Element in ein anderes <see cref="T:System.Array" /> ein. Die Länge wird als 32-Bit-Ganzzahl angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `sourceArray` -Parameter und der- `destinationArray` Parameter müssen über die gleiche Anzahl von Dimensionen verfügen. Außerdem `destinationArray` muss bereits dimensioniert sein und muss über eine ausreichende Anzahl von Elementen verfügen, um die kopierten Daten aufnehmen zu können.  
  
 Beim Kopieren zwischen mehrdimensionalen Arrays verhält sich das Array wie ein langes eindimensionales Array, bei dem die Zeilen (oder Spalten) konzeptionell am Ende angeordnet werden. Wenn ein Array z. b. über drei Zeilen (oder Spalten) mit jeweils vier Elementen verfügt, werden beim Kopieren von sechs Elementen vom Anfang des Arrays alle vier Elemente der ersten Zeile (oder Spalte) und die ersten beiden Elemente der zweiten Zeile (oder Spalte) kopiert.  
  
 Wenn `sourceArray` und `destinationArray` sich überlappen, verhält sich diese Methode so, als ob die ursprünglichen Werte von `sourceArray` an einem temporären Speicherort beibehalten wurden, bevor über `destinationArray` schrieben wird.  
  
 [C++]  
  
 Diese Methode entspricht der standardmäßigen C/C++-Funktion `memmove` , nicht `memcpy` .  
  
 Arrays können aus Verweistyp Arrays oder Werttyp Arrays bestehen. Die typdownumwandlung erfolgt nach Bedarf.  
  
-   Beim Kopieren aus einem Verweistyp Array in ein Werttyp Array wird jedes Element Unboxing und dann kopiert. Beim Kopieren aus einem Werttyp Array in ein Verweistyp Array wird jedes Element gekapselt und dann kopiert.  
  
-   Beim Kopieren aus einem Verweistyp-oder Werttyp Array in ein <xref:System.Object> Array wird eine <xref:System.Object> erstellt, die jeden Wert oder Verweis enthält und anschließend kopiert wird. Beim Kopieren aus einem <xref:System.Object> Array in einen Verweistyp-oder Werttyp Array und ist die Zuweisung nicht möglich, wird eine ausgelöst <xref:System.InvalidCastException> .  
  
-   Wenn `sourceArray` und `destinationArray` beide als Verweistyp Arrays oder beide Arrays vom Typ sind <xref:System.Object> , wird eine flache Kopie ausgeführt. Eine flache Kopie eines <xref:System.Array> ist ein neues <xref:System.Array> , das Verweise auf dieselben Elemente wie die ursprüngliche enthält <xref:System.Array> . Die Elemente selbst oder alle Elemente, auf die von den Elementen verwiesen wird, werden nicht kopiert. Im Gegensatz dazu kopiert eine tiefe Kopie von <xref:System.Array> die Elemente und alle Elemente, die direkt oder indirekt von den Elementen referenziert werden.  
  
 Eine <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn die Arrays nicht kompatible Typen sind. Typkompatibilität wird wie folgt definiert:  
  
-   Ein Typ ist mit sich selbst kompatibel.  
  
-   Ein Werttyp ist mit <xref:System.Object> und mit einem Schnittstellentyp kompatibel, der durch diesen Werttyp implementiert wird. Ein Werttyp wird nur dann als verbunden mit einer Schnittstelle betrachtet, wenn er diese Schnittstelle direkt implementiert. Getrennte Typen sind nicht kompatibel.  
  
-   Zwei intrinsische (vordefinierte) Werttypen sind kompatibel, wenn das Kopieren vom Quelltyp in den Zieltyp eine erweiternde Konvertierung ist. Eine erweiternde Konvertierung verliert niemals Informationen, während eine einschränkende Konvertierung Informationen verlieren kann. Beispielsweise ist das Konvertieren einer 32-Bit-Ganzzahl mit Vorzeichen in eine 64-Bit-Ganzzahl mit Vorzeichen eine erweiternde Konvertierung, und die Konvertierung einer 64-Bit-Ganzzahl mit Vorzeichen in 32 eine Ganzzahl mit Vorzeichen mit Vorzeichen ist eine einschränkende Konvertierung Weitere Informationen zu Konvertierungen finden Sie unter <xref:System.Convert> .  
  
-   Ein nicht System interner (benutzerdefinierter) Werttyp ist nur mit sich selbst kompatibel.  
  
-   Enumerationen weisen eine implizite Konvertierung in <xref:System.Enum> und in ihren zugrunde liegenden Typ auf.  
  
 Wenn jedes Element in `sourceArray` einen Typumwandlung erfordert (z. b. von einer Basisklasse zu einer abgeleiteten Klasse oder von einer Schnittstelle zu einem Objekt) und mindestens ein Element nicht in den entsprechenden Typ in umgewandelt werden kann `destinationArray` , wird eine ausgelöst <xref:System.InvalidCastException> .  
  
 Wenn diese Methode eine Ausnahme beim Kopieren auslöst, ist der Zustand von nicht `destinationArray` definiert.  
  
 Diese Methode ist ein O ( `n` )-Vorgang, bei dem gleich `n` ist `length` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="destinationArray" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> und <paramref name="destinationArray" /> sind von unterschiedlichem Rang.</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> und <paramref name="destinationArray" /> weisen inkompatible Typen auf.</exception>
        <exception cref="T:System.InvalidCastException">Mindestens ein Element in <paramref name="sourceArray" /> kann nicht in den <paramref name="destinationArray" />-Typ umgewandelt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> ist größer als die Anzahl von Elementen in <paramref name="sourceArray" />.  
  
Oder 
 <paramref name="length" /> ist größer als die Anzahl von Elementen in <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, long length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * Array * int64 -&gt; unit" Usage="System.Array.Copy (sourceArray, destinationArray, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="destinationArray" Type="System.Array" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="length" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="sourceArray">Das <see cref="T:System.Array" />, das die zu kopierenden Daten enthält.</param>
        <param name="destinationArray">Das <see cref="T:System.Array" />, das die Daten empfängt.</param>
        <param name="length">Eine 64-Bit-Ganzzahl, die die Anzahl der zu kopierenden Elemente darstellt. Die Ganzzahl muss zwischen 0 (null) und einschließlich <see cref="F:System.Int32.MaxValue" /> liegen.</param>
        <summary>Kopiert einen mit dem ersten Element beginnenden Elementbereich eines <see cref="T:System.Array" /> und fügt ihn ab dem ersten Element in ein anderes <see cref="T:System.Array" /> ein. Die Länge wird als 64-Bit-Ganzzahl angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `sourceArray` -Parameter und der- `destinationArray` Parameter müssen über die gleiche Anzahl von Dimensionen verfügen. Außerdem `destinationArray` muss bereits dimensioniert sein und muss über eine ausreichende Anzahl von Elementen verfügen, um die kopierten Daten aufnehmen zu können.  
  
 Beim Kopieren zwischen mehrdimensionalen Arrays verhält sich das Array wie ein langes eindimensionales Array, bei dem die Zeilen (oder Spalten) konzeptionell am Ende angeordnet werden. Wenn ein Array z. b. über drei Zeilen (oder Spalten) mit jeweils vier Elementen verfügt, werden beim Kopieren von sechs Elementen vom Anfang des Arrays alle vier Elemente der ersten Zeile (oder Spalte) und die ersten beiden Elemente der zweiten Zeile (oder Spalte) kopiert.  
  
 Wenn `sourceArray` und `destinationArray` sich überlappen, verhält sich diese Methode so, als ob die ursprünglichen Werte von `sourceArray` an einem temporären Speicherort beibehalten wurden, bevor über `destinationArray` schrieben wird.  
  
 [C++]  
  
 Diese Methode entspricht der standardmäßigen C/C++-Funktion `memmove` , nicht `memcpy` .  
  
 Arrays können aus Verweistyp Arrays oder Werttyp Arrays bestehen. Die typdownumwandlung erfolgt nach Bedarf.  
  
-   Beim Kopieren aus einem Verweistyp Array in ein Werttyp Array wird jedes Element Unboxing und dann kopiert. Beim Kopieren aus einem Werttyp Array in ein Verweistyp Array wird jedes Element gekapselt und dann kopiert.  
  
-   Beim Kopieren aus einem Verweistyp-oder Werttyp Array in ein <xref:System.Object> Array wird eine <xref:System.Object> erstellt, die jeden Wert oder Verweis enthält und anschließend kopiert wird. Beim Kopieren aus einem <xref:System.Object> Array in einen Verweistyp-oder Werttyp Array und ist die Zuweisung nicht möglich, wird eine ausgelöst <xref:System.InvalidCastException> .  
  
-   Wenn `sourceArray` und `destinationArray` beide als Verweistyp Arrays oder beide Arrays vom Typ sind <xref:System.Object> , wird eine flache Kopie ausgeführt. Eine flache Kopie eines <xref:System.Array> ist ein neues <xref:System.Array> , das Verweise auf dieselben Elemente wie die ursprüngliche enthält <xref:System.Array> . Die Elemente selbst oder alle Elemente, auf die von den Elementen verwiesen wird, werden nicht kopiert. Im Gegensatz dazu kopiert eine tiefe Kopie von <xref:System.Array> die Elemente und alle Elemente, die direkt oder indirekt von den Elementen referenziert werden.  
  
 Eine <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn die Arrays nicht kompatible Typen sind. Typkompatibilität wird wie folgt definiert:  
  
-   Ein Typ ist mit sich selbst kompatibel.  
  
-   Ein Werttyp ist mit <xref:System.Object> und mit einem Schnittstellentyp kompatibel, der durch diesen Werttyp implementiert wird. Ein Werttyp wird nur dann als verbunden mit einer Schnittstelle betrachtet, wenn er diese Schnittstelle direkt implementiert. Getrennte Typen sind nicht kompatibel.  
  
-   Zwei intrinsische (vordefinierte) Werttypen sind kompatibel, wenn das Kopieren vom Quelltyp in den Zieltyp eine erweiternde Konvertierung ist. Eine erweiternde Konvertierung verliert niemals Informationen, während eine einschränkende Konvertierung Informationen verlieren kann. Beispielsweise ist das Konvertieren einer 32-Bit-Ganzzahl mit Vorzeichen in eine 64-Bit-Ganzzahl mit Vorzeichen eine erweiternde Konvertierung, und die Konvertierung einer 64-Bit-Ganzzahl mit Vorzeichen in 32 eine Ganzzahl mit Vorzeichen mit Vorzeichen ist eine einschränkende Konvertierung Weitere Informationen zu Konvertierungen finden Sie unter <xref:System.Convert> .  
  
-   Ein nicht System interner (benutzerdefinierter) Werttyp ist nur mit sich selbst kompatibel.  
  
-   Enumerationen weisen eine implizite Konvertierung in <xref:System.Enum> und in ihren zugrunde liegenden Typ auf.  
  
 Wenn jedes Element in `sourceArray` einen Typumwandlung erfordert (z. b. von einer Basisklasse zu einer abgeleiteten Klasse oder von einer Schnittstelle zu einem Objekt) und mindestens ein Element nicht in den entsprechenden Typ in umgewandelt werden kann `destinationArray` , wird eine ausgelöst <xref:System.InvalidCastException> .  
  
 Wenn diese Methode eine Ausnahme beim Kopieren auslöst, ist der Zustand von nicht `destinationArray` definiert.  
  
 Diese Methode ist ein O ( `n` )-Vorgang, bei dem gleich `n` ist `length` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="destinationArray" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> und <paramref name="destinationArray" /> sind von unterschiedlichem Rang.</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> und <paramref name="destinationArray" /> weisen inkompatible Typen auf.</exception>
        <exception cref="T:System.InvalidCastException">Mindestens ein Element in <paramref name="sourceArray" /> kann nicht in den <paramref name="destinationArray" />-Typ umgewandelt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length" /> ist kleiner als 0 oder größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> ist größer als die Anzahl von Elementen in <paramref name="sourceArray" />.  
  
Oder 
 <paramref name="length" /> ist größer als die Anzahl von Elementen in <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * int * Array * int * int -&gt; unit" Usage="System.Array.Copy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">Das <see cref="T:System.Array" />, das die zu kopierenden Daten enthält.</param>
        <param name="sourceIndex">Eine 32-Bit-Ganzzahl, die den Index im <paramref name="sourceArray" /> angibt, ab dem kopiert werden soll.</param>
        <param name="destinationArray">Das <see cref="T:System.Array" />, das die Daten empfängt.</param>
        <param name="destinationIndex">Eine 32-Bit-Ganzzahl, die den Index im <paramref name="destinationArray" /> angibt, ab dem gespeichert werden soll.</param>
        <param name="length">Eine 32-Bit-Ganzzahl, die die Anzahl der zu kopierenden Elemente darstellt.</param>
        <summary>Kopiert einen beim angegebenen Quellindex beginnenden Elementbereich aus einem <see cref="T:System.Array" /> und fügt ihn ab dem angegebenen Zielindex in ein anderes <see cref="T:System.Array" /> ein. Die Länge und die Indizes werden als 32-Bit-Ganzzahlen angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `sourceArray` -Parameter und der- `destinationArray` Parameter müssen über die gleiche Anzahl von Dimensionen verfügen. Außerdem `destinationArray` muss bereits dimensioniert sein und muss über eine ausreichende Anzahl von Elementen verfügen, beginnend bei der `destinationIndex` Position, an der die kopierten Daten berücksichtigt werden.  
  
 Beim Kopieren zwischen mehrdimensionalen Arrays verhält sich das Array wie ein langes eindimensionales Array, bei dem die Zeilen (oder Spalten) vom Ende bis zum Ende verankert werden. Wenn ein Array z. b. über drei Zeilen (oder Spalten) mit jeweils vier Elementen verfügt, werden beim Kopieren von sechs Elementen vom Anfang des Arrays alle vier Elemente der ersten Zeile (oder Spalte) und die ersten beiden Elemente der zweiten Zeile (oder Spalte) kopiert. Zum Starten des Kopierens vom zweiten Element der dritten Zeile (oder Spalte) `sourceIndex` muss die obere Grenze der ersten Zeile (oder Spalte) plus der Länge der zweiten Zeile (oder Spalte) plus 2 sein.  
  
 Wenn `sourceArray` und `destinationArray` sich überlappen, verhält sich diese Methode so, als ob die ursprünglichen Werte von `sourceArray` an einem temporären Speicherort beibehalten wurden, bevor über `destinationArray` schrieben wird.  
  
 [C++]  
  
 Diese Methode entspricht der standardmäßigen C/C++-Funktion `memmove` , nicht `memcpy` .  
  
 Arrays können aus Verweistyp Arrays oder Werttyp Arrays bestehen. Die typdownumwandlung erfolgt nach Bedarf.  
  
-   Beim Kopieren aus einem Verweistyp Array in ein Werttyp Array wird jedes Element Unboxing und dann kopiert. Beim Kopieren aus einem Werttyp Array in ein Verweistyp Array wird jedes Element gekapselt und dann kopiert.  
  
-   Beim Kopieren aus einem Verweistyp-oder Werttyp Array in ein <xref:System.Object> Array wird eine <xref:System.Object> erstellt, die jeden Wert oder Verweis enthält und anschließend kopiert wird. Beim Kopieren aus einem <xref:System.Object> Array in einen Verweistyp-oder Werttyp Array und ist die Zuweisung nicht möglich, wird eine ausgelöst <xref:System.InvalidCastException> .  
  
-   Wenn `sourceArray` und `destinationArray` beide als Verweistyp Arrays oder beide Arrays vom Typ sind <xref:System.Object> , wird eine flache Kopie ausgeführt. Eine flache Kopie eines <xref:System.Array> ist ein neues <xref:System.Array> , das Verweise auf dieselben Elemente wie die ursprüngliche enthält <xref:System.Array> . Die Elemente selbst oder alle Elemente, auf die von den Elementen verwiesen wird, werden nicht kopiert. Im Gegensatz dazu kopiert eine tiefe Kopie von <xref:System.Array> die Elemente und alle Elemente, die direkt oder indirekt von den Elementen referenziert werden.  
  
 Eine <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn die Arrays nicht kompatible Typen sind. Typkompatibilität wird wie folgt definiert:  
  
-   Ein Typ ist mit sich selbst kompatibel.  
  
-   Ein Werttyp ist mit <xref:System.Object> und mit einem Schnittstellentyp kompatibel, der durch diesen Werttyp implementiert wird. Ein Werttyp wird nur dann als verbunden mit einer Schnittstelle betrachtet, wenn er diese Schnittstelle direkt implementiert. Getrennte Typen sind nicht kompatibel.  
  
-   Zwei intrinsische (vordefinierte) Werttypen sind kompatibel, wenn das Kopieren vom Quelltyp in den Zieltyp eine erweiternde Konvertierung ist. Eine erweiternde Konvertierung verliert niemals Informationen, während eine einschränkende Konvertierung Informationen verlieren kann. Beispielsweise ist das Konvertieren einer 32-Bit-Ganzzahl mit Vorzeichen in eine 64-Bit-Ganzzahl mit Vorzeichen eine erweiternde Konvertierung, und die Konvertierung einer 64-Bit-Ganzzahl mit Vorzeichen in 32 eine Ganzzahl mit Vorzeichen mit Vorzeichen ist eine einschränkende Konvertierung Weitere Informationen zu Konvertierungen finden Sie unter <xref:System.Convert> .  
  
-   Ein nicht System interner (benutzerdefinierter) Werttyp ist nur mit sich selbst kompatibel.  
  
-   Enumerationen weisen eine implizite Konvertierung in <xref:System.Enum> und in ihren zugrunde liegenden Typ auf.  
  
 Wenn jedes Element in `sourceArray` einen Typumwandlung erfordert (z. b. von einer Basisklasse zu einer abgeleiteten Klasse oder von einer Schnittstelle zu einem Objekt) und mindestens ein Element nicht in den entsprechenden Typ in umgewandelt werden kann `destinationArray` , wird eine ausgelöst <xref:System.InvalidCastException> .  
  
 Wenn diese Methode eine Ausnahme beim Kopieren auslöst, ist der Zustand von nicht `destinationArray` definiert.  
  
 Diese Methode ist ein O ( `n` )-Vorgang, bei dem gleich `n` ist `length` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="destinationArray" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> und <paramref name="destinationArray" /> sind von unterschiedlichem Rang.</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> und <paramref name="destinationArray" /> weisen inkompatible Typen auf.</exception>
        <exception cref="T:System.InvalidCastException">Mindestens ein Element in <paramref name="sourceArray" /> kann nicht in den <paramref name="destinationArray" />-Typ umgewandelt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" /> ist kleiner als die untere Grenze der ersten Dimension von <paramref name="sourceArray" />.  
  
Oder 
 <paramref name="destinationIndex" /> ist kleiner als die untere Grenze der ersten Dimension von <paramref name="destinationArray" />.  
  
Oder 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> ist größer als die Anzahl der Elemente vom <paramref name="sourceIndex" /> bis zum Ende des <paramref name="sourceArray" />s.  
  
Oder 
 <paramref name="length" /> ist größer als die Anzahl der Elemente vom <paramref name="destinationIndex" /> bis zum Ende des <paramref name="destinationArray" />s.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int64 sourceIndex, class System.Array destinationArray, int64 destinationIndex, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Long, destinationArray As Array, destinationIndex As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, long sourceIndex, Array ^ destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * int64 * Array * int64 * int64 -&gt; unit" Usage="System.Array.Copy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="sourceIndex" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="destinationArray" Type="System.Array" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="destinationIndex" Type="System.Int64" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="length" Type="System.Int64" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="sourceArray">Das <see cref="T:System.Array" />, das die zu kopierenden Daten enthält.</param>
        <param name="sourceIndex">Eine 64-Bit-Ganzzahl, die den Index im <paramref name="sourceArray" /> angibt, ab dem kopiert werden soll.</param>
        <param name="destinationArray">Das <see cref="T:System.Array" />, das die Daten empfängt.</param>
        <param name="destinationIndex">Eine 64-Bit-Ganzzahl, die den Index im <paramref name="destinationArray" /> angibt, ab dem gespeichert werden soll.</param>
        <param name="length">Eine 64-Bit-Ganzzahl, die die Anzahl der zu kopierenden Elemente darstellt. Die Ganzzahl muss zwischen 0 (null) und einschließlich <see cref="F:System.Int32.MaxValue" /> liegen.</param>
        <summary>Kopiert einen beim angegebenen Quellindex beginnenden Elementbereich aus einem <see cref="T:System.Array" /> und fügt ihn ab dem angegebenen Zielindex in ein anderes <see cref="T:System.Array" /> ein. Die Länge und die Indizes werden als 64-Bit-Ganzzahlen angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `sourceArray` -Parameter und der- `destinationArray` Parameter müssen über die gleiche Anzahl von Dimensionen verfügen. Außerdem `destinationArray` muss bereits dimensioniert sein und muss über eine ausreichende Anzahl von Elementen verfügen, beginnend bei der `destinationIndex` Position, an der die kopierten Daten berücksichtigt werden.  
  
 Beim Kopieren zwischen mehrdimensionalen Arrays verhält sich das Array wie ein langes eindimensionales Array, bei dem die Zeilen (oder Spalten) vom Ende bis zum Ende verankert werden. Wenn ein Array z. b. über drei Zeilen (oder Spalten) mit jeweils vier Elementen verfügt, werden beim Kopieren von sechs Elementen vom Anfang des Arrays alle vier Elemente der ersten Zeile (oder Spalte) und die ersten beiden Elemente der zweiten Zeile (oder Spalte) kopiert. Zum Starten des Kopierens vom zweiten Element der dritten Zeile (oder Spalte) `sourceIndex` muss die obere Grenze der ersten Zeile (oder Spalte) plus der Länge der zweiten Zeile (oder Spalte) plus 2 sein.  
  
 Wenn `sourceArray` und `destinationArray` sich überlappen, verhält sich diese Methode so, als ob die ursprünglichen Werte von `sourceArray` an einem temporären Speicherort beibehalten wurden, bevor über `destinationArray` schrieben wird.  
  
 [C++]  
  
 Diese Methode entspricht der standardmäßigen C/C++-Funktion `memmove` , nicht `memcpy` .  
  
 Arrays können aus Verweistyp Arrays oder Werttyp Arrays bestehen. Die typdownumwandlung erfolgt nach Bedarf.  
  
-   Beim Kopieren aus einem Verweistyp Array in ein Werttyp Array wird jedes Element Unboxing und dann kopiert. Beim Kopieren aus einem Werttyp Array in ein Verweistyp Array wird jedes Element gekapselt und dann kopiert.  
  
-   Beim Kopieren aus einem Verweistyp-oder Werttyp Array in ein <xref:System.Object> Array wird eine <xref:System.Object> erstellt, die jeden Wert oder Verweis enthält und anschließend kopiert wird. Beim Kopieren aus einem <xref:System.Object> Array in einen Verweistyp-oder Werttyp Array und ist die Zuweisung nicht möglich, wird eine ausgelöst <xref:System.InvalidCastException> .  
  
-   Wenn `sourceArray` und `destinationArray` beide als Verweistyp Arrays oder beide Arrays vom Typ sind <xref:System.Object> , wird eine flache Kopie ausgeführt. Eine flache Kopie eines <xref:System.Array> ist ein neues <xref:System.Array> , das Verweise auf dieselben Elemente wie die ursprüngliche enthält <xref:System.Array> . Die Elemente selbst oder alle Elemente, auf die von den Elementen verwiesen wird, werden nicht kopiert. Im Gegensatz dazu kopiert eine tiefe Kopie von <xref:System.Array> die Elemente und alle Elemente, die direkt oder indirekt von den Elementen referenziert werden.  
  
 Eine <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn die Arrays nicht kompatible Typen sind. Typkompatibilität wird wie folgt definiert:  
  
-   Ein Typ ist mit sich selbst kompatibel.  
  
-   Ein Werttyp ist mit <xref:System.Object> und mit einem Schnittstellentyp kompatibel, der durch diesen Werttyp implementiert wird. Ein Werttyp wird nur dann als verbunden mit einer Schnittstelle betrachtet, wenn er diese Schnittstelle direkt implementiert. Getrennte Typen sind nicht kompatibel.  
  
-   Zwei intrinsische (vordefinierte) Werttypen sind kompatibel, wenn das Kopieren vom Quelltyp in den Zieltyp eine erweiternde Konvertierung ist. Eine erweiternde Konvertierung verliert niemals Informationen, während eine einschränkende Konvertierung Informationen verlieren kann. Beispielsweise ist das Konvertieren einer 32-Bit-Ganzzahl mit Vorzeichen in eine 64-Bit-Ganzzahl mit Vorzeichen eine erweiternde Konvertierung, und die Konvertierung einer 64-Bit-Ganzzahl mit Vorzeichen in 32 eine Ganzzahl mit Vorzeichen mit Vorzeichen ist eine einschränkende Konvertierung Weitere Informationen zu Konvertierungen finden Sie unter <xref:System.Convert> .  
  
-   Ein nicht System interner (benutzerdefinierter) Werttyp ist nur mit sich selbst kompatibel.  
  
-   Enumerationen weisen eine implizite Konvertierung in <xref:System.Enum> und in ihren zugrunde liegenden Typ auf.  
  
 Wenn jedes Element in `sourceArray` einen Typumwandlung erfordert (z. b. von einer Basisklasse zu einer abgeleiteten Klasse oder von einer Schnittstelle zu einem Objekt) und mindestens ein Element nicht in den entsprechenden Typ in umgewandelt werden kann `destinationArray` , wird eine ausgelöst <xref:System.InvalidCastException> .  
  
 Wenn diese Methode eine Ausnahme beim Kopieren auslöst, ist der Zustand von nicht `destinationArray` definiert.  
  
 Diese Methode ist ein O ( `n` )-Vorgang, bei dem gleich `n` ist `length` .  
 
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="destinationArray" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> und <paramref name="destinationArray" /> sind von unterschiedlichem Rang.</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> und <paramref name="destinationArray" /> weisen inkompatible Typen auf.</exception>
        <exception cref="T:System.InvalidCastException">Mindestens ein Element in <paramref name="sourceArray" /> kann nicht in den <paramref name="destinationArray" />-Typ umgewandelt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für das <paramref name="sourceArray" />.  
  
Oder 
 <paramref name="destinationIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für das <paramref name="destinationArray" />.  
  
Oder 
 <paramref name="length" /> ist kleiner als 0 oder größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> ist größer als die Anzahl der Elemente vom <paramref name="sourceIndex" /> bis zum Ende des <paramref name="sourceArray" />s.  
  
Oder 
 <paramref name="length" /> ist größer als die Anzahl der Elemente vom <paramref name="destinationIndex" /> bis zum Ende des <paramref name="destinationArray" />s.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiert alle Elemente des aktuellen eindimensionalen Arrays in das angegebene eindimensionale Array.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As Array, index As Integer)" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="array.CopyTo (array, index)" />
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array, int index);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub CopyTo (array As Array, index As Integer)" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale Array, das das Ziel der aus dem aktuellen Array kopierten Elemente ist.</param>
        <param name="index">Eine 32-Bit-Ganzzahl, die den Index im <paramref name="array" /> angibt, ab dem kopiert werden soll.</param>
        <summary>Kopiert alle Elemente des aktuellen eindimensionalen Arrays in das angegebene eindimensionale Array, beginnend am angegebenen Index des Zielarrays. Der Index wird als 32-Bit-Ganzzahl angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kopiert alle Elemente der aktuellen Array Instanz in das `array` Zielarray, beginnend bei Index `index` . Das `array` Zielarray muss bereits dimensioniert sein und muss über eine ausreichende Anzahl von Elementen verfügen, um die kopierten Elemente aufnehmen zu können. Andernfalls löst die Methode eine Ausnahme aus.  
  
 Diese Methode unterstützt die <xref:System.Collections.ICollection?displayProperty=nameWithType> Schnittstelle. Wenn <xref:System.Collections.ICollection?displayProperty=nameWithType> die Implementierung nicht explizit erforderlich ist, verwenden <xref:System.Array.Copy%2A> Sie, um eine zusätzliche Dereferenzierung zu vermeiden.  
  
 Wenn diese Methode eine Ausnahme beim Kopieren auslöst, ist der Zustand von nicht `array` definiert.  
  
 Diese Methode ist ein O ( `n` )-Vorgang, bei dem gleich `n` ist <xref:System.Array.Length%2A> . Sie führt nur eine flache Kopie aus.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie ein <xref:System.Array> in ein anderes kopiert wird <xref:System.Array> .  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein <xref:System.Array> mit einer unteren Grenze ungleich 0 (null) in ein anderes kopiert wird <xref:System.Array> . Beachten Sie, dass die gesamte Quelle <xref:System.Array> kopiert wird, einschließlich leerer Elemente, die vorhandene Elemente im Ziel überschreiben <xref:System.Array> .  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die untere <paramref name="array" />-Grenze.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> ist mehrdimensional.  
  
- oder - 
Die Anzahl der Elemente im Quellarray ist größer als die verfügbare Anzahl der Elemente vom <paramref name="index" /> bis zum Ende des Ziel-<paramref name="array" />s.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">Der Typ der Quell-<see cref="T:System.Array" /> kann nicht automatisch in den Typ des Ziel-<paramref name="array" /> umgewandelt werden.</exception>
        <exception cref="T:System.RankException">Das Quellarray ist mehrdimensional.</exception>
        <exception cref="T:System.InvalidCastException">Mindestens ein Element im Quell-<see cref="T:System.Array" /> kann nicht in den Typ des Ziel-<paramref name="array" />s umgewandelt werden.</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, long index);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Array array, int64 index) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As Array, index As Long)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Array ^ array, long index);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.CopyTo : Array * int64 -&gt; unit" Usage="array.CopyTo (array, index)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array, long index);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int64 index) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub CopyTo (array As Array, index As Long)" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, long index);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int64 -&gt; unit&#xA;override this.CopyTo : Array * int64 -&gt; unit" Usage="array.CopyTo (array, index)" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="index" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale Array, das das Ziel der aus dem aktuellen Array kopierten Elemente ist.</param>
        <param name="index">Eine 64-Bit-Ganzzahl, die den Index im <paramref name="array" /> angibt, ab dem kopiert werden soll.</param>
        <summary>Kopiert alle Elemente des aktuellen eindimensionalen Arrays in das angegebene eindimensionale Array, beginnend am angegebenen Index des Zielarrays. Der Index wird als 64-Bit-Ganzzahl angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kopiert alle Elemente der aktuellen Array Instanz in das `array` Zielarray, beginnend bei Index `index` . Das `array` Zielarray muss bereits dimensioniert sein und muss über eine ausreichende Anzahl von Elementen verfügen, um die kopierten Elemente aufnehmen zu können. Andernfalls löst die Methode eine Ausnahme aus.  
  
 Diese Methode unterstützt die <xref:System.Collections.ICollection?displayProperty=nameWithType> Schnittstelle. Wenn <xref:System.Collections.ICollection?displayProperty=nameWithType> die Implementierung nicht explizit erforderlich ist, verwenden <xref:System.Array.Copy%2A> Sie, um eine zusätzliche Dereferenzierung zu vermeiden.  
  
 Wenn diese Methode eine Ausnahme beim Kopieren auslöst, ist der Zustand von nicht `array` definiert.  
  
 Diese Methode ist ein O ( `n` )-Vorgang, bei dem gleich `n` ist <xref:System.Array.Length%2A> . Sie führt nur eine flache Kopie aus.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie ein <xref:System.Array> in ein anderes kopiert wird <xref:System.Array> .  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein <xref:System.Array> mit einer unteren Grenze ungleich 0 (null) in ein anderes kopiert wird <xref:System.Array> . Beachten Sie, dass die gesamte Quelle <xref:System.Array> kopiert wird, einschließlich leerer Elemente, die vorhandene Elemente im Ziel überschreiben <xref:System.Array> .  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> ist mehrdimensional.  
  
- oder - 
Die Anzahl der Elemente im Quellarray ist größer als die verfügbare Anzahl der Elemente vom <paramref name="index" /> bis zum Ende des Ziel-<paramref name="array" />s.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">Der Typ der Quell-<see cref="T:System.Array" /> kann nicht automatisch in den Typ des Ziel-<paramref name="array" /> umgewandelt werden.</exception>
        <exception cref="T:System.RankException">Das Quell-<see cref="T:System.Array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.InvalidCastException">Mindestens ein Element im Quell-<see cref="T:System.Array" /> kann nicht in den Typ des Ziel-<paramref name="array" />s umgewandelt werden.</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Array" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="elementType">Der <see cref="T:System.Type" /> des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="length">Die Größe des zu erstellenden <see cref="T:System.Array" />.</param>
        <summary>Erstellt ein eindimensionales <see cref="T:System.Array" /> der angegebenen Länge und vom angegebenen <see cref="T:System.Type" /> mit nullbasierter Indizierung.</summary>
        <returns>Ein neues eindimensionales <see cref="T:System.Array" /> der angegebenen Länge und vom angegebenen <see cref="T:System.Type" /> mit nullbasierter Indizierung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu den meisten Klassen <xref:System.Array> stellt die- <xref:System.Array.CreateInstance%2A> Methode anstelle von öffentlichen Konstruktoren bereit, um den spät gebundenen Zugriff zu ermöglichen.  
  
 Verweistyp Elemente werden mit initialisiert `null` . Werttyp Elemente werden mit 0 (null) initialisiert.  
  
 Diese Methode ist ein O ( `n` )-Vorgang, bei dem gleich `n` ist `length` .  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie ein eindimensionales erstellt und initialisiert wird <xref:System.Array> .  
  
 [!code-cpp[Classic Array.CreateInstance Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> ist kein gültiger <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" /> wird nicht unterstützt. Beispielsweise wird <see cref="T:System.Void" /> nicht unterstützt.  
  
Oder 
 <paramref name="elementType" /> ist ein offener generischer Typ.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params int[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;int&gt; ^ lengths);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">Der <see cref="T:System.Type" /> des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="lengths">Ein Array von 32-Bit-Ganzzahlen, das die Größe der einzelnen Dimensionen des zu erstellenden <see cref="T:System.Array" /> darstellt.</param>
        <summary>Erstellt ein mehrdimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung. Die Längen der Dimension werden in einem Array von 32-Bit-Ganzzahlen angegeben.</summary>
        <returns>Ein neues mehrdimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu den meisten Klassen <xref:System.Array> stellt die- <xref:System.Array.CreateInstance%2A> Methode anstelle von öffentlichen Konstruktoren bereit, um den spät gebundenen Zugriff zu ermöglichen.  
  
 Die Anzahl der Elemente im `lengths` Array muss der Anzahl der Dimensionen in der neuen entsprechen <xref:System.Array> . Jedes Element des `lengths` Arrays muss die Länge der entsprechenden Dimension in der neuen angeben <xref:System.Array> .  
  
 Verweistyp Elemente werden mit initialisiert `null` . Werttyp Elemente werden mit 0 (null) initialisiert.  
  
 Bei dieser Methode handelt es sich um einen O ( `n` )-Vorgang, bei dem `n` das Produkt aller Werte in ist `lengths` .  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie ein mehrdimensionales erstellt und initialisiert wird <xref:System.Array> .  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="lengths" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> ist kein gültiger <see cref="T:System.Type" />.  
  
Oder 
Das <paramref name="lengths" />-Array enthält kein Element.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" /> wird nicht unterstützt. Beispielsweise wird <see cref="T:System.Void" /> nicht unterstützt.  
  
Oder 
 <paramref name="elementType" /> ist ein offener generischer Typ.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Irgendein Wert in <paramref name="lengths" /> ist kleiner als 0 (null).</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params long[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int64[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Long()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;long&gt; ^ lengths);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int64[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="lengths" Type="System.Int64[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">Der <see cref="T:System.Type" /> des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="lengths">Ein Array von 64-Bit-Ganzzahlen, das die Größe der einzelnen Dimensionen des zu erstellenden <see cref="T:System.Array" /> darstellt. Jede Ganzzahl im Array muss zwischen 0 (null) und <see cref="F:System.Int32.MaxValue" /> (einschließlich) liegen.</param>
        <summary>Erstellt ein mehrdimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung. Die Längen der Dimension werden in einem Array von 64-Bit-Ganzzahlen angegeben.</summary>
        <returns>Ein neues mehrdimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu den meisten Klassen <xref:System.Array> stellt die- <xref:System.Array.CreateInstance%2A> Methode anstelle von öffentlichen Konstruktoren bereit, um den spät gebundenen Zugriff zu ermöglichen.  
  
 Die Anzahl der Elemente im `lengths` Array muss der Anzahl der Dimensionen in der neuen entsprechen <xref:System.Array> . Jedes Element des `lengths` Arrays muss die Länge der entsprechenden Dimension in der neuen angeben <xref:System.Array> .  
  
 Verweistyp Elemente werden mit initialisiert `null` . Werttyp Elemente werden mit 0 (null) initialisiert.  
  
 Bei dieser Methode handelt es sich um einen O ( `n` )-Vorgang, bei dem `n` das Produkt aller Werte in ist `lengths` .  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie ein mehrdimensionales erstellt und initialisiert wird <xref:System.Array> .  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="lengths" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> ist kein gültiger <see cref="T:System.Type" />.  
  
Oder 
Das <paramref name="lengths" />-Array enthält kein Element.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" /> wird nicht unterstützt. Beispielsweise wird <see cref="T:System.Void" /> nicht unterstützt.  
  
Oder 
 <paramref name="elementType" /> ist ein offener generischer Typ.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Jeder Wert in <paramref name="lengths" /> ist kleiner als 0 (null) oder größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length1, length2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="length1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="length2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="elementType">Der <see cref="T:System.Type" /> des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="length1">Die Größe der ersten Dimension des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="length2">Die Größe der zweiten Dimension des zu erstellenden <see cref="T:System.Array" />.</param>
        <summary>Erstellt ein zweidimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung.</summary>
        <returns>Ein neues zweidimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu den meisten Klassen <xref:System.Array> stellt die- <xref:System.Array.CreateInstance%2A> Methode anstelle von öffentlichen Konstruktoren bereit, um den spät gebundenen Zugriff zu ermöglichen.  
  
 Verweistyp Elemente werden mit initialisiert `null` . Werttyp Elemente werden mit 0 (null) initialisiert.  
  
 Bei dieser Methode handelt es sich um einen O ( `n` )-Vorgang, bei dem `n` das Produkt von `length1` und ist `length2` .  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie ein zweidimensionales erstellt und initialisiert wird <xref:System.Array> .  
  
 [!code-cpp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> ist kein gültiger <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" /> wird nicht unterstützt. Beispielsweise wird <see cref="T:System.Void" /> nicht unterstützt.  
  
Oder 
 <paramref name="elementType" /> ist ein offener generischer Typ.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length1" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="length2" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int[] lengths, int[] lowerBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths, int32[] lowerBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, lengths As Integer(), lowerBounds As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, cli::array &lt;int&gt; ^ lengths, cli::array &lt;int&gt; ^ lowerBounds);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int[] * int[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths, lowerBounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]" />
        <Parameter Name="lowerBounds" Type="System.Int32[]" />
      </Parameters>
      <Docs>
        <param name="elementType">Der <see cref="T:System.Type" /> des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="lengths">Ein eindimensionales Array mit den Größen aller Dimensionen des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="lowerBounds">Ein eindimensionales Array mit der unteren Grenze (Startindex) für jede Dimension des zu erstellenden <see cref="T:System.Array" />.</param>
        <summary>Erstellt ein mehrdimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und Untergrenze.</summary>
        <returns>Ein neues mehrdimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und Untergrenze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu den meisten Klassen <xref:System.Array> stellt die- <xref:System.Array.CreateInstance%2A> Methode anstelle von öffentlichen Konstruktoren bereit, um den spät gebundenen Zugriff zu ermöglichen.  
  
 Die `lengths` und `lowerBounds` Arrays müssen die gleiche Anzahl von Elementen aufweisen. Die Anzahl der Elemente im `lengths` Array muss der Anzahl der Dimensionen in der neuen entsprechen <xref:System.Array> .  
  
 Jedes Element des `lengths` Arrays muss die Länge der entsprechenden Dimension in der neuen angeben <xref:System.Array> .  
  
 Jedes Element des `lowerBounds` Arrays muss die untere Grenze der entsprechenden Dimension in der neuen angeben <xref:System.Array> . Im Allgemeinen werden in der .NET Framework-Klassenbibliothek und vielen Programmiersprachen keine unteren Grenzen ungleich 0 (null) behandelt.  
  
 Verweistyp Elemente werden mit initialisiert `null` . Werttyp Elemente werden mit 0 (null) initialisiert.  
  
 Bei dieser Methode handelt es sich um einen O ( `n` )-Vorgang, bei dem `n` das Produkt aller Werte in ist `lengths` .  
  
> [!NOTE]
> Nicht alle Sprachen unterstützen Arrays mit unteren Grenzen ungleich 0. Daher können Sie Instanzen von ungleich NULL nicht <xref:System.Array> in den Arraytyp der Sprache umwandeln. Beispielsweise ist es nicht möglich, ein eindimensionales ganzzahliges Array mit der unteren Grenze 6 in den c#- `int[]` Typ umzuwandeln. Dies führt zur <xref:System.InvalidCastException> Laufzeit mit der Meldung "das Objekt vom Typ ' System. Int32 [ \* ] ' kann nicht in den Typ ' System. Int32 [] '." umgewandelt werden, wobei das Sternchen ( \* ) einen auf null basierenden Index bedeutet. Sie können jedoch auf Null basierende Arrays eines beliebigen mit erstellten Rang <xref:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])> in das-Array der Sprache umwandeln. Beispielsweise können Sie ein zweidimensionales NULL basiertes ganzzahliges Array, das mit dieser Methode erstellt wurde, in den c#- `int[,]` Typ umwandeln.

## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein mehrdimensionales <xref:System.Array> mit angegebenen unteren Begrenzungen erstellt und initialisiert wird.  
  
 [!code-cpp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="lengths" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="lowerBounds" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> ist kein gültiger <see cref="T:System.Type" />.  
  
Oder 
Das <paramref name="lengths" />-Array enthält kein Element.  
  
Oder 
Das <paramref name="lengths" />- und das <paramref name="lowerBounds" />-Array enthalten nicht dieselbe Anzahl von Elementen.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" /> wird nicht unterstützt. Beispielsweise wird <see cref="T:System.Void" /> nicht unterstützt.  
  
Oder 
 <paramref name="elementType" /> ist ein offener generischer Typ.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Irgendein Wert in <paramref name="lengths" /> ist kleiner als 0 (null).  
  
Oder 
Irgendein Wert in <paramref name="lowerBounds" /> ist sehr groß, so dass die Summe aus Untergrenze und Länge einer Dimension größer ist als <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2, int32 length3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer, length3 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int * int * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length1, length2, length3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="length1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="length2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="length3" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="elementType">Der <see cref="T:System.Type" /> des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="length1">Die Größe der ersten Dimension des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="length2">Die Größe der zweiten Dimension des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="length3">Die Größe der dritten Dimension des zu erstellenden <see cref="T:System.Array" />.</param>
        <summary>Erstellt ein dreidimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung.</summary>
        <returns>Ein neues dreidimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu den meisten Klassen <xref:System.Array> stellt die- <xref:System.Array.CreateInstance%2A> Methode anstelle von öffentlichen Konstruktoren bereit, um den spät gebundenen Zugriff zu ermöglichen.  
  
 Verweistyp Elemente werden mit initialisiert `null` . Werttyp Elemente werden mit 0 (null) initialisiert.  
  
 Bei dieser Methode handelt es sich um einen O ( `n` )-Vorgang, bei dem `n` das Produkt von `length1` , `length2` und ist `length3` .  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie ein dreidimensionales erstellt und initialisiert wird <xref:System.Array> .  
  
 [!code-cpp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> ist kein gültiger <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" /> wird nicht unterstützt. Beispielsweise wird <see cref="T:System.Void" /> nicht unterstützt.  
  
Oder 
 <paramref name="elementType" /> ist ein offener generischer Typ.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length1" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="length2" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="length3" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Empty&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] Empty&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Empty``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty(Of T) () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ Empty();" />
      <MemberSignature Language="F#" Value="static member Empty : unit -&gt; 'T[]" Usage="System.Array.Empty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <summary>Gibt ein leeres Array zurück.</summary>
        <returns>Ein leeres Array.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool Exists(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member Exists : 'T[] * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Array.Exists (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="match">Das <see cref="T:System.Predicate`1" />, das die Bedingungen für die Elemente definiert, nach denen gesucht werden soll.</param>
        <summary>Bestimmt, ob das angegebene Array Elemente enthält, die mit den vom angegebenen Prädikat definierten Bedingungen übereinstimmen.</summary>
        <returns><see langword="true" />, wenn <paramref name="array" /> mindestens ein Element enthält, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die zurückgibt, `true` Wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente von `array` werden einzeln an das <xref:System.Predicate%601> -Element und die Verarbeitung beendet, wenn eine Entsprechung gefunden wird.  
  
> [!NOTE]
>  In c# und Visual Basic muss der Delegat nicht explizit erstellt werden <xref:System.Predicate%601> . Diese Sprachen ableiten den korrekten Delegaten aus dem Kontext und erstellen ihn automatisch.  
  
 Bei dieser Methode handelt es sich um einen O ( `n` )-Vorgang, wobei `n` der <xref:System.Array.Length%2A> von ist `array` .  
  
   
  
## Examples  
 Das folgende Beispiel gibt die Übereinstimmungs Bedingungen für die- <xref:System.Array.Exists%2A> Methode mithilfe von Lambda-Ausdrücken an, um zu überprüfen, ob ein Planet mit einem bestimmten Buchstaben beginnt oder ob der Planet im angegebenen Array gefunden wird.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists3.cs" interactive="try-dotnet" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists3.vb" id="Snippet3":::
  
 Im folgenden Beispiel wird die- <xref:System.Array.Exists%2A> Methode verwendet, um anzugeben, ob Namen in einem Zeichen folgen Array mit einem angegebenen Zeichen beginnen. Im Beispiel wird ein-Objekt instanziiert, `StringSearcher` indem die Zeichenfolge für die Suche an den zugehörigen Klassenkonstruktor übergeben wird. Die `StringSearcher.StartsWith` Methode hat dieselbe Signatur wie der Delegat <xref:System.Predicate%601> . Wenn die- <xref:System.Array.Exists%2A> Methode aufgerufen wird, wird jedes Element des-Arrays an den-Delegaten weitergeleitet, bis die `true` Elemente im Array zurückgegeben oder durchlaufen werden.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists1.vb" id="Snippet1"::: 
  
 Sie können auch einen Lambda Ausdruck verwenden, anstatt explizit eine Methode zu definieren, deren Signatur der des Delegaten entspricht. Im folgenden Beispiel werden die `StringSearcher` -Klasse und Ihre- `StartsWith` Methode durch einen Lambda-Ausdruck ersetzt.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists2.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists2.vb" id="Snippet2":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
        <related type="Article" href="/dotnet/csharp/programming-guide/statements-expressions-operators/lambda-expressions">Lambda-Ausdrücke (C#-Programmierhandbuch)</related>
        <related type="Article" href="/dotnet/visual-basic/programming-guide/language-features/procedures/lambda-expressions">Lambdaausdrücke (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member Fill : 'T[] * 'T -&gt; unit" Usage="System.Array.Fill (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente im Array.</typeparam>
        <param name="array">Das Array, das ausgefüllt werden soll.</param>
        <param name="value">Der Wert, der jedem Arrayelement zugewiesen werden soll.</param>
        <summary>Weist jedem Element des angegebenen <paramref name="array" /> den angegebenen <paramref name="value" /> vom Typ <typeparamref name="T" /> zu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T, startIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Fill : 'T[] * 'T * int * int -&gt; unit" Usage="System.Array.Fill (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das <see cref="T:System.Array" />, das ausgefüllt werden soll.</param>
        <param name="value">Der neue Wert für die Elemente im angegebenen Bereich.</param>
        <param name="startIndex">Ein 32-Bit-Integerwert, der den Index im <see cref="T:System.Array" /> angibt, ab dem die Füllung beginnt.</param>
        <param name="count">Die Anzahl der zu kopierenden Elemente.</param>
        <summary>Weist den angegebenen <paramref name="value" /> des Typs <typeparamref name="T" /> den Elementen des angegebenen <paramref name="array" /> zu, die innerhalb des Bereichs von <paramref name="startIndex" /> (inklusiv) und der nächsten <paramref name="count" />-Anzahl von Indizes liegen.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Find&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Find&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Find&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Find(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T Find(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member Find : 'T[] * Predicate&lt;'T&gt; -&gt; 'T" Usage="System.Array.Find (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte Array.</param>
        <param name="match">Das Prädikat, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt das erste Vorkommen im gesamten <see cref="T:System.Array" /> zurück.</summary>
        <returns>Das erste Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, sofern vorhanden, andernfalls der Standardwert für den Typ <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode oder ein Lambda-Ausdruck, der zurückgibt, `true` Wenn das an ihn übergebenen Objekt mit den im Delegaten oder Lambda-Ausdruck definierten Bedingungen übereinstimmt.  Die Elemente von `array` werden einzeln an das <xref:System.Predicate%601> -Element, beginnend mit dem ersten Element und mit dem letzten-Element, an das-Element übermittelt.  Die Verarbeitung wird beendet, wenn eine Entsprechung gefunden wird.  
  
 Bei dieser Methode handelt es sich um einen O ( `n` )-Vorgang, wobei `n` der <xref:System.Array.Length%2A> von ist `array` .  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein-Delegat <xref:System.Predicate%601> mit der <xref:System.Array.Find%2A> generischen-Methode zum Durchsuchen eines Arrays von- <xref:System.Drawing.Point> Strukturen verwendet. Die Methode, die der Delegat darstellt, `ProductGT10` gibt zurück, `true` Wenn das Produkt der X-und Y-Felder größer als 100.000 ist. Die- <xref:System.Array.Find%2A> Methode ruft den-Delegaten für jedes Element des Arrays auf und gibt den ersten Punkt zurück, der die Test Bedingung erfüllt.  
  
> [!NOTE]
>  Visual Basic-und c#-Benutzer müssen den Delegaten nicht explizit erstellen oder das Typargument der generischen Methode angeben. Die Compiler bestimmen die erforderlichen Typen aus den Methoden Argumenten, die Sie angeben.  
  
 [!code-csharp[System.Array.Find#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/source.cs#1)]
 [!code-vb[System.Array.Find#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/source.vb#1)]  
  
 Anstatt eine Methode explizit mit der erforderlichen Signatur zu definieren, einen Delegaten zu instanziieren <xref:System.Predicate%601> und den Delegaten an die Methode zu übergeben <xref:System.Array.Find%2A> , ist es üblich, einen Lambda-Ausdruck zu verwenden. Das folgende Beispiel ist mit dem vorherigen identisch, mit der Ausnahme, dass ein Lambda-Ausdruck als `match` Argument verwendet wird.  
  
 [!code-csharp[System.Array.Find#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/lambda.cs#2)]
 [!code-vb[System.Array.Find#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/lambda.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] FindAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] FindAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindAll(Of T) (array As T(), match As Predicate(Of T)) As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ FindAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindAll : 'T[] * Predicate&lt;'T&gt; -&gt; 'T[]" Usage="System.Array.FindAll (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="match">Das <see cref="T:System.Predicate`1" />, das die Bedingungen für die Elemente definiert, nach denen gesucht werden soll.</param>
        <summary>Ruft alle Elemente ab, die die vom angegebenen Prädikat definierten Bedingungen erfüllen.</summary>
        <returns>Ein <see cref="T:System.Array" /> mit allen Elementen, die ggf. die durch das angegebene Prädikat definierten Bedingungen erfüllen, andernfalls ein leeres <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die zurückgibt, `true` Wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente von `array` werden einzeln an die <xref:System.Predicate%601> -Elemente, und die Elemente, die den Bedingungen entsprechen, werden im zurückgegebenen Array gespeichert.  
  
 Bei dieser Methode handelt es sich um einen O ( `n` )-Vorgang, wobei `n` der <xref:System.Array.Length%2A> von ist `array` .  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Array von 50 Zufallszahlen mit Werten erstellt, die zwischen 0 und 1.000 liegen können. Anschließend wird die- <xref:System.Array.FindAll%2A> Methode mit einem Lambda-Ausdruck aufgerufen, der die Werte zurückgibt, die zwischen 300 und 600 liegen. Beachten Sie, dass dem Lambda-Ausdruck ein Parameter mit dem Namen übergeben wird `x` .  Dies stellt den einzelnen Array Member dar, der an das-Element übermittelt wird <xref:System.Predicate%601> . Beachten Sie auch, dass die lokalen `lBound` `uBound` Variablen und innerhalb des Lambda-Ausdrucks zugänglich sind.  
  
 [!code-csharp[System.Array.FindAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.findall/cs/findall.cs#1)]
 [!code-vb[System.Array.FindAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.findall/vb/findall.vb#1)]  
  
 Im folgenden Codebeispiel werden die <xref:System.Array.Find%2A> <xref:System.Array.FindLast%2A> <xref:System.Array.FindAll%2A> generischen Methoden, und veranschaulicht. Ein Array von Zeichen folgen wird erstellt, das acht Dinosaurier Namen enthält, von denen zwei (an den Positionen 1 und 5) mit "saurus" enden. Das Codebeispiel definiert auch eine Such Prädikat Methode `EndsWithSaurus` mit dem Namen, die einen Zeichen folgen Parameter annimmt und einen booleschen Wert zurückgibt, der angibt, ob die Eingabe Zeichenfolge auf "saurus" endet.  
  
 Die <xref:System.Array.Find%2A> generische Methode durchläuft das Array von Anfang an, wobei jedes Element wiederum an die- `EndsWithSaurus` Methode übergeben wird. Die Suche wird beendet, wenn die- `EndsWithSaurus` Methode `true` für das-Element "Amargasaurus" zurückgegeben wird.  
  
> [!NOTE]
>  In c# und Visual Basic muss der Delegat `Predicate<string>` ( `Predicate(Of String)` in Visual Basic) nicht explizit erstellt werden. Diese Sprachen ableiten den korrekten Delegaten aus dem Kontext und erstellen ihn automatisch.  
  
 Die <xref:System.Array.FindLast%2A> generische-Methode wird verwendet, um das Array rückwärts vom Ende zu durchsuchen. Er findet das Element "Dilophosaurus" an Position 5. Die <xref:System.Array.FindAll%2A> generische-Methode wird verwendet, um ein Array mit allen Elementen zurückzugeben, die mit "saurus" enden. Die Elemente werden angezeigt.  
  
 Das Codebeispiel veranschaulicht auch die <xref:System.Array.Exists%2A> <xref:System.Array.TrueForAll%2A> generischen Methoden und.  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sucht nach einem Element, das die durch ein angegebenes Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens in einem <see cref="T:System.Array" /> oder einem Teil davon zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="match">Das <see cref="T:System.Predicate`1" />, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens im gesamten <see cref="T:System.Array" /> zurück.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden; andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Array> wird nach vorne durchsucht, beginnend beim ersten Element und endet beim letzten Element.  
  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die zurückgibt, `true` Wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente von `array` werden einzeln an das-Element übermittelt <xref:System.Predicate%601> .  
  
 Bei dieser Methode handelt es sich um einen O ( `n` )-Vorgang, wobei `n` der <xref:System.Array.Length%2A> von ist `array` .  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden alle drei über Ladungen der <xref:System.Array.FindIndex%2A> generischen-Methode veranschaulicht. Ein Array von Zeichen folgen wird erstellt, das acht Dinosaurier Namen enthält, von denen zwei (an den Positionen 1 und 5) mit "saurus" enden. Das Codebeispiel definiert auch eine Such Prädikat Methode `EndsWithSaurus` mit dem Namen, die einen Zeichen folgen Parameter annimmt und einen booleschen Wert zurückgibt, der angibt, ob die Eingabe Zeichenfolge auf "saurus" endet.  
  
 Die- <xref:System.Array.FindIndex%60%601(%60%600[],System.Predicate{%60%600})> Methoden Überladung durchläuft das Array von Anfang an, wobei jedes Element wiederum an die-Methode übergeben wird `EndsWithSaurus` . Die Suche wird beendet, wenn die- `EndsWithSaurus` Methode `true` für das-Element an Position 1 zurückgibt.  
  
> [!NOTE]
>  In c# und Visual Basic muss der Delegat `Predicate<string>` ( `Predicate(Of String)` in Visual Basic) nicht explizit erstellt werden. Diese Sprachen ableiten den korrekten Delegaten aus dem Kontext und erstellen ihn automatisch.  
  
 Die <xref:System.Array.FindIndex%60%601(%60%600[],System.Int32,System.Predicate{%60%600})> -Methoden Überladung wird verwendet, um das Array beginnend an Position 2 zu durchsuchen und bis zum Ende des Arrays fortzufahren. Es findet das-Element an Position 5. Schließlich wird die- <xref:System.Array.FindIndex%60%601(%60%600[],System.Int32,System.Int32,System.Predicate{%60%600})> Methoden Überladung verwendet, um den Bereich von drei Elementen zu durchsuchen, beginnend an Position 2. Sie gibt-1 zurück, da in diesem Bereich keine Dinosaurier Namen vorhanden sind, die mit "saurus" enden.  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="startIndex">Der nullbasierte Startindex für die Suche.</param>
        <param name="match">Das <see cref="T:System.Predicate`1" />, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Array" /> zurück, der vom angegebenen Index bis zum letzten Element reicht.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden; andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Array> wird nach vorne durchsucht, beginnend bei `startIndex` und endet beim letzten Element.  
  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die zurückgibt, `true` Wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente von `array` werden einzeln an das-Element übermittelt <xref:System.Predicate%601> .  
  
 Bei dieser Methode handelt es sich um einen O ( `n` )-Vorgang, wobei `n` die Anzahl der Elemente von `startIndex` bis zum Ende von ist `array` .  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden alle drei über Ladungen der <xref:System.Array.FindIndex%2A> generischen-Methode veranschaulicht. Ein Array von Zeichen folgen wird erstellt, das acht Dinosaurier Namen enthält, von denen zwei (an den Positionen 1 und 5) mit "saurus" enden. Das Codebeispiel definiert auch eine Such Prädikat Methode `EndsWithSaurus` mit dem Namen, die einen Zeichen folgen Parameter annimmt und einen booleschen Wert zurückgibt, der angibt, ob die Eingabe Zeichenfolge auf "saurus" endet.  
  
 Die- <xref:System.Array.FindIndex%60%601(%60%600[],System.Predicate{%60%600})> Methoden Überladung durchläuft das Array von Anfang an, wobei jedes Element wiederum an die-Methode übergeben wird `EndsWithSaurus` . Die Suche wird beendet, wenn die- `EndsWithSaurus` Methode `true` für das-Element an Position 1 zurückgibt.  
  
> [!NOTE]
>  In c# und Visual Basic muss der Delegat `Predicate<string>` ( `Predicate(Of String)` in Visual Basic) nicht explizit erstellt werden. Diese Sprachen ableiten den korrekten Delegaten aus dem Kontext und erstellen ihn automatisch.  
  
 Die <xref:System.Array.FindIndex%60%601(%60%600[],System.Int32,System.Predicate{%60%600})> -Methoden Überladung wird verwendet, um das Array beginnend an Position 2 zu durchsuchen und bis zum Ende des Arrays fortzufahren. Es findet das-Element an Position 5. Schließlich wird die- <xref:System.Array.FindIndex%60%601(%60%600[],System.Int32,System.Int32,System.Predicate{%60%600})> Methoden Überladung verwendet, um den Bereich von drei Elementen zu durchsuchen, beginnend an Position 2. Sie gibt-1 zurück, da in diesem Bereich keine Dinosaurier Namen vorhanden sind, die mit "saurus" enden.  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="match" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * int * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="startIndex">Der nullbasierte Startindex für die Suche.</param>
        <param name="count">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</param>
        <param name="match">Das <see cref="T:System.Predicate`1" />, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Array" /> zurück, der am angegebenen Index beginnt und die angegebene Anzahl von Elementen umfasst.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden; andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Array> wird nach vorne durchsucht `startIndex` , beginnend bei und endet bei `startIndex` Plus `count` 1, wenn `count` größer als 0 ist.  
  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die zurückgibt, `true` Wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente von `array` werden einzeln an das-Element übermittelt <xref:System.Predicate%601> .  
  
 Diese Methode ist ein O ( `n` )-Vorgang, bei dem gleich `n` ist `count` .  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden alle drei über Ladungen der <xref:System.Array.FindIndex%2A> generischen-Methode veranschaulicht. Ein Array von Zeichen folgen wird erstellt, das acht Dinosaurier Namen enthält, von denen zwei (an den Positionen 1 und 5) mit "saurus" enden. Das Codebeispiel definiert auch eine Such Prädikat Methode `EndsWithSaurus` mit dem Namen, die einen Zeichen folgen Parameter annimmt und einen booleschen Wert zurückgibt, der angibt, ob die Eingabe Zeichenfolge auf "saurus" endet.  
  
 Die- <xref:System.Array.FindIndex%60%601(%60%600[],System.Predicate{%60%600})> Methoden Überladung durchläuft das Array von Anfang an, wobei jedes Element wiederum an die-Methode übergeben wird `EndsWithSaurus` . Die Suche wird beendet, wenn die- `EndsWithSaurus` Methode `true` für das-Element an Position 1 zurückgibt.  
  
> [!NOTE]
>  In c# und Visual Basic muss der Delegat `Predicate<string>` ( `Predicate(Of String)` in Visual Basic) nicht explizit erstellt werden. Diese Sprachen ableiten den korrekten Delegaten aus dem Kontext und erstellen ihn automatisch.  
  
 Die <xref:System.Array.FindIndex%60%601(%60%600[],System.Int32,System.Predicate{%60%600})> -Methoden Überladung wird verwendet, um das Array beginnend an Position 2 zu durchsuchen und bis zum Ende des Arrays fortzufahren. Es findet das-Element an Position 5. Schließlich wird die- <xref:System.Array.FindIndex%60%601(%60%600[],System.Int32,System.Int32,System.Predicate{%60%600})> Methoden Überladung verwendet, um den Bereich von drei Elementen zu durchsuchen, beginnend an Position 2. Sie gibt-1 zurück, da in diesem Bereich keine Dinosaurier Namen vorhanden sind, die mit "saurus" enden.  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="match" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.  
  
Oder 
 <paramref name="count" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="startIndex" /> und <paramref name="count" /> geben keinen gültigen Abschnitt im <paramref name="array" /> an.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T FindLast&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T FindLast&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLast(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T FindLast(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLast : 'T[] * Predicate&lt;'T&gt; -&gt; 'T" Usage="System.Array.FindLast (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="match">Das <see cref="T:System.Predicate`1" />, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt das letzte Vorkommen im gesamten <see cref="T:System.Array" /> zurück.</summary>
        <returns>Das letzte Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, sofern vorhanden, andernfalls der Standardwert für den Typ <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die zurückgibt, `true` Wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente von `array` werden einzeln an das <xref:System.Predicate%601> -Element weitergeleitet. dabei <xref:System.Array> wird mit dem letzten-Element begonnen und mit dem ersten Element beendet.  Die Verarbeitung wird beendet, wenn eine Entsprechung gefunden wird.  
  
 Bei dieser Methode handelt es sich um einen O ( `n` )-Vorgang, wobei `n` der <xref:System.Array.Length%2A> von ist `array` .  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die <xref:System.Array.Find%2A> <xref:System.Array.FindLast%2A> <xref:System.Array.FindAll%2A> generischen Methoden, und veranschaulicht. Ein Array von Zeichen folgen wird erstellt, das acht Dinosaurier Namen enthält, von denen zwei (an den Positionen 1 und 5) mit "saurus" enden. Das Codebeispiel definiert auch eine Such Prädikat Methode `EndsWithSaurus` mit dem Namen, die einen Zeichen folgen Parameter annimmt und einen booleschen Wert zurückgibt, der angibt, ob die Eingabe Zeichenfolge auf "saurus" endet.  
  
 Die <xref:System.Array.Find%2A> generische Methode durchläuft das Array von Anfang an, wobei jedes Element wiederum an die- `EndsWithSaurus` Methode übergeben wird. Die Suche wird beendet, wenn die- `EndsWithSaurus` Methode `true` für das-Element "Amargasaurus" zurückgegeben wird.  
  
> [!NOTE]
>  In c# und Visual Basic muss der Delegat `Predicate<string>` ( `Predicate(Of String)` in Visual Basic) nicht explizit erstellt werden. Diese Sprachen ableiten den korrekten Delegaten aus dem Kontext und erstellen ihn automatisch.  
  
 Die <xref:System.Array.FindLast%2A> generische-Methode wird verwendet, um das Array rückwärts vom Ende zu durchsuchen. Er findet das Element "Dilophosaurus" an Position 5. Die <xref:System.Array.FindAll%2A> generische-Methode wird verwendet, um ein Array mit allen Elementen zurückzugeben, die mit "saurus" enden. Die Elemente werden angezeigt.  
  
 Das Codebeispiel veranschaulicht auch die <xref:System.Array.Exists%2A> <xref:System.Array.TrueForAll%2A> generischen Methoden und.  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sucht nach einem Element, das die durch ein angegebenes Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des letzten Vorkommens in einer <see cref="T:System.Array" /> oder einem Teil davon zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="match">Das <see cref="T:System.Predicate`1" />, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des letzten Vorkommens im gesamten <see cref="T:System.Array" /> zurück.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommnisses eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden, andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Array> wird rückwärts nach dem letzten Element und mit dem ersten Element durchsucht.  
  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die zurückgibt, `true` Wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente von `array` werden einzeln an das-Element übermittelt <xref:System.Predicate%601> .  
  
 Bei dieser Methode handelt es sich um einen O ( `n` )-Vorgang, wobei `n` der <xref:System.Array.Length%2A> von ist `array` .  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden alle drei über Ladungen der <xref:System.Array.FindLastIndex%2A> generischen-Methode veranschaulicht. Ein Array von Zeichen folgen wird erstellt, das acht Dinosaurier Namen enthält, von denen zwei (an den Positionen 1 und 5) mit "saurus" enden. Das Codebeispiel definiert auch eine Such Prädikat Methode `EndsWithSaurus` mit dem Namen, die einen Zeichen folgen Parameter annimmt und einen booleschen Wert zurückgibt, der angibt, ob die Eingabe Zeichenfolge auf "saurus" endet.  
  
 Die- <xref:System.Array.FindLastIndex%60%601(%60%600[],System.Predicate{%60%600})> Methoden Überladung durchläuft das Array rückwärts vom Ende, wobei jedes Element wiederum an die-Methode übergeben wird `EndsWithSaurus` . Die Suche wird beendet, wenn die- `EndsWithSaurus` Methode `true` für das-Element an Position 5 zurückgibt.  
  
> [!NOTE]
>  In c# und Visual Basic muss der Delegat `Predicate<string>` ( `Predicate(Of String)` in Visual Basic) nicht explizit erstellt werden. Diese Sprachen ableiten den korrekten Delegaten aus dem Kontext und erstellen ihn automatisch.  
  
 Die <xref:System.Array.FindLastIndex%60%601(%60%600[],System.Int32,System.Predicate{%60%600})> -Methoden Überladung wird verwendet, um das Array beginnend an Position 4 zu durchsuchen und rückwärts zum Anfang des Arrays zurückzufahren. Er findet das Element an Position 1. Schließlich wird die <xref:System.Array.FindLastIndex%60%601(%60%600[],System.Int32,System.Int32,System.Predicate{%60%600})> -Methoden Überladung verwendet, um den Bereich von drei Elementen zu durchsuchen, beginnend an Position 4 und rückwärts (d. h. Elemente 4, 3 und 2). Sie gibt-1 zurück, da in diesem Bereich keine Dinosaurier Namen vorhanden sind, die mit "saurus" enden.  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="startIndex">Der nullbasierte Startindex für die Rückwärtssuche.</param>
        <param name="match">Das <see cref="T:System.Predicate`1" />, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des letzten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Array" /> zurück, der vom ersten Element bis zum angegeben Index reicht.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommnisses eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden, andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Array> -Element wird nach hinten `startIndex` und am ersten Element durchsucht.  
  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die zurückgibt, `true` Wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente von `array` werden einzeln an das-Element übermittelt <xref:System.Predicate%601> .  
  
 Bei dieser Methode handelt es sich um einen O ( `n` )-Vorgang, wobei `n` die Anzahl von Elementen vom Anfang `array` bis zum ist `startIndex` .  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden alle drei über Ladungen der <xref:System.Array.FindLastIndex%2A> generischen-Methode veranschaulicht. Ein Array von Zeichen folgen wird erstellt, das acht Dinosaurier Namen enthält, von denen zwei (an den Positionen 1 und 5) mit "saurus" enden. Das Codebeispiel definiert auch eine Such Prädikat Methode `EndsWithSaurus` mit dem Namen, die einen Zeichen folgen Parameter annimmt und einen booleschen Wert zurückgibt, der angibt, ob die Eingabe Zeichenfolge auf "saurus" endet.  
  
 Die- <xref:System.Array.FindLastIndex%60%601(%60%600[],System.Predicate{%60%600})> Methoden Überladung durchläuft das Array rückwärts vom Ende, wobei jedes Element wiederum an die-Methode übergeben wird `EndsWithSaurus` . Die Suche wird beendet, wenn die- `EndsWithSaurus` Methode `true` für das-Element an Position 5 zurückgibt.  
  
> [!NOTE]
>  In c# und Visual Basic muss der Delegat `Predicate<string>` ( `Predicate(Of String)` in Visual Basic) nicht explizit erstellt werden. Diese Sprachen ableiten den korrekten Delegaten aus dem Kontext und erstellen ihn automatisch.  
  
 Die <xref:System.Array.FindLastIndex%60%601(%60%600[],System.Int32,System.Predicate{%60%600})> -Methoden Überladung wird verwendet, um das Array beginnend an Position 4 zu durchsuchen und rückwärts zum Anfang des Arrays zurückzufahren. Er findet das Element an Position 1. Schließlich wird die <xref:System.Array.FindLastIndex%60%601(%60%600[],System.Int32,System.Int32,System.Predicate{%60%600})> -Methoden Überladung verwendet, um den Bereich von drei Elementen zu durchsuchen, beginnend an Position 4 und rückwärts (d. h. Elemente 4, 3 und 2). Sie gibt-1 zurück, da in diesem Bereich keine Dinosaurier Namen vorhanden sind, die mit "saurus" enden.  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="match" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * int * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="startIndex">Der nullbasierte Startindex für die Rückwärtssuche.</param>
        <param name="count">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</param>
        <param name="match">Das <see cref="T:System.Predicate`1" />, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Array" /> zurück, der die angegebene Anzahl von Elementen umfasst und am angegebenen Index endet.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommnisses eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden, andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Array> wird nach hinten durchsucht `startIndex` , beginnend bei und endet bei `startIndex` minus `count` plus 1, wenn `count` größer als 0 ist.  
  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die zurückgibt, `true` Wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente von `array` werden einzeln an das-Element übermittelt <xref:System.Predicate%601> .  
  
 Diese Methode ist ein O ( `n` )-Vorgang, bei dem gleich `n` ist `count` .  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden alle drei über Ladungen der <xref:System.Array.FindLastIndex%2A> generischen-Methode veranschaulicht. Ein Array von Zeichen folgen wird erstellt, das acht Dinosaurier Namen enthält, von denen zwei (an den Positionen 1 und 5) mit "saurus" enden. Das Codebeispiel definiert auch eine Such Prädikat Methode `EndsWithSaurus` mit dem Namen, die einen Zeichen folgen Parameter annimmt und einen booleschen Wert zurückgibt, der angibt, ob die Eingabe Zeichenfolge auf "saurus" endet.  
  
 Die- <xref:System.Array.FindLastIndex%60%601(%60%600[],System.Predicate{%60%600})> Methoden Überladung durchläuft das Array rückwärts vom Ende, wobei jedes Element wiederum an die-Methode übergeben wird `EndsWithSaurus` . Die Suche wird beendet, wenn die- `EndsWithSaurus` Methode `true` für das-Element an Position 5 zurückgibt.  
  
> [!NOTE]
>  In c# und Visual Basic muss der Delegat `Predicate<string>` ( `Predicate(Of String)` in Visual Basic) nicht explizit erstellt werden. Diese Sprachen ableiten den korrekten Delegaten aus dem Kontext und erstellen ihn automatisch.  
  
 Die <xref:System.Array.FindLastIndex%60%601(%60%600[],System.Int32,System.Predicate{%60%600})> -Methoden Überladung wird verwendet, um das Array beginnend an Position 4 zu durchsuchen und rückwärts zum Anfang des Arrays zurückzufahren. Er findet das Element an Position 1. Schließlich wird die <xref:System.Array.FindLastIndex%60%601(%60%600[],System.Int32,System.Int32,System.Predicate{%60%600})> -Methoden Überladung verwendet, um den Bereich von drei Elementen zu durchsuchen, beginnend an Position 4 und rückwärts (d. h. Elemente 4, 3 und 2). Sie gibt-1 zurück, da in diesem Bereich keine Dinosaurier Namen vorhanden sind, die mit "saurus" enden.  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="match" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.  
  
Oder 
 <paramref name="count" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="startIndex" /> und <paramref name="count" /> geben keinen gültigen Abschnitt im <paramref name="array" /> an.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ForEach&lt;T&gt; (T[] array, Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ForEach&lt;T&gt;(!!T[] array, class System.Action`1&lt;!!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ForEach``1(``0[],System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ForEach(Of T) (array As T(), action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void ForEach(cli::array &lt;T&gt; ^ array, Action&lt;T&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member ForEach : 'T[] * Action&lt;'T&gt; -&gt; unit" Usage="System.Array.ForEach (array, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="action" Type="System.Action&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das eindimensionale nullbasierte <see cref="T:System.Array" />, für dessen Elemente die Aktion ausgeführt werden soll.</param>
        <param name="action">Die <see cref="T:System.Action`1" />, die für jedes Element von <paramref name="array" /> ausgeführt werden soll.</param>
        <summary>Führt die angegebene Aktion für jedes Element des angegebenen Arrays aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Action%601> ist ein Delegat für eine Methode, die eine Aktion für das an ihn weiter gegebene Objekt ausführt.  Die Elemente von `array` werden einzeln an das-Element übermittelt <xref:System.Action%601> .  
  
 Bei dieser Methode handelt es sich um einen O ( `n` )-Vorgang, wobei `n` der <xref:System.Array.Length%2A> von ist `array` .  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie verwendet wird, <xref:System.Array.ForEach%2A> um die Quadrate der einzelnen Elemente in einem ganzzahligen Array anzuzeigen.  
  
 [!code-cpp[System.Array.ForEach#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.foreach/cpp/source.cpp#1)]
 [!code-csharp[System.Array.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.foreach/cs/source.cs#1)]
 [!code-vb[System.Array.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.foreach/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="action" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="array.GetEnumerator " />
      <MemberSignature Language="C#" Value="public virtual System.Collections.IEnumerator GetEnumerator ();" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator () As IEnumerator" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen <see cref="T:System.Collections.IEnumerator" /> für das <see cref="T:System.Array" /> zurück.</summary>
        <returns>Ein <see cref="T:System.Collections.IEnumerator" /> für das <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 Die- `foreach` Anweisung der c#-Sprache ( `for each` in C++, `For Each` in Visual Basic) verbirgt die Komplexität der Enumeratoren. Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. <xref:System.Collections.IEnumerator.Reset%2A> setzt den Enumerator ebenfalls auf diese Position zurück.  An dieser Position ist <xref:System.Collections.IEnumerator.Current%2A> nicht definiert. Daher muss der Enumerator durch einen Aufruf von <xref:System.Collections.IEnumerator.MoveNext%2A> auf das erste Element der Auflistung gesetzt werden, bevor der Wert von <xref:System.Collections.IEnumerator.Current%2A> gelesen werden kann.  
  
 <xref:System.Collections.IEnumerator.Current%2A> gibt solange dasselbe Objekt zurück, bis <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> aufgerufen wird. <xref:System.Collections.IEnumerator.MoveNext%2A> legt <xref:System.Collections.IEnumerator.Current%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.IEnumerator.MoveNext%2A> das Ende der Auflistung übergibt, wird der Enumerator hinter dem letzten Element in der Auflistung platziert, und <xref:System.Collections.IEnumerator.MoveNext%2A> gibt `false` zurück. Wenn sich der Enumerator an dieser Position befindet, geben nachfolgende Aufrufe von <xref:System.Collections.IEnumerator.MoveNext%2A> auch `false` zurück. Wenn der letzte Aufruf <xref:System.Collections.IEnumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.IEnumerator.Current%2A> ist nicht definiert. Um <xref:System.Collections.IEnumerator.Current%2A> wieder auf das erste Element der Auflistung festzulegen, können Sie <xref:System.Collections.IEnumerator.Reset%2A> gefolgt von <xref:System.Collections.IEnumerator.MoveNext%2A> aufrufen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert bleibt. Werden an der Auflistung Änderungen wie z. B. Hinzufügen, Bearbeiten oder Entfernen von Elementen vorgenommen, verliert der Enumerator unwiederbringlich seine Gültigkeit und sein Verhalten ist nicht definiert.  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung. Daher ist die Enumeration einer Auflistung systemintern keine threadsichere Prozedur.  Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie verwendet wird, <xref:System.Array.GetEnumerator%2A> um die Elemente eines Arrays aufzulisten.  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CPP/array_getenumerator.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CS/array_getenumerator.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetEnumerator/VB/array_getenumerator.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLength">
      <MemberSignature Language="C#" Value="public int GetLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLength (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLength(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLength : int -&gt; int" Usage="array.GetLength dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Eine nullbasierte Dimension des <see cref="T:System.Array" />, deren Länge bestimmt werden soll.</param>
        <summary>Ruft eine 32-Bit-Ganzzahl ab, die die Anzahl der Elemente in der angegebenen Dimension des <see cref="T:System.Array" /> angibt.</summary>
        <returns>Eine 32-Bit-Ganzzahl, die die Anzahl der Elemente in der angegebenen Dimension angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Beispiel für <xref:System.Array.GetLength%2A> ist `GetLength(0)` , das die Anzahl der Elemente in der ersten Dimension von zurückgibt <xref:System.Array> .  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie verwendet wird, <xref:System.Array.GetLength%2A> um die Dimensionen von zwei Arrays mit unterschiedlichen Ränge anzuzeigen.  
  
 [!code-cpp[System.Array.GetLength#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getlength/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetLength#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getlength/cs/source.cs#1)]
 [!code-vb[System.Array.GetLength#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getlength/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="dimension" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="dimension" /> ist größer oder gleich <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLongLength">
      <MemberSignature Language="C#" Value="public long GetLongLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLongLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLongLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLongLength (dimension As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long GetLongLength(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLongLength : int -&gt; int64" Usage="array.GetLongLength dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="dimension">Eine nullbasierte Dimension des <see cref="T:System.Array" />, deren Länge bestimmt werden soll.</param>
        <summary>Ruft eine 64-Bit-Ganzzahl ab, die die Anzahl der Elemente in der angegebenen Dimension des <see cref="T:System.Array" /> angibt.</summary>
        <returns>Eine 64-Bit-Ganzzahl, die die Anzahl der Elemente in der angegebenen Dimension angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Beispiel für <xref:System.Array.GetLongLength%2A> ist `GetLongLength(0)` , das die Anzahl der Elemente in der ersten Dimension von zurückgibt <xref:System.Array> .  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="dimension" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="dimension" /> ist größer oder gleich <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLowerBound">
      <MemberSignature Language="C#" Value="public int GetLowerBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLowerBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLowerBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLowerBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLowerBound(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLowerBound : int -&gt; int" Usage="array.GetLowerBound dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Eine nullbasierte Dimension des Arrays, dessen Startindex bestimmt werden soll.</param>
        <summary>Ruft den Index des ersten Elements der angegebenen Dimension im Array ab.</summary>
        <returns>Der Index des ersten Elements der angegebenen Dimension im Array.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetLowerBound(0)`Gibt den Start Index der ersten Dimension des Arrays zurück und `GetLowerBound(Rank - 1)` gibt den Start Index der letzten Dimension des Arrays zurück.  
  
 Die- <xref:System.Array.GetLowerBound%2A> Methode gibt immer einen Wert zurück, der den Index der unteren Grenze des Arrays angibt, auch wenn das Array leer ist.  
  
 Beachten Sie, dass die meisten Arrays in der .NET Framework Null basiert (d. h., die <xref:System.Array.GetLowerBound%2A> Methode gibt 0 (null) für jede Dimension eines Arrays zurück), unterstützt das .NET Framework Arrays, die nicht NULL basiert sind. Solche Arrays können mit der <xref:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])> -Methode erstellt werden und können auch von nicht verwaltetem Code zurückgegeben werden.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Array.GetLowerBound%2A> -Methode und die- <xref:System.Array.GetUpperBound%2A> Methode verwendet, um die Begrenzungen eines eindimensionalen und zweidimensionalen Arrays anzuzeigen und die Werte ihrer Array Elemente anzuzeigen.  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="dimension" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="dimension" /> ist größer oder gleich <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetUpperBound">
      <MemberSignature Language="C#" Value="public int GetUpperBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetUpperBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetUpperBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUpperBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetUpperBound(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetUpperBound : int -&gt; int" Usage="array.GetUpperBound dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Eine nullbasierte Dimension des Arrays, dessen obere Grenze bestimmt werden soll.</param>
        <summary>Ruft den Index des letzten Elements der angegebenen Dimension im Array ab.</summary>
        <returns>Der Index des letzten Elements in der angegebenen Dimension im Array oder -1, wenn die angegebene Dimension leer ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetUpperBound(0)`Gibt den letzten Index in der ersten Dimension des Arrays zurück und `GetUpperBound(Rank - 1)` gibt den letzten Index der letzten Dimension des Arrays zurück.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Array.GetLowerBound%2A> -Methode und die- <xref:System.Array.GetUpperBound%2A> Methode verwendet, um die Begrenzungen eines eindimensionalen und zweidimensionalen Arrays anzuzeigen und die Werte ihrer Array Elemente anzuzeigen.  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="dimension" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="dimension" /> ist größer oder gleich <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den Wert des angegebenen Elements im aktuellen <see cref="T:System.Array" /> ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int -&gt; obj" Usage="array.GetValue index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="index">Eine 32-Bit-Ganzzahl, die die Position des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Ruft den Wert an der angegebenen Position des eindimensionalen <see cref="T:System.Array" /> ab. Der Index wird als 32-Bit-Ganzzahl angegeben.</summary>
        <returns>Der Wert an der angegebenen Position des eindimensionalen <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array.GetLowerBound%2A> -Methode und die- <xref:System.Array.GetUpperBound%2A> Methode können bestimmen, ob der Wert von `index` außerhalb des gültigen Bereichs liegt.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein bestimmter Wert in einem eindimensionalen oder mehrdimensionalen Array festgelegt und erhalten wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> verfügt nicht über genau eine Dimension.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für das aktuelle <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params int[] indices);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Integer()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;int&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int[] -&gt; obj" Usage="array.GetValue indices" />
      <MemberSignature Language="C#" Value="public object? GetValue (params int[] indices);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">Ein eindimensionales Array von 32-Bit-Ganzzahlen, die die Indizes darstellen, die die Position des abzurufenden <see cref="T:System.Array" />-Elements angeben.</param>
        <summary>Ruft den Wert an der angegebenen Position des mehrdimensionalen <see cref="T:System.Array" /> ab. Die Indizes werden als ein Array von 32-Bit-Ganzzahlen angegeben.</summary>
        <returns>Der Wert an der angegebenen Position des mehrdimensionalen <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Anzahl der Elemente in `indices` muss der Anzahl der Dimensionen in der entsprechen <xref:System.Array> . Alle Elemente im `indices` Array müssen kollektiv die Position des gewünschten Elements im mehrdimensionalen angeben <xref:System.Array> .  
  
 Die <xref:System.Array.GetLowerBound%2A> -Methode und die- <xref:System.Array.GetUpperBound%2A> Methode können bestimmen, ob ein Index außerhalb des gültigen Bereichs liegt.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein bestimmter Wert in einem eindimensionalen oder mehrdimensionalen Array festgelegt und erhalten wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl von Dimensionen im aktuellen <see cref="T:System.Array" /> ist nicht mit der Anzahl von Elementen in <paramref name="indices" /> identisch.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Jedes Element in <paramref name="indices" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 -&gt; obj" Usage="array.GetValue index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="index">Eine 64-Bit-Ganzzahl, die die Position des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Ruft den Wert an der angegebenen Position des eindimensionalen <see cref="T:System.Array" /> ab. Der Index wird als 64-Bit-Ganzzahl angegeben.</summary>
        <returns>Der Wert an der angegebenen Position des eindimensionalen <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array.GetLowerBound%2A> -Methode und die- <xref:System.Array.GetUpperBound%2A> Methode können bestimmen, ob der Wert von `index` außerhalb des gültigen Bereichs liegt.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein bestimmter Wert in einem eindimensionalen oder mehrdimensionalen Array festgelegt und erhalten wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> verfügt nicht über genau eine Dimension.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für das aktuelle <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object? GetValue (params long[] indices);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Long()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;long&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64[] -&gt; obj" Usage="array.GetValue indices" />
      <MemberSignature Language="C#" Value="public object GetValue (params long[] indices);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int64[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">Ein eindimensionales Array von 64-Bit-Ganzzahlen, das die Indizes darstellt, die die Position des abzurufenden <see cref="T:System.Array" />-Elements angeben.</param>
        <summary>Ruft den Wert an der angegebenen Position des mehrdimensionalen <see cref="T:System.Array" /> ab. Die Indizes werden als ein Array von 64-Bit-Ganzzahlen angegeben.</summary>
        <returns>Der Wert an der angegebenen Position des mehrdimensionalen <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Anzahl der Elemente in `indices` muss der Anzahl der Dimensionen in der entsprechen <xref:System.Array> . Alle Elemente im `indices` Array müssen kollektiv die Position des gewünschten Elements im mehrdimensionalen angeben <xref:System.Array> .  
  
 Die <xref:System.Array.GetLowerBound%2A> -Methode und die- <xref:System.Array.GetUpperBound%2A> Methode können bestimmen, ob ein Index außerhalb des gültigen Bereichs liegt.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein bestimmter Wert in einem eindimensionalen oder mehrdimensionalen Array festgelegt und erhalten wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl von Dimensionen im aktuellen <see cref="T:System.Array" /> ist nicht mit der Anzahl von Elementen in <paramref name="indices" /> identisch.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Jedes Element in <paramref name="indices" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int * int -&gt; obj" Usage="array.GetValue (index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="index2" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="index1">Eine 32-Bit-Ganzzahl, die den Index für die erste Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index2">Eine 32-Bit-Ganzzahl, die den Index für die zweite Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Ruft den Wert an der angegebenen Position des zweidimensionalen <see cref="T:System.Array" /> ab. Die Indizes werden als 32-Bit-Ganzzahlen angegeben.</summary>
        <returns>Der Wert an der angegebenen Position des zweidimensionalen <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array.GetLowerBound%2A> -Methode und die- <xref:System.Array.GetUpperBound%2A> Methode können bestimmen, ob ein Index außerhalb des gültigen Bereichs liegt.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein bestimmter Wert in einem eindimensionalen oder mehrdimensionalen Array festgelegt und erhalten wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> verfügt nicht über genau zwei Dimensionen.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Entweder <paramref name="index1" /> oder <paramref name="index2" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 * int64 -&gt; obj" Usage="array.GetValue (index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="index2" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="index1">Eine 64-Bit-Ganzzahl, die den Index für die erste Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index2">Eine 64-Bit-Ganzzahl, die den Index für die zweite Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Ruft den Wert an der angegebenen Position des zweidimensionalen <see cref="T:System.Array" /> ab. Die Indizes werden als 64-Bit-Ganzzahlen angegeben.</summary>
        <returns>Der Wert an der angegebenen Position des zweidimensionalen <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array.GetLowerBound%2A> -Methode und die- <xref:System.Array.GetUpperBound%2A> Methode können bestimmen, ob ein Index außerhalb des gültigen Bereichs liegt.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein bestimmter Wert in einem eindimensionalen oder mehrdimensionalen Array festgelegt und erhalten wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> verfügt nicht über genau zwei Dimensionen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Entweder <paramref name="index1" /> oder <paramref name="index2" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer, index3 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2, int index3);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int * int * int -&gt; obj" Usage="array.GetValue (index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="index2" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="index3" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="index1">Eine 32-Bit-Ganzzahl, die den Index für die erste Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index2">Eine 32-Bit-Ganzzahl, die den Index für die zweite Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index3">Eine 32-Bit-Ganzzahl, die den Index für die dritte Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Ruft den Wert an der angegebenen Position des dreidimensionalen <see cref="T:System.Array" /> ab. Die Indizes werden als 32-Bit-Ganzzahlen angegeben.</summary>
        <returns>Der Wert an der angegebenen Position des dreidimensionalen <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array.GetLowerBound%2A> -Methode und die- <xref:System.Array.GetUpperBound%2A> Methode können bestimmen, ob ein Index außerhalb des gültigen Bereichs liegt.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein bestimmter Wert in einem eindimensionalen oder mehrdimensionalen Array festgelegt und erhalten wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> verfügt nicht über genau drei Dimensionen.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Entweder <paramref name="index1" />, <paramref name="index2" /> oder <paramref name="index3" /> liegt außerhalb des Bereichs gültiger Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long, index3 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2, long index3);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 * int64 * int64 -&gt; obj" Usage="array.GetValue (index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="index2" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="index3" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="index1">Eine 64-Bit-Ganzzahl, die den Index für die erste Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index2">Eine 64-Bit-Ganzzahl, die den Index für die zweite Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index3">Eine 64-Bit-Ganzzahl, die den Index für die dritte Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Ruft den Wert an der angegebenen Position des dreidimensionalen <see cref="T:System.Array" /> ab. Die Indizes werden als 64-Bit-Ganzzahlen angegeben.</summary>
        <returns>Der Wert an der angegebenen Position des dreidimensionalen <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array.GetLowerBound%2A> -Methode und die- <xref:System.Array.GetUpperBound%2A> Methode können bestimmen, ob ein Index außerhalb des gültigen Bereichs liegt.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein bestimmter Wert in einem eindimensionalen oder mehrdimensionalen Array festgelegt und erhalten wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> verfügt nicht über genau drei Dimensionen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Entweder <paramref name="index1" />, <paramref name="index2" /> oder <paramref name="index3" /> liegt außerhalb des Bereichs gültiger Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sucht das angegebene Objekt und gibt den Index seines ersten Auftretens in einem eindimensionalen Array oder in einem Elementbereich im Array zurück.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf (array As Array, value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj -&gt; int" Usage="System.Array.IndexOf (array, value)" />
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object? value);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende eindimensionale Array.</param>
        <param name="value">Das in <paramref name="array" /> zu suchende Objekt.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den Index des ersten Vorkommens in einem eindimensionalen Array zurück.</summary>
        <returns>Der Index des ersten Vorkommens von <paramref name="value" /> in <paramref name="array" />, sofern gefunden, andernfalls die untere Grenze des Arrays minus 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode durchsucht alle Elemente eines eindimensionalen Arrays nach `value` . Um zu ermitteln `value` , ob in vorhanden `array` ist, führt die Methode einen Gleichheits Vergleich durch, indem die-Methode jedes Elements aufgerufen wird, `Equals` bis eine Übereinstimmung gefunden wird Dies bedeutet, dass die Überschreibung aufgerufen wird, wenn das Element die-Methode überschreibt <xref:System.Object.Equals(System.Object)?displayProperty=nameWithType> .  
  
 Da die meisten Arrays eine untere Grenze von NULL aufweisen, gibt diese Methode in der Regel-1 zurück, wenn `value` nicht gefunden wird. In dem seltenen Fall, dass die untere Grenze des Arrays gleich <xref:System.Int32.MinValue?displayProperty=nameWithType> (0x80000000) ist und `value` nicht gefunden wird, gibt diese Methode <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF) zurück.  
  
 Bei dieser Methode handelt es sich um einen O ( `n` )-Vorgang, wobei `n` der <xref:System.Array.Length%2A> von ist `array` .  
  
   
  
## Examples  
 Im Beispiel werden die folgenden drei über Ladungen der- <xref:System.Array.IndexOf%2A> Methode aufgerufen, um den Index einer Zeichenfolge in einem Zeichen folgen Array zu finden:  
  
-   <xref:System.Array.IndexOf(System.Array,System.Object)>, um das erste Vorkommen der Zeichenfolge "The" in einem Zeichen folgen Array zu bestimmen.  
  
-   <xref:System.Array.IndexOf(System.Array,System.Object,System.Int32)>, um das erste Vorkommen der Zeichenfolge "The" im vierten bis zu den letzten Elementen eines Zeichen folgen Arrays zu bestimmen.  
  
-   <xref:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)>, um das erste Vorkommen der Zeichenfolge "The" in einem Zeichen folgen Array aus dem-Element zu bestimmen, das der letzten erfolgreichen Entsprechung bis zum Ende des Arrays folgt.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp-interactive[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf (array As Array, value As Object, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex)" />
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object? value, int startIndex);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende eindimensionale Array.</param>
        <param name="value">Das in <paramref name="array" /> zu suchende Objekt.</param>
        <param name="startIndex">Der Startindex für die Suche. 0 (null) ist in einem leeren Array gültig.</param>
        <summary>Sucht das angegebene Objekt in einem Elementbereich eines eindimensionalen Arrays und gibt den Index seines ersten Auftretens zurück. Der Bereich erstreckt sich von einem angegebenen Index bis zum Ende des Arrays.</summary>
        <returns>Der Index des ersten Vorkommens von <paramref name="value" />, sofern gefunden, innerhalb des Bereichs von Elementen in <paramref name="array" />, der sich von <paramref name="startIndex" /> bis zum letzten Element erstreckt; andernfalls die untere Grenze des Arrays minus 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode durchsucht ein eindimensionales Array vom-Element bei Index `startIndex` bis zum letzten Element. Um zu ermitteln `value` , ob in vorhanden `array` ist, führt die Methode einen Gleichheits Vergleich durch, indem die- `Equals` Methode jedes Elements aufgerufen wird, bis eine Übereinstimmung gefunden wird. Dies bedeutet, dass die Überschreibung aufgerufen wird, wenn das Element die-Methode überschreibt <xref:System.Object.Equals(System.Object)?displayProperty=nameWithType> .  
  
 Da die meisten Arrays eine untere Grenze von NULL aufweisen, gibt diese Methode in der Regel-1 zurück, wenn `value` nicht gefunden wird. In dem seltenen Fall, dass die untere Grenze des Arrays gleich <xref:System.Int32.MinValue?displayProperty=nameWithType> (0x80000000) ist und `value` nicht gefunden wird, gibt diese Methode <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF) zurück.  
  
 Wenn `startIndex` <xref:System.Array.Length%2A?displayProperty=nameWithType> ist, gibt die Methode-1 zurück. Wenn `startIndex` größer als ist <xref:System.Array.Length%2A?displayProperty=nameWithType> , löst die Methode eine aus <xref:System.ArgumentOutOfRangeException> .  
  
 Bei dieser Methode handelt es sich um einen O ( `n` )-Vorgang, wobei `n` die Anzahl der Elemente von `startIndex` bis zum Ende von ist `array` .  
  
   
  
## Examples  
 Im Beispiel werden die folgenden drei über Ladungen der- <xref:System.Array.IndexOf%2A> Methode aufgerufen, um den Index einer Zeichenfolge in einem Zeichen folgen Array zu finden:  
  
-   <xref:System.Array.IndexOf(System.Array,System.Object)>, um das erste Vorkommen der Zeichenfolge "The" in einem Zeichen folgen Array zu bestimmen.  
  
-   <xref:System.Array.IndexOf(System.Array,System.Object,System.Int32)>, um das erste Vorkommen der Zeichenfolge "The" im vierten bis zu den letzten Elementen eines Zeichen folgen Arrays zu bestimmen.  
  
-   <xref:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)>, um das erste Vorkommen der Zeichenfolge "The" in einem Zeichen folgen Array aus dem-Element zu bestimmen, das der letzten erfolgreichen Entsprechung bis zum Ende des Arrays folgt.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp-interactive[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex, int count);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf (array As Array, value As Object, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj * int * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex, count)" />
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object? value, int startIndex, int count);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende eindimensionale Array.</param>
        <param name="value">Das in <paramref name="array" /> zu suchende Objekt.</param>
        <param name="startIndex">Der Startindex für die Suche. 0 (null) ist in einem leeren Array gültig.</param>
        <param name="count">Die Anzahl der zu suchenden Elemente.</param>
        <summary>Sucht das angegebene Objekt in einem Bereich von Elementen eines eindimensionalen Arrays und gibt den Index des ersten Vorkommens zurück. Der Bereich erstreckt sich von einem angegebenen Index für eine angegebene Anzahl von Elementen.</summary>
        <returns>Der Index des ersten Vorkommens von <paramref name="value" />, sofern gefunden im <paramref name="array" /> vom <paramref name="startIndex" />-Index bis <paramref name="startIndex" /> + <paramref name="count" /> – 1; andernfalls die untere Grenze des Arrays minus 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode durchsucht die Elemente eines eindimensionalen Arrays von `startIndex` nach `startIndex` Plus `count` minus 1, wenn `count` größer als 0 (null) ist. Um zu ermitteln `value` , ob in vorhanden `array` ist, führt die Methode einen Gleichheits Vergleich durch, indem die- `Equals` Methode jedes Elements aufgerufen wird, bis eine Übereinstimmung gefunden wird. Dies bedeutet, dass die Überschreibung aufgerufen wird, wenn das Element die-Methode überschreibt <xref:System.Object.Equals%2A?displayProperty=nameWithType> .  
  
 Da die meisten Arrays eine untere Grenze von NULL aufweisen, gibt diese Methode in der Regel-1 zurück, wenn `value` nicht gefunden wird. In dem seltenen Fall, dass die untere Grenze des Arrays gleich <xref:System.Int32.MinValue?displayProperty=nameWithType> (0x80000000) ist und `value` nicht gefunden wird, gibt diese Methode <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF) zurück.  
  
 Wenn `startindex` <xref:System.Array.Length%2A?displayProperty=nameWithType> ist, gibt die Methode-1 zurück. Wenn `startIndex` größer als ist <xref:System.Array.Length%2A?displayProperty=nameWithType> , löst die Methode eine aus <xref:System.ArgumentOutOfRangeException> .  
  
 Diese Methode ist ein O ( `n` )-Vorgang, bei dem gleich `n` ist `count` .  
  
   
  
## Examples  
 Im Beispiel werden die folgenden drei über Ladungen der- <xref:System.Array.IndexOf%2A> Methode aufgerufen, um den Index einer Zeichenfolge in einem Zeichen folgen Array zu finden:  
  
-   <xref:System.Array.IndexOf(System.Array,System.Object)>, um das erste Vorkommen der Zeichenfolge "The" in einem Zeichen folgen Array zu bestimmen.  
  
-   <xref:System.Array.IndexOf(System.Array,System.Object,System.Int32)>, um das erste Vorkommen der Zeichenfolge "The" im vierten bis zu den letzten Elementen eines Zeichen folgen Arrays zu bestimmen.  
  
-   <xref:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)>, um das erste Vorkommen der Zeichenfolge "The" in einem Zeichen folgen Array aus dem-Element zu bestimmen, das der letzten erfolgreichen Entsprechung bis zum Ende des Arrays folgt. Um den Wert des Arguments zu ermitteln `count` , subtrahiert er die obere Grenze des Arrays vom Start Index und fügt eine hinzu.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp-interactive[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.  
  
Oder 
 <paramref name="count" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="startIndex" /> und <paramref name="count" /> geben keinen gültigen Abschnitt im <paramref name="array" /> an.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T -&gt; int" Usage="System.Array.IndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte Array.</param>
        <param name="value">Das in <paramref name="array" /> zu suchende Objekt.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den Index des ersten Vorkommens in einem eindimensionalen Array zurück.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens von <paramref name="value" /> im gesamten <paramref name="array" />, sofern gefunden, andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode durchsucht alle Elemente eines eindimensionalen Arrays nach `value` . Um zu ermitteln `value` , ob in vorhanden `array` ist, führt die Methode einen Gleichheits Vergleich durch, indem die- `T.Equals` Methode für jedes Element aufgerufen wird. Dies bedeutet, dass, wenn `T` die-Methode überschreibt <xref:System.Object.Equals%2A> , diese außer Kraft Setzung aufgerufen wird.  
  
 Bei dieser Methode handelt es sich um einen O ( `n` )-Vorgang, wobei `n` der <xref:System.Array.Length%2A> von ist `array` .  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle drei generischen über Ladungen der- <xref:System.Array.IndexOf%2A> Methode veranschaulicht. Ein Array von Zeichen folgen wird erstellt, wobei ein Eintrag zweimal an Indexposition 0 und Index Speicherort 5 angezeigt wird. Die <xref:System.Array.IndexOf%60%601(%60%600[],%60%600)> -Methoden Überladung durchsucht das Array von Anfang an und findet das erste Vorkommen der Zeichenfolge. Die <xref:System.Array.IndexOf%60%601(%60%600[],%60%600,System.Int32)> -Methoden Überladung wird verwendet, um das Array beginnend mit Indexposition 3 zu durchsuchen und bis zum Ende des Arrays zu suchen, und findet das zweite Vorkommen der Zeichenfolge. Schließlich wird die <xref:System.Array.IndexOf%60%601(%60%600[],%60%600,System.Int32,System.Int32)> -Methoden Überladung verwendet, um einen Bereich von zwei Einträgen zu durchsuchen, beginnend bei Indexposition 2; Sie gibt-1 zurück, da es keine Instanzen der Such Zeichenfolge in diesem Bereich gibt.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp-interactive[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte Array.</param>
        <param name="value">Das in <paramref name="array" /> zu suchende Objekt.</param>
        <param name="startIndex">Der nullbasierte Startindex für die Suche. 0 (null) ist in einem leeren Array gültig.</param>
        <summary>Sucht das angegebene Objekt in einem Bereich von Elementen eines eindimensionalen Arrays und gibt den Index des ersten Vorkommens zurück. Der Bereich erstreckt sich von einem angegebenen Index bis zum Ende des Arrays.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens von <paramref name="value" /> innerhalb des Bereichs von Elementen in <paramref name="array" />, der sich von <paramref name="startIndex" /> bis zum letzten Element erstreckt, sofern gefunden, andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode durchsucht ein eindimensionales Array vom-Element an `startIndex` bis zum Ende des-Arrays. Um zu ermitteln `value` , ob in vorhanden `array` ist, führt die Methode einen Gleichheits Vergleich durch, indem die- `T.Equals` Methode für jedes Element aufgerufen wird. Dies bedeutet, dass, wenn `T` die-Methode überschreibt <xref:System.Object.Equals%2A> , diese außer Kraft Setzung aufgerufen wird.  
  
 Wenn `startIndex` <xref:System.Array.Length%2A> ist, gibt die Methode-1 zurück. Wenn `startIndex` größer als ist <xref:System.Array.Length%2A?displayProperty=nameWithType> , löst die Methode eine aus <xref:System.ArgumentOutOfRangeException> .  
  
 Bei dieser Methode handelt es sich um einen O ( `n` )-Vorgang, wobei `n` die Anzahl der Elemente von `startIndex` bis zum Ende von ist `array` .  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle drei generischen über Ladungen der- <xref:System.Array.IndexOf%2A> Methode veranschaulicht. Ein Array von Zeichen folgen wird erstellt, wobei ein Eintrag zweimal an Indexposition 0 und Index Speicherort 5 angezeigt wird. Die <xref:System.Array.IndexOf%60%601(%60%600[],%60%600)> -Methoden Überladung durchsucht das Array von Anfang an und findet das erste Vorkommen der Zeichenfolge. Die <xref:System.Array.IndexOf%60%601(%60%600[],%60%600,System.Int32)> -Methoden Überladung wird verwendet, um das Array beginnend mit Indexposition 3 zu durchsuchen und bis zum Ende des Arrays zu suchen, und findet das zweite Vorkommen der Zeichenfolge. Schließlich wird die <xref:System.Array.IndexOf%60%601(%60%600[],%60%600,System.Int32,System.Int32)> -Methoden Überladung verwendet, um einen Bereich von zwei Einträgen zu durchsuchen, beginnend bei Indexposition 2; Sie gibt-1 zurück, da es keine Instanzen der Such Zeichenfolge in diesem Bereich gibt.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp-interactive[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T * int * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte Array.</param>
        <param name="value">Das in <paramref name="array" /> zu suchende Objekt.</param>
        <param name="startIndex">Der nullbasierte Startindex für die Suche. 0 (null) ist in einem leeren Array gültig.</param>
        <param name="count">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</param>
        <summary>Sucht das angegebene Objekt in einem Elementbereich eines eindimensionalen Arrays und gibt den Index seines ersten Auftretens zurück. Der Bereich erstreckt sich von einem angegebenen Index für eine angegebene Anzahl von Elementen.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens von <paramref name="value" /> innerhalb des Bereichs von Elementen im <paramref name="array" />, das beim <paramref name="startIndex" /> beginnt und die in <paramref name="count" /> angegebene Anzahl von Elementen enthält, sofern gefunden; andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode durchsucht die Elemente eines eindimensionalen Arrays von `startIndex` nach `startIndex` Plus `count` minus 1, wenn `count` größer als 0 (null) ist. Um zu ermitteln `value` , ob in vorhanden `array` ist, führt die Methode einen Gleichheits Vergleich durch, indem die- `T.Equals` Methode für jedes Element aufgerufen wird. Dies bedeutet, dass, wenn `T` die-Methode überschreibt <xref:System.Object.Equals%2A> , diese außer Kraft Setzung aufgerufen wird.  
  
 Wenn `startIndex` <xref:System.Array.Length%2A?displayProperty=nameWithType> ist, gibt die Methode-1 zurück.  Wenn `startIndex` größer als ist <xref:System.Array.Length%2A?displayProperty=nameWithType> , löst die Methode eine aus <xref:System.ArgumentOutOfRangeException> .  
  
 Diese Methode ist ein O ( `n` )-Vorgang, bei dem gleich `n` ist `count` .  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle drei generischen über Ladungen der- <xref:System.Array.IndexOf%2A> Methode veranschaulicht. Ein Array von Zeichen folgen wird erstellt, wobei ein Eintrag zweimal an Indexposition 0 und Index Speicherort 5 angezeigt wird. Die <xref:System.Array.IndexOf%60%601(%60%600[],%60%600)> -Methoden Überladung durchsucht das Array von Anfang an und findet das erste Vorkommen der Zeichenfolge. Die <xref:System.Array.IndexOf%60%601(%60%600[],%60%600,System.Int32)> -Methoden Überladung wird verwendet, um das Array beginnend mit Indexposition 3 zu durchsuchen und bis zum Ende des Arrays zu suchen, und findet das zweite Vorkommen der Zeichenfolge. Schließlich wird die <xref:System.Array.IndexOf%60%601(%60%600[],%60%600,System.Int32,System.Int32)> -Methoden Überladung verwendet, um einen Bereich von zwei Einträgen zu durchsuchen, beginnend bei Indexposition 2; Sie gibt-1 zurück, da es keine Instanzen der Such Zeichenfolge in diesem Bereich gibt.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp-interactive[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.  
  
Oder 
 <paramref name="count" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="startIndex" /> und <paramref name="count" /> geben keinen gültigen Abschnitt im <paramref name="array" /> an.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public void Initialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Initialize" />
      <MemberSignature Language="VB.NET" Value="Public Sub Initialize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Initialize();" />
      <MemberSignature Language="F#" Value="member this.Initialize : unit -&gt; unit" Usage="array.Initialize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initialisiert jedes Element des Werttyp-<see cref="T:System.Array" /> durch einen Aufruf des parameterlosen Konstruktors für den Werttyp.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist so konzipiert, dass Compiler Werttyp Arrays unterstützen. die meisten Benutzer benötigen diese Methode nicht. Er darf nicht für Verweistyp Arrays verwendet werden.  
  
 Wenn der <xref:System.Array> kein Werttyp ist <xref:System.Array> oder der Werttyp keinen Parameter losen Konstruktor hat, <xref:System.Array> wird nicht geändert.  
  
 Der Werttyp <xref:System.Array> kann eine beliebige Untergrenze und eine beliebige Anzahl von Dimensionen aufweisen.  
  
 Diese Methode ist ein O ( `n` )-Vorgang, bei dem gleich `n` ist <xref:System.Array.Length%2A> .  
  
> [!CAUTION]
>  Diese Methode kann nur für Werttypen verwendet werden, die über Konstruktoren verfügen. Werttypen, die nativ in c# sind, verfügen jedoch über keine Konstruktoren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFixedSize As Boolean" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFixedSize { bool get(); };" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Array.IsFixedSize" />
      <MemberSignature Language="C#" Value="public virtual bool IsFixedSize { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsFixedSize As Boolean" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsFixedSize { bool get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Array" /> eine feste Größe aufweist.</summary>
        <value>Diese Eigenschaft ist für alle Arrays immer <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>implementiert die- <xref:System.Array.IsFixedSize%2A> Eigenschaft, da Sie für die- <xref:System.Collections.IList?displayProperty=nameWithType> Schnittstelle erforderlich ist.  
  
 Bei einem Array mit fester Größe ist es nicht zulässig, Elemente hinzuzufügen oder zu entfernen, nachdem das Array erstellt wurde, aber es ermöglicht die Änderung vorhandener Elemente.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Array.IsReadOnly" />
      <MemberSignature Language="C#" Value="public virtual bool IsReadOnly { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsReadOnly As Boolean" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Array" /> schreibgeschützt ist.</summary>
        <value>Diese Eigenschaft ist für alle Arrays immer <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>implementiert die- <xref:System.Array.IsReadOnly%2A> Eigenschaft, da Sie für die- <xref:System.Collections.IList?displayProperty=nameWithType> Schnittstelle erforderlich ist. Ein Array, das schreibgeschützt ist, lässt das Hinzufügen, entfernen oder Ändern von Elementen nach der Erstellung des Arrays nicht zu.  
  
 Wenn Sie eine schreibgeschützte Auflistung benötigen, verwenden Sie eine <xref:System.Collections> Klasse, die die- <xref:System.Collections.IList?displayProperty=nameWithType> Schnittstelle implementiert.  
  
 Wenn Sie ein Array in ein Schnittstellen Objekt umwandeln oder konvertieren <xref:System.Collections.IList> , gibt die- <xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType> Eigenschaft zurück `false` . Wenn Sie jedoch ein Array in eine-Schnittstelle umwandeln oder konvertieren <xref:System.Collections.Generic.IList%601> , `IsReadOnly` gibt die-Eigenschaft zurück `true` .  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="N:System.Collections" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
        <altmember cref="N:System.Collections.Generic" />
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Array.IsSynchronized" />
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSynchronized As Boolean" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSynchronized { bool get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Zugriff auf die <see cref="T:System.Array" /> synchronisiert (threadsicher) ist.</summary>
        <value>Diese Eigenschaft ist für alle Arrays immer <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>implementiert die- <xref:System.Array.IsSynchronized%2A> Eigenschaft, da Sie für die- <xref:System.Collections.ICollection?displayProperty=nameWithType> Schnittstelle erforderlich ist.  
  
 .NET Framework-Klassen basierend auf <xref:System.Array> Geben Sie ihre eigene synchronisierte Version der Auflistung mithilfe der <xref:System.Array.SyncRoot%2A> Eigenschaft.  
  
 Klassen, die Arrays verwenden, können auch Ihre eigene Synchronisierung mithilfe der- <xref:System.Array.SyncRoot%2A> Eigenschaft implementieren. Der Synchronisierungs Code muss Vorgänge für die der Auflistung ausführen `SyncRoot` , nicht direkt für die Auflistung. Dies gewährleistet die einwandfreie Funktion von Auflistungen, die von anderen Objekten abgeleitet sind. Insbesondere wird die ordnungsgemäße Synchronisierung mit anderen Threads verwaltet, die die Auflistung möglicherweise gleichzeitig ändern. Beachten Sie, dass einige Implementierungen von <xref:System.Array.SyncRoot%2A> möglicherweise die selbst zurückgeben <xref:System.Array> .  
  
 Das Auflisten durch eine Auflistung ist intrinsisch keine Thread sichere Prozedur. Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst. Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie ein Array während der gesamten Enumeration mithilfe der- <xref:System.Array.SyncRoot%2A> Eigenschaft gesperrt wird.  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.SyncRoot" />
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt den Index des letzten Vorkommens eines Werts in einem eindimensionalen <see cref="T:System.Array" /> oder in einem Teil des <see cref="T:System.Array" /> zurück.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf (array As Array, value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj -&gt; int" Usage="System.Array.LastIndexOf (array, value)" />
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object? value);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende eindimensionale <see cref="T:System.Array" />.</param>
        <param name="value">Das in <paramref name="array" /> zu suchende Objekt.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den Index des letzten Vorkommens innerhalb des gesamten eindimensionalen <see cref="T:System.Array" /> zurück.</summary>
        <returns>Der Index des letzten Vorkommens von <paramref name="value" /> im gesamten <paramref name="array" />, sofern gefunden, andernfalls die untere Grenze des Arrays minus 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das eindimensionale <xref:System.Array> wird rückwärts durchsucht, beginnend beim letzten Element und endet beim ersten Element.  
  
 Die Elemente werden mit dem angegebenen Wert mithilfe der- <xref:System.Object.Equals%2A?displayProperty=nameWithType> Methode verglichen. Wenn es sich bei dem Elementtyp um einen nicht intrinsischen (benutzerdefinierten) Typ handelt, `Equals` wird die Implementierung dieses Typs verwendet.  
  
 Da die meisten Arrays eine untere Grenze von 0 (null) aufweisen, gibt diese Methode in der Regel-1 zurück, wenn `value` nicht gefunden wird. In dem seltenen Fall, dass die untere Grenze des Arrays gleich <xref:System.Int32.MinValue?displayProperty=nameWithType> und `value` nicht gefunden wird, gibt diese Methode zurück <xref:System.Int32.MaxValue?displayProperty=nameWithType> , d. h `System.Int32.MinValue - 1` ..  
  
 Bei dieser Methode handelt es sich um einen O ( `n` )-Vorgang, wobei `n` der <xref:System.Array.Length%2A> von ist `array` .  
  
 In der .NET Framework Version 2,0 verwendet diese Methode die <xref:System.Object.Equals%2A> -Methode und die-Methode <xref:System.IComparable.CompareTo%2A> von <xref:System.Array> , um zu bestimmen, ob das <xref:System.Object> durch den- `value` Parameter angegebene vorhanden ist. In früheren Versionen der .NET Framework wurde diese Bestimmung durch die Verwendung der <xref:System.Object.Equals%2A> -Methode und der- <xref:System.IComparable.CompareTo%2A> Methode der `value` <xref:System.Object> selbst gemacht.  
  
 <xref:System.IComparable.CompareTo%2A>Methoden des- `item` Parameters für die-Objekte in der Auflistung.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie der Index des letzten Vorkommens eines angegebenen Elements in einem Array bestimmt wird.  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp-interactive[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf (array As Array, value As Object, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex)" />
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object? value, int startIndex);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende eindimensionale <see cref="T:System.Array" />.</param>
        <param name="value">Das in <paramref name="array" /> zu suchende Objekt.</param>
        <param name="startIndex">Der Startindex für die Rückwärtssuche.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den Index des letzten Vorkommens innerhalb des Bereichs von Elementen im eindimensionalen <see cref="T:System.Array" /> zurück, das sich vom ersten Element bis zum angegebenen Index erstreckt.</summary>
        <returns>Der Index des letzten Vorkommens von <paramref name="value" /> innerhalb des Bereichs von Elementen im <paramref name="array" />, das sich vom ersten Element bis zum <paramref name="startIndex" /> erstreckt, sofern gefunden, andernfalls die untere Grenze des Arrays minus 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das eindimensionale <xref:System.Array> wird rückwärts durchsucht, beginnend bei `startIndex` und endet beim ersten Element.  
  
 Die Elemente werden mit dem angegebenen Wert mithilfe der- <xref:System.Object.Equals%2A?displayProperty=nameWithType> Methode verglichen. Wenn es sich bei dem Elementtyp um einen nicht intrinsischen (benutzerdefinierten) Typ handelt, `Equals` wird die Implementierung dieses Typs verwendet.  
  
 Da die meisten Arrays eine untere Grenze von 0 (null) aufweisen, gibt diese Methode in der Regel-1 zurück, wenn `value` nicht gefunden wird. In dem seltenen Fall, dass die untere Grenze des Arrays gleich <xref:System.Int32.MinValue?displayProperty=nameWithType> und `value` nicht gefunden wird, gibt diese Methode zurück <xref:System.Int32.MaxValue?displayProperty=nameWithType> , d. h `System.Int32.MinValue - 1` ..  
  
 Bei dieser Methode handelt es sich um einen O ( `n` )-Vorgang, wobei `n` die Anzahl von Elementen vom Anfang `array` bis zum ist `startIndex` .  
  
 In der .NET Framework Version 2,0 verwendet diese Methode die <xref:System.Object.Equals%2A> -Methode und die-Methode <xref:System.IComparable.CompareTo%2A> von <xref:System.Array> , um zu bestimmen, ob das <xref:System.Object> durch den- `value` Parameter angegebene vorhanden ist. In früheren Versionen der .NET Framework wurde diese Bestimmung durch die Verwendung der <xref:System.Object.Equals%2A> -Methode und der- <xref:System.IComparable.CompareTo%2A> Methode der `value` <xref:System.Object> selbst gemacht.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie der Index des letzten Vorkommens eines angegebenen Elements in einem Array bestimmt wird.  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp-interactive[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex, int count);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf (array As Array, value As Object, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj * int * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex, count)" />
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object? value, int startIndex, int count);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende eindimensionale <see cref="T:System.Array" />.</param>
        <param name="value">Das in <paramref name="array" /> zu suchende Objekt.</param>
        <param name="startIndex">Der Startindex für die Rückwärtssuche.</param>
        <param name="count">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den Index des letzten Vorkommens innerhalb des Bereichs von Elementen im eindimensionalen <see cref="T:System.Array" /> zurück, das die angegebene Anzahl von Elementen enthält und am angegebenen Index endet.</summary>
        <returns>Der Index des letzten Vorkommens von <paramref name="value" /> im Bereich von Elementen in <paramref name="array" />, das die durch <paramref name="count" /> angegebene Anzahl von Elementen enthält und sich bis zum <paramref name="startIndex" /> erstreckt, sofern gefunden, andernfalls die untere Grenze des Arrays minus 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das eindimensionale <xref:System.Array> wird rückwärts durchsucht, beginnend bei `startIndex` und endet bei `startIndex` minus `count` plus 1, wenn `count` größer als 0 ist.  
  
 Die Elemente werden mit dem angegebenen Wert mithilfe der- <xref:System.Object.Equals%2A?displayProperty=nameWithType> Methode verglichen. Wenn es sich bei dem Elementtyp um einen nicht intrinsischen (benutzerdefinierten) Typ handelt, `Equals` wird die Implementierung dieses Typs verwendet.  
  
 Da die meisten Arrays eine untere Grenze von 0 (null) aufweisen, gibt diese Methode in der Regel-1 zurück, wenn `value` nicht gefunden wird. In dem seltenen Fall, dass die untere Grenze des Arrays gleich <xref:System.Int32.MinValue?displayProperty=nameWithType> und `value` nicht gefunden wird, gibt diese Methode zurück <xref:System.Int32.MaxValue?displayProperty=nameWithType> , d. h `System.Int32.MinValue - 1` ..  
  
 Diese Methode ist ein O ( `n` )-Vorgang, bei dem gleich `n` ist `count` .  
  
 In der .NET Framework Version 2,0 verwendet diese Methode die <xref:System.Object.Equals%2A> -Methode und die-Methode <xref:System.IComparable.CompareTo%2A> von <xref:System.Array> , um zu bestimmen, ob das <xref:System.Object> durch den- `value` Parameter angegebene vorhanden ist. In früheren Versionen der .NET Framework wurde diese Bestimmung durch die Verwendung der <xref:System.Object.Equals%2A> -Methode und der- <xref:System.IComparable.CompareTo%2A> Methode der `value` <xref:System.Object> selbst gemacht.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie der Index des letzten Vorkommens eines angegebenen Elements in einem Array bestimmt wird. Beachten Sie, dass <xref:System.Array.LastIndexOf%2A> es sich bei der Methode um eine Rückwärtssuche handelt, daher `count` muss kleiner oder gleich ( `startIndex` abzüglich der unteren Grenze des Arrays Plus 1) sein.  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp-interactive[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.  
  
Oder 
 <paramref name="count" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="startIndex" /> und <paramref name="count" /> geben keinen gültigen Abschnitt im <paramref name="array" /> an.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T -&gt; int" Usage="System.Array.LastIndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="value">Das in <paramref name="array" /> zu suchende Objekt.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den Index des letzten Vorkommens innerhalb des gesamten <see cref="T:System.Array" /> zurück.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommens von <paramref name="value" /> im gesamten <paramref name="array" />, sofern gefunden; andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Array> wird rückwärts nach dem letzten Element und mit dem ersten Element durchsucht.  
  
 Die Elemente werden mit dem angegebenen Wert mithilfe der- <xref:System.Object.Equals%2A?displayProperty=nameWithType> Methode verglichen. Wenn es sich bei dem Elementtyp um einen nicht intrinsischen (benutzerdefinierten) Typ handelt, `Equals` wird die Implementierung dieses Typs verwendet.  
  
 Bei dieser Methode handelt es sich um einen O ( `n` )-Vorgang, wobei `n` der <xref:System.Array.Length%2A> von ist `array` .  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden alle drei generischen über Ladungen der- <xref:System.Array.LastIndexOf%2A> Methode veranschaulicht. Ein Array von Zeichen folgen wird erstellt, wobei ein Eintrag zweimal an Indexposition 0 und Index Speicherort 5 angezeigt wird. Die <xref:System.Array.LastIndexOf%60%601(%60%600[],%60%600)> -Methoden Überladung durchsucht das gesamte Array vom Ende und findet das zweite Vorkommen der Zeichenfolge. Die <xref:System.Array.LastIndexOf%60%601(%60%600[],%60%600,System.Int32)> -Methoden Überladung wird verwendet, um das Array rückwärts zu durchsuchen, beginnend mit Indexposition 3 und mit dem Anfang des Arrays fortzufahren, und findet das erste Vorkommen der Zeichenfolge. Schließlich wird die <xref:System.Array.LastIndexOf%60%601(%60%600[],%60%600,System.Int32,System.Int32)> -Methoden Überladung verwendet, um einen Bereich von vier Einträgen zu durchsuchen, beginnend bei Indexposition 4 und rückwärts (d. h., Sie durchsucht die Elemente an den Positionen 4, 3, 2 und 1). diese Suche gibt-1 zurück, da in diesem Bereich keine Instanzen der Such Zeichenfolge vorhanden sind.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp-interactive[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="value">Das in <paramref name="array" /> zu suchende Objekt.</param>
        <param name="startIndex">Der nullbasierte Startindex für die Rückwärtssuche.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den Index des letzten Vorkommens innerhalb des Bereichs von Elementen in dem <see cref="T:System.Array" /> zurück, das sich vom ersten Element bis zum angegebenen Index erstreckt.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommens von <paramref name="value" /> innerhalb des Bereichs von Elementen im <paramref name="array" />, das sich vom ersten Element bis <paramref name="startIndex" /> erstreckt, sofern gefunden; andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Array> -Element wird nach hinten `startIndex` und am ersten Element durchsucht.  
  
 Die Elemente werden mit dem angegebenen Wert mithilfe der- <xref:System.Object.Equals%2A?displayProperty=nameWithType> Methode verglichen. Wenn es sich bei dem Elementtyp um einen nicht intrinsischen (benutzerdefinierten) Typ handelt, `Equals` wird die Implementierung dieses Typs verwendet.  
  
 Bei dieser Methode handelt es sich um einen O ( `n` )-Vorgang, wobei `n` die Anzahl von Elementen vom Anfang `array` bis zum ist `startIndex` .  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden alle drei generischen über Ladungen der- <xref:System.Array.LastIndexOf%2A> Methode veranschaulicht. Ein Array von Zeichen folgen wird erstellt, wobei ein Eintrag zweimal an Indexposition 0 und Index Speicherort 5 angezeigt wird. Die <xref:System.Array.LastIndexOf%60%601(%60%600[],%60%600)> -Methoden Überladung durchsucht das gesamte Array vom Ende und findet das zweite Vorkommen der Zeichenfolge. Die <xref:System.Array.LastIndexOf%60%601(%60%600[],%60%600,System.Int32)> -Methoden Überladung wird verwendet, um das Array rückwärts zu durchsuchen, beginnend mit Indexposition 3 und mit dem Anfang des Arrays fortzufahren, und findet das erste Vorkommen der Zeichenfolge. Schließlich wird die <xref:System.Array.LastIndexOf%60%601(%60%600[],%60%600,System.Int32,System.Int32)> -Methoden Überladung verwendet, um einen Bereich von vier Einträgen zu durchsuchen, beginnend bei Indexposition 4 und rückwärts (d. h., Sie durchsucht die Elemente an den Positionen 4, 3, 2 und 1). diese Suche gibt-1 zurück, da in diesem Bereich keine Instanzen der Such Zeichenfolge vorhanden sind.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp-interactive[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T * int * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="value">Das in <paramref name="array" /> zu suchende Objekt.</param>
        <param name="startIndex">Der nullbasierte Startindex für die Rückwärtssuche.</param>
        <param name="count">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den Index des letzten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Array" /> zurück, das die angegebene Anzahl von Elementen enthält und am angegebenen Index endet.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommens von <paramref name="value" /> innerhalb des Bereichs von Elementen im <paramref name="array" />, das die in <paramref name="count" /> angegebene Anzahl von Elementen enthält und am <paramref name="startIndex" /> endet, sofern gefunden; andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Array> wird nach hinten durchsucht `startIndex` , beginnend bei und endet bei `startIndex` minus `count` plus 1, wenn `count` größer als 0 ist.  
  
 Die Elemente werden mit dem angegebenen Wert mithilfe der- <xref:System.Object.Equals%2A?displayProperty=nameWithType> Methode verglichen. Wenn es sich bei dem Elementtyp um einen nicht intrinsischen (benutzerdefinierten) Typ handelt, `Equals` wird die Implementierung dieses Typs verwendet.  
  
 Diese Methode ist ein O ( `n` )-Vorgang, bei dem gleich `n` ist `count` .  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden alle drei generischen über Ladungen der- <xref:System.Array.LastIndexOf%2A> Methode veranschaulicht. Ein Array von Zeichen folgen wird erstellt, wobei ein Eintrag zweimal an Indexposition 0 und Index Speicherort 5 angezeigt wird. Die <xref:System.Array.LastIndexOf%60%601(%60%600[],%60%600)> -Methoden Überladung durchsucht das gesamte Array vom Ende und findet das zweite Vorkommen der Zeichenfolge. Die <xref:System.Array.LastIndexOf%60%601(%60%600[],%60%600,System.Int32)> -Methoden Überladung wird verwendet, um das Array rückwärts zu durchsuchen, beginnend mit Indexposition 3 und mit dem Anfang des Arrays fortzufahren, und findet das erste Vorkommen der Zeichenfolge. Schließlich wird die <xref:System.Array.LastIndexOf%60%601(%60%600[],%60%600,System.Int32,System.Int32)> -Methoden Überladung verwendet, um einen Bereich von vier Einträgen zu durchsuchen, beginnend bei Indexposition 4 und rückwärts (d. h., Sie durchsucht die Elemente an den Positionen 4, 3, 2 und 1). diese Suche gibt-1 zurück, da in diesem Bereich keine Instanzen der Such Zeichenfolge vorhanden sind.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp-interactive[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.  
  
Oder 
 <paramref name="count" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="startIndex" /> und <paramref name="count" /> geben keinen gültigen Abschnitt im <paramref name="array" /> an.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Array.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.Array.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Gesamtanzahl der Elemente in allen Dimensionen im <see cref="T:System.Array" /> ab.</summary>
        <value>Die Gesamtanzahl der Elemente in allen Dimensionen im <see cref="T:System.Array" />, 0 (null), wenn keine Elemente im Array enthalten sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die- <xref:System.Array.Length%2A> Eigenschaft verwendet, um die Gesamtanzahl von Elementen in einem Array zu erhalten. Außerdem wird die- <xref:System.Array.GetUpperBound%2A> Methode verwendet, um die Anzahl der Elemente in jeder Dimension eines mehrdimensionalen Arrays zu bestimmen.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.length/cs/length1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.length/vb/length1.vb" id="Snippet1"::: 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Das Array ist mehrdimensional und enthält mehr als <see cref="F:System.Int32.MaxValue" /> Elemente.</exception>
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="LongLength">
      <MemberSignature Language="C#" Value="public long LongLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LongLength" />
      <MemberSignature Language="DocId" Value="P:System.Array.LongLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LongLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LongLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LongLength : int64" Usage="System.Array.LongLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine 64-Bit-Ganzzahl ab, die die Gesamtanzahl der Elemente in allen Dimensionen des <see cref="T:System.Array" /> angibt.</summary>
        <value>Eine 64-Bit-Ganzzahl, die die Gesamtzahl der Elemente in allen Dimensionen des <see cref="T:System.Array" /> angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Array.Length" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="Rank">
      <MemberSignature Language="C#" Value="public int Rank { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Rank" />
      <MemberSignature Language="DocId" Value="P:System.Array.Rank" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rank As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Rank { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Rank : int" Usage="System.Array.Rank" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Rang (Anzahl der Dimensionen) von <see cref="T:System.Array" /> ab. Ein eindimensionales Array gibt z. B. 1 zurück, ein zweidimensionales Array gibt 2 zurück usw.</summary>
        <value>Der Rang (Anzahl der Dimensionen) von <see cref="T:System.Array" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beispielsweise der Visual Basic Code  
  
```vb  
Dim TDArray(0,0,0) As Integer  
```  
  
 und den c#-Code  
  
```csharp  
int[,,] TDArray = new int[1,1,1];  
```  
  
 Erstellen Sie ein Array mit drei Dimensionen mit einer- <xref:System.Array.Rank%2A> Eigenschaft, deren Wert 3 ist.  
  
 Ein Jagged Array (ein Array von Arrays) ist ein eindimensionales Array. der Wert seiner- <xref:System.Array.Rank%2A> Eigenschaft ist 1.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein eindimensionales Array, ein zweidimensionales Array und ein-Jagged Array initialisiert, und die- <xref:System.Array.Rank%2A> Eigenschaft jedes-Objekts wird abgerufen.  
  
 [!code-csharp[System.Array.Rank#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.rank/cs/rank1.cs#1)]
 [!code-vb[System.Array.Rank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.rank/vb/rank1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Resize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Resize&lt;T&gt; (ref T[] array, int newSize);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Resize&lt;T&gt;(!!T[]&amp; array, int32 newSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Resize``1(``0[]@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Resize(Of T) (ByRef array As T(), newSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Resize(cli::array &lt;T&gt; ^ % array, int newSize);" />
      <MemberSignature Language="F#" Value="static member Resize : T[] * int -&gt; unit" Usage="System.Array.Resize (array, newSize)" />
      <MemberSignature Language="C#" Value="public static void Resize&lt;T&gt; (ref T[]? array, int newSize);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="newSize" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das eindimensionale nullbasierte Array, dessen Größe geändert werden soll, oder <see langword="null" />, um ein neues Array mit der angegebenen Größe zu erstellen.</param>
        <param name="newSize">Die Größe des neuen Arrays.</param>
        <summary>Ändert die Anzahl der Elemente eines eindimensionalen Arrays in die angegebene neue Größe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ordnet ein neues Array mit der angegebenen Größe zu, kopiert Elemente aus dem alten Array in das neue Array und ersetzt dann das alte Array durch das neue Array. `array`muss ein eindimensionales Array sein.  
  
 Wenn `array` ist `null` , erstellt diese Methode ein neues Array mit der angegebenen Größe.  
  
 Wenn `newSize` größer als der <xref:System.Array.Length%2A> des alten Arrays ist, wird ein neues Array zugewiesen, und alle Elemente werden aus dem alten Array in das neue Array kopiert.  Wenn `newSize` kleiner als der <xref:System.Array.Length%2A> des alten Arrays ist, wird ein neues Array zugewiesen, und die Elemente werden vom alten Array in das neue Array kopiert, bis das neue Array aufgefüllt wird. die restlichen Elemente im alten Array werden ignoriert.  Wenn `newSize` gleich dem <xref:System.Array.Length%2A> des alten Arrays ist, führt diese Methode keine Aktion aus.  
  
 Diese Methode ist ein O ( `n` )-Vorgang, bei dem gleich `n` ist `newSize` .  
  
 Die- <xref:System.Array.Resize%2A> Methode ändert nur ein eindimensionales-Array. Die- <xref:System.Array> Klasse enthält keine Methode zum Ändern der Größe mehrdimensionaler Arrays. Zu diesem Zweck müssen Sie entweder ihren eigenen Code bereitstellen oder eine zweckgebundene Methode in einer Drittanbieter Bibliothek anrufen. Der folgende Code veranschaulicht eine mögliche Implementierung für eine Methode, die die Größe eines Arrays von *n* Dimensionen ändert.  
  
 [!code-csharp[System.Array.Resize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/resizexd.cs#2)]
 [!code-vb[System.Array.Resize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/resizexd.vb#2)]  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie sich die Größe der Größe auf das Array auswirkt.  
  
 [!code-cpp[System.Array.Resize#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Resize/CPP/System.Array.Resize.cpp#1)]
 [!code-csharp[System.Array.Resize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/arrayresize.cs#1)]
 [!code-vb[System.Array.Resize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/arrayresize.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="newSize" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kehrt die Reihenfolge der Elemente in einem eindimensionalen <see cref="T:System.Array" /> oder in einen Teil des <see cref="T:System.Array" /> um.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse (array As Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array);" />
      <MemberSignature Language="F#" Value="static member Reverse : Array -&gt; unit" Usage="System.Array.Reverse array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">Das umzukehrende eindimensionale <see cref="T:System.Array" />.</param>
        <summary>Kehrt die Reihenfolge der Elemente im gesamten eindimensionalen <see cref="T:System.Array" /> um.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nach einem Rückruf dieser Methode wird das-Element bei `myArray[i]` , wobei `i` ein beliebiger Index im-Array ist, zu verschoben `myArray[j]` , wobei `j` gleich ist `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1` .  
  
 Bei dieser Methode handelt es sich um einen O ( `n` )-Vorgang, wobei `n` der <xref:System.Array.Length%2A> von ist `array` .  
  
 Wie im folgenden Beispiel gezeigt, kann die- <xref:System.Array.Reverse%2A> Methode verwendet werden, um eine Jagged Array umzukehren. Sie Initialisiert eine Jagged Array mit einem-Element für jeden Monat des aktuellen Jahres im Kalender der aktuellen Kultur. Jedes-Element enthält ein Array mit so vielen Elementen, wie dieser Monat Tage hat. Das Beispiel zeigt den Inhalt des Arrays an, ruft die <xref:System.Array.Reverse%2A> -Methode auf und zeigt dann den Inhalt des umgekehrten Arrays an.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.reverse/cs/reversejagged.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.reverse/vb/reversejagged.vb" id="Snippet1":::  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie Sie die Sortierung der Werte in umkehren <xref:System.Array> .  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CPP/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CS/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse Example/VB/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse (array As Array, index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Reverse : Array * int * int -&gt; unit" Usage="System.Array.Reverse (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das umzukehrende eindimensionale <see cref="T:System.Array" />.</param>
        <param name="index">Der Startindex des umzukehrenden Abschnitts.</param>
        <param name="length">Die Anzahl der Elemente im umzukehrenden Abschnitt.</param>
        <summary>Kehrt die Reihenfolge einer Teilmenge der Elemente im eindimensionalen <see cref="T:System.Array" /> um.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nach einem Rückruf dieser Methode wird das-Element bei `myArray[i]` , wobei `i` ein beliebiger Index im-Array ist, zu verschoben `myArray[j]` , wobei `j` gleich ist `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1` .  
  
 Die- <xref:System.Array.Reverse%2A> Methode kann verwendet werden, um eine Jagged Array umzukehren.  
  
 Diese Methode ist ein O ( `n` )-Vorgang, bei dem gleich `n` ist `length` .  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie Sie die Sortierung der Werte in einem Bereich von Elementen in einem umkehren <xref:System.Array> .  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CPP/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CS/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/VB/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die untere <paramref name="array" />-Grenze.  
  
Oder 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="array" /> an.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member Reverse : 'T[] -&gt; unit" Usage="System.Array.Reverse array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente in <paramref name="array" />.</typeparam>
        <param name="array">Das umzukehrende eindimensionale Array von Elementen.</param>
        <summary>Kehrt die Reihenfolge der Elemente im eindimensionalen generischen Array um.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Reverse : 'T[] * int * int -&gt; unit" Usage="System.Array.Reverse (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente in <paramref name="array" />.</typeparam>
        <param name="array">Das umzukehrende eindimensionale Array von Elementen.</param>
        <param name="index">Der Startindex des umzukehrenden Abschnitts.</param>
        <param name="length">Die Anzahl der Elemente im umzukehrenden Abschnitt.</param>
        <summary>Kehrt die Reihenfolge einer Teilmenge der Elemente im eindimensionalen generischen Array um.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die untere <paramref name="array" />-Grenze.  
  
Oder 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="array" /> an.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legt das angegebene Element im aktuellen <see cref="T:System.Array" /> auf den angegebenen Wert fest.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int -&gt; unit" Usage="array.SetValue (value, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Der neue Wert für das angegebene Element.</param>
        <param name="index">Eine 32-Bit-Ganzzahl, die die Position des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Legt das Element an der angegebenen Position des eindimensionalen <see cref="T:System.Array" /> auf einen Wert fest. Der Index wird als 32-Bit-Ganzzahl angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array.GetLowerBound%2A> -Methode und die- <xref:System.Array.GetUpperBound%2A> Methode können bestimmen, ob der Wert von `index` außerhalb des gültigen Bereichs liegt.  
  
 Weitere Informationen zu Konvertierungen finden Sie unter <xref:System.Convert> .  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
> [!NOTE]
>  Wenn <xref:System.Array.SetValue%2A> verwendet wird, um `null` einem Element eines Arrays von Werttypen zuzuweisen, werden alle Felder des-Elements mit 0 (null) initialisiert. Der Wert des-Elements ist kein NULL-Verweis und kann nicht gefunden werden, wenn Sie nach einem NULL-Verweis suchen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein bestimmter Wert in einem eindimensionalen oder mehrdimensionalen Array festgelegt und erhalten wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> verfügt nicht über genau eine Dimension.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> kann nicht in den Elementtyp des aktuellen <see cref="T:System.Array" /> umgewandelt werden.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für das aktuelle <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params int[] indices);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;int&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int[] -&gt; unit" Usage="array.SetValue (value, indices)" />
      <MemberSignature Language="C#" Value="public void SetValue (object? value, params int[] indices);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">Der neue Wert für das angegebene Element.</param>
        <param name="indices">Ein eindimensionales Array von 32-Bit-Ganzzahlen, das die Indizes darstellt, die die Position des festzulegenden Elements angeben.</param>
        <summary>Legt das Element an der angegebenen Position des mehrdimensionalen <see cref="T:System.Array" /> auf einen Wert fest. Die Indizes werden als ein Array von 32-Bit-Ganzzahlen angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Anzahl der Elemente in `indices` muss der Anzahl der Dimensionen in der entsprechen <xref:System.Array> . Alle Elemente im `indices` Array müssen kollektiv die Position des gewünschten Elements im mehrdimensionalen angeben <xref:System.Array> .  
  
 Die <xref:System.Array.GetLowerBound%2A> -Methode und die- <xref:System.Array.GetUpperBound%2A> Methode können bestimmen, ob Werte im `indices` Array außerhalb des gültigen Bereichs liegen.  
  
 Weitere Informationen zu Konvertierungen finden Sie unter <xref:System.Convert> .  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
> [!NOTE]
>  Wenn <xref:System.Array.SetValue%2A> verwendet wird, um `null` einem Element eines Arrays von Werttypen zuzuweisen, werden alle Felder des-Elements mit 0 (null) initialisiert. Der Wert des-Elements ist kein NULL-Verweis und kann nicht gefunden werden, wenn Sie nach einem NULL-Verweis suchen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein bestimmter Wert in einem eindimensionalen oder mehrdimensionalen Array festgelegt und erhalten wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl von Dimensionen im aktuellen <see cref="T:System.Array" /> ist nicht mit der Anzahl von Elementen in <paramref name="indices" /> identisch.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> kann nicht in den Elementtyp des aktuellen <see cref="T:System.Array" /> umgewandelt werden.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Jedes Element in <paramref name="indices" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 -&gt; unit" Usage="array.SetValue (value, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="index" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value">Der neue Wert für das angegebene Element.</param>
        <param name="index">Eine 64-Bit-Ganzzahl, die die Position des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Legt das Element an der angegebenen Position des eindimensionalen <see cref="T:System.Array" /> auf einen Wert fest. Der Index wird als 64-Bit-Ganzzahl angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array.GetLowerBound%2A> -Methode und die- <xref:System.Array.GetUpperBound%2A> Methode können bestimmen, ob der Wert von `index` außerhalb des gültigen Bereichs liegt.  
  
 Weitere Informationen zu Konvertierungen finden Sie unter <xref:System.Convert> .  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
> [!NOTE]
>  Wenn <xref:System.Array.SetValue%2A> verwendet wird, um `null` einem Element eines Arrays von Werttypen zuzuweisen, werden alle Felder des-Elements mit 0 (null) initialisiert. Der Wert des-Elements ist kein NULL-Verweis und kann nicht gefunden werden, wenn Sie nach einem NULL-Verweis suchen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein bestimmter Wert in einem eindimensionalen oder mehrdimensionalen Array festgelegt und erhalten wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> verfügt nicht über genau eine Dimension.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> kann nicht in den Elementtyp des aktuellen <see cref="T:System.Array" /> umgewandelt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für das aktuelle <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object? value, params long[] indices);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Long())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;long&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64[] -&gt; unit" Usage="array.SetValue (value, indices)" />
      <MemberSignature Language="C#" Value="public void SetValue (object value, params long[] indices);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="indices" Type="System.Int64[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">Der neue Wert für das angegebene Element.</param>
        <param name="indices">Ein eindimensionales Array von 64-Bit-Ganzzahlen, das die Indizes darstellt, die die Position des festzulegenden Elements angeben.</param>
        <summary>Legt das Element an der angegebenen Position des mehrdimensionalen <see cref="T:System.Array" /> auf einen Wert fest. Die Indizes werden als ein Array von 64-Bit-Ganzzahlen angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Anzahl der Elemente in `indices` muss der Anzahl der Dimensionen in der entsprechen <xref:System.Array> . Alle Elemente im `indices` Array müssen kollektiv die Position des gewünschten Elements im mehrdimensionalen angeben <xref:System.Array> .  
  
 Die <xref:System.Array.GetLowerBound%2A> -Methode und die- <xref:System.Array.GetUpperBound%2A> Methode können bestimmen, ob Werte im `indices` Array außerhalb des gültigen Bereichs liegen.  
  
 Weitere Informationen zu Konvertierungen finden Sie unter <xref:System.Convert> .  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
> [!NOTE]
>  Wenn <xref:System.Array.SetValue%2A> verwendet wird, um `null` einem Element eines Arrays von Werttypen zuzuweisen, werden alle Felder des-Elements mit 0 (null) initialisiert. Der Wert des-Elements ist kein NULL-Verweis und kann nicht gefunden werden, wenn Sie nach einem NULL-Verweis suchen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein bestimmter Wert in einem eindimensionalen oder mehrdimensionalen Array festgelegt und erhalten wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl von Dimensionen im aktuellen <see cref="T:System.Array" /> ist nicht mit der Anzahl von Elementen in <paramref name="indices" /> identisch.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> kann nicht in den Elementtyp des aktuellen <see cref="T:System.Array" /> umgewandelt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Jedes Element in <paramref name="indices" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int * int -&gt; unit" Usage="array.SetValue (value, index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="index1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="index2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value">Der neue Wert für das angegebene Element.</param>
        <param name="index1">Eine 32-Bit-Ganzzahl, die den Index für die erste Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index2">Eine 32-Bit-Ganzzahl, die den Index für die zweite Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Legt das Element an der angegebenen Position des zweidimensionalen <see cref="T:System.Array" /> auf einen Wert fest. Die Indizes werden als 32-Bit-Ganzzahlen angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array.GetLowerBound%2A> -Methode und die- <xref:System.Array.GetUpperBound%2A> Methode können bestimmen, ob ein Index außerhalb des gültigen Bereichs liegt.  
  
 Weitere Informationen zu Konvertierungen finden Sie unter <xref:System.Convert> .  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
> [!NOTE]
>  Wenn <xref:System.Array.SetValue%2A> verwendet wird, um `null` einem Element eines Arrays von Werttypen zuzuweisen, werden alle Felder des-Elements mit 0 (null) initialisiert. Der Wert des-Elements ist kein NULL-Verweis und kann nicht gefunden werden, wenn Sie nach einem NULL-Verweis suchen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein bestimmter Wert in einem eindimensionalen oder mehrdimensionalen Array festgelegt und erhalten wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> verfügt nicht über genau zwei Dimensionen.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> kann nicht in den Elementtyp des aktuellen <see cref="T:System.Array" /> umgewandelt werden.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Entweder <paramref name="index1" /> oder <paramref name="index2" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 * int64 -&gt; unit" Usage="array.SetValue (value, index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="index1" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="index2" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value">Der neue Wert für das angegebene Element.</param>
        <param name="index1">Eine 64-Bit-Ganzzahl, die den Index für die erste Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index2">Eine 64-Bit-Ganzzahl, die den Index für die zweite Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Legt das Element an der angegebenen Position des zweidimensionalen <see cref="T:System.Array" /> auf einen Wert fest. Die Indizes werden als 64-Bit-Ganzzahlen angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array.GetLowerBound%2A> -Methode und die- <xref:System.Array.GetUpperBound%2A> Methode können bestimmen, ob ein Index außerhalb des gültigen Bereichs liegt.  
  
 Weitere Informationen zu Konvertierungen finden Sie unter <xref:System.Convert> .  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
> [!NOTE]
>  Wenn <xref:System.Array.SetValue%2A> verwendet wird, um `null` einem Element eines Arrays von Werttypen zuzuweisen, werden alle Felder des-Elements mit 0 (null) initialisiert. Der Wert des-Elements ist kein NULL-Verweis und kann nicht gefunden werden, wenn Sie nach einem NULL-Verweis suchen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein bestimmter Wert in einem eindimensionalen oder mehrdimensionalen Array festgelegt und erhalten wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> verfügt nicht über genau zwei Dimensionen.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> kann nicht in den Elementtyp des aktuellen <see cref="T:System.Array" /> umgewandelt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Entweder <paramref name="index1" /> oder <paramref name="index2" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer, index3 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2, int index3);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int * int * int -&gt; unit" Usage="array.SetValue (value, index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="index1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="index2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="index3" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value">Der neue Wert für das angegebene Element.</param>
        <param name="index1">Eine 32-Bit-Ganzzahl, die den Index für die erste Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index2">Eine 32-Bit-Ganzzahl, die den Index für die zweite Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index3">Eine 32-Bit-Ganzzahl, die den Index für die dritte Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Legt einen Wert auf das Element an der angegebenen Position im dreidimensionalen <see cref="T:System.Array" /> fest. Die Indizes werden als 32-Bit-Ganzzahlen angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array.GetLowerBound%2A> -Methode und die- <xref:System.Array.GetUpperBound%2A> Methode können bestimmen, ob ein Index außerhalb des gültigen Bereichs liegt.  
  
 Weitere Informationen zu Konvertierungen finden Sie unter <xref:System.Convert> .  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
> [!NOTE]
>  Wenn <xref:System.Array.SetValue%2A> verwendet wird, um `null` einem Element eines Arrays von Werttypen zuzuweisen, werden alle Felder des-Elements mit 0 (null) initialisiert. Der Wert des-Elements ist kein NULL-Verweis und kann nicht gefunden werden, wenn Sie nach einem NULL-Verweis suchen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein bestimmter Wert in einem eindimensionalen oder mehrdimensionalen Array festgelegt und erhalten wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> verfügt nicht über genau drei Dimensionen.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> kann nicht in den Elementtyp des aktuellen <see cref="T:System.Array" /> umgewandelt werden.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Entweder <paramref name="index1" />, <paramref name="index2" /> oder <paramref name="index3" /> liegt außerhalb des Bereichs gültiger Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long, index3 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2, long index3);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 * int64 * int64 -&gt; unit" Usage="array.SetValue (value, index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="index1" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="index2" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="index3" Type="System.Int64" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value">Der neue Wert für das angegebene Element.</param>
        <param name="index1">Eine 64-Bit-Ganzzahl, die den Index für die erste Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index2">Eine 64-Bit-Ganzzahl, die den Index für die zweite Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index3">Eine 64-Bit-Ganzzahl, die den Index für die dritte Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Legt einen Wert auf das Element an der angegebenen Position im dreidimensionalen <see cref="T:System.Array" /> fest. Die Indizes werden als 64-Bit-Ganzzahlen angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array.GetLowerBound%2A> -Methode und die- <xref:System.Array.GetUpperBound%2A> Methode können bestimmen, ob ein Index außerhalb des gültigen Bereichs liegt.  
  
 Weitere Informationen zu Konvertierungen finden Sie unter <xref:System.Convert> .  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
> [!NOTE]
>  Wenn <xref:System.Array.SetValue%2A> verwendet wird, um `null` einem Element eines Arrays von Werttypen zuzuweisen, werden alle Felder des-Elements mit 0 (null) initialisiert. Der Wert des-Elements ist kein NULL-Verweis und kann nicht gefunden werden, wenn Sie nach einem NULL-Verweis suchen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein bestimmter Wert in einem eindimensionalen oder mehrdimensionalen Array festgelegt und erhalten wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> verfügt nicht über genau drei Dimensionen.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> kann nicht in den Elementtyp des aktuellen <see cref="T:System.Array" /> umgewandelt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Entweder <paramref name="index1" />, <paramref name="index2" /> oder <paramref name="index3" /> liegt außerhalb des Bereichs gültiger Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sortiert die Elemente in einem eindimensionalen Array.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (array As Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array);" />
      <MemberSignature Language="F#" Value="static member Sort : Array -&gt; unit" Usage="System.Array.Sort array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">Das zu sortierende eindimensionale <see cref="T:System.Array" />.</param>
        <summary>Sortiert die Elemente in einem ganzen eindimensionalen <see cref="T:System.Array" /> mithilfe der <see cref="T:System.IComparable" />-Implementierung jedes Elements des <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jedes Element von `array` muss die- <xref:System.IComparable> Schnittstelle implementieren, damit Vergleiche mit jedem anderen Element in möglich sind `array` .  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet den introspektiven Sort-Algorithmus (Introsort) wie folgt:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein [Einfügungs](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 * Protokoll<sup>N</sup>überschreitet, wobei *N* der Bereich des Eingabe Arrays ist, wird ein [Heapsort](https://en.wikipedia.org/wiki/Heapsort) -Algorithmus verwendet.  
  
-   Andernfalls wird ein [Quicksort](https://en.wikipedia.org/wiki/Quicksort) -Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Bei dieser Methode handelt es sich um einen O ( `n` log `n` )-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> von ist `array` .  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie die Werte in <xref:System.Array> mithilfe des Standardcomparers und einem benutzerdefinierten Vergleich, der die Sortierreihenfolge umkehrt, sortiert werden. Beachten Sie, dass das Ergebnis abhängig von der aktuellen variieren kann <xref:System.Globalization.CultureInfo> .  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb" id="Snippet1":::  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.InvalidOperationException">In einem oder mehreren Elementen in <paramref name="array" /> ist die <see cref="T:System.IComparable" />-Schnittstelle nicht implementiert.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array -&gt; unit" Usage="System.Array.Sort (keys, items)" />
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array? items);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys">Das eindimensionale <see cref="T:System.Array" /> mit den zu sortierenden Schlüsseln.</param>
        <param name="items">Das eindimensionale <see cref="T:System.Array" /> mit den Elementen, die den jeweiligen Schlüsseln im <paramref name="keys" /><see cref="T:System.Array" /> entsprechen.  
  
Oder 
 <see langword="null" />, wenn nur das <paramref name="keys" /><see cref="T:System.Array" /> sortiert werden soll.</param>
        <summary>Sortiert ein Paar eindimensionaler <see cref="T:System.Array" />-Objekte (das eine enthält die Schlüssel und das andere die entsprechenden Werte) nach den Schlüsseln im ersten <see cref="T:System.Array" /> und verwendet dabei die <see cref="T:System.IComparable" />-Implementierung der einzelnen Schlüssel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel in der `keys` <xref:System.Array> verfügt über ein entsprechendes Element in der `items` <xref:System.Array> . Wenn eine Taste während der Sortierung neu positioniert wird, wird das entsprechende Element in auf `items` <xref:System.Array> ähnliche Weise neu positioniert. Daher wird das `items` <xref:System.Array> nach der Anordnung der entsprechenden Schlüssel in der sortiert `keys` <xref:System.Array> .  
  
 Jeder Schlüssel in `keys` <xref:System.Array> muss die- <xref:System.IComparable> Schnittstelle implementieren, damit Vergleiche mit jedem anderen Schlüssel möglich sind.  
  
 Sie können sortieren, wenn mehr Elemente als Schlüssel vorhanden sind, aber die Elemente, die keine entsprechenden Schlüssel aufweisen, werden nicht sortiert. Sie können nicht sortieren, wenn mehr Schlüssel als Elemente vorhanden sind. Dadurch wird eine ausgelöst <xref:System.ArgumentException> .  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet den introspektiven Sort-Algorithmus (Introsort) wie folgt:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein [Einfügungs](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 * Protokoll<sup>N</sup>überschreitet, wobei *N* der Bereich des Eingabe Arrays ist, wird ein [Heapsort](https://en.wikipedia.org/wiki/Heapsort) -Algorithmus verwendet.  
  
-   Andernfalls wird ein [Quicksort](https://en.wikipedia.org/wiki/Quicksort) -Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Bei dieser Methode handelt es sich um einen O ( `n` log `n` )-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> von ist `keys` .  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie zwei zugeordnete Arrays sortiert werden, wobei das erste Array die Schlüssel und das zweite Array die Werte enthält. Sortierungen werden mithilfe des Standardcomparers und eines benutzerdefinierten Comparers durchgeführt, der die Sortierreihenfolge umkehrt. Beachten Sie, dass das Ergebnis abhängig von der aktuellen variieren kann <xref:System.Globalization.CultureInfo> .  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb" id="Snippet1"::: 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Die <paramref name="keys" />-<see cref="T:System.Array" />-Klasse ist mehrdimensional.  
  
Oder 
Die <paramref name="items" />-<see cref="T:System.Array" />-Klasse ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> ist nicht <see langword="null" />, und die Länge von <paramref name="keys" /> ist größer als die Länge von <paramref name="items" />.</exception>
        <exception cref="T:System.InvalidOperationException">In einem oder mehreren Elementen in <paramref name="keys" /><see cref="T:System.Array" /> ist die <see cref="T:System.IComparable" />-Schnittstelle nicht implementiert.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.IDictionary" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, System.Collections.IComparer comparer);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (array As Array, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (array, comparer)" />
      <MemberSignature Language="C#" Value="public static void Sort (Array array, System.Collections.IComparer? comparer);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Das zu sortierende eindimensionale Array.</param>
        <param name="comparer">Die Implementierung, die beim Vergleich von Elementen verwendet werden soll.  
  
Oder 
 <see langword="null" />, wenn die <see cref="T:System.IComparable" />-Implementierung des jeweiligen Elements verwendet werden soll.</param>
        <summary>Sortiert die Elemente in einem eindimensionalen <see cref="T:System.Array" /> mithilfe des angegebenen <see cref="T:System.Collections.IComparer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparer` ist `null` , muss jedes Element von `array` die- <xref:System.IComparable> Schnittstelle implementieren, damit Vergleiche mit jedem anderen Element in möglich sind `array` .  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet den introspektiven Sort-Algorithmus (Introsort) wie folgt:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein [Einfügungs](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 * Protokoll<sup>N</sup>überschreitet, wobei *N* der Bereich des Eingabe Arrays ist, wird ein [Heapsort](https://en.wikipedia.org/wiki/Heapsort) -Algorithmus verwendet.  
  
-   Andernfalls wird ein [Quicksort](https://en.wikipedia.org/wiki/Quicksort) -Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Bei dieser Methode handelt es sich um einen O ( `n` log `n` )-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> von ist `array` .  
  
 Die .NET Framework enthält die <xref:System.Collections.IComparer> in der folgenden Tabelle aufgeführten vordefinierten Implementierungen.  
  
|Implementierung|Beschreibung|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Vergleicht zwei-Objekte, aber führt einen Vergleich von Zeichen folgen ohne Beachtung der Groß-und Kleinschreibung durch.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Vergleicht zwei-Objekte mit den Sortier Konventionen der aktuellen Kultur.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Vergleicht zwei-Objekte, indem die Sortier Konventionen der invarianten Kultur verwendet werden.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Vergleicht zwei Objekte vom Typ `T` unter Verwendung der Standard Sortierreihenfolge des Typs.|  
  
 Sie können auch benutzerdefinierte Vergleiche unterstützen, indem Sie dem-Parameter eine Instanz Ihrer eigenen Implementierung bereitstellen <xref:System.Collections.IComparer> `comparer` . Im Beispiel wird eine `ReverseComparer` Klasse definiert, die die Standard Sortierreihenfolge für Instanzen eines Typs umkehrt und den Zeichen folgen Vergleich ohne Berücksichtigung der Groß-und Kleinschreibung ausführt.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Werte in einem Zeichen folgen Array mithilfe des Standardcomparers sortiert. Außerdem wird eine benutzerdefinierte <xref:System.Collections.IComparer> Implementierung mit dem Namen definiert `ReverseComparer` , die die Standard Sortierreihenfolge eines Objekts beim Ausführen eines Zeichen folgen Vergleichs ohne Beachtung der Groß-/Kleinschreibung Beachten Sie, dass die Ausgabe abhängig von der aktuellen Kultur variieren kann.  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb" id="Snippet1"::: 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und in einem oder mehreren Elementen in <paramref name="array" /> ist die <see cref="T:System.IComparable" />-Schnittstelle nicht implementiert.</exception>
        <exception cref="T:System.ArgumentException">Die Implementierung von <paramref name="comparer" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <block subset="none" type="usage"><para>In der .NET Framework 4 und früheren Versionen wurde nur der QuickSort-Algorithmus verwendet. Die Quicksort identifiziert ungültige Vergleiche in einigen Situationen, in denen der Sortiervorgang eine <see cref="T:System.IndexOutOfRangeException" /> Ausnahme auslöst, und löst eine <see cref="T:System.ArgumentException" /> Ausnahme an den Aufrufer aus. Ab [!INCLUDE[net_v45](~/includes/net-v45-md.md)] ist es möglich, dass von zuvor ausgelöste Sortiervorgänge <see cref="T:System.ArgumentException" /> keine Ausnahme auslösen, da die einfügesortier-und Heapsort-Algorithmen keinen ungültigen Vergleich erkennen. Dies gilt größtenteils für Arrays mit weniger als oder gleich 16 Elementen.</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, System.Collections.IComparer comparer);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (keys, items, comparer)" />
      <MemberSignature Language="C#" Value="public static void Sort (Array? keys, Array items, System.Collections.IComparer comparer);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys">Das eindimensionale <see cref="T:System.Array" /> mit den zu sortierenden Schlüsseln.</param>
        <param name="items">Das eindimensionale <see cref="T:System.Array" /> mit den Elementen, die den jeweiligen Schlüsseln im <paramref name="keys" /><see cref="T:System.Array" /> entsprechen.  
  
Oder 
 <see langword="null" />, wenn nur das <paramref name="keys" /><see cref="T:System.Array" /> sortiert werden soll.</param>
        <param name="comparer">Die <see cref="T:System.Collections.IComparer" />-Implementierung, die beim Vergleich von Elementen verwendet werden soll.  
  
Oder 
 <see langword="null" />, wenn die <see cref="T:System.IComparable" />-Implementierung des jeweiligen Elements verwendet werden soll.</param>
        <summary>Sortiert ein Paar von eindimensionalen <see cref="T:System.Array" />-Objekten (ein Objekt enthält die Schlüssel und das andere die entsprechenden Elemente) nach den Schlüsseln im ersten <see cref="T:System.Array" /> und verwendet dabei den angegebenen <see cref="T:System.Collections.IComparer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel in der `keys` <xref:System.Array> verfügt über ein entsprechendes Element in der `items` <xref:System.Array> . Wenn eine Taste während der Sortierung neu positioniert wird, wird das entsprechende Element in auf `items` <xref:System.Array> ähnliche Weise neu positioniert. Daher wird das `items` <xref:System.Array> nach der Anordnung der entsprechenden Schlüssel in der sortiert `keys` <xref:System.Array> .  
  
 Wenn den Wert `comparer` `null` hat, muss jeder Schlüssel in der `keys` <xref:System.Array> die- <xref:System.IComparable> Schnittstelle implementieren, damit Vergleiche mit jedem anderen Schlüssel möglich sind.  
  
 Sie können sortieren, wenn mehr Elemente als Schlüssel vorhanden sind, aber die Elemente, die keine entsprechenden Schlüssel aufweisen, werden nicht sortiert. Sie können nicht sortieren, wenn mehr Schlüssel als Elemente vorhanden sind. Dadurch wird eine ausgelöst <xref:System.ArgumentException> .  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Die .NET Framework enthält die <xref:System.Collections.IComparer> in der folgenden Tabelle aufgeführten vordefinierten Implementierungen.  
  
|Implementierung|Beschreibung|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Vergleicht zwei-Objekte, aber führt einen Vergleich von Zeichen folgen ohne Beachtung der Groß-und Kleinschreibung durch.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Vergleicht zwei-Objekte mit den Sortier Konventionen der aktuellen Kultur.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Vergleicht zwei-Objekte, indem die Sortier Konventionen der invarianten Kultur verwendet werden.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Vergleicht zwei Objekte vom Typ `T` unter Verwendung der Standard Sortierreihenfolge des Typs.|  
  
 Sie können auch benutzerdefinierte Vergleiche unterstützen, indem Sie dem-Parameter eine Instanz Ihrer eigenen Implementierung bereitstellen <xref:System.Collections.IComparer> `comparer` . Im Beispiel wird eine <xref:System.Collections.IComparer> Implementierung definiert, die die Standard Sortierreihenfolge umkehrt und den Zeichen folgen Vergleich ohne Berücksichtigung der Groß-und Kleinschreibung ausführt.  
  
 Diese Methode verwendet den introspektiven Sort-Algorithmus (Introsort) wie folgt:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein [Einfügungs](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 * Protokoll<sup>N</sup>überschreitet, wobei *N* der Bereich des Eingabe Arrays ist, wird ein [Heapsort](https://en.wikipedia.org/wiki/Heapsort) -Algorithmus verwendet.  
  
-   Andernfalls wird ein [Quicksort](https://en.wikipedia.org/wiki/Quicksort) -Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Bei dieser Methode handelt es sich um einen O ( `n` log `n` )-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> von ist `keys` .  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie zwei zugeordnete Arrays sortiert werden, wobei das erste Array die Schlüssel und das zweite Array die Werte enthält. Sortierungen werden mithilfe des Standardcomparers und eines benutzerdefinierten Comparers durchgeführt, der die Sortierreihenfolge umkehrt. Beachten Sie, dass das Ergebnis abhängig von der aktuellen variieren kann <xref:System.Globalization.CultureInfo> .  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Die <paramref name="keys" />-<see cref="T:System.Array" />-Klasse ist mehrdimensional.  
  
Oder 
Die <paramref name="items" />-<see cref="T:System.Array" />-Klasse ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> ist nicht <see langword="null" />, und die Länge von <paramref name="keys" /> ist größer als die Länge von <paramref name="items" />.  
  
Oder 
Die Implementierung von <paramref name="comparer" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und in einem oder mehreren Elementen im <paramref name="keys" /><see cref="T:System.Array" /> ist die <see cref="T:System.IComparable" />-Schnittstelle nicht implementiert.</exception>
        <block subset="none" type="usage"><para>In der .NET Framework 4 und früheren Versionen wurde nur der QuickSort-Algorithmus verwendet. Die Quicksort identifiziert ungültige Vergleiche in einigen Situationen, in denen der Sortiervorgang eine <see cref="T:System.IndexOutOfRangeException" /> Ausnahme auslöst, und löst eine <see cref="T:System.ArgumentException" /> Ausnahme an den Aufrufer aus. Ab [!INCLUDE[net_v45](~/includes/net-v45-md.md)] ist es möglich, dass von zuvor ausgelöste Sortiervorgänge <see cref="T:System.ArgumentException" /> keine Ausnahme auslösen, da die einfügesortier-und Heapsort-Algorithmen keinen ungültigen Vergleich erkennen. Dies gilt größtenteils für Arrays mit weniger als oder gleich 16 Elementen.</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (array As Array, index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * int * int -&gt; unit" Usage="System.Array.Sort (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das zu sortierende eindimensionale <see cref="T:System.Array" />.</param>
        <param name="index">Der Startindex des zu sortierenden Bereichs.</param>
        <param name="length">Die Anzahl der Elemente im zu sortierenden Bereich.</param>
        <summary>Sortiert die Elemente in einem Bereich von Elementen in einem eindimensionalen <see cref="T:System.Array" /> mithilfe der <see cref="T:System.IComparable" />-Implementierung jedes Elements des <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jedes Element innerhalb des angegebenen Bereichs von Elementen in `array` muss die- <xref:System.IComparable> Schnittstelle implementieren, damit Vergleiche mit jedem anderen Element in möglich sind `array` .  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet den introspektiven Sort-Algorithmus (Introsort) wie folgt:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein [Einfügungs](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 * Protokoll<sup>N</sup>überschreitet, wobei *N* der Bereich des Eingabe Arrays ist, wird ein [Heapsort](https://en.wikipedia.org/wiki/Heapsort) -Algorithmus verwendet.  
  
-   Andernfalls wird ein [Quicksort](https://en.wikipedia.org/wiki/Quicksort) -Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Diese Methode ist ein O ( `n` log `n` )-Vorgang, bei dem gleich `n` ist `length` .  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie die Werte in <xref:System.Array> mithilfe des Standardcomparers und einem benutzerdefinierten Vergleich, der die Sortierreihenfolge umkehrt, sortiert werden. Beachten Sie, dass das Ergebnis abhängig von der aktuellen variieren kann <xref:System.Globalization.CultureInfo> .  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die untere <paramref name="array" />-Grenze.  
  
Oder 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="array" /> an.</exception>
        <exception cref="T:System.InvalidOperationException">In einem oder mehreren Elementen in <paramref name="array" /> ist die <see cref="T:System.IComparable" />-Schnittstelle nicht implementiert.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * int * int -&gt; unit" Usage="System.Array.Sort (keys, items, index, length)" />
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array? items, int index, int length);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys">Das eindimensionale <see cref="T:System.Array" /> mit den zu sortierenden Schlüsseln.</param>
        <param name="items">Das eindimensionale <see cref="T:System.Array" /> mit den Elementen, die den jeweiligen Schlüsseln im <paramref name="keys" /><see cref="T:System.Array" /> entsprechen.  
  
Oder 
 <see langword="null" />, wenn nur das <paramref name="keys" /><see cref="T:System.Array" /> sortiert werden soll.</param>
        <param name="index">Der Startindex des zu sortierenden Bereichs.</param>
        <param name="length">Die Anzahl der Elemente im zu sortierenden Bereich.</param>
        <summary>Sortiert einen Bereich von Elementen in einem Paar von eindimensionalen <see cref="T:System.Array" />-Objekten (das eine enthält die Schlüssel und das andere die entsprechenden Werte) nach den Schlüsseln im ersten <see cref="T:System.Array" /> und verwendet dabei die <see cref="T:System.IComparable" />-Implementierung jedes Schlüssels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel in der `keys` <xref:System.Array> verfügt über ein entsprechendes Element in der `items` <xref:System.Array> . Wenn eine Taste während der Sortierung neu positioniert wird, wird das entsprechende Element in auf `items` <xref:System.Array> ähnliche Weise neu positioniert. Daher wird das `items` <xref:System.Array> nach der Anordnung der entsprechenden Schlüssel in der sortiert `keys` <xref:System.Array> .  
  
 Jeder Schlüssel innerhalb des angegebenen Bereichs von Elementen in der `keys` <xref:System.Array> muss die- <xref:System.IComparable> Schnittstelle implementieren, damit Vergleiche mit jedem anderen Schlüssel möglich sind.  
  
 Sie können sortieren, wenn mehr Elemente als Schlüssel vorhanden sind, aber die Elemente, die keine entsprechenden Schlüssel aufweisen, werden nicht sortiert. Sie können nicht sortieren, wenn mehr Schlüssel als Elemente vorhanden sind. Dadurch wird eine ausgelöst <xref:System.ArgumentException> .  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet den introspektiven Sort-Algorithmus (Introsort) wie folgt:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein [Einfügungs](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 * Protokoll<sup>N</sup>überschreitet, wobei *N* der Bereich des Eingabe Arrays ist, wird ein [Heapsort](https://en.wikipedia.org/wiki/Heapsort) -Algorithmus verwendet.  
  
-   Andernfalls wird ein [Quicksort](https://en.wikipedia.org/wiki/Quicksort) -Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Diese Methode ist ein O ( `n` log `n` )-Vorgang, bei dem gleich `n` ist `length` .  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie zwei zugeordnete Arrays sortiert werden, wobei das erste Array die Schlüssel und das zweite Array die Werte enthält. Sortierungen werden mithilfe des Standardcomparers und eines benutzerdefinierten Comparers durchgeführt, der die Sortierreihenfolge umkehrt. Beachten Sie, dass das Ergebnis abhängig von der aktuellen variieren kann <xref:System.Globalization.CultureInfo> .  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Die <paramref name="keys" />-<see cref="T:System.Array" />-Klasse ist mehrdimensional.  
  
Oder 
Die <paramref name="items" />-<see cref="T:System.Array" />-Klasse ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die untere <paramref name="keys" />-Grenze.  
  
Oder 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> ist nicht <see langword="null" />, und die Länge von <paramref name="keys" /> ist größer als die Länge von <paramref name="items" />.  
  
Oder 
 <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="keys" /><see cref="T:System.Array" /> an.  
  
Oder 
 <paramref name="items" /> ist nicht <see langword="null" />, und <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="items" /><see cref="T:System.Array" /> an.</exception>
        <exception cref="T:System.InvalidOperationException">In einem oder mehreren Elementen in <paramref name="keys" /><see cref="T:System.Array" /> ist die <see cref="T:System.IComparable" />-Schnittstelle nicht implementiert.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length, System.Collections.IComparer comparer);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (array As Array, index As Integer, length As Integer, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * int * int * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (array, index, length, comparer)" />
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length, System.Collections.IComparer? comparer);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Das zu sortierende eindimensionale <see cref="T:System.Array" />.</param>
        <param name="index">Der Startindex des zu sortierenden Bereichs.</param>
        <param name="length">Die Anzahl der Elemente im zu sortierenden Bereich.</param>
        <param name="comparer">Die <see cref="T:System.Collections.IComparer" />-Implementierung, die beim Vergleich von Elementen verwendet werden soll.  
  
Oder 
 <see langword="null" />, wenn die <see cref="T:System.IComparable" />-Implementierung des jeweiligen Elements verwendet werden soll.</param>
        <summary>Sortiert die Elemente in einem Bereich von Elementen in einem eindimensionalen <see cref="T:System.Array" /> mithilfe des angegebenen <see cref="T:System.Collections.IComparer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparer` ist `null` , muss jedes Element innerhalb des angegebenen Bereichs von Elementen in `array` die- <xref:System.IComparable> Schnittstelle implementieren, damit Vergleiche mit jedem anderen Element in möglich sind `array` .  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Die .NET Framework enthält die <xref:System.Collections.IComparer> in der folgenden Tabelle aufgeführten vordefinierten Implementierungen.  
  
|Implementierung|Beschreibung|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Vergleicht zwei-Objekte, aber führt einen Vergleich von Zeichen folgen ohne Beachtung der Groß-und Kleinschreibung durch.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Vergleicht zwei-Objekte mit den Sortier Konventionen der aktuellen Kultur.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Vergleicht zwei-Objekte, indem die Sortier Konventionen der invarianten Kultur verwendet werden.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Vergleicht zwei Objekte vom Typ `T` unter Verwendung der Standard Sortierreihenfolge des Typs.|  
  
 Sie können auch benutzerdefinierte Vergleiche unterstützen, indem Sie dem-Parameter eine Instanz Ihrer eigenen Implementierung bereitstellen <xref:System.Collections.IComparer> `comparer` . Im Beispiel wird eine `ReverseComparer` Klasse definiert, die die Standard Sortierreihenfolge für Instanzen eines Typs umkehrt und den Zeichen folgen Vergleich ohne Berücksichtigung der Groß-und Kleinschreibung ausführt.  
  
 Diese Methode verwendet den introspektiven Sort-Algorithmus (Introsort) wie folgt:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein [Einfügungs](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 * Protokoll<sup>N</sup>überschreitet, wobei *N* der Bereich des Eingabe Arrays ist, wird ein [Heapsort](https://en.wikipedia.org/wiki/Heapsort) -Algorithmus verwendet.  
  
-   Andernfalls wird ein [Quicksort](https://en.wikipedia.org/wiki/Quicksort) -Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Diese Methode ist ein O ( `n` log `n` )-Vorgang, bei dem gleich `n` ist `length` .  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie die Werte in <xref:System.Array> mithilfe des Standardcomparers und einem benutzerdefinierten Vergleich, der die Sortierreihenfolge umkehrt, sortiert werden. Beachten Sie, dass das Ergebnis abhängig von der aktuellen variieren kann <xref:System.Globalization.CultureInfo> .  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die untere <paramref name="array" />-Grenze.  
  
Oder 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="array" /> an.  
  
Oder 
Die Implementierung von <paramref name="comparer" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und in einem oder mehreren Elementen in <paramref name="array" /> ist die <see cref="T:System.IComparable" />-Schnittstelle nicht implementiert.</exception>
        <block subset="none" type="usage"><para>In der .NET Framework 4 und früheren Versionen wurde nur der QuickSort-Algorithmus verwendet. Die Quicksort identifiziert ungültige Vergleiche in einigen Situationen, in denen der Sortiervorgang eine <see cref="T:System.IndexOutOfRangeException" /> Ausnahme auslöst, und löst eine <see cref="T:System.ArgumentException" /> Ausnahme an den Aufrufer aus. Ab [!INCLUDE[net_v45](~/includes/net-v45-md.md)] ist es möglich, dass von zuvor ausgelöste Sortiervorgänge <see cref="T:System.ArgumentException" /> keine Ausnahme auslösen, da die einfügesortier-und Heapsort-Algorithmen keinen ungültigen Vergleich erkennen. Dies gilt größtenteils für Arrays mit weniger als oder gleich 16 Elementen.</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length, System.Collections.IComparer comparer);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * int * int * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (keys, items, index, length, comparer)" />
      <MemberSignature Language="C#" Value="public static void Sort (Array? keys, Array items, int index, int length, System.Collections.IComparer comparer);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="4" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys">Das eindimensionale <see cref="T:System.Array" /> mit den zu sortierenden Schlüsseln.</param>
        <param name="items">Das eindimensionale <see cref="T:System.Array" /> mit den Elementen, die den jeweiligen Schlüsseln im <paramref name="keys" /><see cref="T:System.Array" /> entsprechen.  
  
Oder 
 <see langword="null" />, wenn nur das <paramref name="keys" /><see cref="T:System.Array" /> sortiert werden soll.</param>
        <param name="index">Der Startindex des zu sortierenden Bereichs.</param>
        <param name="length">Die Anzahl der Elemente im zu sortierenden Bereich.</param>
        <param name="comparer">Die <see cref="T:System.Collections.IComparer" />-Implementierung, die beim Vergleich von Elementen verwendet werden soll.  
  
Oder 
 <see langword="null" />, wenn die <see cref="T:System.IComparable" />-Implementierung des jeweiligen Elements verwendet werden soll.</param>
        <summary>Sortiert einen Bereich von Elementen in einem Paar von eindimensionalen <see cref="T:System.Array" />-Objekten (das eine enthält die Schlüssel und das andere die entsprechenden Werte) nach den Schlüsseln im ersten <see cref="T:System.Array" /> und verwendet dabei den angegebenen <see cref="T:System.Collections.IComparer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel in der `keys` <xref:System.Array> verfügt über ein entsprechendes Element in der `items` <xref:System.Array> . Wenn eine Taste während der Sortierung neu positioniert wird, wird das entsprechende Element in auf `items` <xref:System.Array> ähnliche Weise neu positioniert. Daher wird das `items` <xref:System.Array> nach der Anordnung der entsprechenden Schlüssel in der sortiert `keys` <xref:System.Array> .  
  
 Wenn `comparer` ist `null` , muss jeder Schlüssel innerhalb des angegebenen Bereichs von Elementen in der `keys` <xref:System.Array> die- <xref:System.IComparable> Schnittstelle implementieren, damit Vergleiche mit jedem anderen Schlüssel möglich sind.  
  
 Sie können sortieren, wenn mehr Elemente als Schlüssel vorhanden sind, aber die Elemente, die keine entsprechenden Schlüssel aufweisen, werden nicht sortiert. Sie können nicht sortieren, wenn mehr Schlüssel als Elemente vorhanden sind. Dadurch wird eine ausgelöst <xref:System.ArgumentException> .  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Die .NET Framework enthält die <xref:System.Collections.IComparer> in der folgenden Tabelle aufgeführten vordefinierten Implementierungen.  
  
|Implementierung|Beschreibung|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Vergleicht zwei-Objekte, aber führt einen Vergleich von Zeichen folgen ohne Beachtung der Groß-und Kleinschreibung durch.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Vergleicht zwei-Objekte mit den Sortier Konventionen der aktuellen Kultur.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Vergleicht zwei-Objekte, indem die Sortier Konventionen der invarianten Kultur verwendet werden.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Vergleicht zwei Objekte vom Typ `T` unter Verwendung der Standard Sortierreihenfolge des Typs.|  
  
 Sie können auch benutzerdefinierte Vergleiche unterstützen, indem Sie dem-Parameter eine Instanz Ihrer eigenen Implementierung bereitstellen <xref:System.Collections.IComparer> `comparer` . Dies geschieht durch Definieren einer benutzerdefinierten <xref:System.Collections.IComparer> Implementierung, die die Standard Sortierreihenfolge umkehrt und den Zeichen folgen Vergleich ohne Berücksichtigung der Groß-und Kleinschreibung ausführt.  
  
 Diese Methode verwendet den introspektiven Sort-Algorithmus (Introsort) wie folgt:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein [Einfügungs](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 * Protokoll<sup>N</sup>überschreitet, wobei *N* der Bereich des Eingabe Arrays ist, wird ein [Heapsort](https://en.wikipedia.org/wiki/Heapsort) -Algorithmus verwendet.  
  
-   Andernfalls wird ein [Quicksort](https://en.wikipedia.org/wiki/Quicksort) -Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Diese Methode ist ein O ( `n` log `n` )-Vorgang, bei dem gleich `n` ist `length` .  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie zwei zugeordnete Arrays sortiert werden, wobei das erste Array die Schlüssel und das zweite Array die Werte enthält. Sortierungen werden mithilfe des Standardcomparers und eines benutzerdefinierten Comparers durchgeführt, der die Sortierreihenfolge umkehrt. Beachten Sie, dass das Ergebnis abhängig von der aktuellen variieren kann <xref:System.Globalization.CultureInfo> .  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb" id="Snippet1"::: 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Die <paramref name="keys" />-<see cref="T:System.Array" />-Klasse ist mehrdimensional.  
  
Oder 
Die <paramref name="items" />-<see cref="T:System.Array" />-Klasse ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die untere <paramref name="keys" />-Grenze.  
  
Oder 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> ist nicht <see langword="null" />, und die Untergrenze von <paramref name="keys" /> entspricht nicht der Untergrenze von <paramref name="items" />.  
  
Oder 
 <paramref name="items" /> ist nicht <see langword="null" />, und die Länge von <paramref name="keys" /> ist größer als die Länge von <paramref name="items" />.  
  
Oder 
 <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="keys" /><see cref="T:System.Array" /> an.  
  
Oder 
 <paramref name="items" /> ist nicht <see langword="null" />, und <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="items" /><see cref="T:System.Array" /> an.  
  
Oder 
Die Implementierung von <paramref name="comparer" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und in einem oder mehreren Elementen im <paramref name="keys" /><see cref="T:System.Array" /> ist die <see cref="T:System.IComparable" />-Schnittstelle nicht implementiert.</exception>
        <block subset="none" type="usage"><para>In der .NET Framework 4 und früheren Versionen wurde nur der QuickSort-Algorithmus verwendet. Die Quicksort identifiziert ungültige Vergleiche in einigen Situationen, in denen der Sortiervorgang eine <see cref="T:System.IndexOutOfRangeException" /> Ausnahme auslöst, und löst eine <see cref="T:System.ArgumentException" /> Ausnahme an den Aufrufer aus. Ab [!INCLUDE[net_v45](~/includes/net-v45-md.md)] ist es möglich, dass von zuvor ausgelöste Sortiervorgänge <see cref="T:System.ArgumentException" /> keine Ausnahme auslösen, da die einfügesortier-und Heapsort-Algorithmen keinen ungültigen Vergleich erkennen. Dies gilt größtenteils für Arrays mit weniger als oder gleich 16 Elementen.</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] -&gt; unit" Usage="System.Array.Sort array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu sortierende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <summary>Sortiert die Elemente in einem ganzen <see cref="T:System.Array" /> mithilfe der Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle jedes Elements des <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jedes Element von `array` muss die <xref:System.IComparable%601> generische-Schnittstelle implementieren, damit Vergleiche mit jedem anderen Element in möglich sind `array` .  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet den introspektiven Sort-Algorithmus (Introsort) wie folgt:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein [Einfügungs](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 * Protokoll<sup>N</sup>überschreitet, wobei *N* der Bereich des Eingabe Arrays ist, wird ein [Heapsort](https://en.wikipedia.org/wiki/Heapsort) -Algorithmus verwendet.  
  
-   Andernfalls wird ein [Quicksort](https://en.wikipedia.org/wiki/Quicksort) -Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Bei dieser Methode handelt es sich um einen O ( `n` log `n` )-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> von ist `array` .  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Array.Sort%60%601(%60%600[])> generische Methoden Überladung und die <xref:System.Array.BinarySearch%60%601(%60%600[],%60%600)> generische Methoden Überladung. Ein Array von Zeichen folgen wird erstellt, in keiner bestimmten Reihenfolge.  
  
 Das Array wird angezeigt, sortiert und erneut angezeigt.  
  
> [!NOTE]
>  Die Aufrufe der <xref:System.Array.Sort%2A> generischen-Methode und der- <xref:System.Array.BinarySearch%2A> Methode unterscheiden sich nicht von Aufrufen ihrer nicht generischen Entsprechungen, da Visual Basic, c# und C++ den Typ des generischen Typparameters vom Typ des ersten Arguments ableiten. Wenn Sie die [Ildasm.exe (IL-Disassembler)](/dotnet/framework/tools/ildasm-exe-il-disassembler) verwenden, um die MSIL (Microsoft Intermediate Language) zu überprüfen, können Sie sehen, dass die generischen Methoden aufgerufen werden.  
  
 Die <xref:System.Array.BinarySearch%60%601(%60%600[],%60%600)> generische Methoden Überladung wird dann verwendet, um nach zwei Zeichen folgen zu suchen, eine, die nicht im-Array ist, und eine, die ist. Das-Array und der Rückgabewert der- <xref:System.Array.BinarySearch%2A> Methode werden an die `ShowWhere` generische-Methode übergeben, die den Indexwert anzeigt, wenn die Zeichenfolge gefunden wird, und andernfalls die Elemente, zwischen denen die Such Zeichenfolge fällt, wenn Sie im Array vorhanden wäre. Der Index ist negativ, wenn die Zeichenfolge nicht n das Array ist, sodass die `ShowWhere` Methode das bitweise Komplement (der ~-Operator in c# und Visual C++, `Xor` -1 in Visual Basic) übernimmt, um den Index des ersten Elements in der Liste zu erhalten, das größer als die Such Zeichenfolge ist.  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb" id="Snippet1"::: 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">In einem oder mehreren Elementen in <paramref name="array" /> ist die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht implementiert.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, System.Collections.Generic.IComparer&lt;T&gt; comparer);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, comparer)" />
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, System.Collections.Generic.IComparer&lt;T&gt;? comparer);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu sortierende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="comparer">Die Implementierung der generischen <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle, die für den Vergleich von Elementen verwendet werden soll, oder <see langword="null" />, um die Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle der einzelnen Elemente zu verwenden.</param>
        <summary>Sortiert die Elemente in einem <see cref="T:System.Array" /> mithilfe der angegebenen generischen <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparer` ist `null` , muss jedes Element von `array` die <xref:System.IComparable%601> generische-Schnittstelle implementieren, damit Vergleiche mit jedem anderen Element in möglich sind `array` .  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet den introspektiven Sort-Algorithmus (Introsort) wie folgt:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein [Einfügungs](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 * Protokoll<sup>N</sup>überschreitet, wobei *N* der Bereich des Eingabe Arrays ist, wird ein [Heapsort](https://en.wikipedia.org/wiki/Heapsort) -Algorithmus verwendet.  
  
-   Andernfalls wird ein [Quicksort](https://en.wikipedia.org/wiki/Quicksort) -Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Bei dieser Methode handelt es sich um einen O ( `n` log `n` )-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> von ist `array` .  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Array.Sort%60%601(%60%600[],System.Collections.Generic.IComparer{%60%600})> generische Methoden Überladung und die <xref:System.Array.BinarySearch%60%601(%60%600[],%60%600,System.Collections.Generic.IComparer{%60%600})> generische Methoden Überladung.  
  
 Im Codebeispiel wird ein alternativer Vergleich für Zeichen folgen mit dem Namen definiert `ReverseCompare` , der `IComparer<string>` die `IComparer(Of String)` `IComparer<String^>` generische Schnittstelle (in Visual Basic Visual C++) implementiert. Der Vergleich Ruft die- <xref:System.String.CompareTo(System.String)> Methode auf und kehrt die Reihenfolge der Vergleichs Elemente um, sodass die Zeichen folgen nicht zu hoch, sondern zu niedrig sortiert werden.  
  
 Das Array wird angezeigt, sortiert und erneut angezeigt. Arrays müssen sortiert werden, um die-Methode zu verwenden <xref:System.Array.BinarySearch%2A> .  
  
> [!NOTE]
>  Die Aufrufe der <xref:System.Array.Sort%60%601(%60%600[],System.Collections.Generic.IComparer{%60%600})> generischen-Methode und der- <xref:System.Array.BinarySearch%60%601(%60%600[],%60%600,System.Collections.Generic.IComparer{%60%600})> Methode unterscheiden sich nicht von Aufrufen ihrer nicht generischen Entsprechungen, da Visual Basic, c# und C++ den Typ des generischen Typparameters vom Typ des ersten Arguments ableiten. Wenn Sie die [Ildasm.exe (IL-Disassembler)](/dotnet/framework/tools/ildasm-exe-il-disassembler) verwenden, um die MSIL (Microsoft Intermediate Language) zu überprüfen, können Sie sehen, dass die generischen Methoden aufgerufen werden.  
  
 Die <xref:System.Array.BinarySearch%60%601(%60%600[],%60%600,System.Collections.Generic.IComparer{%60%600})> generische Methoden Überladung wird dann verwendet, um nach zwei Zeichen folgen zu suchen, eine, die nicht im-Array ist, und eine, die ist. Das-Array und der Rückgabewert der- <xref:System.Array.BinarySearch%60%601(%60%600[],%60%600,System.Collections.Generic.IComparer{%60%600})> Methode werden an die `ShowWhere` generische-Methode übergeben, die den Indexwert anzeigt, wenn die Zeichenfolge gefunden wird, und andernfalls die Elemente, zwischen denen die Such Zeichenfolge fällt, wenn Sie im Array vorhanden wäre. Der Index ist negativ, wenn die Zeichenfolge nicht n das Array ist, sodass die `ShowWhere` Methode das bitweise Komplement (der ~-Operator in c# und Visual C++, `Xor` -1 in Visual Basic) übernimmt, um den Index des ersten Elements in der Liste zu erhalten, das größer als die Such Zeichenfolge ist.  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und in einem oder mehreren Elementen im <paramref name="array" /> ist die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht implementiert.</exception>
        <exception cref="T:System.ArgumentException">Die Implementierung von <paramref name="comparer" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <block subset="none" type="usage"><para>In der .NET Framework 4 und früheren Versionen wurde nur der QuickSort-Algorithmus verwendet. Die Quicksort identifiziert ungültige Vergleiche in einigen Situationen, in denen der Sortiervorgang eine <see cref="T:System.IndexOutOfRangeException" /> Ausnahme auslöst, und löst eine <see cref="T:System.ArgumentException" /> Ausnahme an den Aufrufer aus. Ab [!INCLUDE[net_v45](~/includes/net-v45-md.md)] ist es möglich, dass von zuvor ausgelöste Sortiervorgänge <see cref="T:System.ArgumentException" /> keine Ausnahme auslösen, da die einfügesortier-und Heapsort-Algorithmen keinen ungültigen Vergleich erkennen. Dies gilt größtenteils für Arrays mit weniger als oder gleich 16 Elementen.</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Comparison`1&lt;!!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Comparison{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, Comparison&lt;T&gt; ^ comparison);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * Comparison&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, comparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu sortierende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="comparison">Die <see cref="T:System.Comparison`1" />, die beim Vergleich von Elementen verwendet werden soll.</param>
        <summary>Sortiert die Elemente in einem <see cref="T:System.Array" /> mithilfe des angegebenen <see cref="T:System.Comparison`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet den introktiven Sort-Algorithmus (Introsort) wie folgt:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein [Einfügungs](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 * Protokoll<sup>N</sup>überschreitet, wobei *N* der Bereich des Eingabe Arrays ist, wird ein [Heapsort](https://en.wikipedia.org/wiki/Heapsort) -Algorithmus verwendet.  
  
-   Andernfalls wird ein [Quicksort](https://en.wikipedia.org/wiki/Quicksort) -Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Bei dieser Methode handelt es sich um einen O ( `n` log `n` )-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> von ist `array` .  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Collections.Generic.List%601.Sort(System.Comparison{%600})> -methodenüberladung.  
  
 Das Codebeispiel definiert eine Alternative Vergleichsmethode für Zeichen folgen mit dem Namen `CompareDinosByLength` . Diese Methode funktioniert wie folgt: zuerst werden die Vergleiche für getestet `null` , und ein NULL-Verweis wird als kleiner als ein nicht-NULL-Wert behandelt. Zweitens werden die Zeichen folgen Längen verglichen, und die längere Zeichenfolge wird als größer eingestuft. Drittens: Wenn die Längen gleich sind, wird der normale Zeichen folgen Vergleich verwendet.  
  
 Ein Array von Zeichen folgen wird erstellt und mit vier Zeichen folgen ohne bestimmte Reihenfolge aufgefüllt. Die Liste enthält auch eine leere Zeichenfolge und einen NULL-Verweis. Die Liste wird angezeigt, mithilfe eines generischen Delegaten sortiert <xref:System.Comparison%601> , der die `CompareDinosByLength` Methode darstellt, und wird erneut angezeigt.  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortComparison/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortComparison/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortComparison/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="comparison" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Implementierung von <paramref name="comparison" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparison" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <block subset="none" type="usage"><para>In der .NET Framework 4 und früheren Versionen wurde nur der QuickSort-Algorithmus verwendet. Die Quicksort identifiziert ungültige Vergleiche in einigen Situationen, in denen der Sortiervorgang eine <see cref="T:System.IndexOutOfRangeException" /> Ausnahme auslöst, und löst eine <see cref="T:System.ArgumentException" /> Ausnahme an den Aufrufer aus. Ab [!INCLUDE[net_v45](~/includes/net-v45-md.md)] ist es möglich, dass von zuvor ausgelöste Sortiervorgänge <see cref="T:System.ArgumentException" /> keine Ausnahme auslösen, da die einfügesortier-und Heapsort-Algorithmen keinen ungültigen Vergleich erkennen. Zum größten Teil gilt dies für Arrays mit weniger als oder gleich 6 Elementen.</para></block>
        <altmember cref="T:System.Comparison`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * int * int -&gt; unit" Usage="System.Array.Sort (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu sortierende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="index">Der Startindex des zu sortierenden Bereichs.</param>
        <param name="length">Die Anzahl der Elemente im zu sortierenden Bereich.</param>
        <summary>Sortiert die Elemente in einem Bereich von Elementen in einem <see cref="T:System.Array" /> mithilfe der Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle jedes Elements des <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jedes Element innerhalb des angegebenen Bereichs von Elementen in `array` muss die <xref:System.IComparable%601> generische-Schnittstelle implementieren, damit Vergleiche mit jedem anderen Element in möglich sind `array` .  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet den introspektiven Sort-Algorithmus (Introsort) wie folgt:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein [Einfügungs](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 * Protokoll<sup>N</sup>überschreitet, wobei *N* der Bereich des Eingabe Arrays ist, wird ein [Heapsort](https://en.wikipedia.org/wiki/Heapsort) -Algorithmus verwendet.  
  
-   Andernfalls wird ein [Quicksort](https://en.wikipedia.org/wiki/Quicksort) -Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Diese Methode ist ein O ( `n` log `n` )-Vorgang, bei dem gleich `n` ist `length` .  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Array.Sort%60%601(%60%600[],System.Int32,System.Int32)> generische Methoden Überladung und die <xref:System.Array.Sort%60%602(%60%600[],%60%601[],System.Int32,System.Int32,System.Collections.Generic.IComparer{%60%600})> generische Methoden Überladung zum Sortieren eines Bereichs in einem Array veranschaulicht.  
  
 Im Codebeispiel wird ein alternativer Vergleich für Zeichen folgen mit dem Namen definiert `ReverseCompare` , der `IComparer<string>` die `IComparer(Of String)` `IComparer<String^>` generische Schnittstelle (in Visual Basic Visual C++) implementiert. Der Vergleich Ruft die- <xref:System.String.CompareTo(System.String)> Methode auf und kehrt die Reihenfolge der Vergleichs Elemente um, sodass die Zeichen folgen nicht zu hoch, sondern zu niedrig sortiert werden.  
  
 Im Codebeispiel wird ein Array von Dinosaurier Namen erstellt und angezeigt, das aus drei HERBIVORES gefolgt von drei Fleisch freten (Tyrannosaurids) besteht. Die <xref:System.Array.Sort%60%601(%60%600[],System.Int32,System.Int32)> generische Methoden Überladung wird verwendet, um die letzten drei Elemente des Arrays zu sortieren, die dann angezeigt werden. Die <xref:System.Array.Sort%60%602(%60%600[],%60%601[],System.Int32,System.Int32,System.Collections.Generic.IComparer{%60%600})> generische Methoden Überladung wird mit verwendet `ReverseCompare` , um die letzten drei Elemente in umgekehrter Reihenfolge zu sortieren. Die umfassend verwirrten Dinosaurier werden erneut angezeigt.  
  
> [!NOTE]
>  Die Aufrufe der <xref:System.Array.Sort%60%601(%60%600[],System.Collections.Generic.IComparer{%60%600})> generischen-Methode und der- <xref:System.Array.BinarySearch%60%601(%60%600[],%60%600,System.Collections.Generic.IComparer{%60%600})> Methode unterscheiden sich nicht von Aufrufen ihrer nicht generischen Entsprechungen, da Visual Basic, c# und C++ den Typ des generischen Typparameters vom Typ des ersten Arguments ableiten. Wenn Sie die [Ildasm.exe (IL-Disassembler)](/dotnet/framework/tools/ildasm-exe-il-disassembler) verwenden, um die MSIL (Microsoft Intermediate Language) zu überprüfen, können Sie sehen, dass die generischen Methoden aufgerufen werden.  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb" id="Snippet1"::: 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die untere <paramref name="array" />-Grenze.  
  
Oder 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="array" /> an.</exception>
        <exception cref="T:System.InvalidOperationException">In einem oder mehreren Elementen in <paramref name="array" /> ist die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht implementiert.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length, System.Collections.Generic.IComparer&lt;T&gt; comparer);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * int * int * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, index, length, comparer)" />
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length, System.Collections.Generic.IComparer&lt;T&gt;? comparer);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu sortierende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="index">Der Startindex des zu sortierenden Bereichs.</param>
        <param name="length">Die Anzahl der Elemente im zu sortierenden Bereich.</param>
        <param name="comparer">Die Implementierung der generischen <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle, die für den Vergleich von Elementen verwendet werden soll, oder <see langword="null" />, um die Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle der einzelnen Elemente zu verwenden.</param>
        <summary>Sortiert die Elemente in einem Bereich von Elementen im <see cref="T:System.Array" /> mithilfe der angegebenen generischen <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparer` ist `null` , muss jedes Element innerhalb des angegebenen Bereichs von Elementen in `array` die <xref:System.IComparable%601> generische-Schnittstelle implementieren, damit Vergleiche mit jedem anderen Element in möglich sind `array` .  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet den introspektiven Sort-Algorithmus (Introsort) wie folgt:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein [Einfügungs](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 * Protokoll<sup>N</sup>überschreitet, wobei *N* der Bereich des Eingabe Arrays ist, wird ein [Heapsort](https://en.wikipedia.org/wiki/Heapsort) -Algorithmus verwendet.  
  
-   Andernfalls wird ein [Quicksort](https://en.wikipedia.org/wiki/Quicksort) -Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Diese Methode ist ein O ( `n` log `n` )-Vorgang, bei dem gleich `n` ist `length` .  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Array.Sort%60%601(%60%600[],System.Int32,System.Int32)> generische Methoden Überladung und die <xref:System.Array.Sort%60%602(%60%600[],%60%601[],System.Int32,System.Int32,System.Collections.Generic.IComparer{%60%600})> generische Methoden Überladung zum Sortieren eines Bereichs in einem Array veranschaulicht.  
  
 Im Codebeispiel wird ein alternativer Vergleich für Zeichen folgen mit dem Namen definiert `ReverseCompare` , der `IComparer<string>` die `IComparer(Of String)` `IComparer<String^>` generische Schnittstelle (in Visual Basic Visual C++) implementiert. Der Vergleich Ruft die- <xref:System.String.CompareTo(System.String)> Methode auf und kehrt die Reihenfolge der Vergleichs Elemente um, sodass die Zeichen folgen nicht zu hoch, sondern zu niedrig sortiert werden.  
  
 Im Codebeispiel wird ein Array von Dinosaurier Namen erstellt und angezeigt, das aus drei HERBIVORES gefolgt von drei Fleisch freten (Tyrannosaurids) besteht. Die <xref:System.Array.Sort%60%601(%60%600[],System.Int32,System.Int32)> generische Methoden Überladung wird verwendet, um die letzten drei Elemente des Arrays zu sortieren, die dann angezeigt werden. Die <xref:System.Array.Sort%60%602(%60%600[],%60%601[],System.Int32,System.Int32,System.Collections.Generic.IComparer{%60%600})> generische Methoden Überladung wird mit verwendet `ReverseCompare` , um die letzten drei Elemente in umgekehrter Reihenfolge zu sortieren. Die umfassend verwirrten Dinosaurier werden erneut angezeigt.  
  
> [!NOTE]
>  Die Aufrufe der <xref:System.Array.Sort%60%601(%60%600[],System.Collections.Generic.IComparer{%60%600})> generischen-Methode und der- <xref:System.Array.BinarySearch%60%601(%60%600[],%60%600,System.Collections.Generic.IComparer{%60%600})> Methode unterscheiden sich nicht von Aufrufen ihrer nicht generischen Entsprechungen, da Visual Basic, c# und C++ den Typ des generischen Typparameters vom Typ des ersten Arguments ableiten. Wenn Sie die [Ildasm.exe (IL-Disassembler)](/dotnet/framework/tools/ildasm-exe-il-disassembler) verwenden, um die MSIL (Microsoft Intermediate Language) zu überprüfen, können Sie sehen, dass die generischen Methoden aufgerufen werden.  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die untere <paramref name="array" />-Grenze.  
  
Oder 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="array" /> an.  
  
Oder 
Die Implementierung von <paramref name="comparer" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und in einem oder mehreren Elementen im <paramref name="array" /> ist die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht implementiert.</exception>
        <block subset="none" type="usage"><para>In der .NET Framework 4 und früheren Versionen wurde nur der QuickSort-Algorithmus verwendet. Die Quicksort identifiziert ungültige Vergleiche in einigen Situationen, in denen der Sortiervorgang eine <see cref="T:System.IndexOutOfRangeException" /> Ausnahme auslöst, und löst eine <see cref="T:System.ArgumentException" /> Ausnahme an den Aufrufer aus. Ab [!INCLUDE[net_v45](~/includes/net-v45-md.md)] ist es möglich, dass von zuvor ausgelöste Sortiervorgänge <see cref="T:System.ArgumentException" /> keine Ausnahme auslösen, da die einfügesortier-und Heapsort-Algorithmen keinen ungültigen Vergleich erkennen. Dies gilt größtenteils für Arrays mit weniger als oder gleich 16 Elementen.</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] -&gt; unit" Usage="System.Array.Sort (keys, items)" />
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[]? keys, TValue[]? items);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Der Typ der Elemente des Schlüsselarrays.</typeparam>
        <typeparam name="TValue">Der Typ der Elemente des Elementarrays.</typeparam>
        <param name="keys">Das eindimensionale nullbasierte <see cref="T:System.Array" /> mit den zu sortierenden Schlüsseln.</param>
        <param name="items">Das eindimensionale nullbasierte <see cref="T:System.Array" />, das die den Schlüsseln in <paramref name="keys" /> entsprechenden Elemente enthält, oder <see langword="null" />, um nur <paramref name="keys" /> zu sortieren.</param>
        <summary>Sortiert ein Paar von <see cref="T:System.Array" />-Objekten (das eine enthält die Schlüssel und das andere die entsprechenden Werte) nach den Schlüsseln im ersten <see cref="T:System.Array" /> und verwendet dabei die Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle jedes Schlüssels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel in der `keys` <xref:System.Array> verfügt über ein entsprechendes Element in der `items` <xref:System.Array> . Wenn eine Taste während der Sortierung neu positioniert wird, wird das entsprechende Element in auf `items` <xref:System.Array> ähnliche Weise neu positioniert. Daher wird das `items` <xref:System.Array> nach der Anordnung der entsprechenden Schlüssel in der sortiert `keys` <xref:System.Array> .  
  
 Jeder Schlüssel in `keys` <xref:System.Array> muss die generische- <xref:System.IComparable%601> Schnittstelle implementieren, damit Vergleiche mit jedem anderen Schlüssel möglich sind.  
  
 Sie können sortieren, wenn mehr Elemente als Schlüssel vorhanden sind, aber die Elemente, die keine entsprechenden Schlüssel aufweisen, werden nicht sortiert. Sie können nicht sortieren, wenn mehr Schlüssel als Elemente vorhanden sind. Dadurch wird eine ausgelöst <xref:System.ArgumentException> .  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet den introspektiven Sort-Algorithmus (Introsort) wie folgt:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elemente ist, wird ein [Einfügungs](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 * Protokoll<sup>N</sup>überschreitet, wobei *N* der Bereich des Eingabe Arrays ist, wird ein [Heapsort](https://en.wikipedia.org/wiki/Heapsort) -Algorithmus verwendet.  
  
-   Andernfalls wird ein [Quicksort](https://en.wikipedia.org/wiki/Quicksort) -Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Bei dieser Methode handelt es sich um einen O ( `n` log `n` )-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> von ist `array` .  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die <xref:System.Array.Sort%60%602(%60%600[],%60%601[])> <xref:System.Array.Sort%60%602(%60%600[],%60%601[],System.Collections.Generic.IComparer{%60%600})> <xref:System.Array.Sort%60%602(%60%600[],%60%601[],System.Int32,System.Int32)> <xref:System.Array.Sort%60%602(%60%600[],%60%601[],System.Int32,System.Int32,System.Collections.Generic.IComparer{%60%600})> generischen Methoden Überladungen,, und veranschaulicht, um Paare von Arrays zu sortieren, die Schlüssel und Werte darstellen.  
  
 Im Codebeispiel wird ein alternativer Vergleich für Zeichen folgen mit dem Namen definiert `ReverseCompare` , der `IComparer<string>` die `IComparer(Of String)` `IComparer<String^>` generische Schnittstelle (in Visual Basic Visual C++) implementiert. Der Vergleich Ruft die- <xref:System.String.CompareTo(System.String)> Methode auf und kehrt die Reihenfolge der Vergleichs Elemente um, sodass die Zeichen folgen nicht zu hoch, sondern zu niedrig sortiert werden.  
  
 Im Codebeispiel wird ein Array von Dinosaurier Namen (den Schlüsseln) und ein Array aus ganzen Zahlen erstellt und angezeigt, das die maximale Länge der einzelnen Dinosaurier in Meter (die Werte) darstellt. Die Arrays werden dann sortiert und mehrmals angezeigt:  
  
-   Die- <xref:System.Array.Sort%60%602(%60%600[],%60%601[])> Überladung wird verwendet, um beide Arrays in der Reihenfolge der Dinosaurier Namen im ersten Array zu sortieren.  
  
-   Die <xref:System.Array.Sort%60%602(%60%600[],%60%601[],System.Collections.Generic.IComparer{%60%600})> -Überladung und eine Instanz von `ReverseCompare` werden verwendet, um die Sortierreihenfolge der paarweise Arrays umzukehren.  
  
-   Die- <xref:System.Array.Sort%60%602(%60%600[],%60%601[],System.Int32,System.Int32)> Überladung wird zum Sortieren der letzten drei Elemente beider Arrays verwendet.  
  
-   Mit der- <xref:System.Array.Sort%60%602(%60%600[],%60%601[],System.Int32,System.Int32,System.Collections.Generic.IComparer{%60%600})> Überladung werden die letzten drei Elemente beider Arrays in umgekehrter Reihenfolge sortiert.  
  
> [!NOTE]
>  Die Aufrufe der generischen Methoden unterscheiden sich nicht von den Aufrufen ihrer nicht generischen Entsprechungen, da Visual Basic, c# und C++ den Typ des generischen Typparameters vom Typ der ersten beiden Argumente ableiten. Wenn Sie die [Ildasm.exe (IL-Disassembler)](/dotnet/framework/tools/ildasm-exe-il-disassembler) verwenden, um die MSIL (Microsoft Intermediate Language) zu überprüfen, können Sie sehen, dass die generischen Methoden aufgerufen werden.  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> ist nicht <see langword="null" />, und die Untergrenze von <paramref name="keys" /> entspricht nicht der Untergrenze von <paramref name="items" />.  
  
Oder 
 <paramref name="items" /> ist nicht <see langword="null" />, und die Länge von <paramref name="keys" /> ist größer als die Länge von <paramref name="items" />.</exception>
        <exception cref="T:System.InvalidOperationException">In einem oder mehreren Elementen im <paramref name="keys" /><see cref="T:System.Array" /> ist die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht implementiert.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; unit" Usage="System.Array.Sort (keys, items, comparer)" />
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[]? keys, TValue[]? items, System.Collections.Generic.IComparer&lt;TKey&gt;? comparer);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Der Typ der Elemente des Schlüsselarrays.</typeparam>
        <typeparam name="TValue">Der Typ der Elemente des Elementarrays.</typeparam>
        <param name="keys">Das eindimensionale nullbasierte <see cref="T:System.Array" /> mit den zu sortierenden Schlüsseln.</param>
        <param name="items">Das eindimensionale nullbasierte <see cref="T:System.Array" />, das die den Schlüsseln in <paramref name="keys" /> entsprechenden Elemente enthält, oder <see langword="null" />, um nur <paramref name="keys" /> zu sortieren.</param>
        <param name="comparer">Die Implementierung der generischen <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle, die für den Vergleich von Elementen verwendet werden soll, oder <see langword="null" />, um die Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle der einzelnen Elemente zu verwenden.</param>
        <summary>Sortiert ein Paar von <see cref="T:System.Array" />-Objekten (das eine enthält die Schlüssel und das andere die entsprechenden Werte) nach den Schlüsseln im ersten <see cref="T:System.Array" /> und verwendet dabei die angegebene generische <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel in der `keys` <xref:System.Array> verfügt über ein entsprechendes Element in der `items` <xref:System.Array> . Wenn eine Taste während der Sortierung neu positioniert wird, wird das entsprechende Element in auf `items` <xref:System.Array> ähnliche Weise neu positioniert. Daher wird das `items` <xref:System.Array> nach der Anordnung der entsprechenden Schlüssel in der sortiert `keys` <xref:System.Array> .  
  
 Wenn den Wert `comparer` `null` hat, muss jeder Schlüssel in der `keys` <xref:System.Array> die <xref:System.IComparable%601> generische-Schnittstelle implementieren, damit Vergleiche mit jedem anderen Schlüssel möglich sind.  
  
 Sie können sortieren, wenn mehr Elemente als Schlüssel vorhanden sind, aber die Elemente, die keine entsprechenden Schlüssel aufweisen, werden nicht sortiert. Sie können nicht sortieren, wenn mehr Schlüssel als Elemente vorhanden sind. Dadurch wird eine ausgelöst <xref:System.ArgumentException> .  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet den introspektiven Sort-Algorithmus (Introsort) wie folgt:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein [Einfügungs](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 * Protokoll<sup>N</sup>überschreitet, wobei *N* der Bereich des Eingabe Arrays ist, wird ein [Heapsort](https://en.wikipedia.org/wiki/Heapsort) -Algorithmus verwendet.  
  
-   Andernfalls wird ein [Quicksort](https://en.wikipedia.org/wiki/Quicksort) -Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Bei dieser Methode handelt es sich um einen O ( `n` log `n` )-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> von ist `array` .

## Examples  
 Im folgenden Codebeispiel werden die <xref:System.Array.Sort%60%602(%60%600[],%60%601[])> \] <xref:System.Array.Sort%60%602(%60%600[],%60%601[],System.Collections.Generic.IComparer{%60%600})> <xref:System.Array.Sort%60%602(%60%600[],%60%601[],System.Int32,System.Int32)> generischen Methoden Überladungen, [,, und veranschaulicht <xref:System.Array.Sort%60%602(%60%600[],%60%601[],System.Int32,System.Int32,System.Collections.Generic.IComparer{%60%600})> , um Paare von Arrays zu sortieren, die Schlüssel und Werte darstellen.  
  
 Im Codebeispiel wird ein alternativer Vergleich für Zeichen folgen mit dem Namen definiert `ReverseCompare` , der `IComparer<string>` die `IComparer(Of String)` `IComparer<String^>` generische Schnittstelle (in Visual Basic Visual C++) implementiert. Der Vergleich Ruft die- <xref:System.String.CompareTo(System.String)> Methode auf und kehrt die Reihenfolge der Vergleichs Elemente um, sodass die Zeichen folgen nicht zu hoch, sondern zu niedrig sortiert werden.  
  
 Im Codebeispiel wird ein Array von Dinosaurier Namen (den Schlüsseln) und ein Array aus ganzen Zahlen erstellt und angezeigt, das die maximale Länge der einzelnen Dinosaurier in Meter (die Werte) darstellt. Die Arrays werden dann sortiert und mehrmals angezeigt:  
  
-   Die- <xref:System.Array.Sort%60%602(%60%600[],%60%601[])> Überladung wird verwendet, um beide Arrays in der Reihenfolge der Dinosaurier Namen im ersten Array zu sortieren.  
  
-   Die <xref:System.Array.Sort%60%602(%60%600[],%60%601[],System.Collections.Generic.IComparer{%60%600})> -Überladung und eine Instanz von `ReverseCompare` werden verwendet, um die Sortierreihenfolge der paarweise Arrays umzukehren.  
  
-   Die- <xref:System.Array.Sort%60%602(%60%600[],%60%601[],System.Int32,System.Int32)> Überladung wird zum Sortieren der letzten drei Elemente beider Arrays verwendet.  
  
-   Mit der- <xref:System.Array.Sort%60%602(%60%600[],%60%601[],System.Int32,System.Int32,System.Collections.Generic.IComparer{%60%600})> Überladung werden die letzten drei Elemente beider Arrays in umgekehrter Reihenfolge sortiert.  
  
> [!NOTE]
>  Die Aufrufe der generischen Methoden unterscheiden sich nicht von den Aufrufen ihrer nicht generischen Entsprechungen, da Visual Basic, c# und C++ den Typ des generischen Typparameters vom Typ der ersten beiden Argumente ableiten. Wenn Sie die [Ildasm.exe (IL-Disassembler)](/dotnet/framework/tools/ildasm-exe-il-disassembler) verwenden, um die MSIL (Microsoft Intermediate Language) zu überprüfen, können Sie sehen, dass die generischen Methoden aufgerufen werden.  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> ist nicht <see langword="null" />, und die Untergrenze von <paramref name="keys" /> entspricht nicht der Untergrenze von <paramref name="items" />.  
  
Oder 
 <paramref name="items" /> ist nicht <see langword="null" />, und die Länge von <paramref name="keys" /> ist größer als die Länge von <paramref name="items" />.  
  
Oder 
Die Implementierung von <paramref name="comparer" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und in einem oder mehreren Elementen in <paramref name="keys" /><see cref="T:System.Array" /> ist die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht implementiert.</exception>
        <block subset="none" type="usage"><para>In der .NET Framework 4 und früheren Versionen wurde nur der QuickSort-Algorithmus verwendet. Die Quicksort identifiziert ungültige Vergleiche in einigen Situationen, in denen der Sortiervorgang eine <see cref="T:System.IndexOutOfRangeException" /> Ausnahme auslöst, und löst eine <see cref="T:System.ArgumentException" /> Ausnahme an den Aufrufer aus. Ab [!INCLUDE[net_v45](~/includes/net-v45-md.md)] ist es möglich, dass von zuvor ausgelöste Sortiervorgänge <see cref="T:System.ArgumentException" /> keine Ausnahme auslösen, da die einfügesortier-und Heapsort-Algorithmen keinen ungültigen Vergleich erkennen. Dies gilt größtenteils für Arrays mit weniger als oder gleich 16 Elementen.</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * int * int -&gt; unit" Usage="System.Array.Sort (keys, items, index, length)" />
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[]? keys, TValue[]? items, int index, int length);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Der Typ der Elemente des Schlüsselarrays.</typeparam>
        <typeparam name="TValue">Der Typ der Elemente des Elementarrays.</typeparam>
        <param name="keys">Das eindimensionale nullbasierte <see cref="T:System.Array" /> mit den zu sortierenden Schlüsseln.</param>
        <param name="items">Das eindimensionale nullbasierte <see cref="T:System.Array" />, das die den Schlüsseln in <paramref name="keys" /> entsprechenden Elemente enthält, oder <see langword="null" />, um nur <paramref name="keys" /> zu sortieren.</param>
        <param name="index">Der Startindex des zu sortierenden Bereichs.</param>
        <param name="length">Die Anzahl der Elemente im zu sortierenden Bereich.</param>
        <summary>Sortiert einen Bereich von Elementen in einem Paar von <see cref="T:System.Array" />-Objekten (das eine enthält die Schlüssel und das andere die entsprechenden Werte) nach den Schlüsseln im ersten <see cref="T:System.Array" /> und verwendet dabei die Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle jedes Schlüssels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel in der `keys` <xref:System.Array> verfügt über ein entsprechendes Element in der `items` <xref:System.Array> . Wenn eine Taste während der Sortierung neu positioniert wird, wird das entsprechende Element in auf `items` <xref:System.Array> ähnliche Weise neu positioniert. Daher wird das `items` <xref:System.Array> nach der Anordnung der entsprechenden Schlüssel in der sortiert `keys` <xref:System.Array> .  
  
 Jeder Schlüssel innerhalb des angegebenen Bereichs von Elementen in der `keys` <xref:System.Array> muss die <xref:System.IComparable%601> generische-Schnittstelle implementieren, damit Vergleiche mit jedem anderen Schlüssel möglich sind.  
  
 Sie können sortieren, wenn mehr Elemente als Schlüssel vorhanden sind, aber die Elemente, die keine entsprechenden Schlüssel aufweisen, werden nicht sortiert. Sie können nicht sortieren, wenn mehr Schlüssel als Elemente vorhanden sind. Dadurch wird eine ausgelöst <xref:System.ArgumentException> .  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet den introspektiven Sort-Algorithmus (Introsort) wie folgt:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein [Einfügungs](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 * Protokoll<sup>N</sup>überschreitet, wobei *N* der Bereich des Eingabe Arrays ist, wird ein [Heapsort](https://en.wikipedia.org/wiki/Heapsort) -Algorithmus verwendet.  
  
-   Andernfalls wird ein [Quicksort](https://en.wikipedia.org/wiki/Quicksort) -Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Diese Methode ist ein O ( `n` log `n` )-Vorgang, bei dem gleich `n` ist `length` .
  
## Examples  
 Im folgenden Codebeispiel werden die <xref:System.Array.Sort%60%602(%60%600[],%60%601[])> <xref:System.Array.Sort%60%602(%60%600[],%60%601[],System.Collections.Generic.IComparer{%60%600})> <xref:System.Array.Sort%60%602(%60%600[],%60%601[],System.Int32,System.Int32)> <xref:System.Array.Sort%60%602(%60%600[],%60%601[],System.Int32,System.Int32,System.Collections.Generic.IComparer{%60%600})> generischen Methoden Überladungen,, und veranschaulicht, um Paare von Arrays zu sortieren, die Schlüssel und Werte darstellen.  
  
 Im Codebeispiel wird ein alternativer Vergleich für Zeichen folgen mit dem Namen definiert `ReverseCompare` , der `IComparer<string>` die `IComparer(Of String)` `IComparer<String^>` generische Schnittstelle (in Visual Basic Visual C++) implementiert. Der Vergleich Ruft die- <xref:System.String.CompareTo(System.String)> Methode auf und kehrt die Reihenfolge der Vergleichs Elemente um, sodass die Zeichen folgen nicht zu hoch, sondern zu niedrig sortiert werden.  
  
 Im Codebeispiel wird ein Array von Dinosaurier Namen (den Schlüsseln) und ein Array aus ganzen Zahlen erstellt und angezeigt, das die maximale Länge der einzelnen Dinosaurier in Meter (die Werte) darstellt. Die Arrays werden dann sortiert und mehrmals angezeigt:  
  
-   Die- <xref:System.Array.Sort%60%602(%60%600[],%60%601[])> Überladung wird verwendet, um beide Arrays in der Reihenfolge der Dinosaurier Namen im ersten Array zu sortieren.  
  
-   Die <xref:System.Array.Sort%60%602(%60%600[],%60%601[],System.Collections.Generic.IComparer{%60%600})> -Überladung und eine Instanz von `ReverseCompare` werden verwendet, um die Sortierreihenfolge der paarweise Arrays umzukehren.  
  
-   Die- <xref:System.Array.Sort%60%602(%60%600[],%60%601[],System.Int32,System.Int32)> Überladung wird zum Sortieren der letzten drei Elemente beider Arrays verwendet.  
  
-   Mit der- <xref:System.Array.Sort%60%602(%60%600[],%60%601[],System.Int32,System.Int32,System.Collections.Generic.IComparer{%60%600})> Überladung werden die letzten drei Elemente beider Arrays in umgekehrter Reihenfolge sortiert.  
  
> [!NOTE]
> Die Aufrufe der generischen Methoden unterscheiden sich nicht von den Aufrufen ihrer nicht generischen Entsprechungen, da Visual Basic, c# und C++ den Typ des generischen Typparameters vom Typ der ersten beiden Argumente ableiten. Wenn Sie die [Ildasm.exe (IL-Disassembler)](/dotnet/framework/tools/ildasm-exe-il-disassembler) verwenden, um die MSIL (Microsoft Intermediate Language) zu überprüfen, können Sie sehen, dass die generischen Methoden aufgerufen werden.  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb" id="Snippet1"::: 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die untere <paramref name="keys" />-Grenze.  
  
Oder 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> ist nicht <see langword="null" />, und die Untergrenze von <paramref name="keys" /> entspricht nicht der Untergrenze von <paramref name="items" />.  
  
Oder 
 <paramref name="items" /> ist nicht <see langword="null" />, und die Länge von <paramref name="keys" /> ist größer als die Länge von <paramref name="items" />.  
  
Oder 
 <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="keys" /><see cref="T:System.Array" /> an.  
  
Oder 
 <paramref name="items" /> ist nicht <see langword="null" />, und <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="items" /><see cref="T:System.Array" /> an.</exception>
        <exception cref="T:System.InvalidOperationException">In einem oder mehreren Elementen im <paramref name="keys" /><see cref="T:System.Array" /> ist die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht implementiert.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer, comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * int * int * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; unit" Usage="System.Array.Sort (keys, items, index, length, comparer)" />
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[]? keys, TValue[]? items, int index, int length, System.Collections.Generic.IComparer&lt;TKey&gt;? comparer);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" Index="4" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Der Typ der Elemente des Schlüsselarrays.</typeparam>
        <typeparam name="TValue">Der Typ der Elemente des Elementarrays.</typeparam>
        <param name="keys">Das eindimensionale nullbasierte <see cref="T:System.Array" /> mit den zu sortierenden Schlüsseln.</param>
        <param name="items">Das eindimensionale nullbasierte <see cref="T:System.Array" />, das die den Schlüsseln in <paramref name="keys" /> entsprechenden Elemente enthält, oder <see langword="null" />, um nur <paramref name="keys" /> zu sortieren.</param>
        <param name="index">Der Startindex des zu sortierenden Bereichs.</param>
        <param name="length">Die Anzahl der Elemente im zu sortierenden Bereich.</param>
        <param name="comparer">Die Implementierung der generischen <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle, die für den Vergleich von Elementen verwendet werden soll, oder <see langword="null" />, um die Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle der einzelnen Elemente zu verwenden.</param>
        <summary>Sortiert einen Bereich von Elementen in einem Paar von <see cref="T:System.Array" />-Objekten (das eine enthält die Schlüssel und das andere die entsprechenden Werte) nach den Schlüsseln im ersten <see cref="T:System.Array" /> und verwendet dabei die angegebene generische <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel in der `keys` <xref:System.Array> verfügt über ein entsprechendes Element in der `items` <xref:System.Array> . Wenn eine Taste während der Sortierung neu positioniert wird, wird das entsprechende Element in auf `items` <xref:System.Array> ähnliche Weise neu positioniert. Daher wird das `items` <xref:System.Array> nach der Anordnung der entsprechenden Schlüssel in der sortiert `keys` <xref:System.Array> .  
  
 Wenn `comparer` ist `null` , muss jeder Schlüssel innerhalb des angegebenen Bereichs von Elementen in der `keys` <xref:System.Array> die <xref:System.IComparable%601> generische-Schnittstelle implementieren, damit Vergleiche mit jedem anderen Schlüssel möglich sind.  
  
 Sie können sortieren, wenn mehr Elemente als Schlüssel vorhanden sind, aber die Elemente, die keine entsprechenden Schlüssel aufweisen, werden nicht sortiert. Sie können nicht sortieren, wenn mehr Schlüssel als Elemente vorhanden sind. Dadurch wird eine ausgelöst <xref:System.ArgumentException> .  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet den introspektiven Sort-Algorithmus (Introsort) wie folgt:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein [Einfügungs](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 * Protokoll<sup>N</sup>überschreitet, wobei *N* der Bereich des Eingabe Arrays ist, wird ein [Heapsort](https://en.wikipedia.org/wiki/Heapsort) -Algorithmus verwendet.  
  
-   Andernfalls wird ein [Quicksort](https://en.wikipedia.org/wiki/Quicksort) -Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Diese Methode ist ein O ( `n` log `n` )-Vorgang, bei dem gleich `n` ist `length` .
  
## Examples  
 Im folgenden Codebeispiel werden die <xref:System.Array.Sort%60%602(%60%600[],%60%601[])> <xref:System.Array.Sort%60%602(%60%600[],%60%601[],System.Collections.Generic.IComparer{%60%600})> <xref:System.Array.Sort%60%602(%60%600[],%60%601[],System.Int32,System.Int32)> <xref:System.Array.Sort%60%602(%60%600[],%60%601[],System.Int32,System.Int32,System.Collections.Generic.IComparer{%60%600})> generischen Methoden Überladungen,, und veranschaulicht, um Paare von Arrays zu sortieren, die Schlüssel und Werte darstellen.  
  
 Im Codebeispiel wird ein alternativer Vergleich für Zeichen folgen mit dem Namen definiert `ReverseCompare` , der `IComparer<string>` die `IComparer(Of String)` `IComparer<String^>` generische Schnittstelle (in Visual Basic Visual C++) implementiert. Der Vergleich Ruft die- <xref:System.String.CompareTo(System.String)> Methode auf und kehrt die Reihenfolge der Vergleichs Elemente um, sodass die Zeichen folgen nicht zu hoch, sondern zu niedrig sortiert werden.  
  
 Im Codebeispiel wird ein Array von Dinosaurier Namen (den Schlüsseln) und ein Array aus ganzen Zahlen erstellt und angezeigt, das die maximale Länge der einzelnen Dinosaurier in Meter (die Werte) darstellt. Die Arrays werden dann sortiert und mehrmals angezeigt:  
  
-   Die- <xref:System.Array.Sort%60%602(%60%600[],%60%601[])> Überladung wird verwendet, um beide Arrays in der Reihenfolge der Dinosaurier Namen im ersten Array zu sortieren.  
  
-   Die <xref:System.Array.Sort%60%602(%60%600[],%60%601[],System.Collections.Generic.IComparer{%60%600})> -Überladung und eine Instanz von `ReverseCompare` werden verwendet, um die Sortierreihenfolge der paarweise Arrays umzukehren.  
  
-   Die- <xref:System.Array.Sort%60%602(%60%600[],%60%601[],System.Int32,System.Int32)> Überladung wird zum Sortieren der letzten drei Elemente beider Arrays verwendet.  
  
-   Mit der- <xref:System.Array.Sort%60%602(%60%600[],%60%601[],System.Int32,System.Int32,System.Collections.Generic.IComparer{%60%600})> Überladung werden die letzten drei Elemente beider Arrays in umgekehrter Reihenfolge sortiert.  
  
> [!NOTE]
> Die Aufrufe der generischen Methoden unterscheiden sich nicht von den Aufrufen ihrer nicht generischen Entsprechungen, da Visual Basic, c# und C++ den Typ des generischen Typparameters vom Typ der ersten beiden Argumente ableiten. Wenn Sie die [Ildasm.exe (IL-Disassembler)](/dotnet/framework/tools/ildasm-exe-il-disassembler) verwenden, um die MSIL (Microsoft Intermediate Language) zu überprüfen, können Sie sehen, dass die generischen Methoden aufgerufen werden.  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die untere <paramref name="keys" />-Grenze.  
  
Oder 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> ist nicht <see langword="null" />, und die Untergrenze von <paramref name="keys" /> entspricht nicht der Untergrenze von <paramref name="items" />.  
  
Oder 
 <paramref name="items" /> ist nicht <see langword="null" />, und die Länge von <paramref name="keys" /> ist größer als die Länge von <paramref name="items" />.  
  
Oder 
 <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="keys" /><see cref="T:System.Array" /> an.  
  
Oder 
 <paramref name="items" /> ist nicht <see langword="null" />, und <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="items" /><see cref="T:System.Array" /> an.  
  
Oder 
Die Implementierung von <paramref name="comparer" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und in einem oder mehreren Elementen in <paramref name="keys" /><see cref="T:System.Array" /> ist die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht implementiert.</exception>
        <block subset="none" type="usage"><para>In der .NET Framework 4 und früheren Versionen wurde nur der QuickSort-Algorithmus verwendet. Die Quicksort identifiziert ungültige Vergleiche in einigen Situationen, in denen der Sortiervorgang eine <see cref="T:System.IndexOutOfRangeException" /> Ausnahme auslöst, und löst eine <see cref="T:System.ArgumentException" /> Ausnahme an den Aufrufer aus. Ab [!INCLUDE[net_v45](~/includes/net-v45-md.md)] ist es möglich, dass von zuvor ausgelöste Sortiervorgänge <see cref="T:System.ArgumentException" /> keine Ausnahme auslösen, da die einfügesortier-und Heapsort-Algorithmen keinen ungültigen Vergleich erkennen. Dies gilt größtenteils für Arrays mit weniger als oder gleich 16 Elementen.</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Array.SyncRoot" />
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SyncRoot As Object" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ SyncRoot { System::Object ^ get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab, mit dem der Zugriff auf <see cref="T:System.Array" /> synchronisiert werden kann.</summary>
        <value>Ein Objekt, mit dem der Zugriff auf <see cref="T:System.Array" /> synchronisiert werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft implementiert die- <xref:System.Collections.ICollection?displayProperty=nameWithType> Schnittstelle.  
  
 .NET Framework-Klassen basierend auf <xref:System.Array> Geben Sie ihre eigene synchronisierte Version der Auflistung mithilfe der <xref:System.Array.SyncRoot%2A> Eigenschaft.  
  
 Klassen, die Arrays verwenden, können auch Ihre eigene Synchronisierung mithilfe der- <xref:System.Array.SyncRoot%2A> Eigenschaft implementieren. Der Synchronisierungs Code muss Vorgänge für die der Auflistung ausführen `SyncRoot` , nicht direkt für die Auflistung. Dies gewährleistet die einwandfreie Funktion von Auflistungen, die von anderen Objekten abgeleitet sind. Insbesondere wird die ordnungsgemäße Synchronisierung mit anderen Threads verwaltet, die die Auflistung möglicherweise gleichzeitig ändern. Beachten Sie, dass einige Implementierungen von <xref:System.Array.SyncRoot%2A> möglicherweise die selbst zurückgeben <xref:System.Array> .  
  
 Das Auflisten durch eine Auflistung ist intrinsisch keine Thread sichere Prozedur. Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst. Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie ein Array während der gesamten Enumeration mithilfe der- <xref:System.Array.SyncRoot%2A> Eigenschaft gesperrt wird.  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.ICollection.Count" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#Count" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Count As Integer Implements ICollection.Count" />
      <MemberSignature Language="C++ CLI" Value="property int System::Collections::ICollection::Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.System.Collections.ICollection.Count : int" Usage="System.Collections.ICollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Elemente ab, die in <see cref="T:System.Array" /> enthalten sind.</summary>
        <value>Die Anzahl der in der Auflistung enthaltenen Elemente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.ICollection>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.System.Collections.ICollection.IsSynchronized : bool" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Zugriff auf die <see cref="T:System.Array" /> synchronisiert (threadsicher) ist.</summary>
        <value>TRUE, wenn der Zugriff auf <see cref="T:System.Array" /> synchronisiert (threadsicher) ist, andernfalls FALSE.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.System.Collections.ICollection.SyncRoot : obj" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab, mit dem der Zugriff auf <see cref="T:System.Array" /> synchronisiert werden kann.</summary>
        <value>Ein Objekt, mit dem der Zugriff auf <see cref="T:System.Array" /> synchronisiert werden kann.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (value As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ value) = System::Collections::IList::Add;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IList.Add : obj -&gt; int&#xA;override this.System.Collections.IList.Add : obj -&gt; int" Usage="array.System.Collections.IList.Add value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Das dem <see cref="T:System.Collections.IList" /> hinzuzufügende Objekt.</param>
        <summary>Beim Aufrufen dieser Methode wird immer eine <see cref="T:System.NotSupportedException" />-Ausnahme ausgelöst.</summary>
        <returns>Das Hinzufügen eines Werts zu einem Array wird nicht unterstützt. Es wird kein Wert zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalerweise fügt eine-Implementierung einer Auflistung <xref:System.Collections.IList.Add%2A?displayProperty=nameWithType> einen Member hinzu. Da Arrays jedoch eine Fixed-Größe aufweisen (die- <xref:System.Array.IsFixedSize%2A> Eigenschaft gibt immer zurück `true` ), löst diese Methode immer eine- <xref:System.NotSupportedException> Ausnahme aus.  
  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IList>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> hat eine feste Größe.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Clear">
      <MemberSignature Language="C#" Value="void IList.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements IList.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Clear() = System::Collections::IList::Clear;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IList.Clear : unit -&gt; unit&#xA;override this.System.Collections.IList.Clear : unit -&gt; unit" Usage="array.System.Collections.IList.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle Elemente aus <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IList>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> ist schreibgeschützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (value As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ value) = System::Collections::IList::Contains;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IList.Contains : obj -&gt; bool&#xA;override this.System.Collections.IList.Contains : obj -&gt; bool" Usage="array.System.Collections.IList.Contains value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Das in der aktuellen Liste zu suchende Objekt. Das gesuchte Element kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Bestimmt, ob sich ein Element in <see cref="T:System.Collections.IList" /> befindet.</summary>
        <returns><see langword="true" />, wenn das <paramref name="value" /> in der <see cref="T:System.Collections.IList" /> gefunden wird, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IList>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (value As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ value) = System::Collections::IList::IndexOf;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IList.IndexOf : obj -&gt; int&#xA;override this.System.Collections.IList.IndexOf : obj -&gt; int" Usage="array.System.Collections.IList.IndexOf value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Das in der aktuellen Liste zu suchende Objekt.</param>
        <summary>Bestimmt den Index eines bestimmten Elements in der <see cref="T:System.Collections.IList" />.</summary>
        <returns>Der Index von value, falls in der Liste enthalten, andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IList>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, value As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ value) = System::Collections::IList::Insert;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IList.Insert : int * obj -&gt; unit&#xA;override this.System.Collections.IList.Insert : int * obj -&gt; unit" Usage="array.System.Collections.IList.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Der Index, an dem <paramref name="value" /> eingefügt werden soll.</param>
        <param name="value">Das einzufügende Objekt.</param>
        <summary>Fügt am angegebenen Index ein Element in die <see cref="T:System.Collections.IList" /> ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IList>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kein gültiger Index in <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> ist schreibgeschützt.  
  
- oder - 
<see cref="T:System.Collections.IList" /> hat eine feste Größe.</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="value" /> ist ein NULL-Verweis in der <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.System.Collections.IList.IsFixedSize : bool" Usage="System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die <see cref="T:System.Array" /> eine feste Größe aufweist.</summary>
        <value>TRUE, wenn <see cref="T:System.Array" /> eine feste Größe hat, andernfalls FALSE.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.System.Collections.IList.IsReadOnly : bool" Usage="System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die <see cref="T:System.Array" /> schreibgeschützt ist.</summary>
        <value>TRUE, wenn <see cref="T:System.Array" /> schreibgeschützt ist, andernfalls FALSE.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IList::Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.System.Collections.IList.Item(int) : obj with get, set" Usage="System.Collections.IList.Item" />
      <MemberSignature Language="C#" Value="object? System.Collections.IList.Item[int index] { get; set; }" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der Index des abzurufenden oder festzulegenden Elements.</param>
        <summary>Ruft das Element am angegebenen Index ab oder legt dieses fest.</summary>
        <value>Das Element am angegebenen Index.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IList>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="index" /> ist größer oder gleich <see cref="P:System.Collections.ICollection.Count" />.</exception>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> verfügt nicht über genau eine Dimension.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (value As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ value) = System::Collections::IList::Remove;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IList.Remove : obj -&gt; unit&#xA;override this.System.Collections.IList.Remove : obj -&gt; unit" Usage="array.System.Collections.IList.Remove value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Das aus der <see cref="T:System.Collections.IList" /> zu entfernende Objekt.</param>
        <summary>Entfernt das erste Vorkommen eines angegebenen Objekts aus der <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IList>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> ist schreibgeschützt.  
  
- oder - 
<see cref="T:System.Collections.IList" /> hat eine feste Größe.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.RemoveAt">
      <MemberSignature Language="C#" Value="void IList.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveAt (index As Integer) Implements IList.RemoveAt" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.RemoveAt(int index) = System::Collections::IList::RemoveAt;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IList.RemoveAt : int -&gt; unit&#xA;override this.System.Collections.IList.RemoveAt : int -&gt; unit" Usage="array.System.Collections.IList.RemoveAt index" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der Index des zu entfernenden Elements.</param>
        <summary>Entfernt das <see cref="T:System.Collections.IList" />-Element am angegebenen Index.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IList>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">index ist kein gültiger Index in der <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> ist schreibgeschützt.  
  
- oder - 
<see cref="T:System.Collections.IList" /> hat eine feste Größe.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IStructuralComparable.CompareTo (object other, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralComparable.CompareTo(object other, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (other As Object, comparer As IComparer) As Integer Implements IStructuralComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralComparable.CompareTo(System::Object ^ other, System::Collections::IComparer ^ comparer) = System::Collections::IStructuralComparable::CompareTo;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IStructuralComparable.CompareTo : obj * System.Collections.IComparer -&gt; int&#xA;override this.System.Collections.IStructuralComparable.CompareTo : obj * System.Collections.IComparer -&gt; int" Usage="array.System.Collections.IStructuralComparable.CompareTo (other, comparer)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="other">Das Objekt, das mit der aktuellen Instanz verglichen werden soll.</param>
        <param name="comparer">Ein Objekt, das das aktuelle Objekt und <paramref name="other" /> vergleicht.</param>
        <summary>Bestimmt, ob das aktuelle Auflistungsobjekt in der Sortierreihenfolge vor oder nach einem anderen Objekt oder an derselben Position auftritt.</summary>
        <returns>Eine Ganzzahl, die die Beziehung des aktuellen Auflistungsobjekts zu "other" angibt, wie in der folgenden Tabelle dargestellt.  
  
 <list type="table"><listheader><term> Rückgabewert 
 </term><description> Beschreibung 
 </description></listheader><item><term> -1 
 </term><description> Die aktuelle Instanz tritt vor <paramref name="other" /> auf.  
  
 </description></item><item><term> 0 
 </term><description> Die aktuelle Instanz und <paramref name="other" /> sind gleich.  
  
 </description></item><item><term> 1 
 </term><description> Die aktuelle Instanz folgt auf <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IStructuralComparable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.Equals">
      <MemberSignature Language="C#" Value="bool IStructuralEquatable.Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IStructuralEquatable.Equals(object other, class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As Object, comparer As IEqualityComparer) As Boolean Implements IStructuralEquatable.Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IStructuralEquatable.Equals(System::Object ^ other, System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::Equals;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IStructuralEquatable.Equals : obj * System.Collections.IEqualityComparer -&gt; bool&#xA;override this.System.Collections.IStructuralEquatable.Equals : obj * System.Collections.IEqualityComparer -&gt; bool" Usage="array.System.Collections.IStructuralEquatable.Equals (other, comparer)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="other">Das Objekt, das mit der aktuellen Instanz verglichen werden soll.</param>
        <param name="comparer">Ein Objekt, das bestimmt, ob die aktuelle Instanz und <paramref name="other" /> gleich sind.</param>
        <summary>Bestimmt, ob ein Objekt gleich der aktuellen Instanz ist.</summary>
        <returns><see langword="true" />, wenn die beiden Objekte gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IStructuralEquatable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.GetHashCode">
      <MemberSignature Language="C#" Value="int IStructuralEquatable.GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralEquatable.GetHashCode(class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function GetHashCode (comparer As IEqualityComparer) As Integer Implements IStructuralEquatable.GetHashCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralEquatable.GetHashCode(System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::GetHashCode;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IStructuralEquatable.GetHashCode : System.Collections.IEqualityComparer -&gt; int&#xA;override this.System.Collections.IStructuralEquatable.GetHashCode : System.Collections.IEqualityComparer -&gt; int" Usage="array.System.Collections.IStructuralEquatable.GetHashCode comparer" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="comparer">Ein Objekt, das den Hashcode des aktuellen Objekts berechnet.</param>
        <summary>Gibt einen Hashcode für die aktuelle Instanz zurück.</summary>
        <returns>Der Hashcode für die aktuelle Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IStructuralEquatable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrueForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TrueForAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TrueForAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrueForAll(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TrueForAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member TrueForAll : 'T[] * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Array.TrueForAll (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das eindimensionale nullbasierte <see cref="T:System.Array" />, das auf die Bedingungen geprüft werden soll.</param>
        <param name="match">Das Prädikat, das die Bedingungen definiert, auf die die Elemente geprüft werden sollen.</param>
        <summary>Bestimmt, ob jedes Element im Array die vom angegebenen Prädikat definierten Bedingungen erfüllt.</summary>
        <returns><see langword="true" />, wenn jedes Element im <paramref name="array" /> die vom angegebenen Prädikat definierten Bedingungen erfüllt, andernfalls <see langword="false" />. Wenn keine Elemente im Array vorhanden sind, lautet der Rückgabewert <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die zurückgibt, `true` Wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente von `array` werden einzeln an die <xref:System.Predicate%601> -Klasse, und die Verarbeitung wird beendet, wenn der Delegat `false` für ein beliebiges Element zurückgegeben wird.  
  
 Bei dieser Methode handelt es sich um einen O ( `n` )-Vorgang, wobei `n` der <xref:System.Array.Length%2A> von ist `array` .  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, ob das letzte Zeichen jedes Elements in einem Zeichen folgen Array eine Zahl ist. Es werden zwei Zeichen folgen Arrays erstellt. Das erste Array enthält beide Zeichen folgen, die mit alphabetischen Zeichen enden, und Zeichen folgen, die mit numerischen Zeichen enden. Das zweite Array besteht nur aus Zeichen folgen, die mit numerischen Zeichen enden. Im Beispiel wird auch eine-Methode definiert, `EndWithANumber` deren Signatur dem-Delegaten entspricht <xref:System.Predicate%601> . Das Beispiel übergibt jedes Array zusammen mit einem Delegaten, der <xref:System.Array.TrueForAll%2A> die Methode darstellt, an die-Methode `EndsWithANumber` .  
  
 [!code-csharp[System.Array.TrueForAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall2.cs#2)]
 [!code-vb[System.Array.TrueForAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall2.vb#2)]  
  
 Das folgende Beispiel ähnelt dem ersten, mit dem Unterschied, dass es das Zeichen folgen Array an die-Methode übergibt, <xref:System.Array.TrueForAll%2A> zusammen mit einem Lambda-Ausdruck, der bestimmt, ob ein bestimmtes Array Element mit der Zeichen folgen Darstellung einer Zahl endet.  
  
 [!code-csharp[System.Array.TrueForAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall1.cs#1)]
 [!code-vb[System.Array.TrueForAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall1.vb#1)]  
  
 In beiden Fällen gibt die <xref:System.Array.TrueForAll%2A> Methode zurück, sobald `false` das erste Array Element gefunden wird, das nicht mit einer Zahl endet. Andernfalls wird zurückgegeben, `true` nachdem alle Elemente im Array durchlaufen wurden.  
  
> [!NOTE]
>  Wie beide Beispiele zeigen, ist es in c# und Visual Basic nicht erforderlich, den Delegaten `Predicate<string>` ( `Predicate(Of String)` in Visual Basic) explizit zu erstellen. Diese Sprachen ableiten den korrekten Delegaten aus dem Kontext und erstellen ihn automatisch.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>
