<Type Name="Array" FullName="System.Array">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5ed051d813aa91d0a794c1c9d9da2aebf0e2b4ca" /><Meta Name="ms.sourcegitcommit" Value="6c0b6310824199ff476e4a9eec6e9ed0bd1a51c9" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/05/2019" /><Meta Name="ms.locfileid" Value="74874389" /></Metadata><TypeSignature Language="C#" Value="public abstract class Array : ICloneable, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Array extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Array" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Array&#xA;Implements ICloneable, IList, IStructuralComparable, IStructuralEquatable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Array abstract : ICloneable, System::Collections::IList, System::Collections::IStructuralComparable, System::Collections::IStructuralEquatable" />
  <TypeSignature Language="F#" Value="type Array = class&#xA;    interface ICloneable&#xA;    interface ICollection&#xA;    interface IList&#xA;    interface IEnumerable&#xA;    interface IStructuralComparable&#xA;    interface IStructuralEquatable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralEquatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt Methoden zum Erstellen, Bearbeiten, Durchsuchen und Sortieren von Arrays bereit und ist damit Basisklasse für alle Arrays in der Common Language Runtime.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array>-Klasse ist nicht Teil der <xref:System.Collections>-Namespaces. Sie wird jedoch immer noch als Sammlung betrachtet, da Sie auf der <xref:System.Collections.IList>-Schnittstelle basiert.  
  
 Die <xref:System.Array>-Klasse ist die Basisklasse für sprach Implementierungen, die Arrays unterstützen. Allerdings können nur das System und die Compiler explizit von der <xref:System.Array> Klasse abgeleitet werden. Benutzer sollten die von der Sprache bereitgestellten Arraykonstrukte verwenden.  
  
 Ein Element ist ein Wert in einem <xref:System.Array>. Die Länge einer <xref:System.Array> ist die Gesamtzahl der Elemente, die Sie enthalten kann. Die untere Grenze des ein <xref:System.Array> ist der Index des ersten Elements. Ein-<xref:System.Array> kann über eine beliebige untere Grenze verfügen, hat jedoch standardmäßig eine untere Grenze von NULL. Eine andere Untergrenze kann definiert werden, wenn eine Instanz der <xref:System.Array>-Klasse mit <xref:System.Array.CreateInstance%2A>erstellt wird. Ein mehrdimensionaler <xref:System.Array> kann für jede Dimension über unterschiedliche Begrenzungen verfügen. Ein Array kann maximal 32 Dimensionen aufweisen.  
  
 Im Gegensatz zu den Klassen in den <xref:System.Collections>-Namespaces verfügt <xref:System.Array> über eine festgelegte Kapazität. Um die Kapazität zu erhöhen, müssen Sie ein neues <xref:System.Array>-Objekt mit der erforderlichen Kapazität erstellen, die Elemente aus dem alten <xref:System.Array>-Objekt in das neue kopieren und die alte <xref:System.Array>löschen.  

 Die Array Größe ist auf insgesamt 4 Milliarden Elemente und auf einen maximalen Index von 0x7fefffff in einer beliebigen Dimension (0x7fffffc7 für Byte Arrays und Arrays von Einzel Byte Strukturen) beschränkt.
  
 **Nur .NET Framework:** Standardmäßig beträgt die maximale Größe eines <xref:System.Array> 2 Gigabyte (GB). In einer 64-Bit-Umgebung können Sie die Größenbeschränkung vermeiden, indem Sie das `enabled`-Attribut des [gcallowverylargeobjects](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) -Konfigurations Elements auf `true` in der Laufzeitumgebung festlegen.
  
 Eindimensionale Arrays implementieren die generischen Schnittstellen <xref:System.Collections.Generic.IList%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType> und <xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType>. Die Implementierungen werden zur Laufzeit für Arrays bereitgestellt, und infolgedessen werden die generischen Schnittstellen nicht in der Deklarations Syntax für die <xref:System.Array>-Klasse angezeigt. Außerdem sind keine Referenz Themen für Schnittstellenmember verfügbar, auf die nur durch Umwandeln eines Arrays in den generischen Schnittstellentyp (explizite Schnittstellen Implementierungen) zugegriffen werden kann. Beim Umwandeln eines Arrays in eine dieser Schnittstellen ist es wichtig zu beachten, dass Member, die Elemente hinzufügen, einfügen oder entfernen, <xref:System.NotSupportedException>auslösen.  
  
 <xref:System.Type>-Objekte stellen Informationen über Arraytypdeklarationen bereit. <xref:System.Array> Objekte mit demselben Arraytyp verwenden dasselbe <xref:System.Type> Objekt.  
  
 <xref:System.Type.IsArray%2A?displayProperty=nameWithType> und <xref:System.Type.GetElementType%2A?displayProperty=nameWithType> geben möglicherweise nicht die erwarteten Ergebnisse mit <xref:System.Array> zurück, da das Ergebnis ein Objekt und kein Array ist, wenn ein Array in den Typ <xref:System.Array>umgewandelt wird. Das heißt, `typeof(System.Array).IsArray` gibt `false`zurück, und `typeof(System.Array).GetElementType` gibt `null`zurück.  
  
 Die <xref:System.Array.Copy%2A?displayProperty=nameWithType>-Methode kopiert Elemente nicht nur zwischen Arrays desselben Typs, sondern auch zwischen Standard Arrays unterschiedlicher Typen. die Typumwandlung wird automatisch verarbeitet.  
  
 Einige Methoden, z. b. <xref:System.Array.CreateInstance%2A>, <xref:System.Array.Copy%2A>, <xref:System.Array.CopyTo%2A>, <xref:System.Array.GetValue%2A>und <xref:System.Array.SetValue%2A>, stellen über Ladungen bereit, die ganzzahlige 64-Bit-Werte als Parameter für große Kapazitäts Arrays akzeptieren. <xref:System.Array.LongLength%2A> und <xref:System.Array.GetLongLength%2A> geben 64-Bit-Ganzzahlen zurück, die die Länge des Arrays angeben.  
  
 Es ist nicht garantiert, dass die <xref:System.Array> sortiert wird.  Sie müssen die <xref:System.Array> vor dem Durchführen von Vorgängen (z. b. <xref:System.Array.BinarySearch%2A>) Sortieren, bei denen die <xref:System.Array> sortiert werden muss.  
  
 Die Verwendung eines <xref:System.Array> Objekts von Zeigern in nativem Code wird nicht unterstützt und löst eine <xref:System.NotSupportedException> für mehrere Methoden aus.  
  
   
  
## Examples  

 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]
 
 Im folgenden Codebeispiel wird gezeigt, wie <xref:System.Array.Copy%2A?displayProperty=nameWithType> Elemente zwischen einem Array vom Typ Integer und einem Array vom Typ <xref:System.Object>kopiert.  
  
 [!code-cpp[Classic Array Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source.cs#1)]
 [!code-vb[Classic Array Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source.vb#1)]  
  
 Im folgenden Codebeispiel wird eine <xref:System.Array> erstellt und initialisiert, und die zugehörigen Eigenschaften und deren Elemente werden angezeigt.  
  
 [!code-cpp[Classic Array Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source3.cpp#2)]
 [!code-csharp-interactive[Classic Array Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source3.cs#2)]
 [!code-vb[Classic Array Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source3.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Öffentliche statische (<see langword="Shared" /> in Visual Basic) Member dieses Typs sind Thread sicher. Bei Instanzmembern ist die Threadsicherheit nicht gewährleistet.  
  
Diese Implementierung stellt keinen synchronisierten (Thread sicheren) Wrapper für eine <see cref="T:System.Array" />bereit. .NET Framework Klassen, die auf <see cref="T:System.Array" /> basieren, bieten jedoch eine eigene synchronisierte Version der Auflistung mithilfe der <see cref="P:System.Array.SyncRoot" />-Eigenschaft.  
  
Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur. Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst. Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.</threadsafe>
    <altmember cref="T:System.Object" />
    <altmember cref="T:System.Type" />
    <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
    <related type="Article" href="~/docs/csharp/programming-guide/arrays/index.md">Arrays (C#-Programmierhandbuch)</related>
    <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/arrays/index.md">Arrays in Visual Basic</related>
  </Docs>
  <Members>
    <Member MemberName="AsReadOnly&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!!T&gt; AsReadOnly&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.AsReadOnly``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsReadOnly(Of T) (array As T()) As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member AsReadOnly : 'T[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;" Usage="System.Array.AsReadOnly array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das eindimensionale, nullbasierte Array, das mit einem schreibgeschützten <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />-Wrapper umschlossen werden soll.</param>
        <summary>Gibt einen schreibgeschützten Wrapper für das angegebene Array zurück.</summary>
        <returns>Ein schreibgeschützter <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />-Wrapper für das angegebene Array.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um Änderungen am Array zu verhindern, machen Sie das Array nur über diesen Wrapper verfügbar.  
  
 Eine Auflistung, die schreibgeschützt ist, ist einfach eine Sammlung mit einem Wrapper, der das Ändern der Auflistung verhindert. Wenn also Änderungen an der zugrunde liegenden Auflistung vorgenommen werden, reflektiert die schreibgeschützte Auflistung diese Änderungen.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Array in einem schreibgeschützten <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>umschlossen.  
  
 [!code-cpp[System.Array.AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CPP/arrayasreadonly.cpp#1)]
 [!code-csharp[System.Array.AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CS/arrayasreadonly.cs#1)]
 [!code-vb[System.Array.AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.AsReadOnly/VB/arrayasreadonly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Durchsucht ein sortiertes eindimensionales <see cref="T:System.Array" /> mithilfe eines binären Suchalgorithmus nach einem Wert.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * obj -&gt; int" Usage="System.Array.BinarySearch (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende sortierte eindimensionale <see cref="T:System.Array" />.</param>
        <param name="value">Das Objekt, nach dem gesucht werden soll.</param>
        <summary>Durchsucht ein ganzes sortiertes eindimensionales Array mithilfe der <see cref="T:System.IComparable" />-Schnittstelle, die von jedem Element des Arrays und durch das angegebene Objekt implementiert wird, nach einem bestimmten Element.</summary>
        <returns>Der Index des angegebenen <paramref name="value" /> im angegebenen <paramref name="array" />, sofern <paramref name="value" /> gefunden wurde, andernfalls eine negative Zahl. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> kleiner als mindestens ein Element in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <paramref name="value" /> ist. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> größer als alle Elemente in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1). Wenn diese Methode mit einem nicht sortierten <paramref name="array" /> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <paramref name="value" /> in <paramref name="array" /> vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt nicht das Suchen von Arrays, die negative Indizes enthalten. `array` muss sortiert werden, bevor diese Methode aufgerufen wird.  
  
 Wenn das <xref:System.Array> den angegebenen Wert nicht enthält, gibt die Methode eine negative Ganzzahl zurück. Sie können den bitweisen Komplement Operator (~ in C#, `Not` in Visual Basic) auf das negative Ergebnis anwenden, um einen Index zu entwickeln. Wenn dieser Index ein Wert größer als die obere Grenze des Arrays ist, sind keine Elemente größer als `value` im Array. Andernfalls ist dies der Index des ersten Elements, das größer als `value`ist.  
  
 Entweder `value` oder jedes Element von `array` muss die <xref:System.IComparable>-Schnittstelle implementieren, die für Vergleiche verwendet wird. Die Elemente `array` müssen bereits in einem zunehmenden Wert entsprechend der Sortierreihenfolge sortiert werden, die durch die <xref:System.IComparable> Implementierung definiert wird. Andernfalls ist das Ergebnis möglicherweise falsch.  
  
> [!NOTE]
>  Wenn`value` die <xref:System.IComparable>-Schnittstelle nicht implementiert, werden die Elemente von `array` nicht auf <xref:System.IComparable> getestet, bevor die Suche beginnt. Eine-Ausnahme wird ausgelöst, wenn bei der Suche ein Element gefunden wird, das <xref:System.IComparable>nicht implementiert.  
  
 Doppelte Elemente sind zulässig. Wenn die <xref:System.Array> mehr als ein Element enthält, das gleich `value`ist, gibt die Methode den Index von nur einem der Vorkommen und nicht notwendigerweise der ersten zurück.  
  
 `null` können immer mit einem beliebigen anderen Referenztyp verglichen werden. aus diesem Grund generieren Vergleiche mit `null` keine Ausnahme.  
  
> [!NOTE]
>  Bei jedem getesteten Element wird `value` an die entsprechende <xref:System.IComparable> Implementierung weitergeleitet, auch wenn `value` `null`ist. Das heißt, die <xref:System.IComparable>-Implementierung bestimmt, wie ein bestimmtes Element mit `null`verglichen wird.  
  
 Bei dieser Methode handelt es sich um einen O (Log `n`)-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> von `array`ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie <xref:System.Array.BinarySearch%2A> verwendet wird, um ein bestimmtes Objekt in einem <xref:System.Array>zu suchen.  
  
> [!NOTE]
>  Das Array wird mit seinen Elementen in aufsteigender Sortierreihenfolge erstellt. Die <xref:System.Array.BinarySearch%2A>-Methode erfordert, dass das Array in aufsteigender Reihenfolge sortiert wird.  
  
 [!code-cpp[Classic Array.BinarySearch Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.BinarySearch Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CS/source.cs#1)]
 [!code-vb[Classic Array.BinarySearch Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> verfügt über einen Typ, der nicht mit den Elementen von <paramref name="array" />kompatibel ist.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" /> implementiert nicht die <see cref="T:System.IComparable" />-Schnittstelle, und bei der Suche wird ein Element gefunden, das die <see cref="T:System.IComparable" />-Schnittstelle nicht implementiert.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * obj * System.Collections.IComparer -&gt; int" Usage="System.Array.BinarySearch (array, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende sortierte eindimensionale <see cref="T:System.Array" />.</param>
        <param name="value">Das Objekt, nach dem gesucht werden soll.</param>
        <param name="comparer">Die <see cref="T:System.Collections.IComparer" />-Implementierung, die beim Vergleich von Elementen verwendet werden soll.  
  
- oder - 
 <see langword="null" />, wenn die <see cref="T:System.IComparable" />-Implementierung des jeweiligen Elements verwendet werden soll.</param>
        <summary>Durchsucht ein ganzes sortiertes eindimensionales Array mithilfe der angegebenen <see cref="T:System.Collections.IComparer" />-Schnittstelle nach einem Wert.</summary>
        <returns>Der Index des angegebenen <paramref name="value" /> im angegebenen <paramref name="array" />, sofern <paramref name="value" /> gefunden wurde, andernfalls eine negative Zahl. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> kleiner als mindestens ein Element in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <paramref name="value" /> ist. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> größer als alle Elemente in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1). Wenn diese Methode mit einem nicht sortierten <paramref name="array" /> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <paramref name="value" /> in <paramref name="array" /> vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt nicht das Suchen von Arrays, die negative Indizes enthalten. `array` muss sortiert werden, bevor diese Methode aufgerufen wird.  
  
 Wenn das <xref:System.Array> den angegebenen Wert nicht enthält, gibt die Methode eine negative Ganzzahl zurück. Sie können den bitweisen Komplement Operator (~ in C#, `Not` in Visual Basic) auf das negative Ergebnis anwenden, um einen Index zu entwickeln. Wenn dieser Index ein Wert größer als die obere Grenze des Arrays ist, sind keine Elemente größer als `value` im Array. Andernfalls ist dies der Index des ersten Elements, das größer als `value`ist.  
  
 Der Vergleich passt an, wie die Elemente verglichen werden. Beispielsweise können Sie eine <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> als Vergleichs Operator verwenden, um Zeichen folgen suchen ohne Berücksichtigung der Groß-/Kleinschreibung auszuführen.  
  
 Wenn `comparer` nicht `null`ist, werden die Elemente `array` unter Verwendung der angegebenen <xref:System.Collections.IComparer> Implementierung mit dem angegebenen Wert verglichen. Die Elemente `array` müssen bereits in einem zunehmenden Wert entsprechend der durch `comparer`definierten Sortierreihenfolge sortiert werden. Andernfalls ist das Ergebnis möglicherweise falsch.  
  
 Wenn`comparer` `null`ist, erfolgt der Vergleich mithilfe der <xref:System.IComparable>-Implementierung, die vom Element selbst oder durch den angegebenen Wert bereitgestellt wird. Die Elemente `array` müssen bereits in einem zunehmenden Wert entsprechend der Sortierreihenfolge sortiert werden, die durch die <xref:System.IComparable> Implementierung definiert wird. Andernfalls ist das Ergebnis möglicherweise falsch.  
  
> [!NOTE]
>  Wenn `comparer` `null` und `value` die <xref:System.IComparable> Schnittstelle nicht implementiert, werden die Elemente von `array` vor Beginn der Suche nicht auf <xref:System.IComparable> getestet. Eine-Ausnahme wird ausgelöst, wenn bei der Suche ein Element gefunden wird, das <xref:System.IComparable>nicht implementiert.  
  
 Doppelte Elemente sind zulässig. Wenn die <xref:System.Array> mehr als ein Element enthält, das gleich `value`ist, gibt die Methode den Index von nur einem der Vorkommen und nicht notwendigerweise der ersten zurück.  
  
 `null` können immer mit einem beliebigen anderen Referenztyp verglichen werden. aus diesem Grund generieren Vergleiche mit `null` keine Ausnahme.  
  
> [!NOTE]
>  Bei jedem getesteten Element wird `value` an die entsprechende <xref:System.IComparable> Implementierung weitergeleitet, auch wenn `value` `null`ist. Das heißt, die <xref:System.IComparable>-Implementierung bestimmt, wie ein bestimmtes Element mit `null`verglichen wird.  
  
 Bei dieser Methode handelt es sich um einen O (Log `n`)-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> von `array`ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparer" /> ist <see langword="null" />und <paramref name="value" /> verfügt über einen Typ, der nicht mit den Elementen von <paramref name="array" />kompatibel ist.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist<see langword="null" />, <paramref name="value" /> implementiert nicht die <see cref="T:System.IComparable" />-Schnittstelle, und bei der Suche wird ein Element gefunden, das die <see cref="T:System.IComparable" />-Schnittstelle nicht implementiert.</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * int * int * obj -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende sortierte eindimensionale <see cref="T:System.Array" />.</param>
        <param name="index">Der Startindex des zu durchsuchenden Bereichs.</param>
        <param name="length">Die Länge des zu durchsuchenden Bereichs.</param>
        <param name="value">Das Objekt, nach dem gesucht werden soll.</param>
        <summary>Durchsucht einen Bereich von Elementen in einem sortierten eindimensionalen Array mithilfe der <see cref="T:System.IComparable" />-Schnittstelle, die von jedem Element des Arrays und durch den angegebenen Wert implementiert wird, nach einem Wert.</summary>
        <returns>Der Index des angegebenen <paramref name="value" /> im angegebenen <paramref name="array" />, sofern <paramref name="value" /> gefunden wurde, andernfalls eine negative Zahl. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> kleiner als mindestens ein Element in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <paramref name="value" /> ist. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> größer als alle Elemente in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1). Wenn diese Methode mit einem nicht sortierten <paramref name="array" /> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <paramref name="value" /> in <paramref name="array" /> vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt nicht das Suchen von Arrays, die negative Indizes enthalten. `array` muss sortiert werden, bevor diese Methode aufgerufen wird.  
  
 Wenn das <xref:System.Array> den angegebenen Wert nicht enthält, gibt die Methode eine negative Ganzzahl zurück. Sie können den bitweisen Komplement Operator (~ in C#, `Not` in Visual Basic) auf das negative Ergebnis anwenden, um einen Index zu entwickeln. Wenn dieser Index ein Wert größer als die obere Grenze des Arrays ist, sind keine Elemente größer als `value` im Array. Andernfalls ist dies der Index des ersten Elements, das größer als `value`ist.  
  
 Entweder `value` oder jedes Element von `array` muss die <xref:System.IComparable>-Schnittstelle implementieren, die für Vergleiche verwendet wird. Die Elemente `array` müssen bereits in einem zunehmenden Wert entsprechend der Sortierreihenfolge sortiert werden, die durch die <xref:System.IComparable> Implementierung definiert wird. Andernfalls ist das Ergebnis möglicherweise falsch.  
  
> [!NOTE]
>  Wenn `value` die <xref:System.IComparable>-Schnittstelle nicht implementiert, werden die Elemente von `array` nicht auf <xref:System.IComparable> getestet, bevor die Suche beginnt. Eine-Ausnahme wird ausgelöst, wenn bei der Suche ein Element gefunden wird, das <xref:System.IComparable>nicht implementiert.  
  
 Doppelte Elemente sind zulässig. Wenn die <xref:System.Array> mehr als ein Element enthält, das gleich `value`ist, gibt die Methode den Index von nur einem der Vorkommen und nicht notwendigerweise der ersten zurück.  
  
 `null` können immer mit einem beliebigen anderen Referenztyp verglichen werden. aus diesem Grund generieren Vergleiche mit `null` keine Ausnahme.  
  
> [!NOTE]
>  Bei jedem getesteten Element wird `value` an die entsprechende <xref:System.IComparable> Implementierung weitergeleitet, auch wenn `value` `null`ist. Das heißt, die <xref:System.IComparable>-Implementierung bestimmt, wie ein bestimmtes Element mit `null`verglichen wird.  
  
 Bei dieser Methode handelt es sich um einen O (Log `n`)-Vorgang, bei dem `n` `length`ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die untere <paramref name="array" />-Grenze.  
  
- oder - 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="array" /> an.  
  
- oder - 
 <paramref name="value" /> verfügt über einen Typ, der nicht mit den Elementen von <paramref name="array" /> kompatibel ist.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" /> implementiert nicht die <see cref="T:System.IComparable" />-Schnittstelle, und bei der Suche wird ein Element gefunden, das die <see cref="T:System.IComparable" />-Schnittstelle nicht implementiert.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * int * int * obj * System.Collections.IComparer -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende sortierte eindimensionale <see cref="T:System.Array" />.</param>
        <param name="index">Der Startindex des zu durchsuchenden Bereichs.</param>
        <param name="length">Die Länge des zu durchsuchenden Bereichs.</param>
        <param name="value">Das Objekt, nach dem gesucht werden soll.</param>
        <param name="comparer">Die <see cref="T:System.Collections.IComparer" />-Implementierung, die beim Vergleich von Elementen verwendet werden soll.  
  
- oder - 
 <see langword="null" />, wenn die <see cref="T:System.IComparable" />-Implementierung des jeweiligen Elements verwendet werden soll.</param>
        <summary>Durchsucht einen Bereich von Elementen in einem sortierten eindimensionalen Array mithilfe der angegebenen <see cref="T:System.Collections.IComparer" />-Schnittstelle nach einem Wert.</summary>
        <returns>Der Index des angegebenen <paramref name="value" /> im angegebenen <paramref name="array" />, sofern <paramref name="value" /> gefunden wurde, andernfalls eine negative Zahl. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> kleiner als mindestens ein Element in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <paramref name="value" /> ist. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> größer als alle Elemente in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1). Wenn diese Methode mit einem nicht sortierten <paramref name="array" /> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <paramref name="value" /> in <paramref name="array" /> vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt nicht das Suchen von Arrays, die negative Indizes enthalten. `array` muss sortiert werden, bevor diese Methode aufgerufen wird.  
  
 Wenn das <xref:System.Array> den angegebenen Wert nicht enthält, gibt die Methode eine negative Ganzzahl zurück. Sie können den bitweisen Komplement Operator (~ in C#, `Not` in Visual Basic) auf das negative Ergebnis anwenden, um einen Index zu entwickeln. Wenn dieser Index ein Wert größer als die obere Grenze des Arrays ist, sind keine Elemente größer als `value` im Array. Andernfalls ist dies der Index des ersten Elements, das größer als `value`ist.  
  
 Der Vergleich passt an, wie die Elemente verglichen werden. Beispielsweise können Sie eine <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> als Vergleichs Operator verwenden, um Zeichen folgen suchen ohne Berücksichtigung der Groß-/Kleinschreibung auszuführen.  
  
 Wenn `comparer` nicht `null`ist, werden die Elemente `array` unter Verwendung der angegebenen <xref:System.Collections.IComparer> Implementierung mit dem angegebenen Wert verglichen. Die Elemente `array` müssen bereits in einem zunehmenden Wert entsprechend der durch `comparer`definierten Sortierreihenfolge sortiert werden. Andernfalls ist das Ergebnis möglicherweise falsch.  
  
 Wenn `comparer` `null`ist, erfolgt der Vergleich mithilfe der <xref:System.IComparable>-Implementierung, die vom Element selbst oder durch den angegebenen Wert bereitgestellt wird. Die Elemente `array` müssen bereits in einem zunehmenden Wert entsprechend der Sortierreihenfolge sortiert werden, die durch die <xref:System.IComparable> Implementierung definiert wird. Andernfalls ist das Ergebnis möglicherweise falsch.  
  
> [!NOTE]
>  Wenn `comparer` `null` und `value` die <xref:System.IComparable> Schnittstelle nicht implementiert, werden die Elemente von `array` vor Beginn der Suche nicht auf <xref:System.IComparable> getestet. Eine-Ausnahme wird ausgelöst, wenn bei der Suche ein Element gefunden wird, das <xref:System.IComparable>nicht implementiert.  
  
 Doppelte Elemente sind zulässig. Wenn die <xref:System.Array> mehr als ein Element enthält, das gleich `value`ist, gibt die Methode den Index von nur einem der Vorkommen und nicht notwendigerweise der ersten zurück.  
  
 `null` können immer mit einem beliebigen anderen Referenztyp verglichen werden. Daher generieren Vergleiche mit `null` keine Ausnahme bei der Verwendung <xref:System.IComparable>.  
  
> [!NOTE]
>  Bei jedem getesteten Element wird `value` an die entsprechende <xref:System.IComparable> Implementierung weitergeleitet, auch wenn `value` `null`ist. Das heißt, die <xref:System.IComparable>-Implementierung bestimmt, wie ein bestimmtes Element mit `null`verglichen wird.  
  
 Bei dieser Methode handelt es sich um einen O (Log `n`)-Vorgang, bei dem `n` `length`ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die untere <paramref name="array" />-Grenze.  
  
- oder - 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="array" /> an.  
  
- oder - 
 <paramref name="comparer" /> ist <see langword="null" /> und <paramref name="value" /> verfügt über einen Typ, der nicht mit den Elementen von <paramref name="array" /> kompatibel ist.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist<see langword="null" />, <paramref name="value" /> implementiert nicht die <see cref="T:System.IComparable" />-Schnittstelle, und bei der Suche wird ein Element gefunden, das die <see cref="T:System.IComparable" />-Schnittstelle nicht implementiert.</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * 'T -&gt; int" Usage="System.Array.BinarySearch (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende sortierte eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="value">Das Objekt, nach dem gesucht werden soll.</param>
        <summary>Durchsucht ein ganzes sortiertes eindimensionales Array mithilfe der generischen <see cref="T:System.IComparable`1" />-Schnittstelle, die von jedem Element des <see cref="T:System.Array" /> und vom angegebenen Objekt implementiert wird, nach einem bestimmten Element.</summary>
        <returns>Der Index des angegebenen <paramref name="value" /> im angegebenen <paramref name="array" />, sofern <paramref name="value" /> gefunden wurde, andernfalls eine negative Zahl. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> kleiner als mindestens ein Element in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <paramref name="value" /> ist. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> größer als alle Elemente in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1). Wenn diese Methode mit einem nicht sortierten <paramref name="array" /> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <paramref name="value" /> in <paramref name="array" /> vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt nicht das Suchen von Arrays, die negative Indizes enthalten. `array` muss sortiert werden, bevor diese Methode aufgerufen wird.  
  
 Wenn `array` den angegebenen Wert nicht enthält, gibt die Methode eine negative Ganzzahl zurück. Sie können den bitweisen Komplement Operator (~ in C#, `Not` in Visual Basic) auf das negative Ergebnis anwenden, um einen Index zu entwickeln. Wenn dieser Index gleich der Größe des Arrays ist, sind keine Elemente größer als `value` im Array. Andernfalls ist dies der Index des ersten Elements, das größer als `value`ist.  
  
 `T` müssen die <xref:System.IComparable%601> generische-Schnittstelle implementieren, die für Vergleiche verwendet wird. Die Elemente `array` müssen bereits in einem zunehmenden Wert entsprechend der Sortierreihenfolge sortiert werden, die durch die <xref:System.IComparable%601> Implementierung definiert wird. Andernfalls ist das Ergebnis möglicherweise falsch.  
  
 Doppelte Elemente sind zulässig. Wenn die <xref:System.Array> mehr als ein Element enthält, das gleich `value`ist, gibt die Methode den Index von nur einem der Vorkommen und nicht notwendigerweise der ersten zurück.  
  
 `null` können immer mit einem beliebigen anderen Referenztyp verglichen werden. aus diesem Grund generieren Vergleiche mit `null` keine Ausnahme.  
  
> [!NOTE]
>  Bei jedem getesteten Element wird `value` an die entsprechende <xref:System.IComparable%601> Implementierung weitergeleitet, auch wenn `value` `null`ist. Das heißt, die <xref:System.IComparable%601>-Implementierung bestimmt, wie ein bestimmtes Element mit `null`verglichen wird.  
  
 Bei dieser Methode handelt es sich um einen O (Log `n`)-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> von `array`ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> generische Methoden Überladung und die <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> generische Methoden Überladung veranschaulicht. Ein Array von Zeichen folgen wird erstellt, in keiner bestimmten Reihenfolge.  
  
 Das Array wird angezeigt, sortiert und erneut angezeigt. Arrays müssen sortiert werden, um die <xref:System.Array.BinarySearch%2A>-Methode zu verwenden.  
  
> [!NOTE]
>  Die Aufrufe der generischen Methoden <xref:System.Array.Sort%2A> und <xref:System.Array.BinarySearch%2A> unterscheiden sich nicht von den Aufrufen ihrer nicht generischen Entsprechungen, da Visual Basic C#,, C++ und den Typ des generischen Typparameters vom Typ des ersten Arguments ableiten. Wenn Sie den [Ildasm. exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) verwenden, um die MSIL (Microsoft Intermediate Language) zu überprüfen, können Sie sehen, dass die generischen Methoden aufgerufen werden.  
  
 Die generische Methoden Überladung von <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> wird dann verwendet, um nach zwei Zeichen folgen zu suchen, eine, die nicht im-Array ist, und eine, die ist. Das Array und der Rückgabewert der <xref:System.Array.BinarySearch%2A>-Methode werden an die generische Methode `ShowWhere` übergeben, die den Indexwert anzeigt, wenn die Zeichenfolge gefunden wird, und andernfalls die Elemente, zwischen denen die Such Zeichenfolge fällt, wenn Sie sich im Array befindet. Der Index ist negativ, wenn die Zeichenfolge nicht im Array enthalten ist, sodass die `ShowWhere`-Methode das bitweise Komplement (der ~ C# -Operator C++in und Visual, `Xor`-1 in Visual Basic) übernimmt, um den Index des ersten Elements in der Liste zu erhalten, das größer als die Such Zeichenfolge ist.  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die generische <see cref="T:System.IComparable`1" />-Schnittstelle wird von <paramref name="T" /> nicht implementiert.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="System.Array.BinarySearch (array, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende sortierte eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="value">Das Objekt, nach dem gesucht werden soll.</param>
        <param name="comparer">Die <see cref="T:System.Collections.Generic.IComparer`1" />-Implementierung, die beim Vergleich von Elementen verwendet werden soll.  
  
- oder - 
 <see langword="null" />, wenn die <see cref="T:System.IComparable`1" />-Implementierung des jeweiligen Elements verwendet werden soll.</param>
        <summary>Durchsucht ein ganzes sortiertes eindimensionales Array mithilfe der angegebenen generischen <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle nach einem Wert.</summary>
        <returns>Der Index des angegebenen <paramref name="value" /> im angegebenen <paramref name="array" />, sofern <paramref name="value" /> gefunden wurde, andernfalls eine negative Zahl. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> kleiner als mindestens ein Element in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <paramref name="value" /> ist. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> größer als alle Elemente in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1). Wenn diese Methode mit einem nicht sortierten <paramref name="array" /> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <paramref name="value" /> in <paramref name="array" /> vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt nicht das Suchen von Arrays, die negative Indizes enthalten. `array` muss sortiert werden, bevor diese Methode aufgerufen wird.  
  
 Wenn das <xref:System.Array> den angegebenen Wert nicht enthält, gibt die Methode eine negative Ganzzahl zurück. Sie können den bitweisen Komplement Operator (~ in C#, `Not` in Visual Basic) auf das negative Ergebnis anwenden, um einen Index zu entwickeln. Wenn dieser Index gleich der Größe des Arrays ist, sind keine Elemente größer als `value` im Array. Andernfalls ist dies der Index des ersten Elements, das größer als `value`ist.  
  
 Der Vergleich passt an, wie die Elemente verglichen werden. Beispielsweise können Sie eine <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> als Vergleichs Operator verwenden, um Zeichen folgen suchen ohne Berücksichtigung der Groß-/Kleinschreibung auszuführen.  
  
 Wenn `comparer` nicht `null`ist, werden die Elemente von `array` mithilfe der angegebenen <xref:System.Collections.Generic.IComparer%601> Implementierung der generischen-Schnittstelle mit dem angegebenen Wert verglichen. Die Elemente `array` müssen bereits in einem zunehmenden Wert entsprechend der durch `comparer`definierten Sortierreihenfolge sortiert werden. Andernfalls ist das Ergebnis möglicherweise falsch.  
  
 Wenn `comparer` `null`ist, erfolgt der Vergleich mithilfe der <xref:System.IComparable%601> generischen Schnittstellen Implementierung, die von `T`bereitgestellt wird. Die Elemente `array` müssen bereits in einem zunehmenden Wert entsprechend der Sortierreihenfolge sortiert werden, die durch die <xref:System.IComparable%601> Implementierung definiert wird. Andernfalls ist das Ergebnis möglicherweise falsch.  
  
> [!NOTE]
>  Wenn `comparer` `null` und `value` die <xref:System.IComparable%601> generische Schnittstelle nicht implementiert, werden die Elemente von `array` vor Beginn der Suche nicht auf <xref:System.IComparable%601> getestet. Eine-Ausnahme wird ausgelöst, wenn bei der Suche ein Element gefunden wird, das <xref:System.IComparable%601>nicht implementiert.  
  
 Doppelte Elemente sind zulässig. Wenn die <xref:System.Array> mehr als ein Element enthält, das gleich `value`ist, gibt die Methode den Index von nur einem der Vorkommen und nicht notwendigerweise der ersten zurück.  
  
 `null` können immer mit einem beliebigen anderen Referenztyp verglichen werden. aus diesem Grund generieren Vergleiche mit `null` keine Ausnahme.  
  
> [!NOTE]
>  Bei jedem getesteten Element wird `value` an die entsprechende <xref:System.IComparable%601> Implementierung weitergeleitet, auch wenn `value` `null`ist. Das heißt, die <xref:System.IComparable%601>-Implementierung bestimmt, wie ein bestimmtes Element mit `null`verglichen wird.  
  
 Bei dieser Methode handelt es sich um einen O (Log `n`)-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> von `array`ist.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generische Methoden Überladung und die <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generische Methoden Überladung.  
  
 Im Codebeispiel wird ein alternativer Vergleich für Zeichen folgen mit dem Namen `ReverseCompare`definiert, der die generische Schnittstelle `IComparer<string>` (`IComparer(Of String)` in Visual Basic C++, `IComparer<String^>` in Visual) implementiert. Der Vergleich Ruft die <xref:System.String.CompareTo%28System.String%29>-Methode auf und kehrt die Reihenfolge der Vergleichs Elemente um, sodass die Zeichen folgen nicht zu hoch, sondern zu niedrig sortiert werden.  
  
 Das Array wird angezeigt, sortiert und erneut angezeigt. Arrays müssen sortiert werden, um die <xref:System.Array.BinarySearch%2A>-Methode zu verwenden.  
  
> [!NOTE]
>  Die Aufrufe der generischen Methoden <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> und <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> unterscheiden sich nicht von den Aufrufen ihrer nicht generischen Entsprechungen, da Visual Basic C#,, C++ und den Typ des generischen Typparameters vom Typ des ersten Arguments ableiten. Wenn Sie den [Ildasm. exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) verwenden, um die MSIL (Microsoft Intermediate Language) zu überprüfen, können Sie sehen, dass die generischen Methoden aufgerufen werden.  
  
 Die generische Methoden Überladung von <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> wird dann verwendet, um nach zwei Zeichen folgen zu suchen, eine, die nicht im-Array ist, und eine, die ist. Das Array und der Rückgabewert der <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>-Methode werden an die generische Methode `ShowWhere` übergeben, die den Indexwert anzeigt, wenn die Zeichenfolge gefunden wird, und andernfalls die Elemente, zwischen denen die Such Zeichenfolge fällt, wenn Sie sich im Array befindet. Der Index ist negativ, wenn die Zeichenfolge nicht n das Array ist, sodass die `ShowWhere`-Methode das bitweise Komplement (der ~ C# -Operator C++in und Visual, `Xor`-1 in Visual Basic) übernimmt, um den Index des ersten Elements in der Liste zu erhalten, das größer als die Such Zeichenfolge ist.  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparer" /> ist <see langword="null" /> und <paramref name="value" /> verfügt über einen Typ, der nicht mit den Elementen von <paramref name="array" /> kompatibel ist.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" /> und <paramref name="T" /> implementiert die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * int * int * 'T -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende sortierte eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="index">Der Startindex des zu durchsuchenden Bereichs.</param>
        <param name="length">Die Länge des zu durchsuchenden Bereichs.</param>
        <param name="value">Das Objekt, nach dem gesucht werden soll.</param>
        <summary>Durchsucht einen Bereich von Elementen in einem sortierten eindimensionalen Array mithilfe der generischen <see cref="T:System.IComparable`1" />-Schnittstelle, die von jedem Element des <see cref="T:System.Array" /> und vom angegebenen Wert implementiert wird, nach einem Wert.</summary>
        <returns>Der Index des angegebenen <paramref name="value" /> im angegebenen <paramref name="array" />, sofern <paramref name="value" /> gefunden wurde, andernfalls eine negative Zahl. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> kleiner als mindestens ein Element in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <paramref name="value" /> ist. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> größer als alle Elemente in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1). Wenn diese Methode mit einem nicht sortierten <paramref name="array" /> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <paramref name="value" /> in <paramref name="array" /> vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt nicht das Suchen von Arrays, die negative Indizes enthalten. `array` muss sortiert werden, bevor diese Methode aufgerufen wird.  
  
 Wenn das Array den angegebenen Wert nicht enthält, gibt die Methode eine negative Ganzzahl zurück. Sie können den bitweisen Komplement Operator (~ in C#, `Not` in Visual Basic) auf das negative Ergebnis anwenden, um einen Index zu entwickeln. Wenn dieser Index gleich der Größe des Arrays ist, sind keine Elemente größer als `value` im Array. Andernfalls ist dies der Index des ersten Elements, das größer als `value`ist.  
  
 `T` müssen die <xref:System.IComparable%601> generische-Schnittstelle implementieren, die für Vergleiche verwendet wird. Die Elemente `array` müssen bereits in einem zunehmenden Wert entsprechend der Sortierreihenfolge sortiert werden, die durch die <xref:System.IComparable%601> Implementierung definiert wird. Andernfalls ist das Ergebnis möglicherweise falsch.  
  
 Doppelte Elemente sind zulässig. Wenn die <xref:System.Array> mehr als ein Element enthält, das gleich `value`ist, gibt die Methode den Index von nur einem der Vorkommen und nicht notwendigerweise der ersten zurück.  
  
 `null` können immer mit einem beliebigen anderen Referenztyp verglichen werden. aus diesem Grund generieren Vergleiche mit `null` keine Ausnahme.  
  
> [!NOTE]
>  Bei jedem getesteten Element wird `value` an die entsprechende <xref:System.IComparable%601> Implementierung weitergeleitet, auch wenn `value` `null`ist. Das heißt, die <xref:System.IComparable%601>-Implementierung bestimmt, wie ein bestimmtes Element mit `null`verglichen wird.  
  
 Bei dieser Methode handelt es sich um einen O (Log `n`)-Vorgang, bei dem `n` `length`ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die Untergrenze von <paramref name="array" />.  
  
- oder - 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="array" /> an.  
  
- oder - 
 <paramref name="value" /> verfügt über einen Typ, der nicht mit den Elementen von <paramref name="array" /> kompatibel ist.</exception>
        <exception cref="T:System.InvalidOperationException">Die generische <see cref="T:System.IComparable`1" />-Schnittstelle wird von <paramref name="T" /> nicht implementiert.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * int * int * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende sortierte eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="index">Der Startindex des zu durchsuchenden Bereichs.</param>
        <param name="length">Die Länge des zu durchsuchenden Bereichs.</param>
        <param name="value">Das Objekt, nach dem gesucht werden soll.</param>
        <param name="comparer">Die <see cref="T:System.Collections.Generic.IComparer`1" />-Implementierung, die beim Vergleich von Elementen verwendet werden soll.  
  
- oder - 
 <see langword="null" />, wenn die <see cref="T:System.IComparable`1" />-Implementierung des jeweiligen Elements verwendet werden soll.</param>
        <summary>Durchsucht einen Bereich von Elementen in einem sortierten eindimensionalen Array mithilfe der angegebenen generischen <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle nach einem Wert.</summary>
        <returns>Der Index des angegebenen <paramref name="value" /> im angegebenen <paramref name="array" />, sofern <paramref name="value" /> gefunden wurde, andernfalls eine negative Zahl. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> kleiner als mindestens ein Element in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement des Indexes des ersten Elements, das größer als <paramref name="value" /> ist. Wenn <paramref name="value" /> nicht gefunden wurde und <paramref name="value" /> größer als alle Elemente in <paramref name="array" /> ist, entspricht die zurückgegebene negative Zahl dem bitweisen Komplement (des Indexes des letzten Elements plus 1). Wenn diese Methode mit einem nicht sortierten <paramref name="array" /> aufgerufen wird, kann der Rückgabewert falsch sein und selbst dann eine negative Zahl zurückgegeben werden, wenn <paramref name="value" /> in <paramref name="array" /> vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt nicht das Suchen von Arrays, die negative Indizes enthalten. `array` muss sortiert werden, bevor diese Methode aufgerufen wird.  
  
 Wenn das Array den angegebenen Wert nicht enthält, gibt die Methode eine negative Ganzzahl zurück. Sie können den bitweisen Komplement Operator (~ in C#, `Not` in Visual Basic) auf das negative Ergebnis anwenden, um einen Index zu entwickeln. Wenn dieser Index gleich der Größe des Arrays ist, sind keine Elemente größer als `value` im Array. Andernfalls ist dies der Index des ersten Elements, das größer als `value`ist.  
  
 Der Vergleich passt an, wie die Elemente verglichen werden. Beispielsweise können Sie eine <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> als Vergleichs Operator verwenden, um Zeichen folgen suchen ohne Berücksichtigung der Groß-/Kleinschreibung auszuführen.  
  
 Wenn `comparer` nicht `null`ist, werden die Elemente von `array` mithilfe der angegebenen <xref:System.Collections.Generic.IComparer%601> Implementierung der generischen-Schnittstelle mit dem angegebenen Wert verglichen. Die Elemente `array` müssen bereits in einem zunehmenden Wert entsprechend der durch `comparer`definierten Sortierreihenfolge sortiert werden. Andernfalls ist das Ergebnis möglicherweise falsch.  
  
 Wenn `comparer` `null`ist, erfolgt der Vergleich mithilfe der <xref:System.IComparable%601> generischen Schnittstellen Implementierung, die für den Typ `T`bereitgestellt wird. Die Elemente `array` müssen bereits in einem zunehmenden Wert entsprechend der Sortierreihenfolge sortiert werden, die durch die <xref:System.IComparable%601> Implementierung definiert wird. Andernfalls ist das Ergebnis möglicherweise falsch.  
  
 Doppelte Elemente sind zulässig. Wenn die <xref:System.Array> mehr als ein Element enthält, das gleich `value`ist, gibt die Methode den Index von nur einem der Vorkommen und nicht notwendigerweise der ersten zurück.  
  
 `null` können immer mit einem beliebigen anderen Referenztyp verglichen werden. Daher generieren Vergleiche mit `null` keine Ausnahme bei der Verwendung <xref:System.IComparable%601>.  
  
> [!NOTE]
>  Bei jedem getesteten Element wird `value` an die entsprechende <xref:System.IComparable%601> Implementierung weitergeleitet, auch wenn `value` `null`ist. Das heißt, die <xref:System.IComparable%601>-Implementierung bestimmt, wie ein bestimmtes Element mit `null`verglichen wird.  
  
 Bei dieser Methode handelt es sich um einen O (Log `n`)-Vorgang, bei dem `n` `length`ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die Untergrenze von <paramref name="array" />.  
  
- oder - 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="array" /> an.  
  
- oder - 
 <paramref name="comparer" /> ist <see langword="null" />, und <paramref name="value" /> verfügt über einen Typ, der nicht mit den Elementen von <paramref name="array" /> kompatibel ist.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und <paramref name="T" /> implementiert die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public static void Clear (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clear(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Clear(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Clear : Array * int * int -&gt; unit" Usage="System.Array.Clear (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das Array, dessen Elemente gelöscht werden sollen.</param>
        <param name="index">Der Startindex für den Bereich der zu löschenden Elemente.</param>
        <param name="length">Die Anzahl der zu löschenden Elemente.</param>
        <summary>Legt einen Bereich von Elementen in einem Array mit dem Standardwert der einzelnen Elementtypen fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode setzt jedes Element in einem Array auf den Standardwert des Elementtyps zurück. Elemente von Verweis Typen (einschließlich <xref:System.String> Elementen) werden auf `null`festgelegt, und es werden Elemente von Werttypen auf die in der folgenden Tabelle dargestellten Standardwerte festgelegt.  
  
|Typ|Wert|  
|----------|-----------|  
|<xref:System.Boolean>|`false`|  
|Alle numerischen ganzzahligen und Gleit Komma Typen|0 (null)|  
|<xref:System.DateTime>|<xref:System.DateTime.MinValue?displayProperty=nameWithType>|  
|Andere Werttypen|Standardwert der Felder des Typs|  
  
 Der Bereich der gelöschten Elemente wird von Zeile zu Zeile in einem mehrdimensionalen Array umschlossen.  
  
 Diese Methode löscht nur die Werte der-Elemente. die Elemente selbst werden nicht gelöscht. Ein Array hat eine Größe mit fester Größe. Daher können Elemente nicht hinzugefügt oder entfernt werden.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` `length`ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Array.Clear%2A>-Methode verwendet, um ganzzahlige Werte in einem eindimensionalen, zweidimensionalen und dreidimensionalen Array zurückzusetzen.  
  
 [!code-csharp[System.Array.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/example.cs#1)]
 [!code-vb[System.Array.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/example.vb#1)]  
  
 Im folgenden Beispiel wird eine `TimeZoneTime` Struktur definiert, die ein <xref:System.TimeZoneInfo> Feld und ein <xref:System.DateTimeOffset> Feld enthält. Anschließend wird die <xref:System.Array.Clear%2A>-Methode aufgerufen, um ein Element in einem Array von `TimeZoneTime` Werten mit zwei Elementen zu löschen. Die-Methode legt den Wert des gelöschten Elements auf den Standardwert eines <xref:System.TimeZoneInfo> Objekts fest, das `null`ist, und den Standardwert eines <xref:System.DateTimeOffset>-Objekts, das <xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType>ist.  
  
 [!code-csharp[System.Array.Clear#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/clearstruct1.cs#2)]
 [!code-vb[System.Array.Clear#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/clearstruct1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> ist kleiner als die Untergrenze von <paramref name="array" />.  
  
- oder - 
 <paramref name="length" /> ist kleiner als Null.  
  
- oder - 
Die Summe von <paramref name="index" /> und <paramref name="length" /> ist größer als die Größe des <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Clone() cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Clone();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; obj" Usage="array.Clone " FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="array.Clone " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public virtual object Clone ();" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine flache Kopie von <see cref="T:System.Array" />.</summary>
        <returns>Eine flache Kopie von <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei einer flachen Kopie einer <xref:System.Array> werden nur die Elemente der <xref:System.Array>kopiert, unabhängig davon, ob es sich um Verweis Typen oder Werttypen handelt, die Objekte, auf die die Verweise verweisen, werden jedoch nicht kopiert. Die Verweise in der neuen <xref:System.Array> zeigen auf dieselben Objekte, auf die die Verweise im ursprünglichen <xref:System.Array> zeigen.  
  
 Im Gegensatz dazu kopiert eine tiefe Kopie einer <xref:System.Array> die Elemente und alles, auf das von den Elementen direkt oder indirekt verwiesen wird.  
  
 Der Klon hat denselben <xref:System.Type> wie der ursprüngliche <xref:System.Array>.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` <xref:System.Array.Length%2A>ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> Array geklont und das Verhalten einer flachen Kopie veranschaulicht.  
  
 [!code-cpp[System.Array.Clone#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Clone/CPP/arrayclone.cpp#1)]
 [!code-csharp[System.Array.Clone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clone/CS/arrayclone.cs#1)]
 [!code-vb[System.Array.Clone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clone/VB/arrayclone.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ConstrainedCopy">
      <MemberSignature Language="C#" Value="public static void ConstrainedCopy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConstrainedCopy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ConstrainedCopy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ConstrainedCopy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="F#" Value="static member ConstrainedCopy : Array * int * Array * int * int -&gt; unit" Usage="System.Array.ConstrainedCopy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="sourceIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destinationArray" Type="System.Array" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destinationIndex" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceArray">Das <see cref="T:System.Array" />, das die zu kopierenden Daten enthält.</param>
        <param name="sourceIndex">Eine 32-Bit-Ganzzahl, die den Index im <paramref name="sourceArray" /> angibt, ab dem kopiert werden soll.</param>
        <param name="destinationArray">Das <see cref="T:System.Array" />, das die Daten empfängt.</param>
        <param name="destinationIndex">Eine 32-Bit-Ganzzahl, die den Index im <paramref name="destinationArray" /> angibt, ab dem gespeichert werden soll.</param>
        <param name="length">Eine 32-Bit-Ganzzahl, die die Anzahl der zu kopierenden Elemente darstellt.</param>
        <summary>Kopiert einen beim angegebenen Quellindex beginnenden Elementbereich aus einem <see cref="T:System.Array" /> und fügt ihn ab dem angegebenen Zielindex in ein anderes <see cref="T:System.Array" /> ein.  Stellt sicher, dass alle Änderungen rückgängig gemacht werden, wenn der Kopiervorgang nicht vollständig abgeschlossen wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Parameter "`sourceArray`" und "`destinationArray`" müssen die gleiche Anzahl von Dimensionen aufweisen.  Der `sourceArray` Typ muss mit dem Typ übereinstimmen oder vom `destinationArray` Typ abgeleitet werden. Andernfalls wird eine <xref:System.ArrayTypeMismatchException> ausgelöst.  Im Gegensatz zu <xref:System.Array.Copy%2A>überprüft <xref:System.Array.ConstrainedCopy%2A> die Kompatibilität der Array Typen, bevor ein Vorgang durchgeführt wird.  
  
 Beim Kopieren zwischen mehrdimensionalen Arrays verhält sich das Array wie ein langes eindimensionales Array, bei dem die Zeilen (oder Spalten) vom Ende bis zum Ende verankert werden. Wenn ein Array z. b. über drei Zeilen (oder Spalten) mit jeweils vier Elementen verfügt, werden beim Kopieren von sechs Elementen vom Anfang des Arrays alle vier Elemente der ersten Zeile (oder Spalte) und die ersten beiden Elemente der zweiten Zeile (oder Spalte) kopiert. Um mit dem Kopieren vom zweiten Element der dritten Zeile (oder Spalte) zu beginnen, muss `sourceIndex` die obere Grenze der ersten Zeile (oder Spalte) plus der Länge der zweiten Zeile (oder Spalte) plus 2 sein.  
  
 Wenn sich `sourceArray` und `destinationArray` überlappen, verhält sich diese Methode so, als ob die ursprünglichen Werte von `sourceArray` an einem temporären Speicherort beibehalten wurden, bevor `destinationArray` überschrieben wurde.  
  
 [C++]  
  
 Diese Methode entspricht der standardmäßigen C/FunctionC++ -`memmove`, nicht `memcpy`.  
  
 Arrays können aus Verweistyp Arrays oder Werttyp Arrays bestehen.  Wenn `sourceArray` und `destinationArray` beide als Verweistyp Arrays oder beide Arrays vom Typ <xref:System.Object>sind, wird eine flache Kopie ausgeführt. Eine flache Kopie eines <xref:System.Array> ist ein neues <xref:System.Array>, das Verweise auf dieselben Elemente wie die ursprüngliche <xref:System.Array>enthält. Die Elemente selbst oder alle Elemente, auf die von den Elementen verwiesen wird, werden nicht kopiert. Im Gegensatz dazu kopiert eine tiefe Kopie einer <xref:System.Array> die Elemente und alles, auf das von den Elementen direkt oder indirekt verwiesen wird.  
  
 Wenn diese Methode eine Ausnahme beim Kopieren auslöst, bleibt die `destinationArray` unverändert. Daher können <xref:System.Array.ConstrainedCopy%2A> in einem eingeschränkten Ausführungs Bereich (<xref:System.Runtime.ConstrainedExecution.Cer>) verwendet werden.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` `length`ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="destinationArray" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> und <paramref name="destinationArray" /> sind von unterschiedlichem Rang.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">Der <paramref name="sourceArray" />-Typ entspricht weder dem <paramref name="destinationArray" />-Typ, noch wird er von diesem abgeleitet.</exception>
        <exception cref="T:System.InvalidCastException">Mindestens ein Element im <paramref name="sourceArray" /> kann nicht in den Typ des <paramref name="destinationArray" />s umgewandelt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" /> ist kleiner als die untere Grenze der ersten Dimension von <paramref name="sourceArray" />.  
  
- oder - 
 <paramref name="destinationIndex" /> ist kleiner als die untere Grenze der ersten Dimension von <paramref name="destinationArray" />.  
  
- oder - 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> ist größer als die Anzahl der Elemente vom <paramref name="sourceIndex" /> bis zum Ende des <paramref name="sourceArray" />s.  
  
- oder - 
 <paramref name="length" /> ist größer als die Anzahl der Elemente vom <paramref name="destinationIndex" /> bis zum Ende des <paramref name="destinationArray" />s.</exception>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.Clone" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.Cer" />
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TInput,TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput[] ConvertAll&lt;TInput,TOutput&gt; (TInput[] array, Converter&lt;TInput,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput[] ConvertAll&lt;TInput, TOutput&gt;(!!TInput[] array, class System.Converter`2&lt;!!TInput, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertAll(Of TInput, TOutput) (array As TInput(), converter As Converter(Of TInput, TOutput)) As TOutput()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput, typename TOutput&gt;&#xA; static cli::array &lt;TOutput&gt; ^ ConvertAll(cli::array &lt;TInput&gt; ^ array, Converter&lt;TInput, TOutput&gt; ^ converter);" />
      <MemberSignature Language="F#" Value="static member ConvertAll : 'Input[] * Converter&lt;'Input, 'Output&gt; -&gt; 'Output[]" Usage="System.Array.ConvertAll (array, converter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="TInput[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="converter" Type="System.Converter&lt;TInput,TOutput&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">Der Typ der Elemente des Quellarrays.</typeparam>
        <typeparam name="TOutput">Der Typ der Elemente des Zielarrays.</typeparam>
        <param name="array">Das eindimensionale nullbasierte <see cref="T:System.Array" />, das in einen Zieltyp konvertiert werden soll.</param>
        <param name="converter">Ein <see cref="T:System.Converter`2" />, der jedes Element von einem Typ in einen anderen Typ konvertiert.</param>
        <summary>Konvertiert ein Array des einen Typs in ein Array eines anderen Typs.</summary>
        <returns>Ein Array des Zieltyps, das die konvertierten Elemente aus dem Quellarray enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Converter%602> ist ein Delegat einer Methode, die ein Objekt in den Zieltyp konvertiert.  Die Elemente `array` werden einzeln an den <xref:System.Converter%602>und die konvertierten Elemente im neuen Array gespeichert.  
  
 Der Quell `array` bleibt unverändert.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> von `array`ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Methode mit dem Namen `PointFToPoint` definiert, die eine <xref:System.Drawing.PointF>-Struktur in eine <xref:System.Drawing.Point> Struktur konvertiert. Im Beispiel wird dann ein Array aus <xref:System.Drawing.PointF> Strukturen erstellt, ein `Converter<PointF, Point>` Delegat (`Converter(Of PointF, Point)` in Visual Basic) erstellt, um die `PointFToPoint`-Methode darzustellen, und der-Delegat wird an die <xref:System.Array.ConvertAll%2A>-Methode weitergeleitet. Die <xref:System.Array.ConvertAll%2A>-Methode übergibt jedes Element der Eingabeliste an die `PointFToPoint`-Methode und fügt die konvertierten Elemente in eine neue Liste von <xref:System.Drawing.Point> Strukturen ein. Beide Listen werden angezeigt.  
  
 [!code-cpp[Array_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[Array_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_ConvertAll/cs/source.cs#1)]
 [!code-vb[Array_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="converter" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiert einen Bereich von Elementen eines <see cref="T:System.Array" /> in ein anderes <see cref="T:System.Array" /> und führt ggf. Typumwandlungen und Boxing durch.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * Array * int -&gt; unit" Usage="System.Array.Copy (sourceArray, destinationArray, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">Das <see cref="T:System.Array" />, das die zu kopierenden Daten enthält.</param>
        <param name="destinationArray">Das <see cref="T:System.Array" />, das die Daten empfängt.</param>
        <param name="length">Eine 32-Bit-Ganzzahl, die die Anzahl der zu kopierenden Elemente darstellt.</param>
        <summary>Kopiert einen mit dem ersten Element beginnenden Elementbereich eines <see cref="T:System.Array" /> und fügt ihn ab dem ersten Element in ein anderes <see cref="T:System.Array" /> ein. Die Länge wird als 32-Bit-Ganzzahl angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Parameter "`sourceArray`" und "`destinationArray`" müssen die gleiche Anzahl von Dimensionen aufweisen. Außerdem muss `destinationArray` bereits dimensioniert sein und muss über eine ausreichende Anzahl von Elementen verfügen, um die kopierten Daten aufnehmen zu können.  
  
 Beim Kopieren zwischen mehrdimensionalen Arrays verhält sich das Array wie ein langes eindimensionales Array, bei dem die Zeilen (oder Spalten) konzeptionell am Ende angeordnet werden. Wenn ein Array z. b. über drei Zeilen (oder Spalten) mit jeweils vier Elementen verfügt, werden beim Kopieren von sechs Elementen vom Anfang des Arrays alle vier Elemente der ersten Zeile (oder Spalte) und die ersten beiden Elemente der zweiten Zeile (oder Spalte) kopiert.  
  
 Wenn sich `sourceArray` und `destinationArray` überlappen, verhält sich diese Methode so, als ob die ursprünglichen Werte von `sourceArray` an einem temporären Speicherort beibehalten wurden, bevor `destinationArray` überschrieben wurde.  
  
 [C++]  
  
 Diese Methode entspricht der standardmäßigen C/FunctionC++ -`memmove`, nicht `memcpy`.  
  
 Arrays können aus Verweistyp Arrays oder Werttyp Arrays bestehen. Die typdownumwandlung erfolgt nach Bedarf.  
  
-   Beim Kopieren aus einem Verweistyp Array in ein Werttyp Array wird jedes Element Unboxing und dann kopiert. Beim Kopieren aus einem Werttyp Array in ein Verweistyp Array wird jedes Element gekapselt und dann kopiert.  
  
-   Beim Kopieren aus einem Verweistyp-oder Werttyp Array in ein <xref:System.Object> Array wird ein <xref:System.Object> erstellt, um jeden Wert oder Verweis zu speichern und anschließend kopiert zu werden. Beim Kopieren aus einem <xref:System.Object> Arrays in einen Verweistyp-oder Werttyp Array und die Zuweisung ist nicht möglich, wird eine <xref:System.InvalidCastException> ausgelöst.  
  
-   Wenn `sourceArray` und `destinationArray` beide als Verweistyp Arrays oder beide Arrays vom Typ <xref:System.Object>sind, wird eine flache Kopie ausgeführt. Eine flache Kopie eines <xref:System.Array> ist ein neues <xref:System.Array>, das Verweise auf dieselben Elemente wie die ursprüngliche <xref:System.Array>enthält. Die Elemente selbst oder alle Elemente, auf die von den Elementen verwiesen wird, werden nicht kopiert. Im Gegensatz dazu kopiert eine tiefe Kopie einer <xref:System.Array> die Elemente und alles, auf das von den Elementen direkt oder indirekt verwiesen wird.  
  
 Eine <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn die Arrays nicht kompatible Typen sind. Typkompatibilität wird wie folgt definiert:  
  
-   Ein Typ ist mit sich selbst kompatibel.  
  
-   Ein Werttyp ist kompatibel mit <xref:System.Object> und mit einem Schnittstellentyp, der durch diesen Werttyp implementiert wird. Ein Werttyp wird nur dann als verbunden mit einer Schnittstelle betrachtet, wenn er diese Schnittstelle direkt implementiert. Getrennte Typen sind nicht kompatibel.  
  
-   Zwei intrinsische (vordefinierte) Werttypen sind kompatibel, wenn das Kopieren vom Quelltyp in den Zieltyp eine erweiternde Konvertierung ist. Eine erweiternde Konvertierung verliert niemals Informationen, während eine einschränkende Konvertierung Informationen verlieren kann. Beispielsweise ist das Konvertieren einer 32-Bit-Ganzzahl mit Vorzeichen in eine 64-Bit-Ganzzahl mit Vorzeichen eine erweiternde Konvertierung, und die Konvertierung einer 64-Bit-Ganzzahl mit Vorzeichen in 32 eine Ganzzahl mit Vorzeichen mit Vorzeichen ist eine einschränkende Konvertierung Weitere Informationen zu Konvertierungen finden Sie unter <xref:System.Convert>.  
  
-   Ein nicht System interner (benutzerdefinierter) Werttyp ist nur mit sich selbst kompatibel.  
  
-   Enumerationen verfügen über eine implizite Konvertierung in <xref:System.Enum> und ihren zugrunde liegenden Typ.  
  
 Wenn jedes Element in `sourceArray` einen Typumwandlung erfordert (z. b. von einer Basisklasse zu einer abgeleiteten Klasse oder von einer Schnittstelle zu einem Objekt) und mindestens ein Element in `destinationArray`nicht in den entsprechenden Typ umgewandelt werden kann, wird ein <xref:System.InvalidCastException> ausgelöst.  
  
 Wenn diese Methode eine Ausnahme beim Kopieren auslöst, ist der Status `destinationArray` nicht definiert.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` `length`ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="destinationArray" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> und <paramref name="destinationArray" /> sind von unterschiedlichem Rang.</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> und <paramref name="destinationArray" /> weisen inkompatible Typen auf.</exception>
        <exception cref="T:System.InvalidCastException">Mindestens ein Element in <paramref name="sourceArray" /> kann nicht in den <paramref name="destinationArray" />-Typ umgewandelt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> ist größer als die Anzahl von Elementen in <paramref name="sourceArray" />.  
  
- oder - 
 <paramref name="length" /> ist größer als die Anzahl von Elementen in <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, long length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * Array * int64 -&gt; unit" Usage="System.Array.Copy (sourceArray, destinationArray, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="destinationArray" Type="System.Array" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="sourceArray">Das <see cref="T:System.Array" />, das die zu kopierenden Daten enthält.</param>
        <param name="destinationArray">Das <see cref="T:System.Array" />, das die Daten empfängt.</param>
        <param name="length">Eine 64-Bit-Ganzzahl, die die Anzahl der zu kopierenden Elemente darstellt. Die Ganzzahl muss zwischen 0 (null) und einschließlich <see cref="F:System.Int32.MaxValue" /> liegen.</param>
        <summary>Kopiert einen mit dem ersten Element beginnenden Elementbereich eines <see cref="T:System.Array" /> und fügt ihn ab dem ersten Element in ein anderes <see cref="T:System.Array" /> ein. Die Länge wird als 64-Bit-Ganzzahl angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Parameter "`sourceArray`" und "`destinationArray`" müssen die gleiche Anzahl von Dimensionen aufweisen. Außerdem muss `destinationArray` bereits dimensioniert sein und muss über eine ausreichende Anzahl von Elementen verfügen, um die kopierten Daten aufnehmen zu können.  
  
 Beim Kopieren zwischen mehrdimensionalen Arrays verhält sich das Array wie ein langes eindimensionales Array, bei dem die Zeilen (oder Spalten) konzeptionell am Ende angeordnet werden. Wenn ein Array z. b. über drei Zeilen (oder Spalten) mit jeweils vier Elementen verfügt, werden beim Kopieren von sechs Elementen vom Anfang des Arrays alle vier Elemente der ersten Zeile (oder Spalte) und die ersten beiden Elemente der zweiten Zeile (oder Spalte) kopiert.  
  
 Wenn sich `sourceArray` und `destinationArray` überlappen, verhält sich diese Methode so, als ob die ursprünglichen Werte von `sourceArray` an einem temporären Speicherort beibehalten wurden, bevor `destinationArray` überschrieben wurde.  
  
 [C++]  
  
 Diese Methode entspricht der standardmäßigen C/FunctionC++ -`memmove`, nicht `memcpy`.  
  
 Arrays können aus Verweistyp Arrays oder Werttyp Arrays bestehen. Die typdownumwandlung erfolgt nach Bedarf.  
  
-   Beim Kopieren aus einem Verweistyp Array in ein Werttyp Array wird jedes Element Unboxing und dann kopiert. Beim Kopieren aus einem Werttyp Array in ein Verweistyp Array wird jedes Element gekapselt und dann kopiert.  
  
-   Beim Kopieren aus einem Verweistyp-oder Werttyp Array in ein <xref:System.Object> Array wird ein <xref:System.Object> erstellt, um jeden Wert oder Verweis zu speichern und anschließend kopiert zu werden. Beim Kopieren aus einem <xref:System.Object> Arrays in einen Verweistyp-oder Werttyp Array und die Zuweisung ist nicht möglich, wird eine <xref:System.InvalidCastException> ausgelöst.  
  
-   Wenn `sourceArray` und `destinationArray` beide als Verweistyp Arrays oder beide Arrays vom Typ <xref:System.Object>sind, wird eine flache Kopie ausgeführt. Eine flache Kopie eines <xref:System.Array> ist ein neues <xref:System.Array>, das Verweise auf dieselben Elemente wie die ursprüngliche <xref:System.Array>enthält. Die Elemente selbst oder alle Elemente, auf die von den Elementen verwiesen wird, werden nicht kopiert. Im Gegensatz dazu kopiert eine tiefe Kopie einer <xref:System.Array> die Elemente und alles, auf das von den Elementen direkt oder indirekt verwiesen wird.  
  
 Eine <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn die Arrays nicht kompatible Typen sind. Typkompatibilität wird wie folgt definiert:  
  
-   Ein Typ ist mit sich selbst kompatibel.  
  
-   Ein Werttyp ist kompatibel mit <xref:System.Object> und mit einem Schnittstellentyp, der durch diesen Werttyp implementiert wird. Ein Werttyp wird nur dann als verbunden mit einer Schnittstelle betrachtet, wenn er diese Schnittstelle direkt implementiert. Getrennte Typen sind nicht kompatibel.  
  
-   Zwei intrinsische (vordefinierte) Werttypen sind kompatibel, wenn das Kopieren vom Quelltyp in den Zieltyp eine erweiternde Konvertierung ist. Eine erweiternde Konvertierung verliert niemals Informationen, während eine einschränkende Konvertierung Informationen verlieren kann. Beispielsweise ist das Konvertieren einer 32-Bit-Ganzzahl mit Vorzeichen in eine 64-Bit-Ganzzahl mit Vorzeichen eine erweiternde Konvertierung, und die Konvertierung einer 64-Bit-Ganzzahl mit Vorzeichen in 32 eine Ganzzahl mit Vorzeichen mit Vorzeichen ist eine einschränkende Konvertierung Weitere Informationen zu Konvertierungen finden Sie unter <xref:System.Convert>.  
  
-   Ein nicht System interner (benutzerdefinierter) Werttyp ist nur mit sich selbst kompatibel.  
  
-   Enumerationen verfügen über eine implizite Konvertierung in <xref:System.Enum> und ihren zugrunde liegenden Typ.  
  
 Wenn jedes Element in `sourceArray` einen Typumwandlung erfordert (z. b. von einer Basisklasse zu einer abgeleiteten Klasse oder von einer Schnittstelle zu einem Objekt) und mindestens ein Element in `destinationArray`nicht in den entsprechenden Typ umgewandelt werden kann, wird ein <xref:System.InvalidCastException> ausgelöst.  
  
 Wenn diese Methode eine Ausnahme beim Kopieren auslöst, ist der Status `destinationArray` nicht definiert.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` `length`ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="destinationArray" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> und <paramref name="destinationArray" /> sind von unterschiedlichem Rang.</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> und <paramref name="destinationArray" /> weisen inkompatible Typen auf.</exception>
        <exception cref="T:System.InvalidCastException">Mindestens ein Element im <paramref name="sourceArray" /> kann nicht in den Typ des <paramref name="destinationArray" />s umgewandelt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length" /> ist kleiner als 0 oder größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> ist größer als die Anzahl von Elementen in <paramref name="sourceArray" />.  
  
- oder - 
 <paramref name="length" /> ist größer als die Anzahl von Elementen in <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * int * Array * int * int -&gt; unit" Usage="System.Array.Copy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">Das <see cref="T:System.Array" />, das die zu kopierenden Daten enthält.</param>
        <param name="sourceIndex">Eine 32-Bit-Ganzzahl, die den Index im <paramref name="sourceArray" /> angibt, ab dem kopiert werden soll.</param>
        <param name="destinationArray">Das <see cref="T:System.Array" />, das die Daten empfängt.</param>
        <param name="destinationIndex">Eine 32-Bit-Ganzzahl, die den Index im <paramref name="destinationArray" /> angibt, ab dem gespeichert werden soll.</param>
        <param name="length">Eine 32-Bit-Ganzzahl, die die Anzahl der zu kopierenden Elemente darstellt.</param>
        <summary>Kopiert einen beim angegebenen Quellindex beginnenden Elementbereich aus einem <see cref="T:System.Array" /> und fügt ihn ab dem angegebenen Zielindex in ein anderes <see cref="T:System.Array" /> ein. Die Länge und die Indizes werden als 32-Bit-Ganzzahlen angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Parameter "`sourceArray`" und "`destinationArray`" müssen die gleiche Anzahl von Dimensionen aufweisen. Außerdem muss `destinationArray` bereits dimensioniert sein und muss über eine ausreichende Anzahl von Elementen verfügen, beginnend mit der `destinationIndex` Position, um die kopierten Daten aufzunehmen.  
  
 Beim Kopieren zwischen mehrdimensionalen Arrays verhält sich das Array wie ein langes eindimensionales Array, bei dem die Zeilen (oder Spalten) vom Ende bis zum Ende verankert werden. Wenn ein Array z. b. über drei Zeilen (oder Spalten) mit jeweils vier Elementen verfügt, werden beim Kopieren von sechs Elementen vom Anfang des Arrays alle vier Elemente der ersten Zeile (oder Spalte) und die ersten beiden Elemente der zweiten Zeile (oder Spalte) kopiert. Um mit dem Kopieren vom zweiten Element der dritten Zeile (oder Spalte) zu beginnen, muss `sourceIndex` die obere Grenze der ersten Zeile (oder Spalte) plus der Länge der zweiten Zeile (oder Spalte) plus 2 sein.  
  
 Wenn sich `sourceArray` und `destinationArray` überlappen, verhält sich diese Methode so, als ob die ursprünglichen Werte von `sourceArray` an einem temporären Speicherort beibehalten wurden, bevor `destinationArray` überschrieben wurde.  
  
 [C++]  
  
 Diese Methode entspricht der standardmäßigen C/FunctionC++ -`memmove`, nicht `memcpy`.  
  
 Arrays können aus Verweistyp Arrays oder Werttyp Arrays bestehen. Die typdownumwandlung erfolgt nach Bedarf.  
  
-   Beim Kopieren aus einem Verweistyp Array in ein Werttyp Array wird jedes Element Unboxing und dann kopiert. Beim Kopieren aus einem Werttyp Array in ein Verweistyp Array wird jedes Element gekapselt und dann kopiert.  
  
-   Beim Kopieren aus einem Verweistyp-oder Werttyp Array in ein <xref:System.Object> Array wird ein <xref:System.Object> erstellt, um jeden Wert oder Verweis zu speichern und anschließend kopiert zu werden. Beim Kopieren aus einem <xref:System.Object> Arrays in einen Verweistyp-oder Werttyp Array und die Zuweisung ist nicht möglich, wird eine <xref:System.InvalidCastException> ausgelöst.  
  
-   Wenn `sourceArray` und `destinationArray` beide als Verweistyp Arrays oder beide Arrays vom Typ <xref:System.Object>sind, wird eine flache Kopie ausgeführt. Eine flache Kopie eines <xref:System.Array> ist ein neues <xref:System.Array>, das Verweise auf dieselben Elemente wie die ursprüngliche <xref:System.Array>enthält. Die Elemente selbst oder alle Elemente, auf die von den Elementen verwiesen wird, werden nicht kopiert. Im Gegensatz dazu kopiert eine tiefe Kopie einer <xref:System.Array> die Elemente und alles, auf das von den Elementen direkt oder indirekt verwiesen wird.  
  
 Eine <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn die Arrays nicht kompatible Typen sind. Typkompatibilität wird wie folgt definiert:  
  
-   Ein Typ ist mit sich selbst kompatibel.  
  
-   Ein Werttyp ist kompatibel mit <xref:System.Object> und mit einem Schnittstellentyp, der durch diesen Werttyp implementiert wird. Ein Werttyp wird nur dann als verbunden mit einer Schnittstelle betrachtet, wenn er diese Schnittstelle direkt implementiert. Getrennte Typen sind nicht kompatibel.  
  
-   Zwei intrinsische (vordefinierte) Werttypen sind kompatibel, wenn das Kopieren vom Quelltyp in den Zieltyp eine erweiternde Konvertierung ist. Eine erweiternde Konvertierung verliert niemals Informationen, während eine einschränkende Konvertierung Informationen verlieren kann. Beispielsweise ist das Konvertieren einer 32-Bit-Ganzzahl mit Vorzeichen in eine 64-Bit-Ganzzahl mit Vorzeichen eine erweiternde Konvertierung, und die Konvertierung einer 64-Bit-Ganzzahl mit Vorzeichen in 32 eine Ganzzahl mit Vorzeichen mit Vorzeichen ist eine einschränkende Konvertierung Weitere Informationen zu Konvertierungen finden Sie unter <xref:System.Convert>.  
  
-   Ein nicht System interner (benutzerdefinierter) Werttyp ist nur mit sich selbst kompatibel.  
  
-   Enumerationen verfügen über eine implizite Konvertierung in <xref:System.Enum> und ihren zugrunde liegenden Typ.  
  
 Wenn jedes Element in `sourceArray` einen Typumwandlung erfordert (z. b. von einer Basisklasse zu einer abgeleiteten Klasse oder von einer Schnittstelle zu einem Objekt) und mindestens ein Element in `destinationArray`nicht in den entsprechenden Typ umgewandelt werden kann, wird ein <xref:System.InvalidCastException> ausgelöst.  
  
 Wenn diese Methode eine Ausnahme beim Kopieren auslöst, ist der Status `destinationArray` nicht definiert.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` `length`ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie von einem <xref:System.Array> vom Typ <xref:System.Object> in einen anderen <xref:System.Array> vom Typ Integer kopiert wird.  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="destinationArray" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> und <paramref name="destinationArray" /> sind von unterschiedlichem Rang.</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> und <paramref name="destinationArray" /> weisen inkompatible Typen auf.</exception>
        <exception cref="T:System.InvalidCastException">Mindestens ein Element im <paramref name="sourceArray" /> kann nicht in den Typ des <paramref name="destinationArray" />s umgewandelt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" /> ist kleiner als die untere Grenze der ersten Dimension von <paramref name="sourceArray" />.  
  
- oder - 
 <paramref name="destinationIndex" /> ist kleiner als die untere Grenze der ersten Dimension von <paramref name="destinationArray" />.  
  
- oder - 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> ist größer als die Anzahl der Elemente vom <paramref name="sourceIndex" /> bis zum Ende des <paramref name="sourceArray" />s.  
  
- oder - 
 <paramref name="length" /> ist größer als die Anzahl der Elemente vom <paramref name="destinationIndex" /> bis zum Ende des <paramref name="destinationArray" />s.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int64 sourceIndex, class System.Array destinationArray, int64 destinationIndex, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Long, destinationArray As Array, destinationIndex As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, long sourceIndex, Array ^ destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * int64 * Array * int64 * int64 -&gt; unit" Usage="System.Array.Copy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="sourceIndex" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="destinationArray" Type="System.Array" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="destinationIndex" Type="System.Int64" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int64" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="sourceArray">Das <see cref="T:System.Array" />, das die zu kopierenden Daten enthält.</param>
        <param name="sourceIndex">Eine 64-Bit-Ganzzahl, die den Index im <paramref name="sourceArray" /> angibt, ab dem kopiert werden soll.</param>
        <param name="destinationArray">Das <see cref="T:System.Array" />, das die Daten empfängt.</param>
        <param name="destinationIndex">Eine 64-Bit-Ganzzahl, die den Index im <paramref name="destinationArray" /> angibt, ab dem gespeichert werden soll.</param>
        <param name="length">Eine 64-Bit-Ganzzahl, die die Anzahl der zu kopierenden Elemente darstellt. Die Ganzzahl muss zwischen 0 (null) und einschließlich <see cref="F:System.Int32.MaxValue" /> liegen.</param>
        <summary>Kopiert einen beim angegebenen Quellindex beginnenden Elementbereich aus einem <see cref="T:System.Array" /> und fügt ihn ab dem angegebenen Zielindex in ein anderes <see cref="T:System.Array" /> ein. Die Länge und die Indizes werden als 64-Bit-Ganzzahlen angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Parameter "`sourceArray`" und "`destinationArray`" müssen die gleiche Anzahl von Dimensionen aufweisen. Außerdem muss `destinationArray` bereits dimensioniert sein und muss über eine ausreichende Anzahl von Elementen verfügen, beginnend mit der `destinationIndex` Position, um die kopierten Daten aufzunehmen.  
  
 Beim Kopieren zwischen mehrdimensionalen Arrays verhält sich das Array wie ein langes eindimensionales Array, bei dem die Zeilen (oder Spalten) vom Ende bis zum Ende verankert werden. Wenn ein Array z. b. über drei Zeilen (oder Spalten) mit jeweils vier Elementen verfügt, werden beim Kopieren von sechs Elementen vom Anfang des Arrays alle vier Elemente der ersten Zeile (oder Spalte) und die ersten beiden Elemente der zweiten Zeile (oder Spalte) kopiert. Um mit dem Kopieren vom zweiten Element der dritten Zeile (oder Spalte) zu beginnen, muss `sourceIndex` die obere Grenze der ersten Zeile (oder Spalte) plus der Länge der zweiten Zeile (oder Spalte) plus 2 sein.  
  
 Wenn sich `sourceArray` und `destinationArray` überlappen, verhält sich diese Methode so, als ob die ursprünglichen Werte von `sourceArray` an einem temporären Speicherort beibehalten wurden, bevor `destinationArray` überschrieben wurde.  
  
 [C++]  
  
 Diese Methode entspricht der standardmäßigen C/FunctionC++ -`memmove`, nicht `memcpy`.  
  
 Arrays können aus Verweistyp Arrays oder Werttyp Arrays bestehen. Die typdownumwandlung erfolgt nach Bedarf.  
  
-   Beim Kopieren aus einem Verweistyp Array in ein Werttyp Array wird jedes Element Unboxing und dann kopiert. Beim Kopieren aus einem Werttyp Array in ein Verweistyp Array wird jedes Element gekapselt und dann kopiert.  
  
-   Beim Kopieren aus einem Verweistyp-oder Werttyp Array in ein <xref:System.Object> Array wird ein <xref:System.Object> erstellt, um jeden Wert oder Verweis zu speichern und anschließend kopiert zu werden. Beim Kopieren aus einem <xref:System.Object> Arrays in einen Verweistyp-oder Werttyp Array und die Zuweisung ist nicht möglich, wird eine <xref:System.InvalidCastException> ausgelöst.  
  
-   Wenn `sourceArray` und `destinationArray` beide als Verweistyp Arrays oder beide Arrays vom Typ <xref:System.Object>sind, wird eine flache Kopie ausgeführt. Eine flache Kopie eines <xref:System.Array> ist ein neues <xref:System.Array>, das Verweise auf dieselben Elemente wie die ursprüngliche <xref:System.Array>enthält. Die Elemente selbst oder alle Elemente, auf die von den Elementen verwiesen wird, werden nicht kopiert. Im Gegensatz dazu kopiert eine tiefe Kopie einer <xref:System.Array> die Elemente und alles, auf das von den Elementen direkt oder indirekt verwiesen wird.  
  
 Eine <xref:System.ArrayTypeMismatchException> wird ausgelöst, wenn die Arrays nicht kompatible Typen sind. Typkompatibilität wird wie folgt definiert:  
  
-   Ein Typ ist mit sich selbst kompatibel.  
  
-   Ein Werttyp ist kompatibel mit <xref:System.Object> und mit einem Schnittstellentyp, der durch diesen Werttyp implementiert wird. Ein Werttyp wird nur dann als verbunden mit einer Schnittstelle betrachtet, wenn er diese Schnittstelle direkt implementiert. Getrennte Typen sind nicht kompatibel.  
  
-   Zwei intrinsische (vordefinierte) Werttypen sind kompatibel, wenn das Kopieren vom Quelltyp in den Zieltyp eine erweiternde Konvertierung ist. Eine erweiternde Konvertierung verliert niemals Informationen, während eine einschränkende Konvertierung Informationen verlieren kann. Beispielsweise ist das Konvertieren einer 32-Bit-Ganzzahl mit Vorzeichen in eine 64-Bit-Ganzzahl mit Vorzeichen eine erweiternde Konvertierung, und die Konvertierung einer 64-Bit-Ganzzahl mit Vorzeichen in 32 eine Ganzzahl mit Vorzeichen mit Vorzeichen ist eine einschränkende Konvertierung Weitere Informationen zu Konvertierungen finden Sie unter <xref:System.Convert>.  
  
-   Ein nicht System interner (benutzerdefinierter) Werttyp ist nur mit sich selbst kompatibel.  
  
-   Enumerationen verfügen über eine implizite Konvertierung in <xref:System.Enum> und ihren zugrunde liegenden Typ.  
  
 Wenn jedes Element in `sourceArray` einen Typumwandlung erfordert (z. b. von einer Basisklasse zu einer abgeleiteten Klasse oder von einer Schnittstelle zu einem Objekt) und mindestens ein Element in `destinationArray`nicht in den entsprechenden Typ umgewandelt werden kann, wird ein <xref:System.InvalidCastException> ausgelöst.  
  
 Wenn diese Methode eine Ausnahme beim Kopieren auslöst, ist der Status `destinationArray` nicht definiert.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` `length`ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie von einem <xref:System.Array> vom Typ <xref:System.Object> in einen anderen <xref:System.Array> vom Typ Integer kopiert wird.  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="destinationArray" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> und <paramref name="destinationArray" /> sind von unterschiedlichem Rang.</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> und <paramref name="destinationArray" /> weisen inkompatible Typen auf.</exception>
        <exception cref="T:System.InvalidCastException">Mindestens ein Element im <paramref name="sourceArray" /> kann nicht in den Typ des <paramref name="destinationArray" />s umgewandelt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für das <paramref name="sourceArray" />.  
  
- oder - 
 <paramref name="destinationIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für das <paramref name="destinationArray" />.  
  
- oder - 
 <paramref name="length" /> ist kleiner als 0 oder größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> ist größer als die Anzahl der Elemente vom <paramref name="sourceIndex" /> bis zum Ende des <paramref name="sourceArray" />s.  
  
- oder - 
 <paramref name="length" /> ist größer als die Anzahl der Elemente vom <paramref name="destinationIndex" /> bis zum Ende des <paramref name="destinationArray" />s.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiert alle Elemente des aktuellen eindimensionalen Arrays in das angegebene eindimensionale Array.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="array.CopyTo (array, index)" />
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array, int index);" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale Array, das das Ziel der aus dem aktuellen Array kopierten Elemente ist.</param>
        <param name="index">Eine 32-Bit-Ganzzahl, die den Index im <paramref name="array" /> angibt, ab dem kopiert werden soll.</param>
        <summary>Kopiert alle Elemente des aktuellen eindimensionalen Arrays in das angegebene eindimensionale Array, beginnend am angegebenen Index des Zielarrays. Der Index wird als 32-Bit-Ganzzahl angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kopiert alle Elemente der aktuellen Array Instanz in das `array` Zielarray, beginnend bei Index `index`. Das `array` Zielarray muss bereits dimensioniert sein und muss über eine ausreichende Anzahl von Elementen verfügen, um die kopierten Elemente aufnehmen zu können. Andernfalls löst die Methode eine Ausnahme aus.  
  
 Diese Methode unterstützt die <xref:System.Collections.ICollection?displayProperty=nameWithType> Schnittstelle. Wenn das Implementieren von <xref:System.Collections.ICollection?displayProperty=nameWithType> nicht explizit erforderlich ist, verwenden Sie <xref:System.Array.Copy%2A>, um eine zusätzliche Dereferenzierung zu vermeiden.  
  
 Wenn diese Methode eine Ausnahme beim Kopieren auslöst, ist der Status `array` nicht definiert.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` <xref:System.Array.Length%2A>ist. Sie führt nur eine flache Kopie aus.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie ein <xref:System.Array> in einen anderen <xref:System.Array>kopiert wird.  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 Im folgenden Codebeispiel wird gezeigt, wie ein <xref:System.Array> in eine andere <xref:System.Array> mit einer unteren Grenze ungleich NULL kopiert wird. Beachten Sie, dass die gesamte Quell <xref:System.Array> kopiert wird, einschließlich leerer Elemente, die vorhandene Elemente im Ziel <xref:System.Array>überschreiben.  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die untere <paramref name="array" />-Grenze.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> ist mehrdimensional.  
  
- oder - 
Die Anzahl der Elemente im Quellarray ist größer als die verfügbare Anzahl der Elemente vom <paramref name="index" /> bis zum Ende des Ziel-<paramref name="array" />s.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">Der Typ des Quell-<see cref="T:System.Array" />s kann nicht automatisch in den Typ des Ziel<paramref name="array" />s umgewandelt werden.</exception>
        <exception cref="T:System.RankException">Das Quellarray ist mehrdimensional.</exception>
        <exception cref="T:System.InvalidCastException">Mindestens ein Element im Quell-<see cref="T:System.Array" /> kann nicht in den Typ des Ziel<paramref name="array" />s umgewandelt werden.</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, long index);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Array array, int64 index) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int64)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Array ^ array, long index);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.CopyTo : Array * int64 -&gt; unit" Usage="array.CopyTo (array, index)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array, long index);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int64 index) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, long index);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int64 -&gt; unit&#xA;override this.CopyTo : Array * int64 -&gt; unit" Usage="array.CopyTo (array, index)" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale Array, das das Ziel der aus dem aktuellen Array kopierten Elemente ist.</param>
        <param name="index">Eine 64-Bit-Ganzzahl, die den Index im <paramref name="array" /> angibt, ab dem kopiert werden soll.</param>
        <summary>Kopiert alle Elemente des aktuellen eindimensionalen Arrays in das angegebene eindimensionale Array, beginnend am angegebenen Index des Zielarrays. Der Index wird als 64-Bit-Ganzzahl angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kopiert alle Elemente der aktuellen Array Instanz in das `array` Zielarray, beginnend bei Index `index`. Das `array` Zielarray muss bereits dimensioniert sein und muss über eine ausreichende Anzahl von Elementen verfügen, um die kopierten Elemente aufnehmen zu können. Andernfalls löst die Methode eine Ausnahme aus.  
  
 Diese Methode unterstützt die <xref:System.Collections.ICollection?displayProperty=nameWithType> Schnittstelle. Wenn das Implementieren von <xref:System.Collections.ICollection?displayProperty=nameWithType> nicht explizit erforderlich ist, verwenden Sie <xref:System.Array.Copy%2A>, um eine zusätzliche Dereferenzierung zu vermeiden.  
  
 Wenn diese Methode eine Ausnahme beim Kopieren auslöst, ist der Status `array` nicht definiert.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` <xref:System.Array.Length%2A>ist. Sie führt nur eine flache Kopie aus.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie ein <xref:System.Array> in einen anderen <xref:System.Array>kopiert wird.  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 Im folgenden Codebeispiel wird gezeigt, wie ein <xref:System.Array> in eine andere <xref:System.Array> mit einer unteren Grenze ungleich NULL kopiert wird. Beachten Sie, dass die gesamte Quell <xref:System.Array> kopiert wird, einschließlich leerer Elemente, die vorhandene Elemente im Ziel <xref:System.Array>überschreiben.  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> ist mehrdimensional.  
  
- oder - 
Die Anzahl der Elemente im Quellarray ist größer als die verfügbare Anzahl der Elemente vom <paramref name="index" /> bis zum Ende des Ziel-<paramref name="array" />s.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">Der Typ des Quell-<see cref="T:System.Array" />s kann nicht automatisch in den Typ des Ziel-<paramref name="array" />s umgewandelt werden.</exception>
        <exception cref="T:System.RankException">Das Quell-<see cref="T:System.Array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.InvalidCastException">Mindestens ein Element im Quell-<see cref="T:System.Array" /> kann nicht in den Typ des Ziel<paramref name="array" />s umgewandelt werden.</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Array" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="elementType">Der <see cref="T:System.Type" /> des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="length">Die Größe des zu erstellenden <see cref="T:System.Array" />.</param>
        <summary>Erstellt ein eindimensionales <see cref="T:System.Array" /> der angegebenen Länge und vom angegebenen <see cref="T:System.Type" /> mit nullbasierter Indizierung.</summary>
        <returns>Ein neues eindimensionales <see cref="T:System.Array" /> der angegebenen Länge und vom angegebenen <see cref="T:System.Type" /> mit nullbasierter Indizierung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu den meisten Klassen stellt <xref:System.Array> die <xref:System.Array.CreateInstance%2A> Methode anstelle von öffentlichen Konstruktoren bereit, um den spät gebundenen Zugriff zu ermöglichen.  
  
 Verweistyp Elemente werden mit `null`initialisiert. Werttyp Elemente werden mit 0 (null) initialisiert.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` `length`ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie ein eindimensionales <xref:System.Array>erstellt und initialisiert wird.  
  
 [!code-cpp[Classic Array.CreateInstance Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> ist kein gültiger <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" /> wird nicht unterstützt. Beispielsweise wird <see cref="T:System.Void" /> nicht unterstützt.  
  
- oder - 
 <paramref name="elementType" /> ist ein offener generischer Typ.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params int[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;int&gt; ^ lengths);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">Der <see cref="T:System.Type" /> des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="lengths">Ein Array von 32-Bit-Ganzzahlen, das die Größe der einzelnen Dimensionen des zu erstellenden <see cref="T:System.Array" /> darstellt.</param>
        <summary>Erstellt ein mehrdimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung. Die Längen der Dimension werden in einem Array von 32-Bit-Ganzzahlen angegeben.</summary>
        <returns>Ein neues mehrdimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu den meisten Klassen stellt <xref:System.Array> die <xref:System.Array.CreateInstance%2A> Methode anstelle von öffentlichen Konstruktoren bereit, um den spät gebundenen Zugriff zu ermöglichen.  
  
 Die Anzahl der Elemente im `lengths` Array muss gleich der Anzahl der Dimensionen in der neuen <xref:System.Array>sein. Jedes Element des `lengths` Arrays muss die Länge der entsprechenden Dimension in der neuen <xref:System.Array>angeben.  
  
 Verweistyp Elemente werden mit `null`initialisiert. Werttyp Elemente werden mit 0 (null) initialisiert.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` das Produkt aller Werte in `lengths`ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie eine mehrdimensionale <xref:System.Array>erstellt und initialisiert wird.  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="lengths" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> ist kein gültiger <see cref="T:System.Type" />.  
  
- oder - 
Das <paramref name="lengths" />-Array enthält weniger als ein Element.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" /> wird nicht unterstützt. Beispielsweise wird <see cref="T:System.Void" /> nicht unterstützt.  
  
- oder - 
 <paramref name="elementType" /> ist ein offener generischer Typ.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Irgendein Wert in <paramref name="lengths" /> ist kleiner als 0 (null).</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params long[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int64[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Long()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;long&gt; ^ lengths);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int64[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="lengths" Type="System.Int64[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">Der <see cref="T:System.Type" /> des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="lengths">Ein Array von 64-Bit-Ganzzahlen, das die Größe der einzelnen Dimensionen des zu erstellenden <see cref="T:System.Array" /> darstellt. Jede Ganzzahl im Array muss zwischen 0 (null) und <see cref="F:System.Int32.MaxValue" /> (einschließlich) liegen.</param>
        <summary>Erstellt ein mehrdimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung. Die Längen der Dimension werden in einem Array von 64-Bit-Ganzzahlen angegeben.</summary>
        <returns>Ein neues mehrdimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu den meisten Klassen stellt <xref:System.Array> die <xref:System.Array.CreateInstance%2A> Methode anstelle von öffentlichen Konstruktoren bereit, um den spät gebundenen Zugriff zu ermöglichen.  
  
 Die Anzahl der Elemente im `lengths` Array muss gleich der Anzahl der Dimensionen in der neuen <xref:System.Array>sein. Jedes Element des `lengths` Arrays muss die Länge der entsprechenden Dimension in der neuen <xref:System.Array>angeben.  
  
 Verweistyp Elemente werden mit `null`initialisiert. Werttyp Elemente werden mit 0 (null) initialisiert.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` das Produkt aller Werte in `lengths`ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie eine mehrdimensionale <xref:System.Array>erstellt und initialisiert wird.  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="lengths" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> ist kein gültiger <see cref="T:System.Type" />.  
  
- oder - 
Das <paramref name="lengths" />-Array enthält weniger als ein Element.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" /> wird nicht unterstützt. Beispielsweise wird <see cref="T:System.Void" /> nicht unterstützt.  
  
- oder - 
 <paramref name="elementType" /> ist ein offener generischer Typ.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Jeder Wert in <paramref name="lengths" /> ist kleiner als 0 (null) oder größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length1, length2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="elementType">Der <see cref="T:System.Type" /> des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="length1">Die Größe der ersten Dimension des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="length2">Die Größe der zweiten Dimension des zu erstellenden <see cref="T:System.Array" />.</param>
        <summary>Erstellt ein zweidimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung.</summary>
        <returns>Ein neues zweidimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu den meisten Klassen stellt <xref:System.Array> die <xref:System.Array.CreateInstance%2A> Methode anstelle von öffentlichen Konstruktoren bereit, um den spät gebundenen Zugriff zu ermöglichen.  
  
 Verweistyp Elemente werden mit `null`initialisiert. Werttyp Elemente werden mit 0 (null) initialisiert.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` das Produkt von `length1` und `length2`ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie ein zweidimensionales <xref:System.Array>erstellt und initialisiert wird.  
  
 [!code-cpp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> ist kein gültiger <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" /> wird nicht unterstützt. Beispielsweise wird <see cref="T:System.Void" /> nicht unterstützt.  
  
- oder - 
 <paramref name="elementType" /> ist ein offener generischer Typ.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length1" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="length2" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int[] lengths, int[] lowerBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths, int32[] lowerBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, lengths As Integer(), lowerBounds As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, cli::array &lt;int&gt; ^ lengths, cli::array &lt;int&gt; ^ lowerBounds);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int[] * int[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths, lowerBounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]" />
        <Parameter Name="lowerBounds" Type="System.Int32[]" />
      </Parameters>
      <Docs>
        <param name="elementType">Der <see cref="T:System.Type" /> des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="lengths">Ein eindimensionales Array mit den Größen aller Dimensionen des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="lowerBounds">Ein eindimensionales Array mit der unteren Grenze (Startindex) für jede Dimension des zu erstellenden <see cref="T:System.Array" />.</param>
        <summary>Erstellt ein mehrdimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und Untergrenze.</summary>
        <returns>Ein neues mehrdimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und Untergrenze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu den meisten Klassen stellt <xref:System.Array> die <xref:System.Array.CreateInstance%2A> Methode anstelle von öffentlichen Konstruktoren bereit, um den spät gebundenen Zugriff zu ermöglichen.  
  
 Die `lengths` und `lowerBounds` Arrays müssen die gleiche Anzahl von Elementen aufweisen. Die Anzahl der Elemente im `lengths` Array muss gleich der Anzahl der Dimensionen in der neuen <xref:System.Array>sein.  
  
 Jedes Element des `lengths` Arrays muss die Länge der entsprechenden Dimension in der neuen <xref:System.Array>angeben.  
  
 Jedes Element des `lowerBounds` Arrays muss die untere Grenze der entsprechenden Dimension in der neuen <xref:System.Array>angeben. Im Allgemeinen werden in der .NET Framework-Klassenbibliothek und vielen Programmiersprachen keine unteren Grenzen ungleich 0 (null) behandelt.  
  
 Verweistyp Elemente werden mit `null`initialisiert. Werttyp Elemente werden mit 0 (null) initialisiert.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` das Produkt aller Werte in `lengths`ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie eine mehrdimensionale <xref:System.Array> mit angegebenen Untergrenzen erstellt und initialisiert wird.  
  
 [!code-cpp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="lengths" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="lowerBounds" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> ist kein gültiger <see cref="T:System.Type" />.  
  
- oder - 
Das <paramref name="lengths" />-Array enthält kein Element.  
  
- oder - 
Das <paramref name="lengths" />- und das <paramref name="lowerBounds" />-Array enthalten nicht dieselbe Anzahl von Elementen.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" /> wird nicht unterstützt. Beispielsweise wird <see cref="T:System.Void" /> nicht unterstützt.  
  
- oder - 
 <paramref name="elementType" /> ist ein offener generischer Typ.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Irgendein Wert in <paramref name="lengths" /> ist kleiner als 0 (null).  
  
- oder - 
Irgendein Wert in <paramref name="lowerBounds" /> ist sehr groß, so dass die Summe aus Untergrenze und Länge einer Dimension größer ist als <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2, int32 length3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer, length3 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int * int * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length1, length2, length3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length3" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="elementType">Der <see cref="T:System.Type" /> des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="length1">Die Größe der ersten Dimension des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="length2">Die Größe der zweiten Dimension des zu erstellenden <see cref="T:System.Array" />.</param>
        <param name="length3">Die Größe der dritten Dimension des zu erstellenden <see cref="T:System.Array" />.</param>
        <summary>Erstellt ein dreidimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung.</summary>
        <returns>Ein neues dreidimensionales <see cref="T:System.Array" /> vom angegebenen <see cref="T:System.Type" /> mit der für jede Dimension angegebenen Länge und mit nullbasierter Indizierung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu den meisten Klassen stellt <xref:System.Array> die <xref:System.Array.CreateInstance%2A> Methode anstelle von öffentlichen Konstruktoren bereit, um den spät gebundenen Zugriff zu ermöglichen.  
  
 Verweistyp Elemente werden mit `null`initialisiert. Werttyp Elemente werden mit 0 (null) initialisiert.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` das Produkt von `length1`, `length2`und `length3`ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie ein dreidimensionaler <xref:System.Array>erstellt und initialisiert wird.  
  
 [!code-cpp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> ist kein gültiger <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" /> wird nicht unterstützt. Beispielsweise wird <see cref="T:System.Void" /> nicht unterstützt.  
  
- oder - 
 <paramref name="elementType" /> ist ein offener generischer Typ.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length1" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="length2" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="length3" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Empty&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] Empty&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Empty``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty(Of T) () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ Empty();" />
      <MemberSignature Language="F#" Value="static member Empty : unit -&gt; 'T[]" Usage="System.Array.Empty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <summary>Gibt ein leeres Array zurück.</summary>
        <returns>Ein leeres Array.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool Exists(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member Exists : 'T[] * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Array.Exists (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="match">Das <see cref="T:System.Predicate`1" />, das die Bedingungen für die Elemente definiert, nach denen gesucht werden soll.</param>
        <summary>Bestimmt, ob das angegebene Array Elemente enthält, die mit den vom angegebenen Prädikat definierten Bedingungen übereinstimmen.</summary>
        <returns><see langword="true" />, wenn <paramref name="array" /> mindestens ein Element enthält, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die `true` zurückgibt, wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente `array` werden einzeln an die <xref:System.Predicate%601>übergebenen, und die Verarbeitung wird beendet, wenn eine Entsprechung gefunden wird.  
  
> [!NOTE]
>  In C# und Visual Basic muss der <xref:System.Predicate%601> Delegat nicht explizit erstellt werden. Diese Sprachen ableiten den korrekten Delegaten aus dem Kontext und erstellen ihn automatisch.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> von `array`ist.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Übereinstimmungs Bedingungen für die <xref:System.Array.Exists%2A> Methode mithilfe von Lambda-Ausdrücken angegeben, um zu überprüfen, ob ein Planet mit einem bestimmten Buchstaben beginnt oder ob der Planet im angegebenen Array gefunden wird.  
  
 [!code-csharp[System.Array.Exists#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists3.cs#3)]
 [!code-vb[System.Array.Exists#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists3.vb#3)]  
  
 Im folgenden Beispiel wird die <xref:System.Array.Exists%2A>-Methode verwendet, um anzugeben, ob Namen in einem Zeichen folgen Array mit einem angegebenen Zeichen beginnen. Im Beispiel wird ein `StringSearcher` Objekt instanziiert, indem die Zeichenfolge, nach der gesucht wird, an den Klassenkonstruktor übergeben wird. Die `StringSearcher.StartsWith`-Methode hat dieselbe Signatur wie der <xref:System.Predicate%601> Delegat. Wenn die <xref:System.Array.Exists%2A>-Methode aufgerufen wird, wird jedes Element des Arrays an den Delegaten weitergeleitet, bis es `true` zurückgibt oder alle Elemente im Array durchläuft.  
  
 [!code-csharp[System.Array.Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists1.cs#1)]
 [!code-vb[System.Array.Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists1.vb#1)]  
  
 Sie können auch einen Lambda Ausdruck verwenden, anstatt explizit eine Methode zu definieren, deren Signatur der des Delegaten entspricht. Im folgenden Beispiel werden die `StringSearcher`-Klasse und ihre `StartsWith`-Methode durch einen Lambda-Ausdruck ersetzt.  
  
 [!code-csharp[System.Array.Exists#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists2.cs#2)]
 [!code-vb[System.Array.Exists#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
        <related type="Article" href="~/docs/csharp/programming-guide/statements-expressions-operators/lambda-expressions.md">Lambda-Ausdrücke (C#-Programmierhandbuch)</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/procedures/lambda-expressions.md">Lambdaausdrücke (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member Fill : 'T[] * 'T -&gt; unit" Usage="System.Array.Fill (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente im Array.</typeparam>
        <param name="array">Das Array, das ausgefüllt werden soll.</param>
        <param name="value">Der Wert, der jedem Arrayelement zugewiesen werden soll.</param>
        <summary>Weist jedem Element des angegebenen <paramref name="array" /> den angegebenen <paramref name="value" /> vom Typ <typeparamref name="T" /> zu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T, startIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Fill : 'T[] * 'T * int * int -&gt; unit" Usage="System.Array.Fill (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das <see cref="T:System.Array" />, das ausgefüllt werden soll.</param>
        <param name="value">Der neue Wert für die Elemente im angegebenen Bereich.</param>
        <param name="startIndex">Ein 32-Bit-Integerwert, der den Index im <see cref="T:System.Array" /> angibt, ab dem die Füllung beginnt.</param>
        <param name="count">Die Anzahl der zu kopierenden Elemente.</param>
        <summary>Weist den angegebenen <paramref name="value" /> des Typs <typeparamref name="T" /> den Elementen des angegebenen <paramref name="array" /> zu, die innerhalb des Bereichs von <paramref name="startIndex" /> (inklusiv) und der nächsten <paramref name="count" />-Anzahl von Indizes liegen.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Find&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Find&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Find&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Find(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T Find(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member Find : 'T[] * Predicate&lt;'T&gt; -&gt; 'T" Usage="System.Array.Find (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte Array.</param>
        <param name="match">Das Prädikat, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt das erste Vorkommen im gesamten <see cref="T:System.Array" /> zurück.</summary>
        <returns>Das erste Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, sofern vorhanden, andernfalls der Standardwert für den Typ <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode oder ein Lambda-Ausdruck, der `true` zurückgibt, wenn das an ihn übergebenen Objekt mit den Bedingungen übereinstimmt, die im Delegaten oder Lambda Ausdruck definiert sind.  Die Elemente `array` werden einzeln an die <xref:System.Predicate%601>übermittelt, beginnend mit dem ersten Element und enden mit dem letzten Element.  Die Verarbeitung wird beendet, wenn eine Entsprechung gefunden wird.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> von `array`ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein <xref:System.Predicate%601> Delegaten mit der <xref:System.Array.Find%2A> generischen-Methode verwendet, um ein Array von <xref:System.Drawing.Point> Strukturen zu durchsuchen. Die Methode, die der Delegat darstellt, `ProductGT10`, gibt `true` zurück, wenn das Produkt der X-und Y-Felder größer als 100.000 ist. Die <xref:System.Array.Find%2A>-Methode ruft den-Delegaten für jedes Element des Arrays auf und gibt den ersten Punkt zurück, der die Test Bedingung erfüllt.  
  
> [!NOTE]
>  Visual Basic und C# Benutzer müssen den Delegaten nicht explizit erstellen oder das Typargument der generischen Methode angeben. Die Compiler bestimmen die erforderlichen Typen aus den Methoden Argumenten, die Sie angeben.  
  
 [!code-csharp[System.Array.Find#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/source.cs#1)]
 [!code-vb[System.Array.Find#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/source.vb#1)]  
  
 Anstatt explizit eine Methode mit der erforderlichen Signatur zu definieren, einen <xref:System.Predicate%601> Delegaten zu instanziieren und den Delegaten an die <xref:System.Array.Find%2A>-Methode zu übergeben, ist es üblich, einen Lambda-Ausdruck zu verwenden. Das folgende Beispiel ist mit dem vorherigen identisch, mit der Ausnahme, dass ein Lambda-Ausdruck als `match` Argument verwendet wird.  
  
 [!code-csharp[System.Array.Find#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/lambda.cs#2)]
 [!code-vb[System.Array.Find#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/lambda.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] FindAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] FindAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindAll(Of T) (array As T(), match As Predicate(Of T)) As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ FindAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindAll : 'T[] * Predicate&lt;'T&gt; -&gt; 'T[]" Usage="System.Array.FindAll (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="match">Das <see cref="T:System.Predicate`1" />, das die Bedingungen für die Elemente definiert, nach denen gesucht werden soll.</param>
        <summary>Ruft alle Elemente ab, die die vom angegebenen Prädikat definierten Bedingungen erfüllen.</summary>
        <returns>Ein <see cref="T:System.Array" /> mit allen Elementen, die ggf. die durch das angegebene Prädikat definierten Bedingungen erfüllen, andernfalls ein leeres <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die `true` zurückgibt, wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente `array` werden einzeln an die <xref:System.Predicate%601>übergebenen, und die Elemente, die den Bedingungen entsprechen, werden im zurückgegebenen Array gespeichert.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> von `array`ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Array von 50 Zufallszahlen mit Werten erstellt, die zwischen 0 und 1.000 liegen können. Anschließend wird die <xref:System.Array.FindAll%2A>-Methode mit einem Lambda-Ausdruck aufgerufen, der die Werte zurückgibt, die zwischen 300 und 600 liegen. Beachten Sie, dass dem Lambda-Ausdruck ein Parameter mit dem Namen `x`übergeben wird.  Dies stellt den einzelnen Array Member dar, der an das <xref:System.Predicate%601>-Element übermittelt wird. Beachten Sie außerdem, dass innerhalb des Lambda-Ausdrucks auf die lokalen `lBound`-und `uBound` Variablen zugegriffen werden kann.  
  
 [!code-csharp[System.Array.FindAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.findall/cs/findall.cs#1)]
 [!code-vb[System.Array.FindAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.findall/vb/findall.vb#1)]  
  
 Im folgenden Codebeispiel werden die generischen Methoden <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>und <xref:System.Array.FindAll%2A> veranschaulicht. Ein Array von Zeichen folgen wird erstellt, das acht Dinosaurier Namen enthält, von denen zwei (an den Positionen 1 und 5) mit "saurus" enden. Das Codebeispiel definiert auch eine Such Prädikat Methode mit dem Namen `EndsWithSaurus`, die einen Zeichen folgen Parameter annimmt und einen booleschen Wert zurückgibt, der angibt, ob die Eingabe Zeichenfolge auf "saurus" endet.  
  
 Die <xref:System.Array.Find%2A> generische Methode durchläuft das Array von Anfang an, wobei jedes Element wiederum an die `EndsWithSaurus`-Methode übergeben wird. Die Suche wird beendet, wenn die `EndsWithSaurus`-Methode `true` für das Element "Amargasaurus" zurückgibt.  
  
> [!NOTE]
>  In C# und Visual Basic muss der `Predicate<string>` Delegat (`Predicate(Of String)` in Visual Basic) nicht explizit erstellt werden. Diese Sprachen ableiten den korrekten Delegaten aus dem Kontext und erstellen ihn automatisch.  
  
 Die <xref:System.Array.FindLast%2A> generische Methode wird verwendet, um das Array rückwärts vom Ende zu durchsuchen. Er findet das Element "Dilophosaurus" an Position 5. Die <xref:System.Array.FindAll%2A> generische Methode wird verwendet, um ein Array mit allen Elementen zurückzugeben, die mit "saurus" enden. Die Elemente werden angezeigt.  
  
 Das Codebeispiel veranschaulicht auch das <xref:System.Array.Exists%2A> und <xref:System.Array.TrueForAll%2A> generische Methoden.  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sucht nach einem Element, das die durch ein angegebenes Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens in einem <see cref="T:System.Array" /> oder einem Teil davon zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="match">Das <see cref="T:System.Predicate`1" />, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens im gesamten <see cref="T:System.Array" /> zurück.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden; andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array> wird nach vorne durchsucht, beginnend beim ersten Element und endet beim letzten Element.  
  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die `true` zurückgibt, wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente `array` werden einzeln an die <xref:System.Predicate%601>übermittelt.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> von `array`ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden alle drei über Ladungen der <xref:System.Array.FindIndex%2A> generischen-Methode veranschaulicht. Ein Array von Zeichen folgen wird erstellt, das acht Dinosaurier Namen enthält, von denen zwei (an den Positionen 1 und 5) mit "saurus" enden. Das Codebeispiel definiert auch eine Such Prädikat Methode mit dem Namen `EndsWithSaurus`, die einen Zeichen folgen Parameter annimmt und einen booleschen Wert zurückgibt, der angibt, ob die Eingabe Zeichenfolge auf "saurus" endet.  
  
 Die <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>-Methoden Überladung durchläuft das Array von Anfang an, wobei jedes Element wiederum an die `EndsWithSaurus`-Methode übergeben wird. Die Suche wird beendet, wenn die `EndsWithSaurus`-Methode `true` für das Element an Position 1 zurückgibt.  
  
> [!NOTE]
>  In C# und Visual Basic muss der `Predicate<string>` Delegat (`Predicate(Of String)` in Visual Basic) nicht explizit erstellt werden. Diese Sprachen ableiten den korrekten Delegaten aus dem Kontext und erstellen ihn automatisch.  
  
 Die <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>-Methoden Überladung wird verwendet, um das Array beginnend an Position 2 zu durchsuchen und bis zum Ende des Arrays fortzufahren. Es findet das-Element an Position 5. Zum Schluss wird die <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>-Methoden Überladung verwendet, um den Bereich von drei Elementen zu durchsuchen, beginnend an Position 2. Sie gibt-1 zurück, da in diesem Bereich keine Dinosaurier Namen vorhanden sind, die mit "saurus" enden.  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="startIndex">Der nullbasierte Startindex für die Suche.</param>
        <param name="match">Das <see cref="T:System.Predicate`1" />, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Array" /> zurück, der vom angegebenen Index bis zum letzten Element reicht.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden; andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Array> wird nach `startIndex` durchsucht und endet beim letzten Element.  
  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die `true` zurückgibt, wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente `array` werden einzeln an die <xref:System.Predicate%601>übermittelt.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` die Anzahl der Elemente von `startIndex` bis zum Ende `array`ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden alle drei über Ladungen der <xref:System.Array.FindIndex%2A> generischen-Methode veranschaulicht. Ein Array von Zeichen folgen wird erstellt, das acht Dinosaurier Namen enthält, von denen zwei (an den Positionen 1 und 5) mit "saurus" enden. Das Codebeispiel definiert auch eine Such Prädikat Methode mit dem Namen `EndsWithSaurus`, die einen Zeichen folgen Parameter annimmt und einen booleschen Wert zurückgibt, der angibt, ob die Eingabe Zeichenfolge auf "saurus" endet.  
  
 Die <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>-Methoden Überladung durchläuft das Array von Anfang an, wobei jedes Element wiederum an die `EndsWithSaurus`-Methode übergeben wird. Die Suche wird beendet, wenn die `EndsWithSaurus`-Methode `true` für das Element an Position 1 zurückgibt.  
  
> [!NOTE]
>  In C# und Visual Basic muss der `Predicate<string>` Delegat (`Predicate(Of String)` in Visual Basic) nicht explizit erstellt werden. Diese Sprachen ableiten den korrekten Delegaten aus dem Kontext und erstellen ihn automatisch.  
  
 Die <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>-Methoden Überladung wird verwendet, um das Array beginnend an Position 2 zu durchsuchen und bis zum Ende des Arrays fortzufahren. Es findet das-Element an Position 5. Zum Schluss wird die <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>-Methoden Überladung verwendet, um den Bereich von drei Elementen zu durchsuchen, beginnend an Position 2. Sie gibt-1 zurück, da in diesem Bereich keine Dinosaurier Namen vorhanden sind, die mit "saurus" enden.  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="match" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * int * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="startIndex">Der nullbasierte Startindex für die Suche.</param>
        <param name="count">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</param>
        <param name="match">Das <see cref="T:System.Predicate`1" />, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Array" /> zurück, der am angegebenen Index beginnt und die angegebene Anzahl von Elementen umfasst.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden; andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Array> wird nach vorne durchsucht, beginnend bei `startIndex` und endet bei `startIndex` Plus `count` minus 1, wenn `count` größer als 0 (null) ist.  
  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die `true` zurückgibt, wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente `array` werden einzeln an die <xref:System.Predicate%601>übermittelt.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` `count`ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden alle drei über Ladungen der <xref:System.Array.FindIndex%2A> generischen-Methode veranschaulicht. Ein Array von Zeichen folgen wird erstellt, das acht Dinosaurier Namen enthält, von denen zwei (an den Positionen 1 und 5) mit "saurus" enden. Das Codebeispiel definiert auch eine Such Prädikat Methode mit dem Namen `EndsWithSaurus`, die einen Zeichen folgen Parameter annimmt und einen booleschen Wert zurückgibt, der angibt, ob die Eingabe Zeichenfolge auf "saurus" endet.  
  
 Die <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>-Methoden Überladung durchläuft das Array von Anfang an, wobei jedes Element wiederum an die `EndsWithSaurus`-Methode übergeben wird. Die Suche wird beendet, wenn die `EndsWithSaurus`-Methode `true` für das Element an Position 1 zurückgibt.  
  
> [!NOTE]
>  In C# und Visual Basic muss der `Predicate<string>` Delegat (`Predicate(Of String)` in Visual Basic) nicht explizit erstellt werden. Diese Sprachen ableiten den korrekten Delegaten aus dem Kontext und erstellen ihn automatisch.  
  
 Die <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>-Methoden Überladung wird verwendet, um das Array beginnend an Position 2 zu durchsuchen und bis zum Ende des Arrays fortzufahren. Es findet das-Element an Position 5. Zum Schluss wird die <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>-Methoden Überladung verwendet, um den Bereich von drei Elementen zu durchsuchen, beginnend an Position 2. Sie gibt-1 zurück, da in diesem Bereich keine Dinosaurier Namen vorhanden sind, die mit "saurus" enden.  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="match" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.  
  
- oder - 
 <paramref name="count" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="startIndex" /> und <paramref name="count" /> geben keinen gültigen Abschnitt im <paramref name="array" /> an.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T FindLast&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T FindLast&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLast(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T FindLast(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLast : 'T[] * Predicate&lt;'T&gt; -&gt; 'T" Usage="System.Array.FindLast (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="match">Das <see cref="T:System.Predicate`1" />, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt das letzte Vorkommen im gesamten <see cref="T:System.Array" /> zurück.</summary>
        <returns>Das letzte Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, sofern vorhanden, andernfalls der Standardwert für den Typ <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die `true` zurückgibt, wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente `array` werden einzeln an die <xref:System.Predicate%601>weitergegeben. dabei wird die <xref:System.Array>rückwärts verschoben, beginnend mit dem letzten Element und endende mit dem ersten Element.  Die Verarbeitung wird beendet, wenn eine Entsprechung gefunden wird.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> von `array`ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die generischen Methoden <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>und <xref:System.Array.FindAll%2A> veranschaulicht. Ein Array von Zeichen folgen wird erstellt, das acht Dinosaurier Namen enthält, von denen zwei (an den Positionen 1 und 5) mit "saurus" enden. Das Codebeispiel definiert auch eine Such Prädikat Methode mit dem Namen `EndsWithSaurus`, die einen Zeichen folgen Parameter annimmt und einen booleschen Wert zurückgibt, der angibt, ob die Eingabe Zeichenfolge auf "saurus" endet.  
  
 Die <xref:System.Array.Find%2A> generische Methode durchläuft das Array von Anfang an, wobei jedes Element wiederum an die `EndsWithSaurus`-Methode übergeben wird. Die Suche wird beendet, wenn die `EndsWithSaurus`-Methode `true` für das Element "Amargasaurus" zurückgibt.  
  
> [!NOTE]
>  In C# und Visual Basic muss der`Predicate<string>` Delegat (`Predicate(Of String)` in Visual Basic) nicht explizit erstellt werden. Diese Sprachen ableiten den korrekten Delegaten aus dem Kontext und erstellen ihn automatisch.  
  
 Die <xref:System.Array.FindLast%2A> generische Methode wird verwendet, um das Array rückwärts vom Ende zu durchsuchen. Er findet das Element "Dilophosaurus" an Position 5. Die <xref:System.Array.FindAll%2A> generische Methode wird verwendet, um ein Array mit allen Elementen zurückzugeben, die mit "saurus" enden. Die Elemente werden angezeigt.  
  
 Das Codebeispiel veranschaulicht auch das <xref:System.Array.Exists%2A> und <xref:System.Array.TrueForAll%2A> generische Methoden.  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sucht nach einem Element, das die durch ein angegebenes Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des letzten Vorkommens in einer <see cref="T:System.Array" /> oder einem Teil davon zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="match">Das <see cref="T:System.Predicate`1" />, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des letzten Vorkommens im gesamten <see cref="T:System.Array" /> zurück.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommnisses eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden, andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Array> wird rückwärts durchsucht, beginnend beim letzten Element und endet beim ersten Element.  
  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die `true` zurückgibt, wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente `array` werden einzeln an die <xref:System.Predicate%601>übermittelt.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> von `array`ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden alle drei über Ladungen der <xref:System.Array.FindLastIndex%2A> generischen-Methode veranschaulicht. Ein Array von Zeichen folgen wird erstellt, das acht Dinosaurier Namen enthält, von denen zwei (an den Positionen 1 und 5) mit "saurus" enden. Das Codebeispiel definiert auch eine Such Prädikat Methode mit dem Namen `EndsWithSaurus`, die einen Zeichen folgen Parameter annimmt und einen booleschen Wert zurückgibt, der angibt, ob die Eingabe Zeichenfolge auf "saurus" endet.  
  
 Die <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>-Methoden Überladung durchläuft das Array rückwärts vom Ende, wobei jedes Element wiederum an die `EndsWithSaurus`-Methode übergeben wird. Die Suche wird beendet, wenn die `EndsWithSaurus`-Methode `true` für das Element an Position 5 zurückgibt.  
  
> [!NOTE]
>  In C# und Visual Basic muss der `Predicate<string>` Delegat (`Predicate(Of String)` in Visual Basic) nicht explizit erstellt werden. Diese Sprachen ableiten den korrekten Delegaten aus dem Kontext und erstellen ihn automatisch.  
  
 Die <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>-Methoden Überladung wird verwendet, um das Array beginnend an Position 4 zu durchsuchen und rückwärts bis zum Anfang des Arrays fortzufahren. Er findet das Element an Position 1. Schließlich wird die <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>-Methoden Überladung verwendet, um den Bereich von drei Elementen zu durchsuchen, beginnend an Position 4 und rückwärts (d. h. Elemente 4, 3 und 2). Sie gibt-1 zurück, da in diesem Bereich keine Dinosaurier Namen vorhanden sind, die mit "saurus" enden.  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="startIndex">Der nullbasierte Startindex für die Rückwärtssuche.</param>
        <param name="match">Das <see cref="T:System.Predicate`1" />, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des letzten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Array" /> zurück, der vom ersten Element bis zum angegeben Index reicht.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommnisses eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden, andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Array> wird rückwärts durchsucht, beginnend bei `startIndex` und endet beim ersten Element.  
  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die `true` zurückgibt, wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente `array` werden einzeln an die <xref:System.Predicate%601>übermittelt.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` die Anzahl der Elemente vom Anfang `array` bis `startIndex`ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden alle drei über Ladungen der <xref:System.Array.FindLastIndex%2A> generischen-Methode veranschaulicht. Ein Array von Zeichen folgen wird erstellt, das acht Dinosaurier Namen enthält, von denen zwei (an den Positionen 1 und 5) mit "saurus" enden. Das Codebeispiel definiert auch eine Such Prädikat Methode mit dem Namen `EndsWithSaurus`, die einen Zeichen folgen Parameter annimmt und einen booleschen Wert zurückgibt, der angibt, ob die Eingabe Zeichenfolge auf "saurus" endet.  
  
 Die <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>-Methoden Überladung durchläuft das Array rückwärts vom Ende, wobei jedes Element wiederum an die `EndsWithSaurus`-Methode übergeben wird. Die Suche wird beendet, wenn die `EndsWithSaurus`-Methode `true` für das Element an Position 5 zurückgibt.  
  
> [!NOTE]
>  In C# und Visual Basic muss der `Predicate<string>` Delegat (`Predicate(Of String)` in Visual Basic) nicht explizit erstellt werden. Diese Sprachen ableiten den korrekten Delegaten aus dem Kontext und erstellen ihn automatisch.  
  
 Die <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>-Methoden Überladung wird verwendet, um das Array beginnend an Position 4 zu durchsuchen und rückwärts bis zum Anfang des Arrays fortzufahren. Er findet das Element an Position 1. Schließlich wird die <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>-Methoden Überladung verwendet, um den Bereich von drei Elementen zu durchsuchen, beginnend an Position 4 und rückwärts (d. h. Elemente 4, 3 und 2). Sie gibt-1 zurück, da in diesem Bereich keine Dinosaurier Namen vorhanden sind, die mit "saurus" enden.  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="match" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * int * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="startIndex">Der nullbasierte Startindex für die Rückwärtssuche.</param>
        <param name="count">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</param>
        <param name="match">Das <see cref="T:System.Predicate`1" />, das die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Array" /> zurück, der die angegebene Anzahl von Elementen umfasst und am angegebenen Index endet.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommnisses eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden, andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Array> wird rückwärts nach `startIndex` durchsucht und endet bei `startIndex` minus `count` Plus 1, wenn `count` größer als 0 (null) ist.  
  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die `true` zurückgibt, wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente `array` werden einzeln an die <xref:System.Predicate%601>übermittelt.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` `count`ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden alle drei über Ladungen der <xref:System.Array.FindLastIndex%2A> generischen-Methode veranschaulicht. Ein Array von Zeichen folgen wird erstellt, das acht Dinosaurier Namen enthält, von denen zwei (an den Positionen 1 und 5) mit "saurus" enden. Das Codebeispiel definiert auch eine Such Prädikat Methode mit dem Namen `EndsWithSaurus`, die einen Zeichen folgen Parameter annimmt und einen booleschen Wert zurückgibt, der angibt, ob die Eingabe Zeichenfolge auf "saurus" endet.  
  
 Die <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29>-Methoden Überladung durchläuft das Array rückwärts vom Ende, wobei jedes Element wiederum an die `EndsWithSaurus`-Methode übergeben wird. Die Suche wird beendet, wenn die `EndsWithSaurus`-Methode `true` für das Element an Position 5 zurückgibt.  
  
> [!NOTE]
>  In C# und Visual Basic muss der `Predicate<string>` Delegat (`Predicate(Of String)` in Visual Basic) nicht explizit erstellt werden. Diese Sprachen ableiten den korrekten Delegaten aus dem Kontext und erstellen ihn automatisch.  
  
 Die <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>-Methoden Überladung wird verwendet, um das Array beginnend an Position 4 zu durchsuchen und rückwärts bis zum Anfang des Arrays fortzufahren. Er findet das Element an Position 1. Schließlich wird die <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>-Methoden Überladung verwendet, um den Bereich von drei Elementen zu durchsuchen, beginnend an Position 4 und rückwärts (d. h. Elemente 4, 3 und 2). Sie gibt-1 zurück, da in diesem Bereich keine Dinosaurier Namen vorhanden sind, die mit "saurus" enden.  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="match" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.  
  
- oder - 
 <paramref name="count" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="startIndex" /> und <paramref name="count" /> geben keinen gültigen Abschnitt im <paramref name="array" /> an.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ForEach&lt;T&gt; (T[] array, Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ForEach&lt;T&gt;(!!T[] array, class System.Action`1&lt;!!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ForEach``1(``0[],System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ForEach(Of T) (array As T(), action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void ForEach(cli::array &lt;T&gt; ^ array, Action&lt;T&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member ForEach : 'T[] * Action&lt;'T&gt; -&gt; unit" Usage="System.Array.ForEach (array, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="action" Type="System.Action&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das eindimensionale nullbasierte <see cref="T:System.Array" />, für dessen Elemente die Aktion ausgeführt werden soll.</param>
        <param name="action">Die <see cref="T:System.Action`1" />, die für jedes Element von <paramref name="array" /> ausgeführt werden soll.</param>
        <summary>Führt die angegebene Aktion für jedes Element des angegebenen Arrays aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Action%601> ist ein Delegat für eine Methode, die eine Aktion für das an ihn weiter gegebene Objekt ausführt.  Die Elemente `array` werden einzeln an die <xref:System.Action%601>übermittelt.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> von `array`ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie <xref:System.Array.ForEach%2A> verwendet wird, um die Quadrate der einzelnen Elemente in einem ganzzahligen Array anzuzeigen.  
  
 [!code-cpp[System.Array.ForEach#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.foreach/cpp/source.cpp#1)]
 [!code-csharp[System.Array.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.foreach/cs/source.cs#1)]
 [!code-vb[System.Array.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.foreach/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="action" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="array.GetEnumerator " />
      <MemberSignature Language="C#" Value="public virtual System.Collections.IEnumerator GetEnumerator ();" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator () As IEnumerator" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen <see cref="T:System.Collections.IEnumerator" /> für das <see cref="T:System.Array" />zurück.</summary>
        <returns>Ein <see cref="T:System.Collections.IEnumerator" /> für das <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, C#]  
  
 Die `foreach`-Anweisung der C# Sprache (`for each` in C++, `For Each` in Visual Basic) verbirgt die Komplexität der Enumeratoren. Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. <xref:System.Collections.IEnumerator.Reset%2A> setzt den Enumerator ebenfalls auf diese Position zurück.  An dieser Position ist <xref:System.Collections.IEnumerator.Current%2A> nicht definiert. Daher muss der Enumerator durch einen Aufruf von <xref:System.Collections.IEnumerator.MoveNext%2A> auf das erste Element der Auflistung gesetzt werden, bevor der Wert von <xref:System.Collections.IEnumerator.Current%2A> gelesen werden kann.  
  
 <xref:System.Collections.IEnumerator.Current%2A> gibt solange dasselbe Objekt zurück, bis <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> aufgerufen wird. <xref:System.Collections.IEnumerator.MoveNext%2A> legt <xref:System.Collections.IEnumerator.Current%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.IEnumerator.MoveNext%2A> das Ende der Auflistung übergibt, wird der Enumerator hinter dem letzten Element in der Auflistung platziert, und <xref:System.Collections.IEnumerator.MoveNext%2A> gibt `false` zurück. Wenn sich der Enumerator an dieser Position befindet, geben nachfolgende Aufrufe von <xref:System.Collections.IEnumerator.MoveNext%2A> auch `false` zurück. Wenn der letzte Aufruf <xref:System.Collections.IEnumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.IEnumerator.Current%2A> ist nicht definiert. Um <xref:System.Collections.IEnumerator.Current%2A> wieder auf das erste Element der Auflistung festzulegen, können Sie <xref:System.Collections.IEnumerator.Reset%2A> gefolgt von <xref:System.Collections.IEnumerator.MoveNext%2A> aufrufen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist. Werden an der Auflistung Änderungen wie z. B. Hinzufügen, Bearbeiten oder Entfernen von Elementen vorgenommen, verliert der Enumerator unwiederbringlich seine Gültigkeit und sein Verhalten ist nicht definiert.  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung. Daher ist die Enumeration einer Auflistung systemintern keine threadsichere Prozedur.  Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie <xref:System.Array.GetEnumerator%2A> verwendet wird, um die Elemente eines Arrays aufzulisten.  
  
 [!code-cpp[System.Array_GetEnumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CPP/array_getenumerator.cpp#1)]
 [!code-csharp[System.Array_GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CS/array_getenumerator.cs#1)]
 [!code-vb[System.Array_GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetEnumerator/VB/array_getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLength">
      <MemberSignature Language="C#" Value="public int GetLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLength (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLength(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLength : int -&gt; int" Usage="array.GetLength dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Eine nullbasierte Dimension des <see cref="T:System.Array" />, deren Länge bestimmt werden soll.</param>
        <summary>Ruft eine 32-Bit-Ganzzahl ab, die die Anzahl der Elemente in der angegebenen Dimension des <see cref="T:System.Array" /> angibt.</summary>
        <returns>Ein 32-Bit-Integer, der die Anzahl der Elemente in der angegebenen Dimension angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Beispiel für <xref:System.Array.GetLength%2A> ist `GetLength(0)`, das die Anzahl der Elemente in der ersten Dimension der <xref:System.Array>zurückgibt.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie <xref:System.Array.GetLength%2A> verwendet wird, um die Dimensionen von zwei Arrays mit unterschiedlichen Ränge anzuzeigen.  
  
 [!code-cpp[System.Array.GetLength#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getlength/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetLength#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getlength/cs/source.cs#1)]
 [!code-vb[System.Array.GetLength#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getlength/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="dimension" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="dimension" /> ist größer oder gleich <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLongLength">
      <MemberSignature Language="C#" Value="public long GetLongLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLongLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLongLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLongLength (dimension As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long GetLongLength(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLongLength : int -&gt; int64" Usage="array.GetLongLength dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="dimension">Eine nullbasierte Dimension des <see cref="T:System.Array" />, deren Länge bestimmt werden soll.</param>
        <summary>Ruft eine 64-Bit-Ganzzahl ab, die die Anzahl der Elemente in der angegebenen Dimension des <see cref="T:System.Array" /> angibt.</summary>
        <returns>Eine 64-Bit-Ganzzahl, die die Anzahl der Elemente in der angegebenen Dimension angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Beispiel für <xref:System.Array.GetLongLength%2A> ist `GetLongLength(0)`, das die Anzahl der Elemente in der ersten Dimension der <xref:System.Array>zurückgibt.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="dimension" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="dimension" /> ist größer oder gleich <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLowerBound">
      <MemberSignature Language="C#" Value="public int GetLowerBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLowerBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLowerBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLowerBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLowerBound(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLowerBound : int -&gt; int" Usage="array.GetLowerBound dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Eine nullbasierte Dimension des Arrays, dessen Startindex bestimmt werden soll.</param>
        <summary>Ruft den Index des ersten Elements der angegebenen Dimension im Array ab.</summary>
        <returns>Der Index des ersten Elements der angegebenen Dimension im Array.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetLowerBound(0)` gibt den Start Index der ersten Dimension des Arrays zurück, und `GetLowerBound(Rank - 1)` gibt den Start Index der letzten Dimension des Arrays zurück.  
  
 Die <xref:System.Array.GetLowerBound%2A>-Methode gibt immer einen Wert zurück, der den Index der unteren Grenze des Arrays angibt, auch wenn das Array leer ist.  
  
 Beachten Sie, dass die meisten Arrays in der .NET Framework Null basiert (d. h. die <xref:System.Array.GetLowerBound%2A> Methode für jede Dimension eines Arrays 0 zurückgibt), dass die .NET Framework Arrays unterstützt, die nicht NULL basiert sind. Solche Arrays können mit der <xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29>-Methode erstellt werden und können auch von nicht verwaltetem Code zurückgegeben werden.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die-Methode <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> verwendet, um die Begrenzungen eines eindimensionalen und zweidimensionalen Arrays anzuzeigen und die Werte ihrer Array Elemente anzuzeigen.  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="dimension" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="dimension" /> ist größer oder gleich <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetUpperBound">
      <MemberSignature Language="C#" Value="public int GetUpperBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetUpperBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetUpperBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUpperBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetUpperBound(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetUpperBound : int -&gt; int" Usage="array.GetUpperBound dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Eine nullbasierte Dimension des Arrays, dessen obere Grenze bestimmt werden soll.</param>
        <summary>Ruft den Index des letzten Elements der angegebenen Dimension im Array ab.</summary>
        <returns>Der Index des letzten Elements in der angegebenen Dimension im Array oder -1, wenn die angegebene Dimension leer ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetUpperBound(0)` gibt den letzten Index in der ersten Dimension des Arrays zurück, und `GetUpperBound(Rank - 1)` gibt den letzten Index der letzten Dimension des Arrays zurück.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die-Methode <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> verwendet, um die Begrenzungen eines eindimensionalen und zweidimensionalen Arrays anzuzeigen und die Werte ihrer Array Elemente anzuzeigen.  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="dimension" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="dimension" /> ist größer oder gleich <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den Wert des angegebenen Elements im aktuellen <see cref="T:System.Array" /> ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int -&gt; obj" Usage="array.GetValue index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="index">Eine 32-Bit-Ganzzahl, die die Position des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Ruft den Wert an der angegebenen Position des eindimensionalen <see cref="T:System.Array" /> ab. Der Index wird als 32-Bit-Ganzzahl angegeben.</summary>
        <returns>Der Wert an der angegebenen Position des eindimensionalen <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methoden <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> können bestimmen, ob der Wert von `index` außerhalb des gültigen Bereichs liegt.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein bestimmter Wert in einem eindimensionalen oder mehrdimensionalen Array festgelegt und erhalten wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> verfügt nicht über genau eine Dimension.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für das aktuelle <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Integer()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;int&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int[] -&gt; obj" Usage="array.GetValue indices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">Ein eindimensionales Array von 32-Bit-Ganzzahlen, die die Indizes darstellen, die die Position des abzurufenden <see cref="T:System.Array" />-Elements angeben.</param>
        <summary>Ruft den Wert an der angegebenen Position des mehrdimensionalen <see cref="T:System.Array" /> ab. Die Indizes werden als ein Array von 32-Bit-Ganzzahlen angegeben.</summary>
        <returns>Der Wert an der angegebenen Position des mehrdimensionalen <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Anzahl der Elemente in `indices` muss gleich der Anzahl der Dimensionen im <xref:System.Array>sein. Alle Elemente im `indices` Array müssen gemeinsam die Position des gewünschten Elements im mehrdimensionalen <xref:System.Array>angeben.  
  
 Die Methoden <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> können bestimmen, ob die Indizes außerhalb des gültigen Bereichs liegen.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein bestimmter Wert in einem eindimensionalen oder mehrdimensionalen Array festgelegt und erhalten wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl von Dimensionen im aktuellen <see cref="T:System.Array" /> ist nicht mit der Anzahl von Elementen in <paramref name="indices" /> identisch.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Jedes Element in <paramref name="indices" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 -&gt; obj" Usage="array.GetValue index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index">Eine 64-Bit-Ganzzahl, die die Position des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Ruft den Wert an der angegebenen Position des eindimensionalen <see cref="T:System.Array" /> ab. Der Index wird als 64-Bit-Ganzzahl angegeben.</summary>
        <returns>Der Wert an der angegebenen Position des eindimensionalen <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methoden <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> können bestimmen, ob der Wert von `index` außerhalb des gültigen Bereichs liegt.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein bestimmter Wert in einem eindimensionalen oder mehrdimensionalen Array festgelegt und erhalten wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> verfügt nicht über genau eine Dimension.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für das aktuelle <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Long()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;long&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64[] -&gt; obj" Usage="array.GetValue indices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int64[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">Ein eindimensionales Array von 64-Bit-Ganzzahlen, das die Indizes darstellt, die die Position des abzurufenden <see cref="T:System.Array" />-Elements angeben.</param>
        <summary>Ruft den Wert an der angegebenen Position des mehrdimensionalen <see cref="T:System.Array" /> ab. Die Indizes werden als Array von 64-Bit-Ganzzahlen angegeben.</summary>
        <returns>Der Wert an der angegebenen Position des mehrdimensionalen <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Anzahl der Elemente in `indices` muss gleich der Anzahl der Dimensionen im <xref:System.Array>sein. Alle Elemente im `indices` Array müssen gemeinsam die Position des gewünschten Elements im mehrdimensionalen <xref:System.Array>angeben.  
  
 Die Methoden <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> können bestimmen, ob die Indizes außerhalb des gültigen Bereichs liegen.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein bestimmter Wert in einem eindimensionalen oder mehrdimensionalen Array festgelegt und erhalten wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl von Dimensionen im aktuellen <see cref="T:System.Array" /> ist nicht mit der Anzahl von Elementen in <paramref name="indices" /> identisch.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Jedes Element in <paramref name="indices" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int * int -&gt; obj" Usage="array.GetValue (index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index1">Eine 32-Bit-Ganzzahl, die den Index für die erste Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index2">Eine 32-Bit-Ganzzahl, die den Index für die zweite Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Ruft den Wert an der angegebenen Position des zweidimensionalen <see cref="T:System.Array" /> ab. Die Indizes werden als 32-Bit-Ganzzahlen angegeben.</summary>
        <returns>Der Wert an der angegebenen Position des zweidimensionalen <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methoden <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> können bestimmen, ob die Indizes außerhalb des gültigen Bereichs liegen.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein bestimmter Wert in einem eindimensionalen oder mehrdimensionalen Array festgelegt und erhalten wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> verfügt nicht über genau zwei Dimensionen.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Entweder <paramref name="index1" /> oder <paramref name="index2" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 * int64 -&gt; obj" Usage="array.GetValue (index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index1">Eine 64-Bit-Ganzzahl, die den Index für die erste Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index2">Eine 64-Bit-Ganzzahl, die den Index für die zweite Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Ruft den Wert an der angegebenen Position des zweidimensionalen <see cref="T:System.Array" /> ab. Die Indizes werden als 64-Bit-Ganzzahlen angegeben.</summary>
        <returns>Der Wert an der angegebenen Position des zweidimensionalen <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methoden <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> können bestimmen, ob die Indizes außerhalb des gültigen Bereichs liegen.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein bestimmter Wert in einem eindimensionalen oder mehrdimensionalen Array festgelegt und erhalten wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> verfügt nicht über genau zwei Dimensionen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index1" /> oder <paramref name="index2" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer, index3 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2, int index3);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int * int * int -&gt; obj" Usage="array.GetValue (index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index3" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index1">Eine 32-Bit-Ganzzahl, die den Index für die erste Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index2">Eine 32-Bit-Ganzzahl, die den Index für die zweite Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index3">Eine 32-Bit-Ganzzahl, die den Index für die dritte Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Ruft den Wert an der angegebenen Position des dreidimensionalen <see cref="T:System.Array" /> ab. Die Indizes werden als 32-Bit-Ganzzahlen angegeben.</summary>
        <returns>Der Wert an der angegebenen Position des dreidimensionalen <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methoden <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> können bestimmen, ob die Indizes außerhalb des gültigen Bereichs liegen.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein bestimmter Wert in einem eindimensionalen oder mehrdimensionalen Array festgelegt und erhalten wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> verfügt nicht über genau drei Dimensionen.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Entweder <paramref name="index1" />, <paramref name="index2" /> oder <paramref name="index3" /> liegt außerhalb des Bereichs gültiger Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long, index3 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2, long index3);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 * int64 * int64 -&gt; obj" Usage="array.GetValue (index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index3" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index1">Eine 64-Bit-Ganzzahl, die den Index für die erste Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index2">Eine 64-Bit-Ganzzahl, die den Index für die zweite Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index3">Eine 64-Bit-Ganzzahl, die den Index für die dritte Dimension des abzurufenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Ruft den Wert an der angegebenen Position des dreidimensionalen <see cref="T:System.Array" /> ab. Die Indizes werden als 64-Bit-Ganzzahlen angegeben.</summary>
        <returns>Der Wert an der angegebenen Position des dreidimensionalen <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methoden <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> können bestimmen, ob die Indizes außerhalb des gültigen Bereichs liegen.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein bestimmter Wert in einem eindimensionalen oder mehrdimensionalen Array festgelegt und erhalten wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> verfügt nicht über genau drei Dimensionen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Entweder <paramref name="index1" />, <paramref name="index2" /> oder <paramref name="index3" /> liegt außerhalb des Bereichs gültiger Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sucht das angegebene Objekt und gibt den Index seines ersten Auftretens in einem eindimensionalen Array oder in einem Elementbereich im Array zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj -&gt; int" Usage="System.Array.IndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende eindimensionale Array.</param>
        <param name="value">Das in <paramref name="array" /> zu suchende Objekt.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den Index des ersten Vorkommens in einem eindimensionalen Array zurück.</summary>
        <returns>Der Index des ersten Vorkommens von <paramref name="value" /> in <paramref name="array" />, sofern gefunden, andernfalls die untere Grenze des Arrays minus 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode durchsucht alle Elemente eines eindimensionalen Arrays nach `value`. Um zu ermitteln, ob `value` in `array`vorhanden ist, führt die-Methode einen Gleichheits Vergleich durch, indem die `Equals` Methode jedes Elements aufgerufen wird, bis eine Übereinstimmung gefunden wird Dies bedeutet, dass, wenn das Element die <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> Methode überschreibt, diese außer Kraft Setzung aufgerufen wird.  
  
 Da die meisten Arrays eine untere Grenze von NULL aufweisen, gibt diese Methode in der Regel-1 zurück, wenn`value` nicht gefunden wird. In dem seltenen Fall, dass die untere Grenze des Arrays gleich <xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) und `value` nicht gefunden wird, gibt diese Methode <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF) zurück.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> von `array`ist.  
  
   
  
## Examples  
 Im Beispiel werden die folgenden drei über Ladungen der <xref:System.Array.IndexOf%2A>-Methode aufgerufen, um den Index einer Zeichenfolge in einem Zeichen folgen Array zu finden:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, um das erste Vorkommen der Zeichenfolge "The" in einem Zeichen folgen Array zu bestimmen.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, um das erste Vorkommen der Zeichenfolge "The" im vierten bis zum letzten Element eines Zeichen folgen Arrays zu bestimmen.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, um das erste Vorkommen der Zeichenfolge "The" in einem Zeichen folgen Array aus dem-Element zu bestimmen, das der letzten erfolgreichen Entsprechung bis zum Ende des Arrays folgt.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende eindimensionale Array.</param>
        <param name="value">Das in <paramref name="array" /> zu suchende Objekt.</param>
        <param name="startIndex">Der Startindex für die Suche. 0 (null) ist in einem leeren Array gültig.</param>
        <summary>Sucht das angegebene Objekt in einem Elementbereich eines eindimensionalen Arrays und gibt den Index seines ersten Auftretens zurück. Der Bereich erstreckt sich von einem angegebenen Index bis zum Ende des Arrays.</summary>
        <returns>Der Index des ersten Vorkommens von <paramref name="value" />, sofern gefunden, innerhalb des Bereichs von Elementen in <paramref name="array" />, der sich von <paramref name="startIndex" /> bis zum letzten Element erstreckt; andernfalls die untere Grenze des Arrays minus 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode durchsucht ein eindimensionales Array vom-Element bei Index `startIndex` bis zum letzten Element. Um zu ermitteln, ob `value` in `array`vorhanden ist, führt die-Methode einen Gleichheits Vergleich durch, indem die `Equals`-Methode jedes Elements aufgerufen wird, bis eine Übereinstimmung gefunden wird. Dies bedeutet, dass, wenn das Element die <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> Methode überschreibt, diese außer Kraft Setzung aufgerufen wird.  
  
 Da die meisten Arrays eine untere Grenze von NULL aufweisen, gibt diese Methode in der Regel-1 zurück, wenn `value` nicht gefunden wird. In dem seltenen Fall, dass die untere Grenze des Arrays gleich <xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) und `value` nicht gefunden wird, gibt diese Methode <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF) zurück.  
  
 Wenn `startIndex` <xref:System.Array.Length%2A?displayProperty=nameWithType>ist, gibt die Methode-1 zurück. Wenn `startIndex` größer als <xref:System.Array.Length%2A?displayProperty=nameWithType>ist, löst die Methode eine <xref:System.ArgumentOutOfRangeException>aus.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` die Anzahl der Elemente von `startIndex` bis zum Ende `array`ist.  
  
   
  
## Examples  
 Im Beispiel werden die folgenden drei über Ladungen der <xref:System.Array.IndexOf%2A>-Methode aufgerufen, um den Index einer Zeichenfolge in einem Zeichen folgen Array zu finden:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, um das erste Vorkommen der Zeichenfolge "The" in einem Zeichen folgen Array zu bestimmen.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, um das erste Vorkommen der Zeichenfolge "The" im vierten bis zum letzten Element eines Zeichen folgen Arrays zu bestimmen.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, um das erste Vorkommen der Zeichenfolge "The" in einem Zeichen folgen Array aus dem-Element zu bestimmen, das der letzten erfolgreichen Entsprechung bis zum Ende des Arrays folgt.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj * int * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende eindimensionale Array.</param>
        <param name="value">Das in <paramref name="array" /> zu suchende Objekt.</param>
        <param name="startIndex">Der Startindex für die Suche. 0 (null) ist in einem leeren Array gültig.</param>
        <param name="count">Die Anzahl der zu suchenden Elemente.</param>
        <summary>Sucht das angegebene Objekt in einem Bereich von Elementen eines eindimensionalen Arrays und gibt den Index des ersten Vorkommens zurück. Der Bereich erstreckt sich von einem angegebenen Index für eine angegebene Anzahl von Elementen.</summary>
        <returns>Der Index des ersten Vorkommens von <paramref name="value" />, sofern gefunden im <paramref name="array" /> vom <paramref name="startIndex" />-Index bis <paramref name="startIndex" /> + <paramref name="count" /> – 1; andernfalls die untere Grenze des Arrays minus 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode durchsucht die Elemente eines eindimensionalen Arrays von `startIndex` nach `startIndex` Plus `count` minus 1, wenn `count` größer als 0 (null) ist. Um zu ermitteln, ob `value` in `array`vorhanden ist, führt die-Methode einen Gleichheits Vergleich durch, indem die `Equals`-Methode jedes Elements aufgerufen wird, bis eine Übereinstimmung gefunden wird. Dies bedeutet, dass, wenn das Element die <xref:System.Object.Equals%2A?displayProperty=nameWithType> Methode überschreibt, diese außer Kraft Setzung aufgerufen wird.  
  
 Da die meisten Arrays eine untere Grenze von NULL aufweisen, gibt diese Methode in der Regel-1 zurück, wenn `value` nicht gefunden wird. In dem seltenen Fall, dass die untere Grenze des Arrays gleich <xref:System.Int32.MinValue?displayProperty=nameWithType> (0x80000000) und `value` nicht gefunden wird, gibt diese Methode <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF) zurück.  
  
 Wenn `startindex` <xref:System.Array.Length%2A?displayProperty=nameWithType>ist, gibt die Methode-1 zurück. Wenn `startIndex` größer als <xref:System.Array.Length%2A?displayProperty=nameWithType>ist, löst die Methode eine <xref:System.ArgumentOutOfRangeException>aus.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` `count`ist.  
  
   
  
## Examples  
 Im Beispiel werden die folgenden drei über Ladungen der <xref:System.Array.IndexOf%2A>-Methode aufgerufen, um den Index einer Zeichenfolge in einem Zeichen folgen Array zu finden:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, um das erste Vorkommen der Zeichenfolge "The" in einem Zeichen folgen Array zu bestimmen.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, um das erste Vorkommen der Zeichenfolge "The" im vierten bis zum letzten Element eines Zeichen folgen Arrays zu bestimmen.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, um das erste Vorkommen der Zeichenfolge "The" in einem Zeichen folgen Array aus dem-Element zu bestimmen, das der letzten erfolgreichen Entsprechung bis zum Ende des Arrays folgt. Um den Wert des `count` Arguments zu ermitteln, subtrahiert er die obere Grenze des Arrays vom Start Index und fügt eine hinzu.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.  
  
- oder - 
 <paramref name="count" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="startIndex" /> und <paramref name="count" /> geben keinen gültigen Abschnitt in <paramref name="array" /> an.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T -&gt; int" Usage="System.Array.IndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte Array.</param>
        <param name="value">Das in <paramref name="array" /> zu suchende Objekt.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den Index des ersten Vorkommens in einem eindimensionalen Array zurück.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens von <paramref name="value" /> im gesamten <paramref name="array" />, sofern gefunden, andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode durchsucht alle Elemente eines eindimensionalen Arrays nach `value`. Um zu ermitteln, ob `value` in `array`vorhanden ist, führt die-Methode einen Gleichheits Vergleich durch, indem die `T.Equals`-Methode für jedes Element aufgerufen wird. Dies bedeutet, dass, wenn `T` die <xref:System.Object.Equals%2A>-Methode überschreibt, diese außer Kraft Setzung aufgerufen wird.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> von `array`ist.  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle drei generischen über Ladungen der <xref:System.Array.IndexOf%2A>-Methode veranschaulicht. Ein Array von Zeichen folgen wird erstellt, wobei ein Eintrag zweimal an Indexposition 0 und Index Speicherort 5 angezeigt wird. Die <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>-Methoden Überladung durchsucht das Array von Anfang an und findet das erste Vorkommen der Zeichenfolge. Die <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>-Methoden Überladung wird verwendet, um das Array zu durchsuchen, beginnend mit Indexposition 3 und bis zum Ende des Arrays, und findet das zweite Vorkommen der Zeichenfolge. Zum Schluss wird die <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>-Methoden Überladung verwendet, um einen Bereich von zwei Einträgen zu durchsuchen, beginnend bei Indexposition 2. Sie gibt-1 zurück, da in diesem Bereich keine Instanzen der Such Zeichenfolge vorhanden sind.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte Array.</param>
        <param name="value">Das in <paramref name="array" /> zu suchende Objekt.</param>
        <param name="startIndex">Der nullbasierte Startindex für die Suche. 0 (null) ist in einem leeren Array gültig.</param>
        <summary>Sucht das angegebene Objekt in einem Bereich von Elementen eines eindimensionalen Arrays und gibt den Index des ersten Vorkommens zurück. Der Bereich erstreckt sich von einem angegebenen Index bis zum Ende des Arrays.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens von <paramref name="value" /> innerhalb des Bereichs von Elementen in <paramref name="array" />, der sich von <paramref name="startIndex" /> bis zum letzten Element erstreckt, sofern gefunden, andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode durchsucht ein eindimensionales Array vom-Element am `startIndex` bis zum Ende des-Arrays. Um zu ermitteln, ob `value` in `array`vorhanden ist, führt die-Methode einen Gleichheits Vergleich durch, indem die `T.Equals`-Methode für jedes Element aufgerufen wird. Dies bedeutet, dass, wenn `T` die <xref:System.Object.Equals%2A>-Methode überschreibt, diese außer Kraft Setzung aufgerufen wird.  
  
 Wenn `startIndex` gleich <xref:System.Array.Length%2A>ist, gibt die Methode " -1" zurück. wenn `startIndex` größer als <xref:System.Array.Length%2A?displayProperty=nameWithType>ist, löst die Methode eine <xref:System.ArgumentOutOfRangeException>aus.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` die Anzahl der Elemente von `startIndex` bis zum Ende `array`ist.  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle drei generischen über Ladungen der <xref:System.Array.IndexOf%2A>-Methode veranschaulicht. Ein Array von Zeichen folgen wird erstellt, wobei ein Eintrag zweimal an Indexposition 0 und Index Speicherort 5 angezeigt wird. Die <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>-Methoden Überladung durchsucht das Array von Anfang an und findet das erste Vorkommen der Zeichenfolge. Die <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>-Methoden Überladung wird verwendet, um das Array zu durchsuchen, beginnend mit Indexposition 3 und bis zum Ende des Arrays, und findet das zweite Vorkommen der Zeichenfolge. Zum Schluss wird die <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>-Methoden Überladung verwendet, um einen Bereich von zwei Einträgen zu durchsuchen, beginnend bei Indexposition 2. Sie gibt-1 zurück, da in diesem Bereich keine Instanzen der Such Zeichenfolge vorhanden sind.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T * int * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte Array.</param>
        <param name="value">Das in <paramref name="array" /> zu suchende Objekt.</param>
        <param name="startIndex">Der nullbasierte Startindex für die Suche. 0 (null) ist in einem leeren Array gültig.</param>
        <param name="count">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</param>
        <summary>Sucht das angegebene Objekt in einem Elementbereich eines eindimensionalen Arrays und gibt den Index seines ersten Auftretens zurück. Der Bereich erstreckt sich von einem angegebenen Index für eine angegebene Anzahl von Elementen.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens von <paramref name="value" /> innerhalb des Bereichs von Elementen im <paramref name="array" />, das beim <paramref name="startIndex" /> beginnt und die in <paramref name="count" /> angegebene Anzahl von Elementen enthält, sofern gefunden; andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode durchsucht die Elemente eines eindimensionalen Arrays von `startIndex` nach `startIndex` Plus `count` minus 1, wenn `count` größer als 0 (null) ist. Um zu ermitteln, ob `value` in `array`vorhanden ist, führt die-Methode einen Gleichheits Vergleich durch, indem die `T.Equals`-Methode für jedes Element aufgerufen wird. Dies bedeutet, dass, wenn `T` die <xref:System.Object.Equals%2A>-Methode überschreibt, diese außer Kraft Setzung aufgerufen wird.  
  
 Wenn `startIndex` <xref:System.Array.Length%2A?displayProperty=nameWithType>ist, gibt die Methode-1 zurück.  Wenn `startIndex` größer als <xref:System.Array.Length%2A?displayProperty=nameWithType>ist, löst die Methode eine <xref:System.ArgumentOutOfRangeException>aus.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` `count`ist.  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle drei generischen über Ladungen der <xref:System.Array.IndexOf%2A>-Methode veranschaulicht. Ein Array von Zeichen folgen wird erstellt, wobei ein Eintrag zweimal an Indexposition 0 und Index Speicherort 5 angezeigt wird. Die <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>-Methoden Überladung durchsucht das Array von Anfang an und findet das erste Vorkommen der Zeichenfolge. Die <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>-Methoden Überladung wird verwendet, um das Array zu durchsuchen, beginnend mit Indexposition 3 und bis zum Ende des Arrays, und findet das zweite Vorkommen der Zeichenfolge. Zum Schluss wird die <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>-Methoden Überladung verwendet, um einen Bereich von zwei Einträgen zu durchsuchen, beginnend bei Indexposition 2. Sie gibt-1 zurück, da in diesem Bereich keine Instanzen der Such Zeichenfolge vorhanden sind.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.  
  
- oder - 
 <paramref name="count" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="startIndex" /> und <paramref name="count" /> geben keinen gültigen Abschnitt im <paramref name="array" /> an.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public void Initialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Initialize" />
      <MemberSignature Language="VB.NET" Value="Public Sub Initialize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Initialize();" />
      <MemberSignature Language="F#" Value="member this.Initialize : unit -&gt; unit" Usage="array.Initialize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initialisiert jedes Element des Werttyp-<see cref="T:System.Array" /> durch einen Aufruf des parameterlosen Konstruktors für den Werttyp.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist so konzipiert, dass Compiler Werttyp Arrays unterstützen. die meisten Benutzer benötigen diese Methode nicht. Er darf nicht für Verweistyp Arrays verwendet werden.  
  
 Wenn der <xref:System.Array> kein Werttyp ist <xref:System.Array> oder wenn der Werttyp keinen Parameter losen Konstruktor hat, wird der <xref:System.Array> nicht geändert.  
  
 Der Werttyp <xref:System.Array> kann eine beliebige Untergrenze und eine beliebige Anzahl von Dimensionen aufweisen.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` <xref:System.Array.Length%2A>ist.  
  
> [!CAUTION]
>  Diese Methode kann nur für Werttypen verwendet werden, die über Konstruktoren verfügen. Werttypen, die nativ C# sind, haben jedoch keine Konstruktoren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFixedSize As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFixedSize { bool get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Array.IsFixedSize" />
      <MemberSignature Language="C#" Value="public virtual bool IsFixedSize { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsFixedSize As Boolean" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsFixedSize { bool get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Array" /> eine feste Größe aufweist.</summary>
        <value>Diese Eigenschaft ist für alle Arrays immer <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> implementiert die <xref:System.Array.IsFixedSize%2A>-Eigenschaft, da Sie für die <xref:System.Collections.IList?displayProperty=nameWithType>-Schnittstelle erforderlich ist.  
  
 Bei einem Array mit fester Größe ist es nicht zulässig, Elemente hinzuzufügen oder zu entfernen, nachdem das Array erstellt wurde, aber es ermöglicht die Änderung vorhandener Elemente.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Array.IsReadOnly" />
      <MemberSignature Language="C#" Value="public virtual bool IsReadOnly { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsReadOnly As Boolean" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Array" /> schreibgeschützt ist.</summary>
        <value>Diese Eigenschaft ist für alle Arrays immer <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> implementiert die <xref:System.Array.IsReadOnly%2A>-Eigenschaft, da Sie für die <xref:System.Collections.IList?displayProperty=nameWithType>-Schnittstelle erforderlich ist. Ein Array, das schreibgeschützt ist, lässt das Hinzufügen, entfernen oder Ändern von Elementen nach der Erstellung des Arrays nicht zu.  
  
 Wenn Sie eine schreibgeschützte Auflistung benötigen, verwenden Sie eine <xref:System.Collections> Klasse, die die <xref:System.Collections.IList?displayProperty=nameWithType>-Schnittstelle implementiert.  
  
 Wenn Sie ein Array in ein <xref:System.Collections.IList> Schnittstellen Objekt umwandeln oder konvertieren, gibt die <xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType>-Eigenschaft `false`zurück. Wenn Sie jedoch ein Array in eine <xref:System.Collections.Generic.IList%601>-Schnittstelle umwandeln oder konvertieren, gibt die `IsReadOnly`-Eigenschaft `true`zurück.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="N:System.Collections" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
        <altmember cref="N:System.Collections.Generic" />
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Array.IsSynchronized" />
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSynchronized As Boolean" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSynchronized { bool get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Zugriff auf die <see cref="T:System.Array" /> synchronisiert (threadsicher) ist.</summary>
        <value>Diese Eigenschaft ist für alle Arrays immer <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> implementiert die <xref:System.Array.IsSynchronized%2A>-Eigenschaft, da Sie für die <xref:System.Collections.ICollection?displayProperty=nameWithType>-Schnittstelle erforderlich ist.  
  
 .NET Framework-Klassen basierend auf <xref:System.Array> Geben Sie ihre eigene synchronisierte Version der Auflistung mithilfe der <xref:System.Array.SyncRoot%2A> Eigenschaft.  
  
 Klassen, die Arrays verwenden, können mit der <xref:System.Array.SyncRoot%2A>-Eigenschaft auch eine eigene Synchronisierung implementieren. Der Synchronisierungs Code muss Vorgänge für die `SyncRoot` der Auflistung ausführen, nicht direkt für die Auflistung. Dies gewährleistet die einwandfreie Funktion von Auflistungen, die von anderen Objekten abgeleitet sind. Insbesondere wird die ordnungsgemäße Synchronisierung mit anderen Threads verwaltet, die die Auflistung möglicherweise gleichzeitig ändern. Beachten Sie, dass einige Implementierungen von <xref:System.Array.SyncRoot%2A> möglicherweise die <xref:System.Array> selbst zurückgeben.  
  
 Das Auflisten durch eine Auflistung ist intrinsisch keine Thread sichere Prozedur. Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst. Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie ein Array während der gesamten Enumeration mithilfe der <xref:System.Array.SyncRoot%2A>-Eigenschaft gesperrt wird.  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.SyncRoot" />
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt den Index des letzten Vorkommens eines Werts in einem eindimensionalen <see cref="T:System.Array" /> oder in einem Teil des <see cref="T:System.Array" /> zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj -&gt; int" Usage="System.Array.LastIndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende eindimensionale <see cref="T:System.Array" />.</param>
        <param name="value">Das in <paramref name="array" /> zu suchende Objekt.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den Index des letzten Vorkommens innerhalb des gesamten eindimensionalen <see cref="T:System.Array" /> zurück.</summary>
        <returns>Der Index des letzten Vorkommens von <paramref name="value" /> im gesamten <paramref name="array" />, sofern gefunden, andernfalls die untere Grenze des Arrays minus 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das eindimensionale <xref:System.Array> wird rückwärts durchsucht, beginnend beim letzten Element und endet beim ersten Element.  
  
 Die Elemente werden mit dem angegebenen Wert mit der <xref:System.Object.Equals%2A?displayProperty=nameWithType>-Methode verglichen. Wenn der Elementtyp ein nicht System interner (benutzerdefinierter) Typ ist, wird die `Equals` Implementierung dieses Typs verwendet.  
  
 Da die meisten Arrays eine untere Grenze von 0 (null) aufweisen, gibt diese Methode in der Regel-1 zurück, wenn `value` nicht gefunden wird. In dem seltenen Fall, dass die untere Grenze des Arrays gleich <xref:System.Int32.MinValue?displayProperty=nameWithType> und `value` nicht gefunden wird, gibt diese Methode <xref:System.Int32.MaxValue?displayProperty=nameWithType>zurück, das `System.Int32.MinValue - 1`ist.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> von `array`ist.  
  
 In der .NET Framework Version 2,0 verwendet diese Methode die Methoden <xref:System.Object.Equals%2A> und <xref:System.IComparable.CompareTo%2A> des <xref:System.Array>, um zu bestimmen, ob die vom <xref:System.Object>-Parameter angegebene `value` vorhanden ist. In früheren Versionen der .NET Framework wurde diese Bestimmung mithilfe der Methoden <xref:System.Object.Equals%2A> und <xref:System.IComparable.CompareTo%2A> der `value`<xref:System.Object> selbst hergestellt.  
  
 <xref:System.IComparable.CompareTo%2A> Methoden des `item`-Parameters für die Objekte in der Auflistung.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie der Index des letzten Vorkommens eines angegebenen Elements in einem Array bestimmt wird.  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende eindimensionale <see cref="T:System.Array" />.</param>
        <param name="value">Das in <paramref name="array" /> zu suchende Objekt.</param>
        <param name="startIndex">Der Startindex für die Rückwärtssuche.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den Index des letzten Vorkommens innerhalb des Bereichs von Elementen im eindimensionalen <see cref="T:System.Array" /> zurück, der sich vom ersten Element bis zum angegebenen Index erstreckt.</summary>
        <returns>Der Index des letzten Vorkommens von <paramref name="value" /> innerhalb des Bereichs von Elementen im <paramref name="array" />, das sich vom ersten Element bis zum <paramref name="startIndex" /> erstreckt, sofern gefunden, andernfalls die untere Grenze des Arrays minus 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der eindimensionale <xref:System.Array> wird rückwärts durchsucht, beginnend bei `startIndex` und endet beim ersten Element.  
  
 Die Elemente werden mit dem angegebenen Wert mit der <xref:System.Object.Equals%2A?displayProperty=nameWithType>-Methode verglichen. Wenn der Elementtyp ein nicht System interner (benutzerdefinierter) Typ ist, wird die `Equals` Implementierung dieses Typs verwendet.  
  
 Da die meisten Arrays eine untere Grenze von 0 (null) aufweisen, gibt diese Methode in der Regel-1 zurück, wenn `value` nicht gefunden wird. In dem seltenen Fall, dass die untere Grenze des Arrays gleich <xref:System.Int32.MinValue?displayProperty=nameWithType> und `value` nicht gefunden wird, gibt diese Methode <xref:System.Int32.MaxValue?displayProperty=nameWithType>zurück, das `System.Int32.MinValue - 1`ist.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` die Anzahl der Elemente vom Anfang `array` bis `startIndex`ist.  
  
 In der .NET Framework Version 2,0 verwendet diese Methode die Methoden <xref:System.Object.Equals%2A> und <xref:System.IComparable.CompareTo%2A> des <xref:System.Array>, um zu bestimmen, ob die vom <xref:System.Object>-Parameter angegebene `value` vorhanden ist. In früheren Versionen der .NET Framework wurde diese Bestimmung mithilfe der Methoden <xref:System.Object.Equals%2A> und <xref:System.IComparable.CompareTo%2A> der `value`<xref:System.Object> selbst hergestellt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie der Index des letzten Vorkommens eines angegebenen Elements in einem Array bestimmt wird.  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj * int * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das zu durchsuchende eindimensionale <see cref="T:System.Array" />.</param>
        <param name="value">Das in <paramref name="array" /> zu suchende Objekt.</param>
        <param name="startIndex">Der Startindex für die Rückwärtssuche.</param>
        <param name="count">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den Index des letzten Vorkommens innerhalb des Bereichs von Elementen im eindimensionalen <see cref="T:System.Array" /> zurück, der die angegebene Anzahl von Elementen enthält und am angegebenen Index endet.</summary>
        <returns>Der Index des letzten Vorkommens von <paramref name="value" /> im Bereich von Elementen in <paramref name="array" />, das die durch <paramref name="count" /> angegebene Anzahl von Elementen enthält und sich bis zum <paramref name="startIndex" /> erstreckt, sofern gefunden, andernfalls die untere Grenze des Arrays minus 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der eindimensionale <xref:System.Array> wird rückwärts durchsucht, beginnend bei `startIndex` und endet bei `startIndex` minus `count` Plus 1, wenn `count` größer als 0 (null) ist.  
  
 Die Elemente werden mit dem angegebenen Wert mit der <xref:System.Object.Equals%2A?displayProperty=nameWithType>-Methode verglichen. Wenn der Elementtyp ein nicht System interner (benutzerdefinierter) Typ ist, wird die`Equals` Implementierung dieses Typs verwendet.  
  
 Da die meisten Arrays eine untere Grenze von 0 (null) aufweisen, gibt diese Methode in der Regel-1 zurück, wenn `value` nicht gefunden wird. In dem seltenen Fall, dass die untere Grenze des Arrays gleich <xref:System.Int32.MinValue?displayProperty=nameWithType> und `value` nicht gefunden wird, gibt diese Methode <xref:System.Int32.MaxValue?displayProperty=nameWithType>zurück, das `System.Int32.MinValue - 1`ist.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` `count`ist.  
  
 In der .NET Framework Version 2,0 verwendet diese Methode die Methoden <xref:System.Object.Equals%2A> und <xref:System.IComparable.CompareTo%2A> des <xref:System.Array>, um zu bestimmen, ob die vom <xref:System.Object>-Parameter angegebene `value` vorhanden ist. In früheren Versionen der .NET Framework wurde diese Bestimmung mithilfe der Methoden <xref:System.Object.Equals%2A> und <xref:System.IComparable.CompareTo%2A> der `value`<xref:System.Object> selbst hergestellt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie der Index des letzten Vorkommens eines angegebenen Elements in einem Array bestimmt wird. Beachten Sie, dass die <xref:System.Array.LastIndexOf%2A>-Methode eine Rückwärtssuche ist. Daher muss `count` kleiner oder gleich (`startIndex` minus der unteren Grenze des Arrays Plus 1) sein.  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.  
  
- oder - 
 <paramref name="count" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="startIndex" /> und <paramref name="count" /> geben keinen gültigen Abschnitt in <paramref name="array" /> an.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T -&gt; int" Usage="System.Array.LastIndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="value">Das in <paramref name="array" /> zu suchende Objekt.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den Index des letzten Vorkommens innerhalb des gesamten <see cref="T:System.Array" /> zurück.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommens von <paramref name="value" /> im gesamten <paramref name="array" />, sofern gefunden; andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Array> wird rückwärts durchsucht, beginnend beim letzten Element und endet beim ersten Element.  
  
 Die Elemente werden mit dem angegebenen Wert mit der <xref:System.Object.Equals%2A?displayProperty=nameWithType>-Methode verglichen. Wenn der Elementtyp ein nicht System interner (benutzerdefinierter) Typ ist, wird die `Equals` Implementierung dieses Typs verwendet.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> von `array`ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden alle drei generischen über Ladungen der <xref:System.Array.LastIndexOf%2A>-Methode veranschaulicht. Ein Array von Zeichen folgen wird erstellt, wobei ein Eintrag zweimal an Indexposition 0 und Index Speicherort 5 angezeigt wird. Die <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>-Methoden Überladung durchsucht das gesamte Array vom Ende und findet das zweite Vorkommen der Zeichenfolge. Die <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>-Methoden Überladung wird verwendet, um das Array rückwärts zu durchsuchen, beginnend mit Indexposition 3 und bis zum Anfang des Arrays fortzufahren, und findet das erste Vorkommen der Zeichenfolge. Schließlich wird die <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>-Methoden Überladung verwendet, um einen Bereich von vier Einträgen zu durchsuchen, beginnend bei Indexposition 4 und rückwärts, d. h., Sie durchsucht die Elemente an den Positionen 4, 3, 2 und 1. Diese Suche gibt-1 zurück, da in diesem Bereich keine Instanzen der Such Zeichenfolge vorhanden sind.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="value">Das in <paramref name="array" /> zu suchende Objekt.</param>
        <param name="startIndex">Der nullbasierte Startindex für die Rückwärtssuche.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den Index des letzten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Array" /> zurück, der sich vom ersten Element bis zum angegebenen Index erstreckt.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommens von <paramref name="value" /> innerhalb des Bereichs von Elementen im <paramref name="array" />, das sich vom ersten Element bis <paramref name="startIndex" /> erstreckt, sofern gefunden; andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Array> wird rückwärts durchsucht, beginnend bei `startIndex` und endet beim ersten Element.  
  
 Die Elemente werden mit dem angegebenen Wert mit der <xref:System.Object.Equals%2A?displayProperty=nameWithType>-Methode verglichen. Wenn der Elementtyp ein nicht System interner (benutzerdefinierter) Typ ist, wird die `Equals` Implementierung dieses Typs verwendet.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` die Anzahl der Elemente vom Anfang `array` bis `startIndex`ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden alle drei generischen über Ladungen der <xref:System.Array.LastIndexOf%2A>-Methode veranschaulicht. Ein Array von Zeichen folgen wird erstellt, wobei ein Eintrag zweimal an Indexposition 0 und Index Speicherort 5 angezeigt wird. Die <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>-Methoden Überladung durchsucht das gesamte Array vom Ende und findet das zweite Vorkommen der Zeichenfolge. Die <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>-Methoden Überladung wird verwendet, um das Array rückwärts zu durchsuchen, beginnend mit Indexposition 3 und bis zum Anfang des Arrays fortzufahren, und findet das erste Vorkommen der Zeichenfolge. Schließlich wird die <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>-Methoden Überladung verwendet, um einen Bereich von vier Einträgen zu durchsuchen, beginnend bei Indexposition 4 und rückwärts, d. h., Sie durchsucht die Elemente an den Positionen 4, 3, 2 und 1. Diese Suche gibt-1 zurück, da in diesem Bereich keine Instanzen der Such Zeichenfolge vorhanden sind.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T * int * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu durchsuchende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="value">Das in <paramref name="array" /> zu suchende Objekt.</param>
        <param name="startIndex">Der nullbasierte Startindex für die Rückwärtssuche.</param>
        <param name="count">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den Index des letzten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Array" /> zurück, der die angegebene Anzahl von Elementen enthält und am angegebenen Index endet.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommens von <paramref name="value" /> innerhalb des Bereichs von Elementen im <paramref name="array" />, das die in <paramref name="count" /> angegebene Anzahl von Elementen enthält und am <paramref name="startIndex" /> endet, sofern gefunden; andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Array> wird rückwärts nach `startIndex` durchsucht und endet bei `startIndex` minus `count` Plus 1, wenn `count` größer als 0 (null) ist.  
  
 Die Elemente werden mit dem angegebenen Wert mit der <xref:System.Object.Equals%2A?displayProperty=nameWithType>-Methode verglichen. Wenn der Elementtyp ein nicht System interner (benutzerdefinierter) Typ ist, wird die `Equals` Implementierung dieses Typs verwendet.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` `count`ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden alle drei generischen über Ladungen der <xref:System.Array.LastIndexOf%2A>-Methode veranschaulicht. Ein Array von Zeichen folgen wird erstellt, wobei ein Eintrag zweimal an Indexposition 0 und Index Speicherort 5 angezeigt wird. Die <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>-Methoden Überladung durchsucht das gesamte Array vom Ende und findet das zweite Vorkommen der Zeichenfolge. Die <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>-Methoden Überladung wird verwendet, um das Array rückwärts zu durchsuchen, beginnend mit Indexposition 3 und bis zum Anfang des Arrays fortzufahren, und findet das erste Vorkommen der Zeichenfolge. Schließlich wird die <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>-Methoden Überladung verwendet, um einen Bereich von vier Einträgen zu durchsuchen, beginnend bei Indexposition 4 und rückwärts, d. h., Sie durchsucht die Elemente an den Positionen 4, 3, 2 und 1. Diese Suche gibt-1 zurück, da in diesem Bereich keine Instanzen der Such Zeichenfolge vorhanden sind.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für <paramref name="array" />.  
  
- oder - 
 <paramref name="count" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="startIndex" /> und <paramref name="count" /> geben keinen gültigen Abschnitt im <paramref name="array" /> an.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Array.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.Array.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Gesamtanzahl der Elemente in allen Dimensionen im <see cref="T:System.Array" /> ab.</summary>
        <value>Die Gesamtanzahl der Elemente in allen Dimensionen im <see cref="T:System.Array" />, 0 (null), wenn keine Elemente im Array enthalten sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Array.Length%2A>-Eigenschaft verwendet, um die Gesamtanzahl von Elementen in einem Array zu erhalten. Außerdem wird die <xref:System.Array.GetUpperBound%2A>-Methode verwendet, um die Anzahl der Elemente in jeder Dimension eines mehrdimensionalen Arrays zu bestimmen.  
  
 [!code-csharp[System.Array.Length#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.length/cs/length1.cs#1)]
 [!code-vb[System.Array.Length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.length/vb/length1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Das Array ist mehrdimensional und enthält mehr als <see cref="F:System.Int32.MaxValue" /> Elemente.</exception>
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="LongLength">
      <MemberSignature Language="C#" Value="public long LongLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LongLength" />
      <MemberSignature Language="DocId" Value="P:System.Array.LongLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LongLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LongLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LongLength : int64" Usage="System.Array.LongLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine 64-Bit-Ganzzahl ab, die die Gesamtanzahl der Elemente in allen Dimensionen des <see cref="T:System.Array" /> angibt.</summary>
        <value>Eine 64-Bit-Ganzzahl, die die Gesamtanzahl der Elemente in allen Dimensionen des <see cref="T:System.Array" /> angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Array.Length" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="Rank">
      <MemberSignature Language="C#" Value="public int Rank { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Rank" />
      <MemberSignature Language="DocId" Value="P:System.Array.Rank" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rank As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Rank { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Rank : int" Usage="System.Array.Rank" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft der Rang (Anzahl der Dimensionen) des <see cref="T:System.Array" /> ab. Beispielsweise gibt ein eindimensionales Array 1 zurück, eines zweidimensionalen Arrays gibt 2 zurück, usw.</summary>
        <value>Der Rang (Anzahl der Dimensionen) von <see cref="T:System.Array" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beispielsweise der Visual Basic Code  
  
```vb  
Dim TDArray(0,0,0) As Integer  
```  
  
 und der C# Code  
  
```csharp  
int[,,] TDArray = new int[1,1,1];  
```  
  
 Erstellen Sie ein Array mit drei Dimensionen mit einer <xref:System.Array.Rank%2A>-Eigenschaft, deren Wert 3 ist.  
  
 Ein Jagged Array (ein Array von Arrays) ist ein eindimensionales Array. der Wert der <xref:System.Array.Rank%2A>-Eigenschaft ist 1.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein eindimensionales Array, ein zweidimensionales Array und ein Jagged Array initialisiert, und die <xref:System.Array.Rank%2A>-Eigenschaft der einzelnen wird abgerufen.  
  
 [!code-csharp[System.Array.Rank#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.rank/cs/rank1.cs#1)]
 [!code-vb[System.Array.Rank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.rank/vb/rank1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Resize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Resize&lt;T&gt; (ref T[] array, int newSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Resize&lt;T&gt;(!!T[]&amp; array, int32 newSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Resize``1(``0[]@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Resize(Of T) (ByRef array As T(), newSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Resize(cli::array &lt;T&gt; ^ % array, int newSize);" />
      <MemberSignature Language="F#" Value="static member Resize : T[] * int -&gt; unit" Usage="System.Array.Resize (array, newSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="newSize" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das eindimensionale nullbasierte Array, dessen Größe geändert werden soll, oder <see langword="null" />, um ein neues Array mit der angegebenen Größe zu erstellen.</param>
        <param name="newSize">Die Größe des neuen Arrays.</param>
        <summary>Ändert die Anzahl der Elemente eines eindimensionalen Arrays in die angegebene neue Größe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ordnet ein neues Array mit der angegebenen Größe zu, kopiert Elemente aus dem alten Array in das neue Array und ersetzt dann das alte Array durch das neue Array. `array` muss ein eindimensionales Array sein.  
  
 Wenn `array` `null`ist, erstellt diese Methode ein neues Array mit der angegebenen Größe.  
  
 Wenn `newSize` größer als die <xref:System.Array.Length%2A> des alten Arrays ist, wird ein neues Array zugewiesen, und alle Elemente werden aus dem alten Array in das neue Array kopiert.  Wenn `newSize` kleiner als der <xref:System.Array.Length%2A> des alten Arrays ist, wird ein neues Array zugewiesen, und die Elemente werden vom alten Array in das neue Array kopiert, bis das neue Array aufgefüllt wird. die restlichen Elemente im alten Array werden ignoriert.  Wenn `newSize` gleich der <xref:System.Array.Length%2A> des alten Arrays ist, führt diese Methode keine Aktion aus.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` `newSize`ist.  
  
 Mit der <xref:System.Array.Resize%2A>-Methode wird nur die Größe eines eindimensionalen Arrays geändert. Die <xref:System.Array>-Klasse enthält keine Methode zum Ändern der Größe mehrdimensionaler Arrays. Zu diesem Zweck müssen Sie entweder ihren eigenen Code bereitstellen oder eine zweckgebundene Methode in einer Drittanbieter Bibliothek anrufen. Der folgende Code veranschaulicht eine mögliche Implementierung für eine Methode, die die Größe eines Arrays von *n* Dimensionen ändert.  
  
 [!code-csharp[System.Array.Resize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/resizexd.cs#2)]
 [!code-vb[System.Array.Resize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/resizexd.vb#2)]  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie sich die Größe der Größe auf das Array auswirkt.  
  
 [!code-cpp[System.Array.Resize#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Resize/CPP/System.Array.Resize.cpp#1)]
 [!code-csharp[System.Array.Resize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/arrayresize.cs#1)]
 [!code-vb[System.Array.Resize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/arrayresize.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="newSize" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kehrt die Reihenfolge der Elemente in einem eindimensionalen <see cref="T:System.Array" /> oder in einen Teil des <see cref="T:System.Array" /> um.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array);" />
      <MemberSignature Language="F#" Value="static member Reverse : Array -&gt; unit" Usage="System.Array.Reverse array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">Das umzukehrende eindimensionale <see cref="T:System.Array" />.</param>
        <summary>Kehrt die Reihenfolge der Elemente im gesamten eindimensionalen <see cref="T:System.Array" /> um.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nach einem Aufrufe dieser Methode wird das-Element bei `myArray[i]`, bei dem `i` ein beliebiger Index im Array ist, zu `myArray[j]`verschoben, wobei `j` `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`entspricht.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> von `array`ist.  
  
 Wie im folgenden Beispiel gezeigt, kann die <xref:System.Array.Reverse%2A>-Methode verwendet werden, um eine Jagged Array umzukehren. Sie Initialisiert eine Jagged Array mit einem-Element für jeden Monat des aktuellen Jahres im Kalender der aktuellen Kultur. Jedes-Element enthält ein Array mit so vielen Elementen, wie dieser Monat Tage hat. Im Beispiel wird der Inhalt des Arrays angezeigt, die <xref:System.Array.Reverse%2A>-Methode aufgerufen und dann der Inhalt des umgekehrten Arrays angezeigt.  
  
 [!code-csharp[System.Array.Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.reverse/cs/reversejagged.cs#1)]
 [!code-vb[System.Array.Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.reverse/vb/reversejagged.vb#1)]  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie Sie die Sortierung der Werte in einer <xref:System.Array>umkehren.  
  
 [!code-cpp[Classic Array.Reverse Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Reverse : Array * int * int -&gt; unit" Usage="System.Array.Reverse (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das umzukehrende eindimensionale <see cref="T:System.Array" />.</param>
        <param name="index">Der Startindex des umzukehrenden Abschnitts.</param>
        <param name="length">Die Anzahl der Elemente im umzukehrenden Abschnitt.</param>
        <summary>Kehrt die Reihenfolge der Elemente in einem Bereich von Elementen im eindimensionalen <see cref="T:System.Array" /> um.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nach einem Aufrufe dieser Methode wird das-Element bei `myArray[i]`, bei dem `i` ein beliebiger Index im Array ist, zu `myArray[j]`verschoben, wobei `j` `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`entspricht.  
  
 Die <xref:System.Array.Reverse%2A>-Methode kann verwendet werden, um eine Jagged Array umzukehren.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` `length`ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie Sie die Sortierung der Werte in einem Bereich von Elementen in einer <xref:System.Array>umkehren.  
  
 [!code-cpp[Classic Array.Reverse1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die untere <paramref name="array" />-Grenze.  
  
- oder - 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="array" /> an.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member Reverse : 'T[] -&gt; unit" Usage="System.Array.Reverse array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Reverse : 'T[] * int * int -&gt; unit" Usage="System.Array.Reverse (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="index">To be added.</param>
        <param name="length">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legt das angegebene Element im aktuellen <see cref="T:System.Array" /> auf den angegebenen Wert fest.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int -&gt; unit" Usage="array.SetValue (value, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Der neue Wert für das angegebene Element.</param>
        <param name="index">Eine 32-Bit-Ganzzahl, die die Position des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Legt das Element an der angegebenen Position des eindimensionalen <see cref="T:System.Array" /> auf einen Wert fest. Der Index wird als 32-Bit-Ganzzahl angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methoden <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> können bestimmen, ob der Wert von `index` außerhalb des gültigen Bereichs liegt.  
  
 Weitere Informationen zu Konvertierungen finden Sie unter <xref:System.Convert>.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
> [!NOTE]
>  Wenn <xref:System.Array.SetValue%2A> verwendet wird, um `null` einem Element eines Arrays von Werttypen zuzuweisen, werden alle Felder des-Elements mit 0 (null) initialisiert. Der Wert des-Elements ist kein NULL-Verweis und kann nicht gefunden werden, wenn Sie nach einem NULL-Verweis suchen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein bestimmter Wert in einem eindimensionalen oder mehrdimensionalen Array festgelegt und erhalten wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> verfügt nicht über genau eine Dimension.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> kann nicht in den Elementtyp des aktuellen <see cref="T:System.Array" />umgewandelt werden.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für das aktuelle <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;int&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int[] -&gt; unit" Usage="array.SetValue (value, indices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">Der neue Wert für das angegebene Element.</param>
        <param name="indices">Ein eindimensionales Array von 32-Bit-Ganzzahlen, das die Indizes darstellt, die die Position des festzulegenden Elements angeben.</param>
        <summary>Legt das Element an der angegebenen Position des mehrdimensionalen <see cref="T:System.Array" /> auf einen Wert fest. Die Indizes werden als ein Array von 32-Bit-Ganzzahlen angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Anzahl der Elemente in `indices` muss gleich der Anzahl der Dimensionen im <xref:System.Array>sein. Alle Elemente im `indices` Array müssen gemeinsam die Position des gewünschten Elements im mehrdimensionalen <xref:System.Array>angeben.  
  
 Die Methoden <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> können bestimmen, ob Werte im `indices` Array außerhalb des gültigen Bereichs liegen.  
  
 Weitere Informationen zu Konvertierungen finden Sie unter <xref:System.Convert>.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
> [!NOTE]
>  Wenn <xref:System.Array.SetValue%2A> verwendet wird, um `null` einem Element eines Arrays von Werttypen zuzuweisen, werden alle Felder des-Elements mit 0 (null) initialisiert. Der Wert des-Elements ist kein NULL-Verweis und kann nicht gefunden werden, wenn Sie nach einem NULL-Verweis suchen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein bestimmter Wert in einem eindimensionalen oder mehrdimensionalen Array festgelegt und erhalten wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl von Dimensionen im aktuellen <see cref="T:System.Array" /> ist nicht mit der Anzahl von Elementen in <paramref name="indices" /> identisch.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> kann nicht in den Elementtyp des aktuellen <see cref="T:System.Array" /> umgewandelt werden.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Jedes Element in <paramref name="indices" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 -&gt; unit" Usage="array.SetValue (value, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Der neue Wert für das angegebene Element.</param>
        <param name="index">Eine 64-Bit-Ganzzahl, die die Position des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Legt das Element an der angegebenen Position des eindimensionalen <see cref="T:System.Array" /> auf einen Wert fest. Der Index wird als 64-Bit-Ganzzahl angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methoden <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> können bestimmen, ob der Wert von `index` außerhalb des gültigen Bereichs liegt.  
  
 Weitere Informationen zu Konvertierungen finden Sie unter <xref:System.Convert>.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
> [!NOTE]
>  Wenn <xref:System.Array.SetValue%2A> verwendet wird, um `null` einem Element eines Arrays von Werttypen zuzuweisen, werden alle Felder des-Elements mit 0 (null) initialisiert. Der Wert des-Elements ist kein NULL-Verweis und kann nicht gefunden werden, wenn Sie nach einem NULL-Verweis suchen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein bestimmter Wert in einem eindimensionalen oder mehrdimensionalen Array festgelegt und erhalten wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> verfügt nicht über genau eine Dimension.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> kann nicht in den Elementtyp des aktuellen <see cref="T:System.Array" />umgewandelt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für das aktuelle <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Long())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;long&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64[] -&gt; unit" Usage="array.SetValue (value, indices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indices" Type="System.Int64[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">Der neue Wert für das angegebene Element.</param>
        <param name="indices">Ein eindimensionales Array von 64-Bit-Ganzzahlen, das die Indizes darstellt, die die Position des festzulegenden Elements angeben.</param>
        <summary>Legt das Element an der angegebenen Position des mehrdimensionalen <see cref="T:System.Array" /> auf einen Wert fest. Die Indizes werden als Array von 64-Bit-Ganzzahlen angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Anzahl der Elemente in `indices` muss gleich der Anzahl der Dimensionen im <xref:System.Array>sein. Alle Elemente im `indices` Array müssen gemeinsam die Position des gewünschten Elements im mehrdimensionalen <xref:System.Array>angeben.  
  
 Die Methoden <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> können bestimmen, ob Werte im `indices` Array außerhalb des gültigen Bereichs liegen.  
  
 Weitere Informationen zu Konvertierungen finden Sie unter <xref:System.Convert>.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
> [!NOTE]
>  Wenn <xref:System.Array.SetValue%2A> verwendet wird, um `null` einem Element eines Arrays von Werttypen zuzuweisen, werden alle Felder des-Elements mit 0 (null) initialisiert. Der Wert des-Elements ist kein NULL-Verweis und kann nicht gefunden werden, wenn Sie nach einem NULL-Verweis suchen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein bestimmter Wert in einem eindimensionalen oder mehrdimensionalen Array festgelegt und erhalten wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl von Dimensionen im aktuellen <see cref="T:System.Array" /> ist nicht mit der Anzahl von Elementen in <paramref name="indices" /> identisch.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> kann nicht in den Elementtyp des aktuellen <see cref="T:System.Array" /> umgewandelt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Jedes Element in <paramref name="indices" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int * int -&gt; unit" Usage="array.SetValue (value, index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Der neue Wert für das angegebene Element.</param>
        <param name="index1">Eine 32-Bit-Ganzzahl, die den Index für die erste Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index2">Eine 32-Bit-Ganzzahl, die den Index für die zweite Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Legt das Element an der angegebenen Position des zweidimensionalen <see cref="T:System.Array" /> auf einen Wert fest. Die Indizes werden als 32-Bit-Ganzzahlen angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methoden <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> können bestimmen, ob die Indizes außerhalb des gültigen Bereichs liegen.  
  
 Weitere Informationen zu Konvertierungen finden Sie unter <xref:System.Convert>.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
> [!NOTE]
>  Wenn <xref:System.Array.SetValue%2A> verwendet wird, um `null` einem Element eines Arrays von Werttypen zuzuweisen, werden alle Felder des-Elements mit 0 (null) initialisiert. Der Wert des-Elements ist kein NULL-Verweis und kann nicht gefunden werden, wenn Sie nach einem NULL-Verweis suchen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein bestimmter Wert in einem eindimensionalen oder mehrdimensionalen Array festgelegt und erhalten wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> verfügt nicht über genau zwei Dimensionen.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> kann nicht in den Elementtyp des aktuellen <see cref="T:System.Array" /> umgewandelt werden.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Entweder <paramref name="index1" /> oder <paramref name="index2" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 * int64 -&gt; unit" Usage="array.SetValue (value, index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index1" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Der neue Wert für das angegebene Element.</param>
        <param name="index1">Eine 64-Bit-Ganzzahl, die den Index für die erste Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index2">Eine 64-Bit-Ganzzahl, die den Index für die zweite Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Legt das Element an der angegebenen Position des zweidimensionalen <see cref="T:System.Array" /> auf einen Wert fest. Die Indizes werden als 64-Bit-Ganzzahlen angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methoden <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> können bestimmen, ob die Indizes außerhalb des gültigen Bereichs liegen.  
  
 Weitere Informationen zu Konvertierungen finden Sie unter <xref:System.Convert>.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
> [!NOTE]
>  Wenn <xref:System.Array.SetValue%2A> verwendet wird, um `null` einem Element eines Arrays von Werttypen zuzuweisen, werden alle Felder des-Elements mit 0 (null) initialisiert. Der Wert des-Elements ist kein NULL-Verweis und kann nicht gefunden werden, wenn Sie nach einem NULL-Verweis suchen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein bestimmter Wert in einem eindimensionalen oder mehrdimensionalen Array festgelegt und erhalten wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> verfügt nicht über genau zwei Dimensionen.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> kann nicht in den Elementtyp des aktuellen <see cref="T:System.Array" /> umgewandelt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Entweder <paramref name="index1" /> oder <paramref name="index2" /> liegt außerhalb des Bereichs der gültigen Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer, index3 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2, int index3);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int * int * int -&gt; unit" Usage="array.SetValue (value, index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index3" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Der neue Wert für das angegebene Element.</param>
        <param name="index1">Eine 32-Bit-Ganzzahl, die den Index für die erste Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index2">Eine 32-Bit-Ganzzahl, die den Index für die zweite Dimension des festzulegenden <see cref="T:System.Array" /> -Elements darstellt.</param>
        <param name="index3">Eine 32-Bit-Ganzzahl, die den Index für die dritte Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Legt einen Wert auf das Element an der angegebenen Position im dreidimensionalen <see cref="T:System.Array" /> fest. Die Indizes werden als 32-Bit-Ganzzahlen angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methoden <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> können bestimmen, ob die Indizes außerhalb des gültigen Bereichs liegen.  
  
 Weitere Informationen zu Konvertierungen finden Sie unter <xref:System.Convert>.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
> [!NOTE]
>  Wenn <xref:System.Array.SetValue%2A> verwendet wird, um `null` einem Element eines Arrays von Werttypen zuzuweisen, werden alle Felder des-Elements mit 0 (null) initialisiert. Der Wert des-Elements ist kein NULL-Verweis und kann nicht gefunden werden, wenn Sie nach einem NULL-Verweis suchen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein bestimmter Wert in einem eindimensionalen oder mehrdimensionalen Array festgelegt und erhalten wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> verfügt nicht über genau drei Dimensionen.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> kann nicht in den Elementtyp des aktuellen <see cref="T:System.Array" /> umgewandelt werden.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Entweder <paramref name="index1" />, <paramref name="index2" /> oder <paramref name="index3" /> liegt außerhalb des Bereichs gültiger Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long, index3 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2, long index3);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 * int64 * int64 -&gt; unit" Usage="array.SetValue (value, index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index1" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index3" Type="System.Int64" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Der neue Wert für das angegebene Element.</param>
        <param name="index1">Eine 64-Bit-Ganzzahl, die den Index für die erste Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index2">Eine 64-Bit-Ganzzahl, die den Index für die zweite Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <param name="index3">Eine 64-Bit-Ganzzahl, die den Index für die dritte Dimension des festzulegenden <see cref="T:System.Array" />-Elements darstellt.</param>
        <summary>Legt das Element an der angegebenen Position des dreidimensionalen <see cref="T:System.Array" /> auf einen Wert fest. Die Indizes werden als 64-Bit-Ganzzahlen angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methoden <xref:System.Array.GetLowerBound%2A> und <xref:System.Array.GetUpperBound%2A> können bestimmen, ob die Indizes außerhalb des gültigen Bereichs liegen.  
  
 Weitere Informationen zu Konvertierungen finden Sie unter <xref:System.Convert>.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
> [!NOTE]
>  Wenn <xref:System.Array.SetValue%2A> verwendet wird, um `null` einem Element eines Arrays von Werttypen zuzuweisen, werden alle Felder des-Elements mit 0 (null) initialisiert. Der Wert des-Elements ist kein NULL-Verweis und kann nicht gefunden werden, wenn Sie nach einem NULL-Verweis suchen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein bestimmter Wert in einem eindimensionalen oder mehrdimensionalen Array festgelegt und erhalten wird.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> verfügt nicht über genau drei Dimensionen.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> kann nicht in den Elementtyp des aktuellen <see cref="T:System.Array" /> umgewandelt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Entweder <paramref name="index1" />, <paramref name="index2" /> oder <paramref name="index3" /> liegt außerhalb des Bereichs gültiger Indizes für die entsprechende Dimension des aktuellen <see cref="T:System.Array" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sortiert die Elemente in einem eindimensionalen Array.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array);" />
      <MemberSignature Language="F#" Value="static member Sort : Array -&gt; unit" Usage="System.Array.Sort array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">Das zu sortierende eindimensionale <see cref="T:System.Array" />.</param>
        <summary>Sortiert die Elemente in einem ganzen eindimensionalen <see cref="T:System.Array" /> mithilfe der <see cref="T:System.IComparable" />-Implementierung jedes Elements des <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jedes Element von `array` muss die <xref:System.IComparable>-Schnittstelle implementieren, damit Vergleiche mit jedem anderen Element in `array`möglich sind.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet den introspektiven Sort-Algorithmus (Introsort) wie folgt:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein [Einfügungs](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 * Protokoll<sup>N</sup>überschreitet, wobei *N* der Bereich des Eingabe Arrays ist, wird ein [Heapsort](https://en.wikipedia.org/wiki/Heapsort) -Algorithmus verwendet.  
  
-   Andernfalls wird ein [Quicksort](https://en.wikipedia.org/wiki/Quicksort) -Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Für Arrays, die mit den Heapsort-und Quick Sort-Algorithmen sortiert werden, ist diese Methode im schlimmsten Fall ein O (`n` Log `n`)-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> `array`ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie die Werte in einem <xref:System.Array> mithilfe des Standardcomparers und eines benutzerdefinierten Vergleichs, der die Sortierreihenfolge umkehrt, sortiert werden. Beachten Sie, dass das Ergebnis abhängig von der aktuellen <xref:System.Globalization.CultureInfo>variieren kann.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.InvalidOperationException">In einem oder mehreren Elementen in <paramref name="array" /> ist die <see cref="T:System.IComparable" />-Schnittstelle nicht implementiert.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array -&gt; unit" Usage="System.Array.Sort (keys, items)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys">Das eindimensionale <see cref="T:System.Array" /> mit den zu sortierenden Schlüsseln.</param>
        <param name="items">Das eindimensionale <see cref="T:System.Array" /> mit den Elementen, die den jeweiligen Schlüsseln im <paramref name="keys" /><see cref="T:System.Array" /> entsprechen.  
  
- oder - 
 <see langword="null" />, wenn nur das <paramref name="keys" /><see cref="T:System.Array" /> sortiert werden soll.</param>
        <summary>Sortiert ein Paar eindimensionaler <see cref="T:System.Array" />-Objekte (das eine enthält die Schlüssel und das andere die entsprechenden Werte) nach den Schlüsseln im ersten <see cref="T:System.Array" /> und verwendet dabei die <see cref="T:System.IComparable" />-Implementierung der einzelnen Schlüssel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel im `keys`<xref:System.Array> verfügt über ein entsprechendes Element im `items`<xref:System.Array>. Wenn eine Taste während der Sortierung neu positioniert wird, wird das entsprechende Element in der `items`<xref:System.Array> auf ähnliche Weise neu positioniert. Daher wird der `items`<xref:System.Array> entsprechend der Anordnung der entsprechenden Schlüssel im `keys`<xref:System.Array>sortiert.  
  
 Jeder Schlüssel in der `keys`<xref:System.Array> muss die <xref:System.IComparable>-Schnittstelle implementieren, damit Vergleiche mit jedem anderen Schlüssel möglich sind.  
  
 Sie können sortieren, wenn mehr Elemente als Schlüssel vorhanden sind, aber die Elemente, die keine entsprechenden Schlüssel aufweisen, werden nicht sortiert. Sie können nicht sortieren, wenn mehr Schlüssel als Elemente vorhanden sind. Dadurch wird eine <xref:System.ArgumentException>ausgelöst.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet den introspektiven Sort-Algorithmus (Introsort) wie folgt:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein [Einfügungs](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 * Protokoll<sup>N</sup>überschreitet, wobei *N* der Bereich des Eingabe Arrays ist, wird ein [Heapsort](https://en.wikipedia.org/wiki/Heapsort) -Algorithmus verwendet.  
  
-   Andernfalls wird ein [Quicksort](https://en.wikipedia.org/wiki/Quicksort) -Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Für Arrays, die mit den Heapsort-und Quick Sort-Algorithmen sortiert werden, ist diese Methode im schlimmsten Fall ein O (`n` Log `n`)-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> `keys`ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie zwei zugeordnete Arrays sortiert werden, wobei das erste Array die Schlüssel und das zweite Array die Werte enthält. Sortierungen werden mithilfe des Standardcomparers und eines benutzerdefinierten Comparers durchgeführt, der die Sortierreihenfolge umkehrt. Beachten Sie, dass das Ergebnis abhängig von der aktuellen <xref:System.Globalization.CultureInfo>variieren kann.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Die <paramref name="keys" />-<see cref="T:System.Array" />-Klasse ist mehrdimensional.  
  
- oder - 
Die <paramref name="items" />-<see cref="T:System.Array" />-Klasse ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> ist nicht <see langword="null" />, und die Länge von <paramref name="keys" /> ist größer als die Länge von <paramref name="items" />.</exception>
        <exception cref="T:System.InvalidOperationException">In einem oder mehreren Elementen in <paramref name="keys" /><see cref="T:System.Array" /> ist die <see cref="T:System.IComparable" />-Schnittstelle nicht implementiert.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.IDictionary" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (array, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Das zu sortierende eindimensionale Array.</param>
        <param name="comparer">Die Implementierung, die beim Vergleich von Elementen verwendet werden soll.  
  
- oder - 
 <see langword="null" />, wenn die <see cref="T:System.IComparable" />-Implementierung des jeweiligen Elements verwendet werden soll.</param>
        <summary>Sortiert die Elemente in einem eindimensionalen <see cref="T:System.Array" /> mithilfe des angegebenen <see cref="T:System.Collections.IComparer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparer` `null`ist, muss jedes Element von `array` die <xref:System.IComparable> Schnittstelle implementieren, damit Vergleiche mit jedem anderen Element in `array`möglich sind.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet den introspektiven Sort-Algorithmus (Introsort) wie folgt:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein [Einfügungs](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 * Protokoll<sup>N</sup>überschreitet, wobei *N* der Bereich des Eingabe Arrays ist, wird ein [Heapsort](https://en.wikipedia.org/wiki/Heapsort) -Algorithmus verwendet.  
  
-   Andernfalls wird ein [Quicksort](https://en.wikipedia.org/wiki/Quicksort) -Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Für Arrays, die mit den Heapsort-und Quick Sort-Algorithmen sortiert werden, ist diese Methode im schlimmsten Fall ein O (`n` Log `n`)-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> `array`ist.  
  
 Die .NET Framework enthält vordefinierte <xref:System.Collections.IComparer> Implementierungen, die in der folgenden Tabelle aufgeführt sind.  
  
|Implementierung|Beschreibung|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Vergleicht zwei-Objekte, aber führt einen Vergleich von Zeichen folgen ohne Beachtung der Groß-und Kleinschreibung durch.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Vergleicht zwei-Objekte mit den Sortier Konventionen der aktuellen Kultur.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Vergleicht zwei-Objekte, indem die Sortier Konventionen der invarianten Kultur verwendet werden.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Vergleicht zwei Objekte vom Typ `T` mithilfe der Standard Sortierreihenfolge des Typs.|  
  
 Sie können auch benutzerdefinierte Vergleiche unterstützen, indem Sie eine Instanz Ihrer eigenen <xref:System.Collections.IComparer>-Implementierung für den `comparer`-Parameter bereitstellen. In diesem Beispiel wird eine `ReverseComparer` Klasse definiert, die die Standard Sortierreihenfolge für Instanzen eines Typs umkehrt und den Zeichen folgen Vergleich ohne Berücksichtigung der Groß-und Kleinschreibung ausführt.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Werte in einem Zeichen folgen Array mithilfe des Standardcomparers sortiert. Außerdem wird eine benutzerdefinierte <xref:System.Collections.IComparer> Implementierung mit dem Namen `ReverseComparer` definiert, die die Standard Sortierreihenfolge eines Objekts beim Ausführen eines Zeichen folgen Vergleichs ohne Beachtung der Groß-/Kleinschreibung Beachten Sie, dass die Ausgabe abhängig von der aktuellen Kultur variieren kann.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und in einem oder mehreren Elementen in <paramref name="array" /> ist die <see cref="T:System.IComparable" />-Schnittstelle nicht implementiert.</exception>
        <exception cref="T:System.ArgumentException">Die Implementierung von <paramref name="comparer" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <block subset="none" type="usage"><para>In der .NET Framework 4 und früheren Versionen wurde nur der QuickSort-Algorithmus verwendet. Die Quicksort identifiziert ungültige Vergleiche in einigen Situationen, in denen der Sortiervorgang eine <see cref="T:System.IndexOutOfRangeException" /> Ausnahme auslöst, und löst eine <see cref="T:System.ArgumentException" /> Ausnahme an den Aufrufer aus. Beginnend mit dem [!INCLUDE[net_v45](~/includes/net-v45-md.md)]ist es möglich, dass bei Sortiervorgängen, die zuvor <see cref="T:System.ArgumentException" /> ausgelöst haben, keine Ausnahme ausgelöst wird, da die einfügesortier-und Heapsort-Algorithmen keinen ungültigen Vergleich erkennen. Dies gilt größtenteils für Arrays mit weniger als oder gleich 16 Elementen.</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (keys, items, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys">Das eindimensionale <see cref="T:System.Array" /> mit den zu sortierenden Schlüsseln.</param>
        <param name="items">Das eindimensionale <see cref="T:System.Array" /> mit den Elementen, die den jeweiligen Schlüsseln im <paramref name="keys" /><see cref="T:System.Array" /> entsprechen.  
  
- oder - 
 <see langword="null" />, wenn nur das <paramref name="keys" /><see cref="T:System.Array" /> sortiert werden soll.</param>
        <param name="comparer">Die <see cref="T:System.Collections.IComparer" />-Implementierung, die beim Vergleich von Elementen verwendet werden soll.  
  
- oder - 
 <see langword="null" />, wenn die <see cref="T:System.IComparable" />-Implementierung des jeweiligen Elements verwendet werden soll.</param>
        <summary>Sortiert ein Paar von eindimensionalen <see cref="T:System.Array" />-Objekten (ein Objekt enthält die Schlüssel und das andere die entsprechenden Elemente) nach den Schlüsseln im ersten <see cref="T:System.Array" /> und verwendet dabei den angegebenen <see cref="T:System.Collections.IComparer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel im `keys`<xref:System.Array> verfügt über ein entsprechendes Element im `items`<xref:System.Array>. Wenn eine Taste während der Sortierung neu positioniert wird, wird das entsprechende Element in der `items`<xref:System.Array> auf ähnliche Weise neu positioniert. Daher wird der `items`<xref:System.Array> entsprechend der Anordnung der entsprechenden Schlüssel im `keys`<xref:System.Array>sortiert.  
  
 Wenn `comparer` `null`ist, muss jeder Schlüssel im `keys`<xref:System.Array> die <xref:System.IComparable> Schnittstelle implementieren, damit Vergleiche mit jedem anderen Schlüssel möglich sind.  
  
 Sie können sortieren, wenn mehr Elemente als Schlüssel vorhanden sind, aber die Elemente, die keine entsprechenden Schlüssel aufweisen, werden nicht sortiert. Sie können nicht sortieren, wenn mehr Schlüssel als Elemente vorhanden sind. Dadurch wird eine <xref:System.ArgumentException>ausgelöst.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Die .NET Framework enthält vordefinierte <xref:System.Collections.IComparer> Implementierungen, die in der folgenden Tabelle aufgeführt sind.  
  
|Implementierung|Beschreibung|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Vergleicht zwei-Objekte, aber führt einen Vergleich von Zeichen folgen ohne Beachtung der Groß-und Kleinschreibung durch.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Vergleicht zwei-Objekte mit den Sortier Konventionen der aktuellen Kultur.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Vergleicht zwei-Objekte, indem die Sortier Konventionen der invarianten Kultur verwendet werden.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Vergleicht zwei Objekte vom Typ `T` mithilfe der Standard Sortierreihenfolge des Typs.|  
  
 Sie können auch benutzerdefinierte Vergleiche unterstützen, indem Sie eine Instanz Ihrer eigenen <xref:System.Collections.IComparer>-Implementierung für den `comparer`-Parameter bereitstellen. Dies geschieht durch Definieren einer <xref:System.Collections.IComparer>-Implementierung, die die Standard Sortierreihenfolge umkehrt und den Zeichen folgen Vergleich ohne Berücksichtigung der Groß-und Kleinschreibung ausführt.  
  
 Diese Methode verwendet den introspektiven Sort-Algorithmus (Introsort) wie folgt:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein [Einfügungs](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 * Protokoll<sup>N</sup>überschreitet, wobei *N* der Bereich des Eingabe Arrays ist, wird ein [Heapsort](https://en.wikipedia.org/wiki/Heapsort) -Algorithmus verwendet.  
  
-   Andernfalls wird ein [Quicksort](https://en.wikipedia.org/wiki/Quicksort) -Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Für Arrays, die mit den Heapsort-und Quick Sort-Algorithmen sortiert werden, ist diese Methode im schlimmsten Fall ein O (`n` Log `n`)-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> `keys`ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie zwei zugeordnete Arrays sortiert werden, wobei das erste Array die Schlüssel und das zweite Array die Werte enthält. Sortierungen werden mithilfe des Standardcomparers und eines benutzerdefinierten Comparers durchgeführt, der die Sortierreihenfolge umkehrt. Beachten Sie, dass das Ergebnis abhängig von der aktuellen <xref:System.Globalization.CultureInfo>variieren kann.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Die <paramref name="keys" />-<see cref="T:System.Array" />-Klasse ist mehrdimensional.  
  
- oder - 
Die <paramref name="items" />-<see cref="T:System.Array" />-Klasse ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> ist nicht <see langword="null" />, und die Länge von <paramref name="keys" /> ist größer als die Länge von <paramref name="items" />.  
  
- oder - 
Die Implementierung von <paramref name="comparer" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und in einem oder mehreren Elementen im <paramref name="keys" /><see cref="T:System.Array" /> ist die <see cref="T:System.IComparable" />-Schnittstelle nicht implementiert.</exception>
        <block subset="none" type="usage"><para>In der .NET Framework 4 und früheren Versionen wurde nur der QuickSort-Algorithmus verwendet. Die Quicksort identifiziert ungültige Vergleiche in einigen Situationen, in denen der Sortiervorgang eine <see cref="T:System.IndexOutOfRangeException" /> Ausnahme auslöst, und löst eine <see cref="T:System.ArgumentException" /> Ausnahme an den Aufrufer aus. Beginnend mit dem [!INCLUDE[net_v45](~/includes/net-v45-md.md)]ist es möglich, dass bei Sortiervorgängen, die zuvor <see cref="T:System.ArgumentException" /> ausgelöst haben, keine Ausnahme ausgelöst wird, da die einfügesortier-und Heapsort-Algorithmen keinen ungültigen Vergleich erkennen. Dies gilt größtenteils für Arrays mit weniger als oder gleich 16 Elementen.</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * int * int -&gt; unit" Usage="System.Array.Sort (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das zu sortierende eindimensionale <see cref="T:System.Array" />.</param>
        <param name="index">Der Startindex des zu sortierenden Bereichs.</param>
        <param name="length">Die Anzahl der Elemente im zu sortierenden Bereich.</param>
        <summary>Sortiert die Elemente in einem Bereich von Elementen in einem eindimensionalen <see cref="T:System.Array" /> mithilfe der <see cref="T:System.IComparable" />-Implementierung jedes Elements des <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jedes Element innerhalb des angegebenen Bereichs von Elementen in `array` muss die <xref:System.IComparable>-Schnittstelle implementieren, damit Vergleiche mit jedem anderen Element in `array`möglich sind.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet den introspektiven Sort-Algorithmus (Introsort) wie folgt:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein [Einfügungs](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 * Protokoll<sup>N</sup>überschreitet, wobei *N* der Bereich des Eingabe Arrays ist, wird ein [Heapsort](https://en.wikipedia.org/wiki/Heapsort) -Algorithmus verwendet.  
  
-   Andernfalls wird ein [Quicksort](https://en.wikipedia.org/wiki/Quicksort) -Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Für Arrays, die mit den Heapsort-und Quick Sort-Algorithmen sortiert werden, ist diese Methode im schlimmsten Fall ein O (`n` Log `n`)-Vorgang, bei dem `n` `length`ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie die Werte in einem <xref:System.Array> mithilfe des Standardcomparers und eines benutzerdefinierten Vergleichs, der die Sortierreihenfolge umkehrt, sortiert werden. Beachten Sie, dass das Ergebnis abhängig von der aktuellen <xref:System.Globalization.CultureInfo>variieren kann.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die untere <paramref name="array" />-Grenze.  
  
- oder - 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="array" /> an.</exception>
        <exception cref="T:System.InvalidOperationException">In einem oder mehreren Elementen in <paramref name="array" /> ist die <see cref="T:System.IComparable" />-Schnittstelle nicht implementiert.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * int * int -&gt; unit" Usage="System.Array.Sort (keys, items, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys">Das eindimensionale <see cref="T:System.Array" /> mit den zu sortierenden Schlüsseln.</param>
        <param name="items">Das eindimensionale <see cref="T:System.Array" /> mit den Elementen, die den jeweiligen Schlüsseln im <paramref name="keys" /><see cref="T:System.Array" /> entsprechen.  
  
- oder - 
 <see langword="null" />, wenn nur das <paramref name="keys" /><see cref="T:System.Array" /> sortiert werden soll.</param>
        <param name="index">Der Startindex des zu sortierenden Bereichs.</param>
        <param name="length">Die Anzahl der Elemente im zu sortierenden Bereich.</param>
        <summary>Sortiert einen Bereich von Elementen in einem Paar von eindimensionalen <see cref="T:System.Array" />-Objekten (das eine enthält die Schlüssel und das andere die entsprechenden Werte) nach den Schlüsseln im ersten <see cref="T:System.Array" /> und verwendet dabei die <see cref="T:System.IComparable" />-Implementierung jedes Schlüssels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel im `keys`<xref:System.Array> verfügt über ein entsprechendes Element im `items`<xref:System.Array>. Wenn eine Taste während der Sortierung neu positioniert wird, wird das entsprechende Element in der `items`<xref:System.Array> auf ähnliche Weise neu positioniert. Daher wird der `items`<xref:System.Array> entsprechend der Anordnung der entsprechenden Schlüssel im `keys`<xref:System.Array>sortiert.  
  
 Jeder Schlüssel innerhalb des angegebenen Bereichs von Elementen in der `keys`<xref:System.Array> muss die <xref:System.IComparable>-Schnittstelle implementieren, damit Vergleiche mit jedem anderen Schlüssel möglich sind.  
  
 Sie können sortieren, wenn mehr Elemente als Schlüssel vorhanden sind, aber die Elemente, die keine entsprechenden Schlüssel aufweisen, werden nicht sortiert. Sie können nicht sortieren, wenn mehr Schlüssel als Elemente vorhanden sind. Dadurch wird eine <xref:System.ArgumentException>ausgelöst.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet den introspektiven Sort-Algorithmus (Introsort) wie folgt:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein [Einfügungs](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 * Protokoll<sup>N</sup>überschreitet, wobei *N* der Bereich des Eingabe Arrays ist, wird ein [Heapsort](https://en.wikipedia.org/wiki/Heapsort) -Algorithmus verwendet.  
  
-   Andernfalls wird ein [Quicksort](https://en.wikipedia.org/wiki/Quicksort) -Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Für Arrays, die mit den Heapsort-und Quick Sort-Algorithmen sortiert werden, ist diese Methode im schlimmsten Fall ein O (`n` Log `n`)-Vorgang, bei dem `n` `length`ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie zwei zugeordnete Arrays sortiert werden, wobei das erste Array die Schlüssel und das zweite Array die Werte enthält. Sortierungen werden mithilfe des Standardcomparers und eines benutzerdefinierten Comparers durchgeführt, der die Sortierreihenfolge umkehrt. Beachten Sie, dass das Ergebnis abhängig von der aktuellen <xref:System.Globalization.CultureInfo>variieren kann.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Die <paramref name="keys" />-<see cref="T:System.Array" />-Klasse ist mehrdimensional.  
  
- oder - 
Die <paramref name="items" />-<see cref="T:System.Array" />-Klasse ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die untere <paramref name="keys" />-Grenze.  
  
- oder - 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> ist nicht <see langword="null" />, und die Länge von <paramref name="keys" /> ist größer als die Länge von <paramref name="items" />.  
  
- oder - 
 <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="keys" /><see cref="T:System.Array" /> an.  
  
- oder - 
 <paramref name="items" /> ist nicht <see langword="null" />, und <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="items" /><see cref="T:System.Array" /> an.</exception>
        <exception cref="T:System.InvalidOperationException">In einem oder mehreren Elementen in <paramref name="keys" /><see cref="T:System.Array" /> ist die <see cref="T:System.IComparable" />-Schnittstelle nicht implementiert.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * int * int * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (array, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Das zu sortierende eindimensionale <see cref="T:System.Array" />.</param>
        <param name="index">Der Startindex des zu sortierenden Bereichs.</param>
        <param name="length">Die Anzahl der Elemente im zu sortierenden Bereich.</param>
        <param name="comparer">Die <see cref="T:System.Collections.IComparer" />-Implementierung, die beim Vergleich von Elementen verwendet werden soll.  
  
- oder - 
 <see langword="null" />, wenn die <see cref="T:System.IComparable" />-Implementierung des jeweiligen Elements verwendet werden soll.</param>
        <summary>Sortiert die Elemente in einem Bereich von Elementen in einem eindimensionalen <see cref="T:System.Array" /> mithilfe des angegebenen <see cref="T:System.Collections.IComparer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparer` `null`ist, muss jedes Element innerhalb des angegebenen Bereichs von Elementen in `array` die <xref:System.IComparable> Schnittstelle implementieren, damit Vergleiche mit jedem anderen Element in `array`möglich sind.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Die .NET Framework enthält vordefinierte <xref:System.Collections.IComparer> Implementierungen, die in der folgenden Tabelle aufgeführt sind.  
  
|Implementierung|Beschreibung|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Vergleicht zwei-Objekte, aber führt einen Vergleich von Zeichen folgen ohne Beachtung der Groß-und Kleinschreibung durch.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Vergleicht zwei-Objekte mit den Sortier Konventionen der aktuellen Kultur.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Vergleicht zwei-Objekte, indem die Sortier Konventionen der invarianten Kultur verwendet werden.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Vergleicht zwei Objekte vom Typ `T` mithilfe der Standard Sortierreihenfolge des Typs.|  
  
 Sie können auch benutzerdefinierte Vergleiche unterstützen, indem Sie eine Instanz Ihrer eigenen <xref:System.Collections.IComparer>-Implementierung für den `comparer`-Parameter bereitstellen. In diesem Beispiel wird eine `ReverseComparer` Klasse definiert, die die Standard Sortierreihenfolge für Instanzen eines Typs umkehrt und den Zeichen folgen Vergleich ohne Berücksichtigung der Groß-und Kleinschreibung ausführt.  
  
 Diese Methode verwendet den introspektiven Sort-Algorithmus (Introsort) wie folgt:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein [Einfügungs](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 * Protokoll<sup>N</sup>überschreitet, wobei *N* der Bereich des Eingabe Arrays ist, wird ein [Heapsort](https://en.wikipedia.org/wiki/Heapsort) -Algorithmus verwendet.  
  
-   Andernfalls wird ein [Quicksort](https://en.wikipedia.org/wiki/Quicksort) -Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Für Arrays, die mit den Heapsort-und Quick Sort-Algorithmen sortiert werden, ist diese Methode im schlimmsten Fall ein O (`n` Log `n`)-Vorgang, bei dem `n` `length`ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie die Werte in einem <xref:System.Array> mithilfe des Standardcomparers und eines benutzerdefinierten Vergleichs, der die Sortierreihenfolge umkehrt, sortiert werden. Beachten Sie, dass das Ergebnis abhängig von der aktuellen <xref:System.Globalization.CultureInfo>variieren kann.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die untere <paramref name="array" />-Grenze.  
  
- oder - 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="array" /> an.  
  
- oder - 
Die Implementierung von <paramref name="comparer" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und in einem oder mehreren Elementen in <paramref name="array" /> ist die <see cref="T:System.IComparable" />-Schnittstelle nicht implementiert.</exception>
        <block subset="none" type="usage"><para>In der .NET Framework 4 und früheren Versionen wurde nur der QuickSort-Algorithmus verwendet. Die Quicksort identifiziert ungültige Vergleiche in einigen Situationen, in denen der Sortiervorgang eine <see cref="T:System.IndexOutOfRangeException" /> Ausnahme auslöst, und löst eine <see cref="T:System.ArgumentException" /> Ausnahme an den Aufrufer aus. Beginnend mit dem [!INCLUDE[net_v45](~/includes/net-v45-md.md)]ist es möglich, dass bei Sortiervorgängen, die zuvor <see cref="T:System.ArgumentException" /> ausgelöst haben, keine Ausnahme ausgelöst wird, da die einfügesortier-und Heapsort-Algorithmen keinen ungültigen Vergleich erkennen. Dies gilt größtenteils für Arrays mit weniger als oder gleich 16 Elementen.</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * int * int * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (keys, items, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys">Das eindimensionale <see cref="T:System.Array" /> mit den zu sortierenden Schlüsseln.</param>
        <param name="items">Das eindimensionale <see cref="T:System.Array" /> mit den Elementen, die den jeweiligen Schlüsseln im <paramref name="keys" /><see cref="T:System.Array" /> entsprechen.  
  
- oder - 
 <see langword="null" />, wenn nur das <paramref name="keys" /><see cref="T:System.Array" /> sortiert werden soll.</param>
        <param name="index">Der Startindex des zu sortierenden Bereichs.</param>
        <param name="length">Die Anzahl der Elemente im zu sortierenden Bereich.</param>
        <param name="comparer">Die <see cref="T:System.Collections.IComparer" />-Implementierung, die beim Vergleich von Elementen verwendet werden soll.  
  
- oder - 
 <see langword="null" />, wenn die <see cref="T:System.IComparable" />-Implementierung des jeweiligen Elements verwendet werden soll.</param>
        <summary>Sortiert einen Bereich von Elementen in einem Paar von eindimensionalen <see cref="T:System.Array" />-Objekten (das eine enthält die Schlüssel und das andere die entsprechenden Werte) nach den Schlüsseln im ersten <see cref="T:System.Array" /> und verwendet dabei den angegebenen <see cref="T:System.Collections.IComparer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel im `keys`<xref:System.Array> verfügt über ein entsprechendes Element im `items`<xref:System.Array>. Wenn eine Taste während der Sortierung neu positioniert wird, wird das entsprechende Element in der `items`<xref:System.Array> auf ähnliche Weise neu positioniert. Daher wird der `items`<xref:System.Array> entsprechend der Anordnung der entsprechenden Schlüssel im `keys`<xref:System.Array>sortiert.  
  
 Wenn `comparer` `null`ist, muss jeder Schlüssel innerhalb des angegebenen Bereichs von Elementen im `keys`<xref:System.Array> die <xref:System.IComparable> Schnittstelle implementieren, damit Vergleiche mit jedem anderen Schlüssel möglich sind.  
  
 Sie können sortieren, wenn mehr Elemente als Schlüssel vorhanden sind, aber die Elemente, die keine entsprechenden Schlüssel aufweisen, werden nicht sortiert. Sie können nicht sortieren, wenn mehr Schlüssel als Elemente vorhanden sind. Dadurch wird eine <xref:System.ArgumentException>ausgelöst.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Die .NET Framework enthält vordefinierte <xref:System.Collections.IComparer> Implementierungen, die in der folgenden Tabelle aufgeführt sind.  
  
|Implementierung|Beschreibung|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Vergleicht zwei-Objekte, aber führt einen Vergleich von Zeichen folgen ohne Beachtung der Groß-und Kleinschreibung durch.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Vergleicht zwei-Objekte mit den Sortier Konventionen der aktuellen Kultur.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Vergleicht zwei-Objekte, indem die Sortier Konventionen der invarianten Kultur verwendet werden.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Vergleicht zwei Objekte vom Typ `T` mithilfe der Standard Sortierreihenfolge des Typs.|  
  
 Sie können auch benutzerdefinierte Vergleiche unterstützen, indem Sie eine Instanz Ihrer eigenen <xref:System.Collections.IComparer>-Implementierung für den `comparer`-Parameter bereitstellen. Dies geschieht durch Definieren einer benutzerdefinierten <xref:System.Collections.IComparer> Implementierung, die die Standard Sortierreihenfolge umkehrt und den Zeichen folgen Vergleich ohne Berücksichtigung der Groß-und Kleinschreibung ausführt.  
  
 Diese Methode verwendet den introspektiven Sort-Algorithmus (Introsort) wie folgt:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein [Einfügungs](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 * Protokoll<sup>N</sup>überschreitet, wobei *N* der Bereich des Eingabe Arrays ist, wird ein [Heapsort](https://en.wikipedia.org/wiki/Heapsort) -Algorithmus verwendet.  
  
-   Andernfalls wird ein [Quicksort](https://en.wikipedia.org/wiki/Quicksort) -Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Für Arrays, die mit den Heapsort-und Quick Sort-Algorithmen sortiert werden, ist diese Methode im schlimmsten Fall ein O (`n` Log `n`)-Vorgang, bei dem `n` `length`ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie zwei zugeordnete Arrays sortiert werden, wobei das erste Array die Schlüssel und das zweite Array die Werte enthält. Sortierungen werden mithilfe des Standardcomparers und eines benutzerdefinierten Comparers durchgeführt, der die Sortierreihenfolge umkehrt. Beachten Sie, dass das Ergebnis abhängig von der aktuellen <xref:System.Globalization.CultureInfo>variieren kann.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.RankException">Die <paramref name="keys" />-<see cref="T:System.Array" />-Klasse ist mehrdimensional.  
  
- oder - 
Die <paramref name="items" />-<see cref="T:System.Array" />-Klasse ist mehrdimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die untere <paramref name="keys" />-Grenze.  
  
- oder - 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> ist nicht <see langword="null" />, und die Untergrenze von <paramref name="keys" /> entspricht nicht der Untergrenze von <paramref name="items" />.  
  
- oder - 
 <paramref name="items" /> ist nicht <see langword="null" />, und die Länge von <paramref name="keys" /> ist größer als die Länge von <paramref name="items" />.  
  
- oder - 
 <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="keys" /><see cref="T:System.Array" /> an.  
  
- oder - 
 <paramref name="items" /> ist nicht <see langword="null" />, und <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="items" /><see cref="T:System.Array" /> an.  
  
- oder - 
Die Implementierung von <paramref name="comparer" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und in einem oder mehreren Elementen im <paramref name="keys" /><see cref="T:System.Array" /> ist die <see cref="T:System.IComparable" />-Schnittstelle nicht implementiert.</exception>
        <block subset="none" type="usage"><para>In der .NET Framework 4 und früheren Versionen wurde nur der QuickSort-Algorithmus verwendet. Die Quicksort identifiziert ungültige Vergleiche in einigen Situationen, in denen der Sortiervorgang eine <see cref="T:System.IndexOutOfRangeException" /> Ausnahme auslöst, und löst eine <see cref="T:System.ArgumentException" /> Ausnahme an den Aufrufer aus. Beginnend mit dem [!INCLUDE[net_v45](~/includes/net-v45-md.md)]ist es möglich, dass bei Sortiervorgängen, die zuvor <see cref="T:System.ArgumentException" /> ausgelöst haben, keine Ausnahme ausgelöst wird, da die einfügesortier-und Heapsort-Algorithmen keinen ungültigen Vergleich erkennen. Dies gilt größtenteils für Arrays mit weniger als oder gleich 16 Elementen.</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] -&gt; unit" Usage="System.Array.Sort array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu sortierende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <summary>Sortiert die Elemente in einem ganzen <see cref="T:System.Array" /> mithilfe der Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle jedes Elements des <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jedes Element von `array` muss die <xref:System.IComparable%601> generische Schnittstelle implementieren, damit Vergleiche mit jedem anderen Element in `array`möglich sind.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet den introspektiven Sort-Algorithmus (Introsort) wie folgt:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein [Einfügungs](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 * Protokoll<sup>N</sup>überschreitet, wobei *N* der Bereich des Eingabe Arrays ist, wird ein [Heapsort](https://en.wikipedia.org/wiki/Heapsort) -Algorithmus verwendet.  
  
-   Andernfalls wird ein [Quicksort](https://en.wikipedia.org/wiki/Quicksort) -Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Für Arrays, die mit den Heapsort-und Quick Sort-Algorithmen sortiert werden, ist diese Methode im schlimmsten Fall ein O (`n` Log `n`)-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> `array`ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> generische Methoden Überladung und die <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> generische Methoden Überladung veranschaulicht. Ein Array von Zeichen folgen wird erstellt, in keiner bestimmten Reihenfolge.  
  
 Das Array wird angezeigt, sortiert und erneut angezeigt.  
  
> [!NOTE]
>  Die Aufrufe der generischen Methoden <xref:System.Array.Sort%2A> und <xref:System.Array.BinarySearch%2A> unterscheiden sich nicht von den Aufrufen ihrer nicht generischen Entsprechungen, da Visual Basic C#,, C++ und den Typ des generischen Typparameters vom Typ des ersten Arguments ableiten. Wenn Sie den [Ildasm. exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) verwenden, um die MSIL (Microsoft Intermediate Language) zu überprüfen, können Sie sehen, dass die generischen Methoden aufgerufen werden.  
  
 Die generische Methoden Überladung von <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> wird dann verwendet, um nach zwei Zeichen folgen zu suchen, eine, die nicht im-Array ist, und eine, die ist. Das Array und der Rückgabewert der <xref:System.Array.BinarySearch%2A>-Methode werden an die generische Methode `ShowWhere` übergeben, die den Indexwert anzeigt, wenn die Zeichenfolge gefunden wird, und andernfalls die Elemente, zwischen denen die Such Zeichenfolge fällt, wenn Sie sich im Array befindet. Der Index ist negativ, wenn die Zeichenfolge nicht n das Array ist, sodass die `ShowWhere`-Methode das bitweise Komplement (der ~ C# -Operator C++in und Visual, `Xor`-1 in Visual Basic) übernimmt, um den Index des ersten Elements in der Liste zu erhalten, das größer als die Such Zeichenfolge ist.  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">In einem oder mehreren Elementen in <paramref name="array" /> ist die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht implementiert.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu sortierende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="comparer">Die Implementierung der generischen <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle, die für den Vergleich von Elementen verwendet werden soll, oder <see langword="null" />, um die Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle der einzelnen Elemente zu verwenden.</param>
        <summary>Sortiert die Elemente in einem <see cref="T:System.Array" /> mithilfe der angegebenen generischen <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparer` `null`ist, muss jedes Element von `array` die <xref:System.IComparable%601> generische Schnittstelle implementieren, damit Vergleiche mit jedem anderen Element in `array`möglich sind.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet den introspektiven Sort-Algorithmus (Introsort) wie folgt:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein [Einfügungs](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 * Protokoll<sup>N</sup>überschreitet, wobei *N* der Bereich des Eingabe Arrays ist, wird ein [Heapsort](https://en.wikipedia.org/wiki/Heapsort) -Algorithmus verwendet.  
  
-   Andernfalls wird ein [Quicksort](https://en.wikipedia.org/wiki/Quicksort) -Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Für Arrays, die mit den Heapsort-und Quick Sort-Algorithmen sortiert werden, ist diese Methode im schlimmsten Fall ein O (`n` Log `n`)-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> `array`ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generische Methoden Überladung und die <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generische Methoden Überladung veranschaulicht.  
  
 Im Codebeispiel wird ein alternativer Vergleich für Zeichen folgen mit dem Namen `ReverseCompare`definiert, der die generische Schnittstelle `IComparer<string>` (`IComparer(Of String)` in Visual Basic C++, `IComparer<String^>` in Visual) implementiert. Der Vergleich Ruft die <xref:System.String.CompareTo%28System.String%29>-Methode auf und kehrt die Reihenfolge der Vergleichs Elemente um, sodass die Zeichen folgen nicht zu hoch, sondern zu niedrig sortiert werden.  
  
 Das Array wird angezeigt, sortiert und erneut angezeigt. Arrays müssen sortiert werden, um die <xref:System.Array.BinarySearch%2A>-Methode zu verwenden.  
  
> [!NOTE]
>  Die Aufrufe der generischen Methoden <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> und <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> unterscheiden sich nicht von den Aufrufen ihrer nicht generischen Entsprechungen, da Visual Basic C#,, C++ und den Typ des generischen Typparameters vom Typ des ersten Arguments ableiten. Wenn Sie den [Ildasm. exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) verwenden, um die MSIL (Microsoft Intermediate Language) zu überprüfen, können Sie sehen, dass die generischen Methoden aufgerufen werden.  
  
 Die generische Methoden Überladung von <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> wird dann verwendet, um nach zwei Zeichen folgen zu suchen, eine, die nicht im-Array ist, und eine, die ist. Das Array und der Rückgabewert der <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>-Methode werden an die generische Methode `ShowWhere` übergeben, die den Indexwert anzeigt, wenn die Zeichenfolge gefunden wird, und andernfalls die Elemente, zwischen denen die Such Zeichenfolge fällt, wenn Sie sich im Array befindet. Der Index ist negativ, wenn die Zeichenfolge nicht n das Array ist, sodass die `ShowWhere`-Methode das bitweise Komplement (der ~ C# -Operator C++in und Visual, `Xor`-1 in Visual Basic) übernimmt, um den Index des ersten Elements in der Liste zu erhalten, das größer als die Such Zeichenfolge ist.  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und in einem oder mehreren Elementen im <paramref name="array" /> ist die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht implementiert.</exception>
        <exception cref="T:System.ArgumentException">Die Implementierung von <paramref name="comparer" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <block subset="none" type="usage"><para>In der .NET Framework 4 und früheren Versionen wurde nur der QuickSort-Algorithmus verwendet. Die Quicksort identifiziert ungültige Vergleiche in einigen Situationen, in denen der Sortiervorgang eine <see cref="T:System.IndexOutOfRangeException" /> Ausnahme auslöst, und löst eine <see cref="T:System.ArgumentException" /> Ausnahme an den Aufrufer aus. Beginnend mit dem [!INCLUDE[net_v45](~/includes/net-v45-md.md)]ist es möglich, dass bei Sortiervorgängen, die zuvor <see cref="T:System.ArgumentException" /> ausgelöst haben, keine Ausnahme ausgelöst wird, da die einfügesortier-und Heapsort-Algorithmen keinen ungültigen Vergleich erkennen. Dies gilt größtenteils für Arrays mit weniger als oder gleich 16 Elementen.</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Comparison`1&lt;!!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Comparison{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, Comparison&lt;T&gt; ^ comparison);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * Comparison&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, comparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu sortierende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="comparison">Die <see cref="T:System.Comparison`1" />, die beim Vergleich von Elementen verwendet werden soll.</param>
        <summary>Sortiert die Elemente in einem <see cref="T:System.Array" /> mithilfe des angegebenen <see cref="T:System.Comparison`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet den introktiven Sort-Algorithmus (Introsort) wie folgt:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein [Einfügungs](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 * Protokoll<sup>N</sup>überschreitet, wobei *N* der Bereich des Eingabe Arrays ist, wird ein [Heapsort](https://en.wikipedia.org/wiki/Heapsort) -Algorithmus verwendet.  
  
-   Andernfalls wird ein [Quicksort](https://en.wikipedia.org/wiki/Quicksort) -Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Für Arrays, die mit den Heapsort-und Quick Sort-Algorithmen sortiert werden, ist diese Methode im schlimmsten Fall ein O (`n` Log `n`)-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> `array`ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> -methodenüberladung.  
  
 Das Codebeispiel definiert eine Alternative Vergleichsmethode für Zeichen folgen mit dem Namen `CompareDinosByLength`. Diese Methode funktioniert wie folgt: zuerst werden die Vergleiche auf`null`getestet, und ein NULL-Verweis wird als kleiner als ein nicht-NULL-Wert behandelt. Zweitens werden die Zeichen folgen Längen verglichen, und die längere Zeichenfolge wird als größer eingestuft. Drittens: Wenn die Längen gleich sind, wird der normale Zeichen folgen Vergleich verwendet.  
  
 Ein Array von Zeichen folgen wird erstellt und mit vier Zeichen folgen ohne bestimmte Reihenfolge aufgefüllt. Die Liste enthält auch eine leere Zeichenfolge und einen NULL-Verweis. Die Liste wird angezeigt, mithilfe eines <xref:System.Comparison%601> generischen Delegaten sortiert, der die `CompareDinosByLength`-Methode darstellt, und wird erneut angezeigt.  
  
 [!code-cpp[Array_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[Array_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortComparison/cs/source.cs#1)]
 [!code-vb[Array_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="comparison" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Implementierung von <paramref name="comparison" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparison" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <block subset="none" type="usage"><para>In der .NET Framework 4 und früheren Versionen wurde nur der QuickSort-Algorithmus verwendet. Die Quicksort identifiziert ungültige Vergleiche in einigen Situationen, in denen der Sortiervorgang eine <see cref="T:System.IndexOutOfRangeException" /> Ausnahme auslöst, und löst eine <see cref="T:System.ArgumentException" /> Ausnahme an den Aufrufer aus. Beginnend mit dem [!INCLUDE[net_v45](~/includes/net-v45-md.md)]ist es möglich, dass bei Sortiervorgängen, die zuvor <see cref="T:System.ArgumentException" /> ausgelöst haben, keine Ausnahme ausgelöst wird, da die einfügesortier-und Heapsort-Algorithmen keinen ungültigen Vergleich erkennen. Zum größten Teil gilt dies für Arrays mit weniger als oder gleich 6 Elementen.</para></block>
        <altmember cref="T:System.Comparison`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * int * int -&gt; unit" Usage="System.Array.Sort (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu sortierende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="index">Der Startindex des zu sortierenden Bereichs.</param>
        <param name="length">Die Anzahl der Elemente im zu sortierenden Bereich.</param>
        <summary>Sortiert die Elemente in einem Bereich von Elementen in einem <see cref="T:System.Array" /> mithilfe der Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle jedes Elements des <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jedes Element innerhalb des angegebenen Bereichs von Elementen in `array` muss die <xref:System.IComparable%601> generische Schnittstelle implementieren, damit Vergleiche mit jedem anderen Element in `array`möglich sind.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet den introspektiven Sort-Algorithmus (Introsort) wie folgt:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein [Einfügungs](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 * Protokoll<sup>N</sup>überschreitet, wobei *N* der Bereich des Eingabe Arrays ist, wird ein [Heapsort](https://en.wikipedia.org/wiki/Heapsort) -Algorithmus verwendet.  
  
-   Andernfalls wird ein [Quicksort](https://en.wikipedia.org/wiki/Quicksort) -Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Für Arrays, die mit den Heapsort-und Quick Sort-Algorithmen sortiert werden, ist diese Methode im schlimmsten Fall ein O (`n` Log `n`)-Vorgang, bei dem `n` `length`ist.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> generische Methoden Überladung und die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generische Methoden Überladung zum Sortieren eines Bereichs in einem Array.  
  
 Im Codebeispiel wird ein alternativer Vergleich für Zeichen folgen mit dem Namen `ReverseCompare`definiert, der die generische Schnittstelle `IComparer<string>` (`IComparer(Of String)` in Visual Basic C++, `IComparer<String^>` in Visual) implementiert. Der Vergleich Ruft die <xref:System.String.CompareTo%28System.String%29>-Methode auf und kehrt die Reihenfolge der Vergleichs Elemente um, sodass die Zeichen folgen nicht zu hoch, sondern zu niedrig sortiert werden.  
  
 Im Codebeispiel wird ein Array von Dinosaurier Namen erstellt und angezeigt, das aus drei HERBIVORES gefolgt von drei Fleisch freten (Tyrannosaurids) besteht. Mit der <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> generischen Methoden Überladung werden die letzten drei Elemente des Arrays sortiert, die dann angezeigt werden. Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generische Methoden Überladung wird mit `ReverseCompare` verwendet, um die letzten drei Elemente in umgekehrter Reihenfolge zu sortieren. Die umfassend verwirrten Dinosaurier werden erneut angezeigt.  
  
> [!NOTE]
>  Die Aufrufe der generischen Methoden <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> und <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> unterscheiden sich nicht von den Aufrufen ihrer nicht generischen Entsprechungen, da Visual Basic C#,, C++ und den Typ des generischen Typparameters vom Typ des ersten Arguments ableiten. Wenn Sie den [Ildasm. exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) verwenden, um die MSIL (Microsoft Intermediate Language) zu überprüfen, können Sie sehen, dass die generischen Methoden aufgerufen werden.  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die Untergrenze von <paramref name="array" />.  
  
- oder - 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="array" /> an.</exception>
        <exception cref="T:System.InvalidOperationException">In einem oder mehreren Elementen in <paramref name="array" /> ist die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht implementiert.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * int * int * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das zu sortierende eindimensionale und nullbasierte <see cref="T:System.Array" />.</param>
        <param name="index">Der Startindex des zu sortierenden Bereichs.</param>
        <param name="length">Die Anzahl der Elemente im zu sortierenden Bereich.</param>
        <param name="comparer">Die Implementierung der generischen <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle, die für den Vergleich von Elementen verwendet werden soll, oder <see langword="null" />, um die Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle der einzelnen Elemente zu verwenden.</param>
        <summary>Sortiert die Elemente in einem Bereich von Elementen im <see cref="T:System.Array" /> mithilfe der angegebenen generischen <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparer` `null`ist, muss jedes Element innerhalb des angegebenen Bereichs von Elementen in `array` die <xref:System.IComparable%601> generische Schnittstelle implementieren, damit Vergleiche mit jedem anderen Element in `array`möglich sind.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet den introspektiven Sort-Algorithmus (Introsort) wie folgt:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein [Einfügungs](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 * Protokoll<sup>N</sup>überschreitet, wobei *N* der Bereich des Eingabe Arrays ist, wird ein [Heapsort](https://en.wikipedia.org/wiki/Heapsort) -Algorithmus verwendet.  
  
-   Andernfalls wird ein [Quicksort](https://en.wikipedia.org/wiki/Quicksort) -Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Für Arrays, die mit den Heapsort-und Quick Sort-Algorithmen sortiert werden, ist diese Methode im schlimmsten Fall ein O (`n` Log `n`)-Vorgang, bei dem `n` `length`ist.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> generische Methoden Überladung und die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generische Methoden Überladung zum Sortieren eines Bereichs in einem Array.  
  
 Im Codebeispiel wird ein alternativer Vergleich für Zeichen folgen mit dem Namen `ReverseCompare`definiert, der die generische Schnittstelle `IComparer<string>` (`IComparer(Of String)` in Visual Basic C++, `IComparer<String^>` in Visual) implementiert. Der Vergleich Ruft die <xref:System.String.CompareTo%28System.String%29>-Methode auf und kehrt die Reihenfolge der Vergleichs Elemente um, sodass die Zeichen folgen nicht zu hoch, sondern zu niedrig sortiert werden.  
  
 Im Codebeispiel wird ein Array von Dinosaurier Namen erstellt und angezeigt, das aus drei HERBIVORES gefolgt von drei Fleisch freten (Tyrannosaurids) besteht. Mit der <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> generischen Methoden Überladung werden die letzten drei Elemente des Arrays sortiert, die dann angezeigt werden. Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generische Methoden Überladung wird mit `ReverseCompare` verwendet, um die letzten drei Elemente in umgekehrter Reihenfolge zu sortieren. Die umfassend verwirrten Dinosaurier werden erneut angezeigt.  
  
> [!NOTE]
>  Die Aufrufe der generischen Methoden <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> und <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> unterscheiden sich nicht von den Aufrufen ihrer nicht generischen Entsprechungen, da Visual Basic C#,, C++ und den Typ des generischen Typparameters vom Typ des ersten Arguments ableiten. Wenn Sie den [Ildasm. exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) verwenden, um die MSIL (Microsoft Intermediate Language) zu überprüfen, können Sie sehen, dass die generischen Methoden aufgerufen werden.  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die Untergrenze von <paramref name="array" />.  
  
- oder - 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="array" /> an.  
  
- oder - 
Die Implementierung von <paramref name="comparer" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und in einem oder mehreren Elementen im <paramref name="array" /> ist die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht implementiert.</exception>
        <block subset="none" type="usage"><para>In der .NET Framework 4 und früheren Versionen wurde nur der QuickSort-Algorithmus verwendet. Die Quicksort identifiziert ungültige Vergleiche in einigen Situationen, in denen der Sortiervorgang eine <see cref="T:System.IndexOutOfRangeException" /> Ausnahme auslöst, und löst eine <see cref="T:System.ArgumentException" /> Ausnahme an den Aufrufer aus. Beginnend mit dem [!INCLUDE[net_v45](~/includes/net-v45-md.md)]ist es möglich, dass bei Sortiervorgängen, die zuvor <see cref="T:System.ArgumentException" /> ausgelöst haben, keine Ausnahme ausgelöst wird, da die einfügesortier-und Heapsort-Algorithmen keinen ungültigen Vergleich erkennen. Dies gilt größtenteils für Arrays mit weniger als oder gleich 16 Elementen.</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] -&gt; unit" Usage="System.Array.Sort (keys, items)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Der Typ der Elemente des Schlüsselarrays.</typeparam>
        <typeparam name="TValue">Der Typ der Elemente des Elementarrays.</typeparam>
        <param name="keys">Das eindimensionale nullbasierte <see cref="T:System.Array" /> mit den zu sortierenden Schlüsseln.</param>
        <param name="items">Das eindimensionale nullbasierte <see cref="T:System.Array" />, das die den Schlüsseln in <paramref name="keys" /> entsprechenden Elemente enthält, oder <see langword="null" />, um nur <paramref name="keys" /> zu sortieren.</param>
        <summary>Sortiert ein Paar von <see cref="T:System.Array" />-Objekten (das eine enthält die Schlüssel und das andere die entsprechenden Werte) nach den Schlüsseln im ersten <see cref="T:System.Array" /> und verwendet dabei die Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle jedes Schlüssels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel im `keys`<xref:System.Array> verfügt über ein entsprechendes Element im `items`<xref:System.Array>. Wenn eine Taste während der Sortierung neu positioniert wird, wird das entsprechende Element in der `items`<xref:System.Array> auf ähnliche Weise neu positioniert. Daher wird der `items`<xref:System.Array> entsprechend der Anordnung der entsprechenden Schlüssel im `keys`<xref:System.Array>sortiert.  
  
 Jeder Schlüssel in der `keys`<xref:System.Array> muss die <xref:System.IComparable%601> generische Schnittstelle implementieren, damit Vergleiche mit jedem anderen Schlüssel möglich sind.  
  
 Sie können sortieren, wenn mehr Elemente als Schlüssel vorhanden sind, aber die Elemente, die keine entsprechenden Schlüssel aufweisen, werden nicht sortiert. Sie können nicht sortieren, wenn mehr Schlüssel als Elemente vorhanden sind. Dadurch wird eine <xref:System.ArgumentException>ausgelöst.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet den introspektiven Sort-Algorithmus (Introsort) wie folgt:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elemente ist, wird ein [Einfügungs](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 * Protokoll<sup>N</sup>überschreitet, wobei *N* der Bereich des Eingabe Arrays ist, wird ein [Heapsort](https://en.wikipedia.org/wiki/Heapsort) -Algorithmus verwendet.  
  
-   Andernfalls wird ein [Quicksort](https://en.wikipedia.org/wiki/Quicksort) -Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Für Arrays, die mit den Heapsort-und Quick Sort-Algorithmen sortiert werden, ist diese Methode im schlimmsten Fall ein O (`n` Log `n`)-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> `array`ist.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>und <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generische Methoden Überladungen, um Paare von Arrays zu sortieren, die Schlüssel und Werte darstellen.  
  
 Im Codebeispiel wird ein alternativer Vergleich für Zeichen folgen mit dem Namen `ReverseCompare`definiert, der die generische Schnittstelle `IComparer<string>` (`IComparer(Of String)` in Visual Basic C++, `IComparer<String^>` in Visual) implementiert. Der Vergleich Ruft die <xref:System.String.CompareTo%28System.String%29>-Methode auf und kehrt die Reihenfolge der Vergleichs Elemente um, sodass die Zeichen folgen nicht zu hoch, sondern zu niedrig sortiert werden.  
  
 Im Codebeispiel wird ein Array von Dinosaurier Namen (den Schlüsseln) und ein Array aus ganzen Zahlen erstellt und angezeigt, das die maximale Länge der einzelnen Dinosaurier in Meter (die Werte) darstellt. Die Arrays werden dann sortiert und mehrmals angezeigt:  
  
-   Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>-Überladung wird verwendet, um beide Arrays in der Reihenfolge der Dinosaurier Namen im ersten Array zu sortieren.  
  
-   Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Überladung und eine Instanz von `ReverseCompare` werden verwendet, um die Sortierreihenfolge der paarweise Arrays umzukehren.  
  
-   Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>-Überladung wird zum Sortieren der letzten drei Elemente beider Arrays verwendet.  
  
-   Mit der <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>-Überladung werden die letzten drei Elemente beider Arrays in umgekehrter Reihenfolge sortiert.  
  
> [!NOTE]
>  Die Aufrufe der generischen Methoden unterscheiden sich nicht von den Aufrufen ihrer nicht generischen Entsprechungen, da Visual Basic C#, und C++ den Typ des generischen Typparameters vom Typ der ersten beiden Argumente ableiten. Wenn Sie den [Ildasm. exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) verwenden, um die MSIL (Microsoft Intermediate Language) zu überprüfen, können Sie sehen, dass die generischen Methoden aufgerufen werden.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> ist nicht <see langword="null" />, und die Untergrenze von <paramref name="keys" /> entspricht nicht der Untergrenze von <paramref name="items" />.  
  
- oder - 
 <paramref name="items" /> ist nicht <see langword="null" />, und die Länge von <paramref name="keys" /> ist größer als die Länge von <paramref name="items" />.</exception>
        <exception cref="T:System.InvalidOperationException">In einem oder mehreren Elementen im <paramref name="keys" /><see cref="T:System.Array" /> ist die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht implementiert.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; unit" Usage="System.Array.Sort (keys, items, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Der Typ der Elemente des Schlüsselarrays.</typeparam>
        <typeparam name="TValue">Der Typ der Elemente des Elementarrays.</typeparam>
        <param name="keys">Das eindimensionale nullbasierte <see cref="T:System.Array" /> mit den zu sortierenden Schlüsseln.</param>
        <param name="items">Das eindimensionale nullbasierte <see cref="T:System.Array" />, das die den Schlüsseln in <paramref name="keys" /> entsprechenden Elemente enthält, oder <see langword="null" />, um nur <paramref name="keys" /> zu sortieren.</param>
        <param name="comparer">Die Implementierung der generischen <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle, die für den Vergleich von Elementen verwendet werden soll, oder <see langword="null" />, um die Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle der einzelnen Elemente zu verwenden.</param>
        <summary>Sortiert ein Paar von <see cref="T:System.Array" />-Objekten (das eine enthält die Schlüssel und das andere die entsprechenden Werte) nach den Schlüsseln im ersten <see cref="T:System.Array" /> und verwendet dabei die angegebene generische <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel im `keys`<xref:System.Array> verfügt über ein entsprechendes Element im `items`<xref:System.Array>. Wenn eine Taste während der Sortierung neu positioniert wird, wird das entsprechende Element in der `items`<xref:System.Array> auf ähnliche Weise neu positioniert. Daher wird der `items`<xref:System.Array> entsprechend der Anordnung der entsprechenden Schlüssel im `keys`<xref:System.Array>sortiert.  
  
 Wenn `comparer` `null`ist, muss jeder Schlüssel im `keys`<xref:System.Array> die generische Schnittstelle des <xref:System.IComparable%601> implementieren, damit Vergleiche mit jedem anderen Schlüssel möglich sind.  
  
 Sie können sortieren, wenn mehr Elemente als Schlüssel vorhanden sind, aber die Elemente, die keine entsprechenden Schlüssel aufweisen, werden nicht sortiert. Sie können nicht sortieren, wenn mehr Schlüssel als Elemente vorhanden sind. Dadurch wird eine <xref:System.ArgumentException>ausgelöst.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet den introspektiven Sort-Algorithmus (Introsort) wie folgt:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein [Einfügungs](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 * Protokoll<sup>N</sup>überschreitet, wobei *N* der Bereich des Eingabe Arrays ist, wird ein [Heapsort](https://en.wikipedia.org/wiki/Heapsort) -Algorithmus verwendet.  
  
-   Andernfalls wird ein [Quicksort](https://en.wikipedia.org/wiki/Quicksort) -Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Für Arrays, die mit den Heapsort-und Quick Sort-Algorithmen sortiert werden, ist diese Methode im schlimmsten Fall ein O (`n` Log `n`)-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> `array`ist.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, [\], TValue\<Xref: System. Array. sortieren: %60 %602 %28 %60 %600% 5B% 5D% 2C %60 %601% 5B% 5D% 2csystem. Collections. Generic. IComparer% 7B %60 %600% 7D %29 >,<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>und <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generische Methoden Überladungen, um Paare von Arrays zu sortieren, die Schlüssel und Werte darstellen.  
  
 Im Codebeispiel wird ein alternativer Vergleich für Zeichen folgen mit dem Namen `ReverseCompare`definiert, der die generische Schnittstelle `IComparer<string>` (`IComparer(Of String)` in Visual Basic C++, `IComparer<String^>` in Visual) implementiert. Der Vergleich Ruft die <xref:System.String.CompareTo%28System.String%29>-Methode auf und kehrt die Reihenfolge der Vergleichs Elemente um, sodass die Zeichen folgen nicht zu hoch, sondern zu niedrig sortiert werden.  
  
 Im Codebeispiel wird ein Array von Dinosaurier Namen (den Schlüsseln) und ein Array aus ganzen Zahlen erstellt und angezeigt, das die maximale Länge der einzelnen Dinosaurier in Meter (die Werte) darstellt. Die Arrays werden dann sortiert und mehrmals angezeigt:  
  
-   Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>-Überladung wird verwendet, um beide Arrays in der Reihenfolge der Dinosaurier Namen im ersten Array zu sortieren.  
  
-   Der [\], TValue\<Xref: System. Array. Sort %60 %602 %28 %60 %600% 5B% 5D% 2C %60 %601% 5B% 5D% 2csystem. Collections. Generic. IComparer% 7B %60 %600% 7D %29 > Überladung und eine Instanz von `ReverseCompare` werden verwendet, um die Sortierreihenfolge der gekoppelten Arrays  
  
-   Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>-Überladung wird zum Sortieren der letzten drei Elemente beider Arrays verwendet.  
  
-   Mit der <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>-Überladung werden die letzten drei Elemente beider Arrays in umgekehrter Reihenfolge sortiert.  
  
> [!NOTE]
>  Die Aufrufe der generischen Methoden unterscheiden sich nicht von den Aufrufen ihrer nicht generischen Entsprechungen, da Visual Basic C#, und C++ den Typ des generischen Typparameters vom Typ der ersten beiden Argumente ableiten. Wenn Sie den [Ildasm. exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) verwenden, um die MSIL (Microsoft Intermediate Language) zu überprüfen, können Sie sehen, dass die generischen Methoden aufgerufen werden.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> ist nicht <see langword="null" />, und die Untergrenze von <paramref name="keys" /> entspricht nicht der Untergrenze von <paramref name="items" />.  
  
- oder - 
 <paramref name="items" /> ist nicht <see langword="null" />, und die Länge von <paramref name="keys" /> ist größer als die Länge von <paramref name="items" />.  
  
- oder - 
Die Implementierung von <paramref name="comparer" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und in einem oder mehreren Elementen in <paramref name="keys" /><see cref="T:System.Array" /> ist die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht implementiert.</exception>
        <block subset="none" type="usage"><para>In der .NET Framework 4 und früheren Versionen wurde nur der QuickSort-Algorithmus verwendet. Die Quicksort identifiziert ungültige Vergleiche in einigen Situationen, in denen der Sortiervorgang eine <see cref="T:System.IndexOutOfRangeException" /> Ausnahme auslöst, und löst eine <see cref="T:System.ArgumentException" /> Ausnahme an den Aufrufer aus. Beginnend mit dem [!INCLUDE[net_v45](~/includes/net-v45-md.md)]ist es möglich, dass bei Sortiervorgängen, die zuvor <see cref="T:System.ArgumentException" /> ausgelöst haben, keine Ausnahme ausgelöst wird, da die einfügesortier-und Heapsort-Algorithmen keinen ungültigen Vergleich erkennen. Dies gilt größtenteils für Arrays mit weniger als oder gleich 16 Elementen.</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * int * int -&gt; unit" Usage="System.Array.Sort (keys, items, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Der Typ der Elemente des Schlüsselarrays.</typeparam>
        <typeparam name="TValue">Der Typ der Elemente des Elementarrays.</typeparam>
        <param name="keys">Das eindimensionale nullbasierte <see cref="T:System.Array" /> mit den zu sortierenden Schlüsseln.</param>
        <param name="items">Das eindimensionale nullbasierte <see cref="T:System.Array" />, das die den Schlüsseln in <paramref name="keys" /> entsprechenden Elemente enthält, oder <see langword="null" />, um nur <paramref name="keys" /> zu sortieren.</param>
        <param name="index">Der Startindex des zu sortierenden Bereichs.</param>
        <param name="length">Die Anzahl der Elemente im zu sortierenden Bereich.</param>
        <summary>Sortiert einen Bereich von Elementen in einem Paar von <see cref="T:System.Array" />-Objekten (das eine enthält die Schlüssel und das andere die entsprechenden Werte) nach den Schlüsseln im ersten <see cref="T:System.Array" /> und verwendet dabei die Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle jedes Schlüssels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel im `keys`<xref:System.Array> verfügt über ein entsprechendes Element im `items`<xref:System.Array>. Wenn eine Taste während der Sortierung neu positioniert wird, wird das entsprechende Element in der `items`<xref:System.Array> auf ähnliche Weise neu positioniert. Daher wird der `items`<xref:System.Array> entsprechend der Anordnung der entsprechenden Schlüssel im `keys`<xref:System.Array>sortiert.  
  
 Jeder Schlüssel innerhalb des angegebenen Bereichs von Elementen in der `keys`<xref:System.Array> muss die <xref:System.IComparable%601> generische Schnittstelle implementieren, damit Vergleiche mit jedem anderen Schlüssel möglich sind.  
  
 Sie können sortieren, wenn mehr Elemente als Schlüssel vorhanden sind, aber die Elemente, die keine entsprechenden Schlüssel aufweisen, werden nicht sortiert. Sie können nicht sortieren, wenn mehr Schlüssel als Elemente vorhanden sind. Dadurch wird eine <xref:System.ArgumentException>ausgelöst.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet den introspektiven Sort-Algorithmus (Introsort) wie folgt:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein [Einfügungs](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 * Protokoll<sup>N</sup>überschreitet, wobei *N* der Bereich des Eingabe Arrays ist, wird ein [Heapsort](https://en.wikipedia.org/wiki/Heapsort) -Algorithmus verwendet.  
  
-   Andernfalls wird ein [Quicksort](https://en.wikipedia.org/wiki/Quicksort) -Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Für Arrays, die mit den Heapsort-und Quick Sort-Algorithmen sortiert werden, ist diese Methode im schlimmsten Fall ein O (`n` Log `n`)-Vorgang, bei dem `n` `length`ist.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, [\], TValue\<Xref: System. Array. Sort %60 %602 %28 %60 %600% 5B% 5D% 2C %60 %601% 5B% 5D% 2csystem. Int32% 2csystem. Int32% 29 > und <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generische Methoden Überladungen, um Paare von Arrays zu sortieren, die Schlüssel und Werte darstellen.  
  
 Im Codebeispiel wird ein alternativer Vergleich für Zeichen folgen mit dem Namen `ReverseCompare`definiert, der die generische Schnittstelle `IComparer<string>` (`IComparer(Of String)` in Visual Basic C++, `IComparer<String^>` in Visual) implementiert. Der Vergleich Ruft die <xref:System.String.CompareTo%28System.String%29>-Methode auf und kehrt die Reihenfolge der Vergleichs Elemente um, sodass die Zeichen folgen nicht zu hoch, sondern zu niedrig sortiert werden.  
  
 Im Codebeispiel wird ein Array von Dinosaurier Namen (den Schlüsseln) und ein Array aus ganzen Zahlen erstellt und angezeigt, das die maximale Länge der einzelnen Dinosaurier in Meter (die Werte) darstellt. Die Arrays werden dann sortiert und mehrmals angezeigt:  
  
-   Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>-Überladung wird verwendet, um beide Arrays in der Reihenfolge der Dinosaurier Namen im ersten Array zu sortieren.  
  
-   Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Überladung und eine Instanz von `ReverseCompare` werden verwendet, um die Sortierreihenfolge der paarweise Arrays umzukehren.  
  
-   Die [\], TValue\<Xref: System. Array. Sort %60 %602 %28 %60 %600% 5B% 5D% 2C %60 %601% 5B% 5D% 2csystem. Int32% 2csystem. Int32% 29 > Überladung wird zum Sortieren der letzten drei Elemente beider Arrays verwendet.  
  
-   Mit der <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>-Überladung werden die letzten drei Elemente beider Arrays in umgekehrter Reihenfolge sortiert.  
  
> [!NOTE]
>  Die Aufrufe der generischen Methoden unterscheiden sich nicht von den Aufrufen ihrer nicht generischen Entsprechungen, da Visual Basic C#, und C++ den Typ des generischen Typparameters vom Typ der ersten beiden Argumente ableiten. Wenn Sie den [Ildasm. exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) verwenden, um die MSIL (Microsoft Intermediate Language) zu überprüfen, können Sie sehen, dass die generischen Methoden aufgerufen werden.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die Untergrenze von <paramref name="keys" />.  
  
- oder - 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> ist nicht <see langword="null" />, und die Untergrenze von <paramref name="keys" /> entspricht nicht der Untergrenze von <paramref name="items" />.  
  
- oder - 
 <paramref name="items" /> ist nicht <see langword="null" />, und die Länge von <paramref name="keys" /> ist größer als die Länge von <paramref name="items" />.  
  
- oder - 
 <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="keys" /><see cref="T:System.Array" /> an.  
  
- oder - 
 <paramref name="items" /> ist nicht <see langword="null" />, und <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="items" /><see cref="T:System.Array" /> an.</exception>
        <exception cref="T:System.InvalidOperationException">In einem oder mehreren Elementen im <paramref name="keys" /><see cref="T:System.Array" /> ist die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht implementiert.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer, comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * int * int * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; unit" Usage="System.Array.Sort (keys, items, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Der Typ der Elemente des Schlüsselarrays.</typeparam>
        <typeparam name="TValue">Der Typ der Elemente des Elementarrays.</typeparam>
        <param name="keys">Das eindimensionale nullbasierte <see cref="T:System.Array" /> mit den zu sortierenden Schlüsseln.</param>
        <param name="items">Das eindimensionale nullbasierte <see cref="T:System.Array" />, das die den Schlüsseln in <paramref name="keys" /> entsprechenden Elemente enthält, oder <see langword="null" />, um nur <paramref name="keys" /> zu sortieren.</param>
        <param name="index">Der Startindex des zu sortierenden Bereichs.</param>
        <param name="length">Die Anzahl der Elemente im zu sortierenden Bereich.</param>
        <param name="comparer">Die Implementierung der generischen <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle, die für den Vergleich von Elementen verwendet werden soll, oder <see langword="null" />, um die Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle der einzelnen Elemente zu verwenden.</param>
        <summary>Sortiert einen Bereich von Elementen in einem Paar von <see cref="T:System.Array" />-Objekten (das eine enthält die Schlüssel und das andere die entsprechenden Werte) nach den Schlüsseln im ersten <see cref="T:System.Array" /> und verwendet dabei die angegebene generische <see cref="T:System.Collections.Generic.IComparer`1" />-Schnittstelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel im `keys`<xref:System.Array> verfügt über ein entsprechendes Element im `items`<xref:System.Array>. Wenn eine Taste während der Sortierung neu positioniert wird, wird das entsprechende Element in der `items`<xref:System.Array> auf ähnliche Weise neu positioniert. Daher wird der `items`<xref:System.Array> entsprechend der Anordnung der entsprechenden Schlüssel im `keys`<xref:System.Array>sortiert.  
  
 Wenn `comparer` `null`ist, muss jeder Schlüssel innerhalb des angegebenen Bereichs von Elementen im `keys`<xref:System.Array> die <xref:System.IComparable%601> generische Schnittstelle implementieren, damit Vergleiche mit jedem anderen Schlüssel möglich sind.  
  
 Sie können sortieren, wenn mehr Elemente als Schlüssel vorhanden sind, aber die Elemente, die keine entsprechenden Schlüssel aufweisen, werden nicht sortiert. Sie können nicht sortieren, wenn mehr Schlüssel als Elemente vorhanden sind. Dadurch wird eine <xref:System.ArgumentException>ausgelöst.  
  
 Wenn die Sortierung nicht erfolgreich abgeschlossen wird, sind die Ergebnisse nicht definiert.  
  
 Diese Methode verwendet den introspektiven Sort-Algorithmus (Introsort) wie folgt:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein [Einfügungs](https://en.wikipedia.org/wiki/Insertion_sort) Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 * Protokoll<sup>N</sup>überschreitet, wobei *N* der Bereich des Eingabe Arrays ist, wird ein [Heapsort](https://en.wikipedia.org/wiki/Heapsort) -Algorithmus verwendet.  
  
-   Andernfalls wird ein [Quicksort](https://en.wikipedia.org/wiki/Quicksort) -Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Für Arrays, die mit den Heapsort-und Quick Sort-Algorithmen sortiert werden, ist diese Methode im schlimmsten Fall ein O (`n` Log `n`)-Vorgang, bei dem `n` `length`ist.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>und [\], TValue\<Xref: System. Array. Sort %60 %602 %28 %60 %600% 5B% 5D% 2C %60 %601% 5B% 5D% 2csystem. Int32% 2csystem. Int32% 2csystem. Collections. Generic. IComparer% 7B %60 %600% 7D %29 > generische Methoden Überladungen, um Paare von Arrays zu sortieren, die Schlüssel und Werte darstellen.  
  
 Im Codebeispiel wird ein alternativer Vergleich für Zeichen folgen mit dem Namen `ReverseCompare`definiert, der die generische Schnittstelle `IComparer<string>`(`IComparer(Of String)` in Visual Basic C++, `IComparer<String^>` in Visual) implementiert. Der Vergleich Ruft die <xref:System.String.CompareTo%28System.String%29>-Methode auf und kehrt die Reihenfolge der Vergleichs Elemente um, sodass die Zeichen folgen nicht zu hoch, sondern zu niedrig sortiert werden.  
  
 Im Codebeispiel wird ein Array von Dinosaurier Namen (den Schlüsseln) und ein Array aus ganzen Zahlen erstellt und angezeigt, das die maximale Länge der einzelnen Dinosaurier in Meter (die Werte) darstellt. Die Arrays werden dann sortiert und mehrmals angezeigt:  
  
-   Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>-Überladung wird verwendet, um beide Arrays in der Reihenfolge der Dinosaurier Namen im ersten Array zu sortieren.  
  
-   Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> Überladung und eine Instanz von `ReverseCompare` werden verwendet, um die Sortierreihenfolge der paarweise Arrays umzukehren.  
  
-   Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>-Überladung wird zum Sortieren der letzten drei Elemente beider Arrays verwendet.  
  
-   Der [\], TValue\<Xref: System. Array. Sort %60 %602 %28 %60 %600% 5B% 5D% 2C %60 %601% 5B% 5D% 2csystem. Int32% 2csystem. Int32% 2csystem. Collections. Generic. IComparer% 7B %60 %600% 7D %29 > Überladung wird verwendet, um die letzten drei Elemente beider Arrays in umgekehrter Reihenfolge zu sortieren.  
  
> [!NOTE]
>  Die Aufrufe der generischen Methoden unterscheiden sich nicht von den Aufrufen ihrer nicht generischen Entsprechungen, da Visual Basic C#, und C++ den Typ des generischen Typparameters vom Typ der ersten beiden Argumente ableiten. Wenn Sie den [Ildasm. exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) verwenden, um die MSIL (Microsoft Intermediate Language) zu überprüfen, können Sie sehen, dass die generischen Methoden aufgerufen werden.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als die Untergrenze von <paramref name="keys" />.  
  
- oder - 
 <paramref name="length" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> ist nicht <see langword="null" />, und die Untergrenze von <paramref name="keys" /> entspricht nicht der Untergrenze von <paramref name="items" />.  
  
- oder - 
 <paramref name="items" /> ist nicht <see langword="null" />, und die Länge von <paramref name="keys" /> ist größer als die Länge von <paramref name="items" />.  
  
- oder - 
 <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="keys" /><see cref="T:System.Array" /> an.  
  
- oder - 
 <paramref name="items" /> ist nicht <see langword="null" />, und <paramref name="index" /> und <paramref name="length" /> geben keinen gültigen Bereich im <paramref name="items" /><see cref="T:System.Array" /> an.  
  
- oder - 
Die Implementierung von <paramref name="comparer" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und in einem oder mehreren Elementen in <paramref name="keys" /><see cref="T:System.Array" /> ist die generische <see cref="T:System.IComparable`1" />-Schnittstelle nicht implementiert.</exception>
        <block subset="none" type="usage"><para>In der .NET Framework 4 und früheren Versionen wurde nur der QuickSort-Algorithmus verwendet. Die Quicksort identifiziert ungültige Vergleiche in einigen Situationen, in denen der Sortiervorgang eine <see cref="T:System.IndexOutOfRangeException" /> Ausnahme auslöst, und löst eine <see cref="T:System.ArgumentException" /> Ausnahme an den Aufrufer aus. Beginnend mit dem [!INCLUDE[net_v45](~/includes/net-v45-md.md)]ist es möglich, dass bei Sortiervorgängen, die zuvor <see cref="T:System.ArgumentException" /> ausgelöst haben, keine Ausnahme ausgelöst wird, da die einfügesortier-und Heapsort-Algorithmen keinen ungültigen Vergleich erkennen. Dies gilt größtenteils für Arrays mit weniger als oder gleich 16 Elementen.</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Arrays</related>
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Array.SyncRoot" />
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SyncRoot As Object" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ SyncRoot { System::Object ^ get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab, mit dem der Zugriff auf <see cref="T:System.Array" /> synchronisiert werden kann.</summary>
        <value>Ein Objekt, mit dem der Zugriff auf die <see cref="T:System.Array" /> synchronisiert werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft implementiert die <xref:System.Collections.ICollection?displayProperty=nameWithType>-Schnittstelle.  
  
 .NET Framework-Klassen basierend auf <xref:System.Array> Geben Sie ihre eigene synchronisierte Version der Auflistung mithilfe der <xref:System.Array.SyncRoot%2A> Eigenschaft.  
  
 Klassen, die Arrays verwenden, können mit der <xref:System.Array.SyncRoot%2A>-Eigenschaft auch eine eigene Synchronisierung implementieren. Der Synchronisierungs Code muss Vorgänge für die `SyncRoot` der Auflistung ausführen, nicht direkt für die Auflistung. Dies gewährleistet die einwandfreie Funktion von Auflistungen, die von anderen Objekten abgeleitet sind. Insbesondere wird die ordnungsgemäße Synchronisierung mit anderen Threads verwaltet, die die Auflistung möglicherweise gleichzeitig ändern. Beachten Sie, dass einige Implementierungen von <xref:System.Array.SyncRoot%2A> möglicherweise die <xref:System.Array> selbst zurückgeben.  
  
 Das Auflisten durch eine Auflistung ist intrinsisch keine Thread sichere Prozedur. Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst. Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie ein Array während der gesamten Enumeration mithilfe der <xref:System.Array.SyncRoot%2A>-Eigenschaft gesperrt wird.  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.ICollection.Count" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#Count" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Count As Integer Implements ICollection.Count" />
      <MemberSignature Language="C++ CLI" Value="property int System::Collections::ICollection::Count { int get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Elemente ab, die in <see cref="T:System.Array" /> enthalten sind.</summary>
        <value>Die Anzahl der Elemente in der Auflistung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.ICollection>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Zugriff auf <see cref="T:System.Array" /> synchronisiert (threadsicher) ist.</summary>
        <value>"true", wenn der Zugriff auf die <see cref="T:System.Array" />-Klasse synchronisiert ist (threadsicher), andernfalls "false".</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab, mit dem der Zugriff auf <see cref="T:System.Array" /> synchronisiert werden kann.</summary>
        <value>Ein Objekt, mit dem der Zugriff auf die <see cref="T:System.Array" /> synchronisiert werden kann.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (value As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ value) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Das dem <see cref="T:System.Collections.IList" /> hinzuzufügende Objekt.</param>
        <summary>Beim Aufrufen dieser Methode wird immer eine <see cref="T:System.NotSupportedException" />-Ausnahme ausgelöst.</summary>
        <returns>Das Hinzufügen eines Werts zu einem Array wird nicht unterstützt. Es wird kein Wert zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalerweise fügt eine <xref:System.Collections.IList.Add%2A?displayProperty=nameWithType>-Implementierung einer Auflistung einen Member hinzu. Da Arrays jedoch eine Fixed-Größe aufweisen (die <xref:System.Array.IsFixedSize%2A>-Eigenschaft gibt immer `true`), löst diese Methode immer eine <xref:System.NotSupportedException>-Ausnahme aus.  
  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IList>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> hat eine feste Größe.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Clear">
      <MemberSignature Language="C#" Value="void IList.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements IList.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Clear() = System::Collections::IList::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle Elemente aus <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IList>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> ist schreibgeschützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (value As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ value) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Das in der aktuellen Liste zu suchende Objekt. Das gesuchte Element kann für Referenztypen <see langword="null" />.</param>
        <summary>Bestimmt, ob sich ein Element in <see cref="T:System.Collections.IList" /> befindet.</summary>
        <returns><see langword="true" />, wenn das <paramref name="value" /> in der <see cref="T:System.Collections.IList" /> gefunden wird, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IList>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (value As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ value) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Das in der aktuellen Liste zu suchende Objekt.</param>
        <summary>Bestimmt den Index eines bestimmten Elements in der <see cref="T:System.Collections.IList" />.</summary>
        <returns>Der Index von Wert, wenn er in der Liste gefunden wird, andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IList>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, value As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ value) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Der Index, an dem <paramref name="value" /> eingefügt werden soll.</param>
        <param name="value">Das einzufügende Objekt.</param>
        <summary>Fügt am angegebenen Index ein Element in die <see cref="T:System.Collections.IList" /> ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IList>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kein gültiger Index in <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> ist schreibgeschützt.  
  
- oder - 
<see cref="T:System.Collections.IList" /> hat eine feste Größe.</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="value" /> ist ein NULL-Verweis in der <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die <see cref="T:System.Array" /> eine feste Größe hat.</summary>
        <value>true, wenn die <see cref="T:System.Array" /> eine Größe mit fester Größe aufweist. andernfalls false.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die <see cref="T:System.Array" /> schreibgeschützt ist.</summary>
        <value>true, wenn das <see cref="T:System.Array" /> schreibgeschützt ist. andernfalls false.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IList::Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der Index des abzurufenden oder festzulegenden Elements.</param>
        <summary>Ruft das Element am angegebenen Index ab oder legt dieses fest.</summary>
        <value>Das Element am angegebenen Index.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IList>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="index" /> ist größer oder gleich <see cref="P:System.Collections.ICollection.Count" />.</exception>
        <exception cref="T:System.ArgumentException">Das aktuelle <see cref="T:System.Array" /> verfügt nicht über genau eine Dimension.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (value As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ value) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Das aus der <see cref="T:System.Collections.IList" /> zu entfernende Objekt.</param>
        <summary>Entfernt das erste Vorkommen eines angegebenen Objekts aus der <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IList>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> ist schreibgeschützt.  
  
- oder - 
<see cref="T:System.Collections.IList" /> hat eine feste Größe.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.RemoveAt">
      <MemberSignature Language="C#" Value="void IList.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveAt (index As Integer) Implements IList.RemoveAt" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.RemoveAt(int index) = System::Collections::IList::RemoveAt;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der Index des zu entfernenden Elements.</param>
        <summary>Entfernt das <see cref="T:System.Collections.IList" />-Element am angegebenen Index.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IList>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">index ist kein gültiger Index in <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> ist schreibgeschützt.  
  
- oder - 
<see cref="T:System.Collections.IList" /> hat eine feste Größe.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IStructuralComparable.CompareTo (object other, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralComparable.CompareTo(object other, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (other As Object, comparer As IComparer) As Integer Implements IStructuralComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralComparable.CompareTo(System::Object ^ other, System::Collections::IComparer ^ comparer) = System::Collections::IStructuralComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="other">Das Objekt, das mit der aktuellen Instanz verglichen werden soll.</param>
        <param name="comparer">Ein Objekt, das das aktuelle Objekt und <paramref name="other" /> vergleicht.</param>
        <summary>Bestimmt, ob das aktuelle Auflistungsobjekt in der Sortierreihenfolge vor oder nach einem anderen Objekt oder an derselben Position auftritt.</summary>
        <returns>Eine ganze Zahl, die die Beziehung des aktuellen Auflistungsobjekts zu "other" angibt, wie in der folgenden Tabelle dargestellt.  
  
 <list type="table"><listheader><term> Rückgabewert 
 </term><description> Beschreibung 
 </description></listheader><item><term> -1 
 </term><description> Die aktuelle Instanz tritt vor <paramref name="other" /> auf.  
  
 </description></item><item><term> 0 
 </term><description> Die aktuelle Instanz und <paramref name="other" /> sind gleich.  
  
 </description></item><item><term> 1 
 </term><description> Die aktuelle Instanz folgt auf <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IStructuralComparable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.Equals">
      <MemberSignature Language="C#" Value="bool IStructuralEquatable.Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IStructuralEquatable.Equals(object other, class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As Object, comparer As IEqualityComparer) As Boolean Implements IStructuralEquatable.Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IStructuralEquatable.Equals(System::Object ^ other, System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::Equals;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="other">Das Objekt, das mit der aktuellen Instanz verglichen werden soll.</param>
        <param name="comparer">Ein Objekt, das bestimmt, ob die aktuelle Instanz und <paramref name="other" /> gleich sind.</param>
        <summary>Bestimmt, ob ein Objekt gleich der aktuellen Instanz ist.</summary>
        <returns><see langword="true" />, wenn die beiden Objekte gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IStructuralEquatable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.GetHashCode">
      <MemberSignature Language="C#" Value="int IStructuralEquatable.GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralEquatable.GetHashCode(class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function GetHashCode (comparer As IEqualityComparer) As Integer Implements IStructuralEquatable.GetHashCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralEquatable.GetHashCode(System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::GetHashCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="comparer">Ein Objekt, das den Hashcode des aktuellen Objekts berechnet.</param>
        <summary>Gibt einen Hashcode für die aktuelle Instanz zurück.</summary>
        <returns>Der Hashcode für die aktuelle Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Array>-Instanz in eine <xref:System.Collections.IStructuralEquatable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrueForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TrueForAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TrueForAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrueForAll(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TrueForAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member TrueForAll : 'T[] * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Array.TrueForAll (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Elemente des Arrays.</typeparam>
        <param name="array">Das eindimensionale nullbasierte <see cref="T:System.Array" />, das auf die Bedingungen geprüft werden soll.</param>
        <param name="match">Das Prädikat, das die Bedingungen definiert, auf die die Elemente geprüft werden sollen.</param>
        <summary>Bestimmt, ob jedes Element im Array die vom angegebenen Prädikat definierten Bedingungen erfüllt.</summary>
        <returns><see langword="true" />, wenn jedes Element im <paramref name="array" /> die vom angegebenen Prädikat definierten Bedingungen erfüllt, andernfalls <see langword="false" />. Wenn keine Elemente im Array vorhanden sind, lautet der Rückgabewert <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die`true` zurückgibt, wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente `array` werden einzeln an den <xref:System.Predicate%601>und die Verarbeitung beendet, wenn der Delegat `false` für ein beliebiges Element zurückgibt.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` der <xref:System.Array.Length%2A> von `array`ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, ob das letzte Zeichen jedes Elements in einem Zeichen folgen Array eine Zahl ist. Es werden zwei Zeichen folgen Arrays erstellt. Das erste Array enthält beide Zeichen folgen, die mit alphabetischen Zeichen enden, und Zeichen folgen, die mit numerischen Zeichen enden. Das zweite Array besteht nur aus Zeichen folgen, die mit numerischen Zeichen enden. Im Beispiel wird auch eine `EndWithANumber` Methode definiert, deren Signatur mit der <xref:System.Predicate%601> Delegaten übereinstimmt. Im Beispiel wird jedes Array zusammen mit einem Delegaten, der die `EndsWithANumber`-Methode darstellt, an die <xref:System.Array.TrueForAll%2A>-Methode weitergeleitet.  
  
 [!code-csharp[System.Array.TrueForAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall2.cs#2)]
 [!code-vb[System.Array.TrueForAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall2.vb#2)]  
  
 Das folgende Beispiel ähnelt dem ersten, mit dem Unterschied, dass es das Zeichen folgen Array an die <xref:System.Array.TrueForAll%2A>-Methode mit einem Lambda-Ausdruck übergibt, der bestimmt, ob ein bestimmtes Array Element mit der Zeichen folgen Darstellung einer Zahl endet.  
  
 [!code-csharp[System.Array.TrueForAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall1.cs#1)]
 [!code-vb[System.Array.TrueForAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall1.vb#1)]  
  
 In beiden Fällen gibt die <xref:System.Array.TrueForAll%2A>-Methode `false` zurück, sobald das erste Array Element gefunden wird, das nicht mit einer Zahl endet. Andernfalls wird `true` zurückgegeben, nachdem alle Elemente im Array durchlaufen wurden.  
  
> [!NOTE]
>  Da beide Beispiele in C# und Visual Basic, ist es nicht notwendig, den `Predicate<string>` Delegaten (`Predicate(Of String)` in Visual Basic) explizit zu erstellen. Diese Sprachen ableiten den korrekten Delegaten aus dem Kontext und erstellen ihn automatisch.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>
