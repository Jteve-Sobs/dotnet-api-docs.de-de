<Type Name="Lazy&lt;T&gt;" FullName="System.Lazy&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="15dde32cbd2443df3366323615d4069debe07cff" /><Meta Name="ms.sourcegitcommit" Value="8b09499854b5b7b909802126edc1f1fca0054c10" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="02/01/2020" /><Meta Name="ms.locfileid" Value="76956814" /></Metadata><TypeSignature Language="C#" Value="public class Lazy&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Lazy`1&lt;T&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Lazy`1" />
  <TypeSignature Language="VB.NET" Value="Public Class Lazy(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class Lazy" />
  <TypeSignature Language="F#" Value="type Lazy&lt;'T&gt; = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.DebuggerDisplay("ThreadSafetyMode={Mode}, IsValueCreated={IsValueCreated}, IsValueFaulted={IsValueFaulted}, Value={ValueForDebugDisplay}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.System_LazyDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Der Typ des Objekts, das verzögert initialisiert wird.</typeparam>
    <summary>Stellt Unterstützung für die verzögerte Initialisierung bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die verzögerte Initialisierung, um die Erstellung eines großen oder ressourcenintensiven Objekts oder die Ausführung einer ressourcenintensiven Aufgabe zu verzögern, insbesondere dann, wenn eine solche Erstellung oder Ausführung während der Lebensdauer des Programms möglicherweise nicht stattfindet.  
  
 Zum Vorbereiten der verzögerten Initialisierung erstellen Sie eine Instanz von <xref:System.Lazy%601>. Das Typargument des <xref:System.Lazy%601> Objekts, das Sie erstellen, gibt den Typ des Objekts an, das Sie verzögert initialisieren möchten. Der Konstruktor, den Sie zum Erstellen des <xref:System.Lazy%601> Objekts verwenden, bestimmt die Merkmale der Initialisierung. Die verzögerte Initialisierung tritt beim ersten Zugriff auf die <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType>-Eigenschaft auf.  
  
 In den meisten Fällen hängt die Auswahl eines Konstruktors von ihren Antworten auf zwei Fragen ab:  
  
-   Ist der Zugriff auf das verzögert initialisierte Objekt von mehreren Threads aus möglich? Wenn dies der Fall ist, kann das <xref:System.Lazy%601> Objekt es in einem beliebigen Thread erstellen. Sie können einen der einfachen Konstruktoren verwenden, dessen Standardverhalten darin besteht, ein Thread sicheres <xref:System.Lazy%601> Objekt zu erstellen, sodass nur eine Instanz des verzögert instanziierten Objekts erstellt wird, unabhängig davon, wie viele Threads darauf zugreifen. Wenn Sie ein <xref:System.Lazy%601> Objekt erstellen möchten, das nicht Thread sicher ist, müssen Sie einen Konstruktor verwenden, mit dem Sie keine Thread Sicherheit angeben können.  
  
    > [!CAUTION]
    >  Wenn das <xref:System.Lazy%601> Objekt Thread sicher wird, wird das verzögert initialisierte Objekt nicht geschützt. Wenn mehrere Threads auf das verzögert initialisierte Objekt zugreifen können, müssen Sie die Eigenschaften und Methoden für den Multithreadzugriff sicher machen.  
  
-   Erfordert die verzögerte Initialisierung viel Code, oder verfügt das verzögert initialisierte Objekt über einen Parameter losen Konstruktor, der alles benötigt, was Sie benötigen, und löst keine Ausnahmen aus? Wenn Sie Initialisierungs Code schreiben müssen, oder wenn Ausnahmen behandelt werden müssen, verwenden Sie einen der-Konstruktoren, der eine Factorymethode annimmt. Schreiben Sie den Initialisierungs Code in der Factorymethode.  
  
 In der folgenden Tabelle wird basierend auf den folgenden beiden Faktoren der zu wählbare Konstruktor angezeigt:  
  
|Auf das Objekt wird über zugegriffen.|Wenn kein Initialisierungs Code erforderlich ist (Parameter loser Konstruktor), verwenden Sie|Wenn Initialisierungs Code erforderlich ist, verwenden Sie|  
|--------------------------------|------------------------------------------------------------------------|---------------------------------------------|  
|Mehrere Threads|<xref:System.Lazy%601.%23ctor>|<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>|  
|Ein Thread|<xref:System.Lazy%601.%23ctor%28System.Boolean%29>, wenn `isThreadSafe` auf `false`festgelegt ist.|<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29>, wenn `isThreadSafe` auf `false`festgelegt ist.|  
  
 Sie können einen Lambda Ausdruck verwenden, um die Factorymethode anzugeben. Dadurch bleibt der gesamte Initialisierungs Code an einem Ort. Der Lambda-Ausdruck erfasst den Kontext, einschließlich aller Argumente, die Sie an den Konstruktor des verzögerten initialisierten Objekts übergeben.  
  
 Zwischen **Speichern von Ausnahmen** Wenn Sie Factorymethoden verwenden, werden Ausnahmen zwischengespeichert. Das heißt, wenn die Factorymethode eine Ausnahme auslöst, wenn ein Thread das erste Mal versucht, auf die <xref:System.Lazy%601.Value%2A>-Eigenschaft des <xref:System.Lazy%601> Objekts zuzugreifen, wird bei jedem nachfolgenden Versuch dieselbe Ausnahme ausgelöst. Dadurch wird sichergestellt, dass alle Aufrufe der <xref:System.Lazy%601.Value%2A>-Eigenschaft dasselbe Ergebnis erzeugen und feine Fehler vermeiden, die auftreten können, wenn verschiedene Threads andere Ergebnisse erhalten. Der <xref:System.Lazy%601> steht für eine tatsächliche `T`, die andernfalls zu einem früheren Zeitpunkt (normalerweise während des Starts) initialisiert worden wären. Ein Fehler an diesem früheren Punkt ist normalerweise schwerwiegend. Wenn eine Möglichkeit für einen BEHEB baren Fehler vorliegt, empfiehlt es sich, die Wiederholungs Logik in der Initialisierungs Routine (in diesem Fall die Factorymethode) zu erstellen, genauso wie bei Verwendung der verzögerten Initialisierung.  
  
 **Alternative zum Sperren** In bestimmten Situationen können Sie den mehr Aufwand des standardmäßigen Sperr Verhaltens des <xref:System.Lazy%601> Objekts vermeiden. In seltenen Fällen kann es zu Deadlocks kommen. In solchen Fällen können Sie den <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29>-oder <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>-Konstruktor verwenden und <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>angeben. Dies ermöglicht es dem <xref:System.Lazy%601> Objekt, eine Kopie des verzögert initialisierten Objekts für jeden von mehreren Threads zu erstellen, wenn die Threads die <xref:System.Lazy%601.Value%2A>-Eigenschaft gleichzeitig aufzurufen. Das <xref:System.Lazy%601>-Objekt stellt sicher, dass alle Threads dieselbe Instanz des verzögerten initialisierten Objekts verwenden, und verwirft die nicht verwendeten Instanzen. Folglich ist der Aufwand für die Reduzierung des Sperr Aufwands, dass Ihr Programm manchmal zusätzliche Kopien eines teuren Objekts erstellen und verwerfen kann. In den meisten Fällen ist dies unwahrscheinlich. Die Beispiele für die <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29>-und <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>-Konstruktoren veranschaulichen dieses Verhalten.  
  
> [!IMPORTANT]
>  Wenn Sie <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>angeben, werden Ausnahmen nie zwischengespeichert, auch wenn Sie eine Factorymethode angeben.  
  
 **Äquivalente Konstruktoren** Zusätzlich zur Aktivierung der Verwendung von <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>können die Konstruktoren <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> und <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> die Funktionalität der anderen Konstruktoren duplizieren. In der folgenden Tabelle werden die Parameterwerte gezeigt, die ein entsprechendes Verhalten verursachen.  
  
|So erstellen Sie ein <xref:System.Lazy%601> Objekt, das|Legen Sie für Konstruktoren, die einen `LazyThreadSafetyMode` `mode`-Parameter aufweisen, `mode` auf fest.|Legen Sie für Konstruktoren mit einem booleschen `isThreadSafe` Parameter `isThreadSafe` auf fest.|Für Konstruktoren ohne Thread Sicherheitsparameter|  
|-------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------|-------------------------------------------------------|  
|Vollständig Thread sicher; verwendet sperren, um sicherzustellen, dass der Wert nur von einem Thread initialisiert wird.|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|Alle derartigen Konstruktoren sind vollständig Thread sicher.|  
|Nicht Thread sicher.|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|Nicht zutreffend|  
|Vollständig Thread sicher; Threads können den Wert initialisieren.|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|Nicht zutreffend|Nicht zutreffend|  
  
 **Weitere Funktionen** Weitere Informationen zur Verwendung von <xref:System.Lazy%601> mit Thread statischen Feldern oder als Sicherungs Speicher für Eigenschaften finden Sie unter verzögerte [Initialisierung](~/docs/framework/performance/lazy-initialization.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Lazy%601>-Klasse verwendet wird, um eine verzögerte Initialisierung mit Zugriff von mehreren Threads bereitzustellen.  
  
> [!NOTE]
>  Im Beispiel wird der <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>-Konstruktor verwendet. Außerdem wird die Verwendung des <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29>-Konstruktors (`true` für `isThreadSafe`) und des <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>-Konstruktors (durch Angabe <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> für `mode`) veranschaulicht. Um zu einem anderen Konstruktor zu wechseln, ändern Sie einfach, welche Konstruktoren auskommentiert werden.  
>   
>  Ein Beispiel, das das Zwischenspeichern von Ausnahmen mit denselben Konstruktoren veranschaulicht, finden Sie im <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>-Konstruktor.  
  
 Im Beispiel wird eine `LargeObject`-Klasse definiert, die durch einen von mehreren Threads verzögert initialisiert wird. Die vier wichtigsten Abschnitte des Codes veranschaulichen die Erstellung des Initialisierers, die Factorymethode, die tatsächliche Initialisierung und den Konstruktor der `LargeObject`-Klasse, die eine Meldung anzeigt, wenn das Objekt erstellt wird. Zu Anfang der `Main`-Methode wird in diesem Beispiel ein threadsicherer verzögerter Initialisierer für `LargeObject` erstellt:  
  
 [!code-csharp[System.Lazy\`1#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#newlazy)]  
  
 Die Factorymethode zeigt die Erstellung des Objekts mit einem Platzhalter für die weitere Initialisierung:  
  
 [!code-csharp[System.Lazy\`1#FactoryFunc](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#factoryfunc)]
 [!code-vb[System.Lazy\`1#FactoryFunc](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#factoryfunc)]  
  
 Beachten Sie, dass die ersten beiden Code Abschnitte mit einer Lambda-Funktion kombiniert werden können, wie hier gezeigt:  
  
 [!code-csharp[System.Lazy\`1#InitWithLambda](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/lambda.cs#initwithlambda)]
 [!code-vb[System.Lazy\`1#InitWithLambda](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/lambda.vb#initwithlambda)]  
  
 Im Beispiel wird angehalten, um anzugeben, dass ein unbestimmter Zeitraum vergehen kann, bevor eine verzögerte Initialisierung stattfindet. Wenn Sie die **Eingabe** Taste drücken, werden im Beispiel drei Threads erstellt und gestartet. Die `ThreadProc`-Methode, die von allen drei Threads verwendet wird, ruft die <xref:System.Lazy%601.Value%2A>-Eigenschaft auf. Wenn dies das erste Mal geschieht, wird die `LargeObject` Instanz erstellt:  
  
 [!code-csharp[System.Lazy\`1#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#valueprop)]  
  
 Der Konstruktor der `LargeObject`-Klasse, die den letzten Schlüssel Abschnitt des Codes enthält, zeigt eine Meldung an und zeichnet die Identität des Initialisierungs Threads auf. Die Ausgabe des Programms wird am Ende der vollständigen Code Auflistung angezeigt.  
  
 [!code-csharp[System.Lazy\`1#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#largector)]  
  
> [!NOTE]
>  Der Einfachheit halber wird in diesem Beispiel eine globale Instanz von <xref:System.Lazy%601> verwendet, und alle Methoden sind `static` (`Shared` in Visual Basic). Dies sind keine Anforderungen für die Verwendung der verzögerten Initialisierung.  
  
 [!code-csharp[System.Lazy\`1#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#all)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Standardmäßig sind alle öffentlichen und geschützten Member der <see cref="T:System.Lazy`1" />-Klasse Thread sicher und können gleichzeitig von mehreren Threads verwendet werden. Diese Sicherheitsgarantien können optional und pro Instanz entfernt werden, wobei Parameter für die Konstruktoren des Typs verwendet werden.</threadsafe>
    <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
    <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Verzögerte Initialisierung</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der Klasse <see cref="T:System.Lazy`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der Klasse <see cref="T:System.Lazy`1" />. Wenn eine verzögerte Initialisierung auftritt, wird der parameterlose Konstruktor des Zieltyps verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Instanz, die mit diesem Konstruktor erstellt wird, kann gleichzeitig von mehreren Threads verwendet werden.  
  
 Der Thread Sicherheitsmodus einer <xref:System.Lazy%601>-Instanz, die mit diesem Konstruktor initialisiert wird, ist <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>. Der Thread Sicherheitsmodus beschreibt das Verhalten, wenn mehrere Threads versuchen, die <xref:System.Lazy%601> Instanz zu initialisieren.  
  
 Eine <xref:System.Lazy%601>-Instanz, die mit diesem Konstruktor erstellt wird, speichert keine Ausnahmen zwischen. Weitere Informationen finden Sie unter der <xref:System.Lazy%601>-Klasse oder unter der <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>-Enumeration.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung dieses Konstruktors veranschaulicht. Außerdem wird die Verwendung des <xref:System.Lazy%601.%23ctor%28System.Boolean%29>-Konstruktors (`true` für `isThreadSafe`) und des <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29>-Konstruktors (durch Angabe <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> für `mode`) veranschaulicht. Um zu einem anderen Konstruktor zu wechseln, ändern Sie einfach, welche Konstruktoren auskommentiert werden.  
  
 Im Beispiel wird eine `LargeObject`-Klasse definiert, die durch einen von mehreren Threads verzögert initialisiert wird. Die zwei wichtigsten Codezeilen in diesem Beispiel sind die Erstellung des Initialisierers und die tatsächliche Initialisierung. Zu Anfang der `Main`-Methode wird in diesem Beispiel ein threadsicherer verzögerter Initialisierer für `LargeObject` erstellt:  
  
 [!code-csharp[System.Lazy\`1.ctor#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctor#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#newlazy)]  
  
 Im Beispiel werden drei Threads erstellt und gestartet, die für ein <xref:System.Threading.ManualResetEvent> Objekt blockiert werden, damit das Beispiel alle Threads gleichzeitig freigeben kann. Die `ThreadProc`-Methode, die von allen drei Threads verwendet wird, ruft die <xref:System.Lazy%601.Value%2A>-Eigenschaft auf, um die `LargeObject` Instanz zu erhalten:  
  
 [!code-csharp[System.Lazy\`1.ctor#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctor#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#valueprop)]  
  
 Die <xref:System.Lazy%601>-Klasse stellt Sperren bereit, sodass nur ein Thread die `LargeObject` Instanz erstellen darf. Das Beispiel zeigt, dass die anderen Threads dieselbe Instanz erhalten.  
  
> [!NOTE]
>  Der Einfachheit halber wird in diesem Beispiel eine globale Instanz von <xref:System.Lazy%601> verwendet, und alle Methoden sind `static` (`Shared` in Visual Basic). Dies sind keine Anforderungen für die Verwendung der verzögerten Initialisierung.  
  
 [!code-csharp[System.Lazy\`1.ctor#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctor#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Verzögerte Initialisierung</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (bool isThreadSafe);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool isThreadSafe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (isThreadSafe As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(bool isThreadSafe);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : bool -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; isThreadSafe" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="isThreadSafe" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isThreadSafe"><see langword="true" />, damit diese Instanz gleichzeitig von mehreren Threads verwendet werden kann; <see langword="false" />, damit die Instanz jeweils nur von einem Thread verwendet werden kann.</param>
        <summary>Initialisiert eine neue Instanz der Klasse <see cref="T:System.Lazy`1" />. Wenn eine verzögerte Initialisierung auftritt, werden der parameterlose Konstruktor des Zieltyps und der angegebene Initialisierungsmodus verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Thread Sicherheitsmodus einer <xref:System.Lazy%601>-Instanz, die mit diesem Konstruktor initialisiert wird, ist <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>, wenn `isThreadSafe` `true`ist. Andernfalls ist der Modus <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>. Der Thread Sicherheitsmodus beschreibt das Verhalten, wenn mehrere Threads versuchen, die <xref:System.Lazy%601> Instanz zu initialisieren. Um den <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> Modus anzugeben, verwenden Sie den <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>-oder <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29>-Konstruktor.  
  
 Eine <xref:System.Lazy%601>-Instanz, die mit diesem Konstruktor erstellt wird, speichert keine Ausnahmen zwischen. Weitere Informationen finden Sie unter der <xref:System.Lazy%601>-Klasse oder unter der <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>-Enumeration.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie dieser Konstruktor verwendet wird, um einen verzögerten Initialisierer zu erstellen, der nicht Thread sicher ist, in Szenarien, in denen der gesamte Zugriff auf das verzögert initialisierte Objekt im gleichen Thread auftritt. Außerdem wird die Verwendung des <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29>-Konstruktors (angeben von <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> für `mode`veranschaulicht. Um zu einem anderen Konstruktor zu wechseln, ändern Sie einfach den auskommentierten Konstruktor.  
  
> [!NOTE]
>  Code, der die Verwendung dieses Konstruktors in Multithread-Szenarien veranschaulicht (angeben von `true` für `isThreadSafe`), finden Sie im Beispiel für den <xref:System.Lazy%601.%23ctor>-Konstruktor.  
  
 Im Beispiel wird eine `LargeObject` Klasse definiert, die verzögert initialisiert wird. In der `Main`-Methode wird in diesem Beispiel eine <xref:System.Lazy%601> Instanz erstellt und dann angehalten. Wenn Sie die **Eingabe** Taste drücken, greift das Beispiel auf die <xref:System.Lazy%601.Value%2A>-Eigenschaft der <xref:System.Lazy%601>-Instanz zu, die eine Initialisierung auslöst. Der Konstruktor der `LargeObject` Klasse zeigt eine Konsolen Meldung an.  
  
> [!NOTE]
>  Der Einfachheit halber wird in diesem Beispiel eine globale Instanz von <xref:System.Lazy%601> verwendet, und alle Methoden sind `static` (`Shared` in Visual Basic). Dies sind keine Anforderungen für die Verwendung der verzögerten Initialisierung.  
  
 [!code-csharp[System.Lazy\`1.ctorBool#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorbool/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorBool#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorbool/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Verzögerte Initialisierung</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; valueFactory" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Der Delegat, der aufgerufen wird, um bei Bedarf den verzögert initialisierten Wert zu erzeugen.</param>
        <summary>Initialisiert eine neue Instanz der Klasse <see cref="T:System.Lazy`1" />. Bei einer verzögerten Initialisierung wird die angegebene Initialisierungsfunktion verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Instanz, die mit diesem Konstruktor erstellt wird, kann gleichzeitig von mehreren Threads verwendet werden.  
  
 Der Thread Sicherheitsmodus einer <xref:System.Lazy%601>-Instanz, die mit diesem Konstruktor initialisiert wird, ist <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>. Der Thread Sicherheitsmodus beschreibt das Verhalten, wenn mehrere Threads versuchen, die <xref:System.Lazy%601> Instanz zu initialisieren.  
  
 Ausnahmen, die von `valueFactory` ausgelöst werden, werden zwischengespeichert. Weitere Informationen finden Sie unter der <xref:System.Lazy%601>-Klasse oder unter der <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>-Enumeration.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie dieser Konstruktor verwendet wird, um eine verzögerte Initialisierung mit Ausnahme Zwischenspeicherung bereitzustellen. Außerdem wird die Verwendung des <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29>-Konstruktors (`true` für `isThreadSafe`) und des <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>-Konstruktors (durch Angabe <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> für `mode`) veranschaulicht. Um zu einem anderen Konstruktor zu wechseln, ändern Sie einfach, welche Konstruktoren auskommentiert werden.  
  
 Im Beispiel wird eine `LargeObject`-Klasse definiert, die durch einen von mehreren Threads verzögert initialisiert wird. Die drei wichtigsten Code Abschnitte veranschaulichen die Erstellung des Initialisierers, die tatsächliche Initialisierung und den Konstruktor der `LargeObject`-Klasse, die das Zwischenspeichern von Ausnahmen veranschaulicht. Zu Anfang der `Main`-Methode wird in diesem Beispiel ein threadsicherer verzögerter Initialisierer für `LargeObject` erstellt:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFunc#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#newlazy)]  
  
 Im Beispiel werden drei Threads erstellt und gestartet. Die `ThreadProc`-Methode, die von allen drei Threads verwendet wird, ruft die <xref:System.Lazy%601.Value%2A>-Eigenschaft auf, um die `LargeObject` Instanz zu erhalten:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFunc#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#valueprop)]  
  
 Im Konstruktor der `LargeObject` Klasse löst der dritte Schlüssel Abschnitt des Codes eine Ausnahme aus, wenn zum ersten Mal eine `LargeObject` Instanz erstellt wird. Anschließend kann die Instanzerstellung erfolgen:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1.ctorFunc#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#largector)]  
  
 Wenn das Beispiel ausgeführt wird, schlägt der erste Thread, der versucht, eine Instanz von `LargeObject` zu erstellen, fehl, und die Ausnahme wird abgefangen. Sie erwarten möglicherweise, dass der nächste Thread eine Instanz erfolgreich erstellt, aber das <xref:System.Lazy%601> Objekt die Ausnahme zwischengespeichert hat. Aus diesem Grund lösen alle drei Threads die Ausnahme aus.  
  
> [!NOTE]
>  Der Einfachheit halber wird in diesem Beispiel eine globale Instanz von <xref:System.Lazy%601> verwendet, und alle Methoden sind `static` (`Shared` in Visual Basic). Dies sind keine Anforderungen für die Verwendung der verzögerten Initialisierung.  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFunc#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="valueFactory" /> ist <see langword="null" /></exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Verzögerte Initialisierung</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (System.Threading.LazyThreadSafetyMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LazyThreadSafetyMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mode As LazyThreadSafetyMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(System::Threading::LazyThreadSafetyMode mode);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : System.Threading.LazyThreadSafetyMode -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; mode" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mode" Type="System.Threading.LazyThreadSafetyMode" />
      </Parameters>
      <Docs>
        <param name="mode">Einer der Enumerationswerte, der den Threadsicherheitsmodus angibt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Lazy`1" />-Klasse, die den parameterlosen Konstruktor von <paramref name="T" /> und den angegebenen Threadsicherheitsmodus verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Thread Sicherheitsmodus einer <xref:System.Lazy%601> Instanz beschreibt das Verhalten, wenn mehrere Threads versuchen, die <xref:System.Lazy%601> Instanz zu initialisieren.  
  
 Eine <xref:System.Lazy%601>-Instanz, die mit diesem Konstruktor erstellt wird, speichert keine Ausnahmen zwischen. Weitere Informationen finden Sie unter der <xref:System.Lazy%601>-Klasse oder unter der <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>-Enumeration.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie dieser Konstruktor verwendet wird, um einen verzögerten Initialisierer zu erstellen, der es mehreren Threads ermöglicht, mit verzögerter Erstellung eines Objekts zu Rennen. Bei der Erstellung von Instanzen sind möglicherweise mehrere Threads erfolgreich, aber alle Threads verwenden die Instanz, die zuerst erstellt wurde.  
  
> [!NOTE]
>  Ein Beispiel für die Verwendung dieses Konstruktors in Single Thread-Szenarien (angeben von <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> für `mode`) finden Sie im <xref:System.Lazy%601.%23ctor%28System.Boolean%29>-Konstruktor. Ein Beispiel, das veranschaulicht, wie dieser Konstruktor verwendet wird, um Sperren anstelle von Racebedingungen in Multithread-Szenarien (mit Angabe von <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> für `mode`) zu ermöglichen, finden Sie im <xref:System.Lazy%601.%23ctor>-Konstruktor.  
  
 Im Beispiel wird eine `LargeObject` Klasse definiert, die von mehreren Threads verzögert initialisiert wird. Die drei wichtigsten Code Abschnitte veranschaulichen die Erstellung des Initialisierers, die tatsächliche Initialisierung sowie den Konstruktor und den Finalizer der `LargeObject`-Klasse. Am Anfang der `Main`-Methode erstellt das Beispiel das <xref:System.Lazy%601>-Objekt, das die verzögerte Initialisierung der `LargeObject`durchführt:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorLTSM#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#newlazy)]  
  
 Im Beispiel werden drei Threads erstellt und gestartet, die für ein <xref:System.Threading.ManualResetEvent> Objekt blockiert werden, damit das Beispiel alle Threads gleichzeitig freigeben kann. In der `ThreadProc`-Methode, die von allen drei Threads verwendet wird, wird durch Aufrufen der <xref:System.Lazy%601.Value%2A>-Eigenschaft die `LargeObject`-Instanz erstellt:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorLTSM#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#valueprop)]  
  
 Da der Konstruktor für die <xref:System.Lazy%601> Instanz <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>angegeben ist, können alle drei Threads `LargeObject` Instanzen erstellen. Das Beispiel veranschaulicht dies durch Anzeigen von Konsolen Meldungen im Konstruktor und im Finalizer der `LargeObject`-Klasse:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#CtorFinalizer](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#ctorfinalizer)]
 [!code-vb[System.Lazy\`1.ctorLTSM#CtorFinalizer](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#ctorfinalizer)]  
  
 Das <xref:System.Lazy%601>-Objekt stellt jedoch sicher, dass nur eine Instanz von allen Threads verwendet wird. Die Ausgabe des Beispiels zeigt, dass alle drei Threads dieselbe Instanz verwenden, und zeigt außerdem, dass die beiden anderen Instanzen von Garbage Collection freigegeben werden können.  
  
> [!NOTE]
>  Der Einfachheit halber wird in diesem Beispiel eine globale Instanz von <xref:System.Lazy%601> verwendet, und alle Methoden sind `static` (`Shared` in Visual Basic). Dies sind keine Anforderungen für die Verwendung der verzögerten Initialisierung.  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorLTSM#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> enthält einen ungültigen Wert.</exception>
        <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Verzögerte Initialisierung</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(T value);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : 'T -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="T" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="value">Der vorinitialisierte Wert, der verwendet werdensoll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Lazy`1" />-Klasse, die einen vorinitialisierten angegebenen Wert verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks
Eine Instanz, die mit diesem Konstruktor erstellt wird, kann gleichzeitig von mehreren Threads verwendet werden.
]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory, bool isThreadSafe);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory, bool isThreadSafe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T), isThreadSafe As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory, bool isThreadSafe);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; * bool -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; (valueFactory, isThreadSafe)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
        <Parameter Name="isThreadSafe" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Der Delegat, der aufgerufen wird, um bei Bedarf den verzögert initialisierten Wert zu erzeugen.</param>
        <param name="isThreadSafe"><see langword="true" />, damit diese Instanz gleichzeitig von mehreren Threads verwendet werden kann, <see langword="false" /> damit diese Instanz jeweils nur von einem Thread verwendet werden kann.</param>
        <summary>Initialisiert eine neue Instanz der Klasse <see cref="T:System.Lazy`1" />. Bei einer verzögerten Initialisierung werden die angegebene Initialisierungsfunktion und der angegebene Initialisierungsmodus verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Thread Sicherheitsmodus einer <xref:System.Lazy%601>-Instanz, die mit diesem Konstruktor initialisiert wird, ist <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>, wenn `isThreadSafe` `true`ist. Andernfalls ist der Modus <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>. Der Thread Sicherheitsmodus beschreibt das Verhalten, wenn mehrere Threads versuchen, die <xref:System.Lazy%601> Instanz zu initialisieren.  
  
 Um den <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> Modus anzugeben, verwenden Sie den <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>-oder <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29>-Konstruktor.  
  
 Ausnahmen, die von `valueFactory` ausgelöst werden, werden zwischengespeichert. Weitere Informationen finden Sie unter der <xref:System.Lazy%601>-Klasse oder unter der <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>-Enumeration.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie dieser Konstruktor verwendet wird, um eine verzögerte Initialisierung mit Ausnahme Zwischenspeicherung in einem Szenario mit einem einzelnen Thread bereitzustellen. Außerdem wird die Verwendung des <xref:System.Lazy%601.%23ctor%2A>-Konstruktors (angeben von <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> für `mode`) veranschaulicht. Um zu diesem Konstruktor zu wechseln, ändern Sie einfach den auskommentierten Konstruktor.  
  
> [!NOTE]
>  Code, der die Verwendung dieses Konstruktors in Multithread-Szenarien veranschaulicht (angeben von `true` für `isThreadSafe`), finden Sie im Beispiel für den <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>-Konstruktor.  
  
 Im Beispiel wird eine `LargeObject`-Klasse definiert, die durch einen von mehreren Threads verzögert initialisiert wird. Die drei wichtigsten Code Abschnitte veranschaulichen die Erstellung des Initialisierers, die tatsächliche Initialisierung und den Konstruktor der `LargeObject`-Klasse, die das Zwischenspeichern von Ausnahmen veranschaulicht. Zu Anfang der `Main`-Methode wird in diesem Beispiel ein threadsicherer verzögerter Initialisierer für `LargeObject` erstellt:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#newlazy)]  
  
 Beim Aufrufen des Konstruktors wird der `isThreadSafe`-Parameter `false`, sodass der <xref:System.Lazy%601> nicht Thread sicher ist. Da es nicht Thread sicher ist, wird im Beispiel die <xref:System.Lazy%601.Value%2A>-Eigenschaft dreimal im gleichen Thread aufgerufen:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#valueprop)]  
  
 Im Konstruktor der `LargeObject` Klasse löst der dritte Schlüssel Abschnitt des Codes eine Ausnahme aus, wenn zum ersten Mal eine `LargeObject` Instanz erstellt wird. Anschließend kann die Instanzerstellung erfolgen:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#largector)]  
  
 Wenn das Beispiel ausgeführt wird, tritt beim ersten Versuch, eine Instanz von `LargeObject` zu erstellen, ein Fehler auf, und die Ausnahme wird abgefangen. Möglicherweise ist der nächste Versuch erfolgreich, aber das <xref:System.Lazy%601> Objekt hat die Ausnahme zwischengespeichert. Aus diesem Grund lösen alle drei Versuche die Ausnahme aus.  
  
> [!NOTE]
>  Der Einfachheit halber wird in diesem Beispiel eine globale Instanz von <xref:System.Lazy%601> verwendet, und alle Methoden sind `static` (`Shared` in Visual Basic). Dies sind keine Anforderungen für die Verwendung der verzögerten Initialisierung.  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="valueFactory" /> ist <see langword="null" /></exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Verzögerte Initialisierung</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory, System.Threading.LazyThreadSafetyMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory, valuetype System.Threading.LazyThreadSafetyMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T), mode As LazyThreadSafetyMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory, System::Threading::LazyThreadSafetyMode mode);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; * System.Threading.LazyThreadSafetyMode -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; (valueFactory, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
        <Parameter Name="mode" Type="System.Threading.LazyThreadSafetyMode" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Der Delegat, der aufgerufen wird, um bei Bedarf den verzögert initialisierten Wert zu erzeugen.</param>
        <param name="mode">Einer der Enumerationswerte, der den Threadsicherheitsmodus angibt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Lazy`1" />-Klasse, die die angegebene Initialisierungsfunktion und den angegebenen Threadsicherheitsmodus verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Thread Sicherheitsmodus einer <xref:System.Lazy%601> Instanz beschreibt das Verhalten, wenn mehrere Threads versuchen, die <xref:System.Lazy%601> Instanz zu initialisieren.  
  
 Ausnahmen, die von `valueFactory` ausgelöst werden, werden zwischengespeichert, es sei denn, `mode` ist <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>. Weitere Informationen finden Sie unter der <xref:System.Lazy%601>-Klasse oder unter der <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>-Enumeration.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie dieser Konstruktor verwendet wird, um einen verzögerten Initialisierer zu erstellen, der es mehreren Threads ermöglicht, mit verzögerter Erstellung eines Objekts zu Rennen. Bei der Erstellung von Instanzen sind möglicherweise mehrere Threads erfolgreich, aber alle Threads verwenden die Instanz, die zuerst erstellt wurde. Außerdem wird im Beispiel veranschaulicht, dass Ausnahmen nie zwischengespeichert werden, wenn Sie <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>angeben. Dies gilt auch dann, wenn die Initialisierung durch eine Funktion statt durch den Parameter losen Konstruktor des verzögerten erstellten Typs erfolgt.  
  
> [!NOTE]
>  Ein Beispiel für die Verwendung dieses Konstruktors in Single Thread-Szenarien (angeben von <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> für `mode`) finden Sie im <xref:System.Lazy%601.%23ctor%28System.Boolean%29>-Konstruktor. Ein Beispiel, das veranschaulicht, wie dieser Konstruktor verwendet wird, um Sperren anstelle von Racebedingungen in Multithread-Szenarien (mit Angabe von <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> für `mode`) zu ermöglichen, finden Sie im <xref:System.Lazy%601.%23ctor>-Konstruktor.  
  
 Im Beispiel wird eine `LargeObject` Klasse definiert, die von mehreren Threads verzögert initialisiert wird. Die vier wichtigsten Abschnitte des Codes veranschaulichen die Erstellung des Initialisierers, die tatsächliche Initialisierung, die Initialisierungsfunktion und den Konstruktor und den Finalizer der `LargeObject`-Klasse. Am Anfang der `Main`-Methode erstellt das Beispiel das <xref:System.Lazy%601>-Objekt, das die verzögerte Initialisierung der `LargeObject`durchführt:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#newlazy)]  
  
 Der verzögerte Initialisierer verwendet eine Funktion, um die Initialisierung auszuführen. In diesem Fall ist eine Funktion erforderlich, da kein Parameter loser Konstruktor für die `LargeObject` Klasse vorhanden ist.  
  
 Im Beispiel werden drei Threads erstellt und gestartet, die für ein <xref:System.Threading.ManualResetEvent> Objekt blockiert werden, damit das Beispiel alle Threads gleichzeitig freigeben kann. In der `ThreadProc`-Methode, die von allen drei Threads verwendet wird, wird durch Aufrufen der <xref:System.Lazy%601.Value%2A>-Eigenschaft die `LargeObject`-Instanz erstellt:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#valueprop)]  
  
 Im dritten Schlüssel Abschnitt des Codes wird die verzögerte Initialisierungsfunktion aufgerufen, um die `LargeObject` Instanz zu erstellen. Die-Funktion löst eine Ausnahme aus, wenn Sie zum ersten Mal aufgerufen wird:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#FactoryFunc](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#factoryfunc)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#FactoryFunc](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#factoryfunc)]  
  
 Bei allen anderen <xref:System.Threading.LazyThreadSafetyMode> Einstellungen wird eine nicht behandelte Ausnahme in der Initialisierungsfunktion zwischengespeichert. <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> unterdrückt jedoch das Zwischenspeichern von Ausnahmen. Die Ausgabe des Beispiels zeigt, dass ein nachfolgender Versuch, das Objekt zu initialisieren, erfolgreich ist.  
  
> [!NOTE]
>  Die Ausnahme Meldung wird normalerweise Nachrichten angezeigt, die angeben, dass das Objekt von anderen Threads erfolgreich initialisiert wurde. Dies liegt an der Verzögerung, die durch auslösen und Abfangen der Ausnahme verursacht wurde.  
  
 Da der Konstruktor für die <xref:System.Lazy%601> Instanz <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>angegeben ist, können alle drei Threads `LargeObject` Instanzen erstellen. Das Beispiel veranschaulicht dies durch Anzeigen von Konsolen Meldungen im Konstruktor und im Finalizer der `LargeObject`-Klasse:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#CtorFinalizer](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#ctorfinalizer)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#CtorFinalizer](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#ctorfinalizer)]  
  
 Das <xref:System.Lazy%601>-Objekt stellt sicher, dass nur eine Instanz von allen Threads verwendet wird (außer dem Thread, in dem die Initialisierungsfunktion eine Ausnahme auslöst). Dies wird in der Ausgabe des Beispiels veranschaulicht.  
  
> [!NOTE]
>  Der Einfachheit halber wird in diesem Beispiel eine globale Instanz von <xref:System.Lazy%601> verwendet, und alle Methoden sind `static` (`Shared` in Visual Basic). Dies sind keine Anforderungen für die Verwendung der verzögerten Initialisierung.  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> enthält einen ungültigen Wert.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="valueFactory" /> ist <see langword="null" /></exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Verzögerte Initialisierung</related>
      </Docs>
    </Member>
    <Member MemberName="IsValueCreated">
      <MemberSignature Language="C#" Value="public bool IsValueCreated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueCreated" />
      <MemberSignature Language="DocId" Value="P:System.Lazy`1.IsValueCreated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueCreated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueCreated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueCreated : bool" Usage="System.Lazy&lt;'T&gt;.IsValueCreated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob ein Wert für diese <see cref="T:System.Lazy`1" />-Instanz erstellt wurde.</summary>
        <value><see langword="true" />, wenn ein Wert für diese <see cref="T:System.Lazy`1" />-Instanz erstellt wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine verzögerte Initialisierung für eine <xref:System.Lazy%601> Instanz erfolgt, kann dies dazu führen, dass entweder ein Wert erstellt oder eine Ausnahme ausgelöst wird. Wenn eine Ausnahme ausgelöst wird, hängt das nachfolgende Verhalten der <xref:System.Lazy%601> Instanz davon ab, ob das Zwischenspeichern von Ausnahmen wirksam ist. Wenn die <xref:System.Lazy%601> Instanz mithilfe eines Konstruktors erstellt wurde, der keine Initialisierungsfunktion angibt, ist das Zwischenspeichern von Ausnahmen nicht wirksam. Ein nachfolgende Versuch, den <xref:System.Lazy%601> zu initialisieren, kann erfolgreich sein, und nach erfolgreicher Initialisierung gibt die <xref:System.Lazy%601.IsValueCreated%2A>-Eigenschaft `true`zurück. Wenn die <xref:System.Lazy%601> Instanz mit einer Initialisierungsfunktion erstellt wurde (angegeben durch den `valueFactory`-Parameter des <xref:System.Lazy%601>-Konstruktors), wird das Zwischenspeichern von Ausnahmen vom Thread Sicherheitsmodus gesteuert.  
  
-   Wenn der Modus <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> oder <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>ist, besteht keine zweite Möglichkeit, die <xref:System.Lazy%601> Instanz zu initialisieren. Wenn eine Ausnahme auftritt und in der Initialisierungsfunktion nicht behandelt wird, wird diese Ausnahme zwischengespeichert und bei nachfolgenden Zugriffen der <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType>-Eigenschaft erneut ausgelöst. Wenn eine Ausnahme ausgelöst wird, wird kein Wert erstellt. in solchen Fällen <xref:System.Lazy%601.IsValueCreated%2A> `false`zurückgegeben.  
  
-   Wenn der Modus <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>ist, erstellt der erste Thread, der die Initialisierungsfunktion erfolgreich ausführt (oder der Parameter lose Konstruktor), den Wert für die <xref:System.Lazy%601> Instanz. Wenn die Initialisierungsfunktion eine Ausnahme in einem Thread auslöst, können andere Threads weiterhin versuchen, die <xref:System.Lazy%601> Instanz zu initialisieren. Die <xref:System.Lazy%601.IsValueCreated%2A>-Eigenschaft gibt `false`zurück, bis der Wert erstellt wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Verzögerte Initialisierung</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="lazy.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine Zeichenfolgendarstellung der <see cref="P:System.Lazy`1.Value" />-Eigenschaft für diese Instanz und gibt diese zurück.</summary>
        <returns>Das Ergebnis des Aufrufs der <see cref="M:System.Object.ToString" />-Methode für die <see cref="P:System.Lazy`1.Value" />-Eigenschaft für diese Instanz, wenn der Wert erstellt wurde (d. h., wenn die <see cref="P:System.Lazy`1.IsValueCreated" />-Eigenschaft <see langword="true" /> zurückgibt ). Andernfalls hat eine Zeichenfolge, die angibt, dass der Wert nicht erstellt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen dieser Methode führt nicht zu einer Initialisierung.  
  
 Die <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType>-Eigenschaft kann nach der verzögerten Initialisierung `null` werden, wenn die Factorymethode, die für den `valueFactory`-Parameter des <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>-, <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>-oder <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29>-Konstruktors angegeben wurde, `null`zurückgibt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Die <see cref="P:System.Lazy`1.Value" />-Eigenschaft ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public T Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Value" />
      <MemberSignature Language="DocId" Value="P:System.Lazy`1.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T Value { T get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : 'T" Usage="System.Lazy&lt;'T&gt;.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den verzögert initialisierten Wert der aktuellen <see cref="T:System.Lazy`1" />-Instanz ab.</summary>
        <value>Der verzögert initialisierte Wert der aktuellen <see cref="T:System.Lazy`1" />-Instanz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Lazy%601.IsValueCreated%2A?displayProperty=nameWithType>-Eigenschaft `false`ist, erzwingt der Zugriff auf die <xref:System.Lazy%601.Value%2A>-Eigenschaft die Initialisierung.  
  
 Zusätzlich zu den aufgelisteten Ausnahmen kann die <xref:System.Lazy%601.Value%2A>-Eigenschaft jede nicht behandelte Ausnahme auslösen, die von der Factorymethode ausgelöst wird, die an den `valueFactory`-Parameter des <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>-, <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>-oder <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29>-Konstruktors übergeben wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Die <see cref="T:System.Lazy`1" />-Klasse wird initialisiert, um den parameterlosen Konstruktor des Typs zu verwenden, der verzögert initialisiert wird, und es fehlen Berechtigungen für den Zugriff auf den Konstruktor.</exception>
        <exception cref="T:System.MissingMemberException">Die <see cref="T:System.Lazy`1" />-Klasse wird initialisiert, um den parameterlosen Konstruktor des Typs zu verwenden, der verzögert initialisiert wird. Dieser Typ besitzt keinen öffentlichen, parameterlosen Konstruktor.</exception>
        <exception cref="T:System.InvalidOperationException">Die Initialisierungsfunktion versucht, in dieser Instanz auf <see cref="P:System.Lazy`1.Value" /> zuzugreifen.</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Verzögerte Initialisierung</related>
      </Docs>
    </Member>
  </Members>
</Type>
