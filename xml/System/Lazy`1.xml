<Type Name="Lazy&lt;T&gt;" FullName="System.Lazy&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ad53c03faf661b5a698d5ef0c4fcd9d0451bbc14" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30729864" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Lazy&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Lazy`1&lt;T&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Lazy`1" />
  <TypeSignature Language="VB.NET" Value="Public Class Lazy(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class Lazy" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("ThreadSafetyMode={Mode}, IsValueCreated={IsValueCreated}, IsValueFaulted={IsValueFaulted}, Value={ValueForDebugDisplay}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.System_LazyDebugView`1))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Der Typ des Objekts, das verzögert initialisiert wird.</typeparam>
    <summary>Stellt Unterstützung für die verzögerte Initialisierung bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie verzögerten Initialisierung, um die Erstellung eines großen oder ressourcenintensiven Objekts oder die Ausführung einer Aufgabe ressourcenintensiven verzögern, insbesondere dann, wenn eine solche erstellen oder die Ausführung nicht während der Lebensdauer des Programms auftreten kann.  
  
 Um für die verzögerte Initialisierung vorzubereiten, erstellen Sie eine Instanz des <xref:System.Lazy%601>. Das Typargument der <xref:System.Lazy%601> -Objekt, das Sie erstellen, gibt den Typ des Objekts, das verzögert initialisiert werden soll. Der Konstruktor, mit denen Sie erstellen die <xref:System.Lazy%601> Objekt bestimmt die Merkmale der Initialisierung. Die verzögerte Initialisierung tritt beim ersten Zugriff auf die <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType>-Eigenschaft auf.  
  
 In den meisten Fällen hängt die Antworten auf die zwei Fragen einen Konstruktor auswählen:  
  
-   Wird von mehreren Threads verzögert initialisierte Objekt werden zugegriffen? Wenn dies der Fall ist, die <xref:System.Lazy%601> Objekt möglicherweise auf einen beliebigen Thread erstellen. Können Sie die einfache Konstruktoren, deren Standardverhalten besteht, erstellen Sie ein threadsicheres <xref:System.Lazy%601> Objekt, damit, dass nur eine Instanz des verzögert instanziierten Objekts erstellt wird, unabhängig davon, wie viele Threads versuchen, darauf zuzugreifen. Zum Erstellen einer <xref:System.Lazy%601> Objekt, das nicht threadsicher ist, müssen Sie einen Konstruktor, der Ihnen ermöglicht, geben Sie keine Threadsicherheit verwenden.  
  
    > [!CAUTION]
    >  Machen die <xref:System.Lazy%601> Objekt threadsicher schützt nicht die verzögert initialisierte Objekt. Wenn mehrere Threads die verzögert initialisierte Objekt zugreifen können, müssen Sie die Eigenschaften und Methoden für Multithreadzugriff sicher vornehmen.  
  
-   Erfordert verzögerter Initialisierung viel Code oder verfügt das verzögert initialisierte Objekt über einen Standardkonstruktor, die alles, was Sie benötigen, und löst keine Ausnahmen aus? Verwenden Sie Wenn Sie Initialisierungscode schreiben oder Ausnahmen behandelt werden müssen, eines Konstruktors, der eine Factorymethode akzeptiert. Schreiben Sie den Initialisierungscode in der Factorymethode.  
  
 In der folgenden Tabelle zeigt, welcher Konstruktor auf, basierend auf diese beiden Faktoren:  
  
|Objekt wird von den zugegriffen werden|Wenn kein Initialisierungscode erforderlich ist (Standardkonstruktor) verwenden|Wenn Code für die Initialisierung erforderlich ist, verwenden|  
|--------------------------------|------------------------------------------------------------------------|---------------------------------------------|  
|Mehrere threads|<xref:System.Lazy%601.%23ctor>|<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>|  
|Ein thread|<xref:System.Lazy%601.%23ctor%28System.Boolean%29> mit `isThreadSafe` festgelegt `false`.|<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> mit `isThreadSafe` festgelegt `false`.|  
  
 Einen Lambda-Ausdruck können die Factory-Methode. Dadurch wird die gesamte Initialisierungscode an einem Ort. Der Lambda-Ausdruck erfasst den Kontext, einschließlich der keine Argumente, die Sie den verzögert initialisierten Konstruktor des Objekts übergeben.  
  
 **Das Zwischenspeichern von Ausnahmen** bei Verwendung von Factorymethoden Ausnahmen werden zwischengespeichert. Das heißt, wenn die Factory-Methode löst eine der ersten Ausnahmezeit aus, ein Thread versucht den Zugriff auf die <xref:System.Lazy%601.Value%2A> Eigenschaft von der <xref:System.Lazy%601> Objekt die gleiche Ausnahme wird bei jedem nachfolgenden Versuch ausgelöst. Dadurch wird sichergestellt, dass jeder Aufruf der <xref:System.Lazy%601.Value%2A> Eigenschaft führt zum gleichen Ergebnis, und vermeidet Fehler auftreten, die auftreten können, wenn es sich bei verschiedenen Threads unterschiedliche Ergebnisse zu erhalten. Die <xref:System.Lazy%601> stellvertretend für ein tatsächliches `T` , andernfalls würde initialisiert wurden zu einem früheren, in der Regel während des Starts. Ein Fehler auf diesen früheren Punkt wird in der Regel Schwerwiegender. Wenn es besteht die Gefahr eines Fehlers wiederhergestellt, wird empfohlen, dass die Wiederholungslogik in die Initialisierungsroutine (in diesem Fall die Factory-Methode), zu erstellen, wie Sie bei Verwendung von verzögerte Initialisierung datenträgerressourceneinstellungen wurden nicht.  
  
 **Alternative zum Sperren** In bestimmten Situationen möchten Sie möglicherweise den Aufwand zu vermeiden der <xref:System.Lazy%601> des Objekts Standard Sperrverhalten. In seltenen Situationen können eine potenzielle Deadlocks vorhanden sein. In solchen Fällen können Sie die <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> oder <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> -Konstruktor, und geben Sie <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>. Dies ermöglicht die <xref:System.Lazy%601> Objekt, das eine Kopie der verzögert initialisierte Objekt auf jedem von mehreren Threads zu erstellen, wenn die Threads rufen die <xref:System.Lazy%601.Value%2A> Eigenschaft gleichzeitig. Die <xref:System.Lazy%601> Objekt wird sichergestellt, dass alle Threads dieselbe Instanz des verzögert initialisierten Objekts und verwirft die Instanzen, die nicht verwendet werden. Daher ist der Aufwand verringert den Aufwand für das Sperren an, dass das Programm möglicherweise manchmal erstellen und zusätzliche Kopien ein teures Objekt zu verwerfen. In den meisten Fällen ist dies wahrscheinlich nicht. In den Beispielen für die <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> und <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> Konstruktoren wird dieses Verhalten demonstriert.  
  
> [!IMPORTANT]
>  Geben Sie bei <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, Ausnahmen werden nie zwischengespeichert, selbst wenn Sie eine Factorymethode angeben.  
  
 **Entsprechende Konstruktoren** zusätzlich zum Aktivieren der Verwendung von <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> und <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> Konstruktoren können die Funktionalität der anderen Konstruktoren duplizieren. Die folgende Tabelle zeigt die Parameterwerte, die ein gleichwertiges Verhalten zu erzeugen.  
  
|Zum Erstellen einer <xref:System.Lazy%601> -Objekt ab|Für Konstruktoren, haben eine `LazyThreadSafetyMode` `mode` Parametersatz, `mode` an|Für Konstruktoren, die einen booleschen Wert haben `isThreadSafe` Parametersatz, `isThreadSafe` an|Konstruktoren ohne Parameter der Thread-Sicherheit|  
|-------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------|-------------------------------------------------------|  
|Vollständig threadsicher; verwendet sperren, um sicherzustellen, dass nur ein Thread den Wert initialisiert.|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|Alle anderen Konstruktoren sind vollständig threadsicher.|  
|Nicht threadsicher.|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|Nicht zutreffend.|  
|Vollständig threadsicher; Threads Racebedingungen, um den Wert zu initialisieren.|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|Nicht zutreffend.|Nicht zutreffend.|  
  
 **Andere Funktionen** Informationen zur Verwendung der <xref:System.Lazy%601> mit threadstatische Felder oder als Sicherungsspeicher für Eigenschaften, finden Sie unter [verzögerte Initialisierung](~/docs/framework/performance/lazy-initialization.md).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von der <xref:System.Lazy%601> Klasse, um die verzögerte Initialisierung mit Zugriff von mehreren Threads bereitzustellen.  
  
> [!NOTE]
>  Im Beispiel wird die <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> Konstruktor. Es zeigt auch die Verwendung von der <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> Konstruktor (Angeben von `true` für `isThreadSafe`) und die <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> Konstruktor (angeben <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> für `mode`). Um einen anderen Konstruktor zu wechseln, ändern Sie einfach die Konstruktoren auskommentiert werden.  
>   
>  Ein Beispiel für die Ausnahme caching mit den gleichen Konstruktoren finden Sie unter der <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> Konstruktor.  
  
 Im Beispiel wird eine `LargeObject`-Klasse definiert, die durch einen von mehreren Threads verzögert initialisiert wird. Die vier wichtigsten Codeabschnitte veranschaulichen die Erstellung der Initialisierer, die Factory-Methode, die eigentliche Initialisierung und den Konstruktor des der `LargeObject` -Klasse, die eine Meldung angezeigt, wenn das Objekt erstellt wird. Zu Anfang der `Main`-Methode wird in diesem Beispiel ein threadsicherer verzögerter Initialisierer für `LargeObject` erstellt:  
  
 [!code-csharp[System.Lazy\`1#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#newlazy)]  
  
 Die Factory-Methode veranschaulicht die Erstellung des Objekts, durch einen Platzhalter für die weitere Initialisierung:  
  
 [!code-csharp[System.Lazy\`1#FactoryFunc](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#factoryfunc)]
 [!code-vb[System.Lazy\`1#FactoryFunc](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#factoryfunc)]  
  
 Beachten Sie, dass die ersten beiden Codeabschnitte mithilfe einer Lambdafunktion kombiniert werden können, wie hier gezeigt:  
  
 [!code-csharp[System.Lazy\`1#InitWithLambda](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/lambda.cs#initwithlambda)]
 [!code-vb[System.Lazy\`1#InitWithLambda](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/lambda.vb#initwithlambda)]  
  
 Im Beispiel wird angehalten, um anzugeben, dass für ein unbestimmter Zeitraum verstreichen kann, bevor die verzögerte Initialisierung auftritt. Beim Drücken der **EINGABETASTE** drücken, das Beispiel erstellt und startet drei Threads. Die `ThreadProc` -Methode, die durch Aufrufe für alle drei Threads verwendet, wird die <xref:System.Lazy%601.Value%2A> Eigenschaft. In diesem Fall erstmalig den `LargeObject` Instanz erstellt wird:  
  
 [!code-csharp[System.Lazy\`1#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#valueprop)]  
  
 Der Konstruktor, der die `LargeObject` Klasse, die die letzte Schlüssel Codeabschnitt enthält, wird eine Meldung angezeigt, und zeichnet die Identität des beim Initialisieren des Threads. Die Ausgabe des Programms wird am Ende der vollständige Beispielcode angezeigt.  
  
 [!code-csharp[System.Lazy\`1#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#largector)]  
  
> [!NOTE]
>  Der Einfachheit halber wird in diesem Beispiel eine globale Instanz von <xref:System.Lazy%601> verwendet, und alle Methoden sind `static` (`Shared` in Visual Basic). Dies sind keine Anforderungen für die Verwendung der verzögerten Initialisierung.  
  
 [!code-csharp[System.Lazy\`1#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#all)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Standardmäßig werden alle öffentlichen und geschützten Member, der die <see cref="T:System.Lazy`1" /> Klasse sind threadsicher und können von mehreren Threads gleichzeitig verwendet werden. Diese Garantien Threadsicherheit können optional und pro Instanz mit Parametern für den Konstruktoren des Typs entfernt werden.</threadsafe>
    <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Lazy`1" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Lazy`1" />-Klasse. Wenn eine verzögerte Initialisierung auftritt, wird der Standardkonstruktor des Zieltyps verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Instanz, die mit diesem Konstruktor erstellt wird, kann von mehreren Threads gleichzeitig verwendet werden.  
  
 Der Threadsicherheitsmodus eine <xref:System.Lazy%601> Instanz, die mit diesem Konstruktor initialisiert wird, ist <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>. Der Threadsicherheitsmodus beschreibt das Verhalten, wenn mehrere Threads, zum Initialisieren versuchen der <xref:System.Lazy%601> Instanz.  
  
 Ein <xref:System.Lazy%601> -Instanz, die mit diesem Konstruktor erstellt wird Ausnahmen nicht zwischengespeichert. Weitere Informationen finden Sie unter der <xref:System.Lazy%601>-Klasse oder unter der <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>-Enumeration.  
  
   
  
## Examples  
 Im folgende Beispiel wird die Verwendung dieses Konstruktors veranschaulicht. Es veranschaulicht auch die Verwendung von der <xref:System.Lazy%601.%23ctor%28System.Boolean%29> Konstruktor (Angeben von `true` für `isThreadSafe`) und die <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> Konstruktor (angeben <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> für `mode`). Um einen anderen Konstruktor zu wechseln, ändern Sie einfach die Konstruktoren auskommentiert werden.  
  
 Im Beispiel wird eine `LargeObject`-Klasse definiert, die durch einen von mehreren Threads verzögert initialisiert wird. Die zwei wichtigsten Codezeilen in diesem Beispiel werden die Erstellung von Initialisierer und die eigentliche Initialisierung. Zu Anfang der `Main`-Methode wird in diesem Beispiel ein threadsicherer verzögerter Initialisierer für `LargeObject` erstellt:  
  
 [!code-csharp[System.Lazy\`1.ctor#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctor#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#newlazy)]  
  
 Das Beispiel erstellt und startet drei Threads, die eine Blockierung auf eine <xref:System.Threading.ManualResetEvent> Objekt, sodass das Beispiel die Threads gleichzeitig freigeben kann. Die `ThreadProc` -Methode, die durch Aufrufe für alle drei Threads verwendet wird die <xref:System.Lazy%601.Value%2A> Eigenschaft, um die `LargeObject` Instanz:  
  
 [!code-csharp[System.Lazy\`1.ctor#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctor#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#valueprop)]  
  
 Die <xref:System.Lazy%601> Klasse bietet sperren, sodass nur ein Thread, zum Erstellen zugelassen wird der `LargeObject` Instanz. Das Beispiel zeigt, dass andere Threads alle die gleiche Instanz abrufen.  
  
> [!NOTE]
>  Der Einfachheit halber wird in diesem Beispiel eine globale Instanz von <xref:System.Lazy%601> verwendet, und alle Methoden sind `static` (`Shared` in Visual Basic). Dies sind keine Anforderungen für die Verwendung der verzögerten Initialisierung.  
  
 [!code-csharp[System.Lazy\`1.ctor#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctor#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (bool isThreadSafe);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool isThreadSafe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (isThreadSafe As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(bool isThreadSafe);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="isThreadSafe" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isThreadSafe">
          <see langword="true" />, damit diese Instanz durch mehrere Threads gleichzeitig verwendet werden kann, <see langword="false" />, damit die Instanz nur von jeweils einem Thread verwendet werden kann.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Lazy`1" />-Klasse. Bei einer verzögerten Initialisierung werden der Standardkonstruktor des Zieltyps und der angegebene Initialisierungsmodus verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Threadsicherheitsmodus eine <xref:System.Lazy%601> Instanz, die mit diesem Konstruktor initialisiert wird, ist <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> Wenn `isThreadSafe` ist `true`ist, andernfalls ist der Modus <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>. Der Threadsicherheitsmodus beschreibt das Verhalten, wenn mehrere Threads, zum Initialisieren versuchen der <xref:System.Lazy%601> Instanz. Angeben der <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> Modus verwenden die <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> oder <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> Konstruktor.  
  
 Ein <xref:System.Lazy%601> -Instanz, die mit diesem Konstruktor erstellt wird Ausnahmen nicht zwischengespeichert. Weitere Informationen finden Sie unter der <xref:System.Lazy%601>-Klasse oder unter der <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>-Enumeration.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung dieses Konstruktors eine verzögerte Initialisierung zu erstellen, die nicht threadsicher ist, für Szenarien ist, in der alle Zugriffe auf die verzögert initialisierte Objekt auf dem gleichen Thread auftritt. Es zeigt auch die Verwendung von der <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> Konstruktor (Angeben von <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> für `mode`. Um einen anderen Konstruktor zu wechseln, ändern Sie einfach welcher Konstruktor auskommentiert ist.  
  
> [!NOTE]
>  Für Code, der veranschaulicht, wie dieser Konstruktor im Multithread-Szenarien (Angabe `true` für `isThreadSafe`), finden Sie im Beispiel für die <xref:System.Lazy%601.%23ctor> Konstruktor.  
  
 Im Beispiel definiert eine `LargeObject` -Klasse, die verzögert initialisiert wird. In der `Main` -Methode, um das Beispiel erstellt eine <xref:System.Lazy%601> Instanz und hält dann an. Beim Drücken der **EINGABETASTE** -Schlüssel im Beispiel greift auf die <xref:System.Lazy%601.Value%2A> Eigenschaft von der <xref:System.Lazy%601> -Instanz, die führt dazu, dass bei der Initialisierung auftreten. Der Konstruktor, der die `LargeObject` Klasse zeigt eine konsolenmeldung an.  
  
> [!NOTE]
>  Der Einfachheit halber wird in diesem Beispiel eine globale Instanz von <xref:System.Lazy%601> verwendet, und alle Methoden sind `static` (`Shared` in Visual Basic). Dies sind keine Anforderungen für die Verwendung der verzögerten Initialisierung.  
  
 [!code-csharp[System.Lazy\`1.ctorBool#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorbool/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorBool#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorbool/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Der Delegat, der aufgerufen wird, um bei Bedarf den verzögert initialisierten Wert zu erzeugen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Lazy`1" />-Klasse. Bei einer verzögerten Initialisierung wird die angegebene Initialisierungsfunktion verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Instanz, die mit diesem Konstruktor erstellt wird, kann von mehreren Threads gleichzeitig verwendet werden.  
  
 Der Threadsicherheitsmodus eine <xref:System.Lazy%601> Instanz, die mit diesem Konstruktor initialisiert wird, ist <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>. Der Threadsicherheitsmodus beschreibt das Verhalten, wenn mehrere Threads, zum Initialisieren versuchen der <xref:System.Lazy%601> Instanz.  
  
 Durch ausgelöste Ausnahmen `valueFactory` zwischengespeichert werden. Weitere Informationen finden Sie unter der <xref:System.Lazy%601>-Klasse oder unter der <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>-Enumeration.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung dieses Konstruktors verzögerte Initialisierung mit Ausnahme Zwischenspeichern bereitstellen. Es zeigt auch die Verwendung von der <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> Konstruktor (Angeben von `true` für `isThreadSafe`) und die <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> Konstruktor (angeben <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> für `mode`). Um einen anderen Konstruktor zu wechseln, ändern Sie einfach die Konstruktoren auskommentiert werden.  
  
 Im Beispiel wird eine `LargeObject`-Klasse definiert, die durch einen von mehreren Threads verzögert initialisiert wird. Die drei wichtigsten Codeabschnitte veranschaulichen die Erstellung der Initialisierer, die eigentliche Initialisierung und den Konstruktor des der `LargeObject` -Klasse, die Zwischenspeichern von Ausnahmen veranschaulicht. Zu Anfang der `Main`-Methode wird in diesem Beispiel ein threadsicherer verzögerter Initialisierer für `LargeObject` erstellt:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFunc#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#newlazy)]  
  
 Das Beispiel erstellt und startet drei Threads. Die `ThreadProc` -Methode, die durch Aufrufe für alle drei Threads verwendet wird die <xref:System.Lazy%601.Value%2A> Eigenschaft, um die `LargeObject` Instanz:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFunc#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#valueprop)]  
  
 Im Konstruktor der der `LargeObject` -Klasse, die wichtigsten dritte Codeabschnitt löst eine Ausnahme erstmalig eine `LargeObject` Instanz erstellt, aber danach instanzerstellung auftreten können:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1.ctorFunc#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#largector)]  
  
 Wenn das Beispiel ausgeführt wird, wird den ersten Thread, der versucht, die zum Erstellen einer Instanz von `LargeObject` schlägt fehl, und die Ausnahme abgefangen wird. Sie erwarten wahrscheinlich, dass der nächste Thread erfolgreich eine Instanz erstellen, würden jedoch <xref:System.Lazy%601> Objekt hat die Ausnahme zwischengespeichert. Aus diesem Grund werden alle drei Threads die Ausnahme auslösen.  
  
> [!NOTE]
>  Der Einfachheit halber wird in diesem Beispiel eine globale Instanz von <xref:System.Lazy%601> verwendet, und alle Methoden sind `static` (`Shared` in Visual Basic). Dies sind keine Anforderungen für die Verwendung der verzögerten Initialisierung.  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFunc#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="valueFactory" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (System.Threading.LazyThreadSafetyMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LazyThreadSafetyMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mode As LazyThreadSafetyMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(System::Threading::LazyThreadSafetyMode mode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mode" Type="System.Threading.LazyThreadSafetyMode" />
      </Parameters>
      <Docs>
        <param name="mode">Einer der Enumerationswerte, der den Threadsicherheitsmodus angibt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Lazy`1" />-Klasse, die den Standardkonstruktor von <paramref name="T" /> und einen angegebenen Threadsicherheitsmodus verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Threadsicherheitsmodus eine <xref:System.Lazy%601> Instanz beschreibt das Verhalten, wenn mehrere Threads, zum Initialisieren versuchen der <xref:System.Lazy%601> Instanz.  
  
 Ein <xref:System.Lazy%601> -Instanz, die mit diesem Konstruktor erstellt wird Ausnahmen nicht zwischengespeichert. Weitere Informationen finden Sie unter der <xref:System.Lazy%601>-Klasse oder unter der <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>-Enumeration.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung dieses Konstruktors eine verzögerte Initialisierung zu erstellen, die können mehrere Threads Rennen verzögert ein Objekt zu erstellen. Mehrere Threads möglicherweise bei der Erstellung von Instanzen erfolgreich, doch alle Threads verwenden Sie die Instanz, die erstmalig erstellt wurde.  
  
> [!NOTE]
>  Ein Beispiel für die Verwendung dieses Konstruktors in Singlethread-Szenarien veranschaulicht (Angeben von <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> für `mode`), finden Sie unter der <xref:System.Lazy%601.%23ctor%28System.Boolean%29> Konstruktor. Ein Beispiel für die Verwendung dieses Konstruktors angeben, Sperren anstelle der Racebedingungen im Multithread-Szenarien veranschaulicht (Angeben von <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> für `mode`), finden Sie unter der <xref:System.Lazy%601.%23ctor> Konstruktor.  
  
 Im Beispiel definiert eine `LargeObject` -Klasse, die von einer von mehreren Threads verzögert initialisiert wird. Die drei wichtigsten Codeabschnitte veranschaulichen die Erstellung der Initialisierer, die eigentliche Initialisierung und den Konstruktor und Finalizer des der `LargeObject` Klasse. Am Anfang der `Main` -Methode, um das Beispiel erstellt die <xref:System.Lazy%601> -Objekt, das verzögerte Initialisierung von führt die `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorLTSM#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#newlazy)]  
  
 Das Beispiel erstellt und startet drei Threads, die eine Blockierung auf eine <xref:System.Threading.ManualResetEvent> Objekt, sodass das Beispiel die Threads gleichzeitig freigeben kann. In der `ThreadProc` -Methode, die von allen drei Threads Aufrufen verwendet wird, die <xref:System.Lazy%601.Value%2A> Eigenschaft erstellt die `LargeObject` Instanz:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorLTSM#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#valueprop)]  
  
 Da der Konstruktor für die <xref:System.Lazy%601> angegebenen Instanz <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, dürfen alle drei Threads erstellen `LargeObject` Instanzen. Das Beispiel veranschaulicht das Anzeigen von konsolenmeldungen im Konstruktor und in der Finalize-Methode der der `LargeObject` Klasse:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#CtorFinalizer](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#ctorfinalizer)]
 [!code-vb[System.Lazy\`1.ctorLTSM#CtorFinalizer](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#ctorfinalizer)]  
  
 Allerdings die <xref:System.Lazy%601> Objekt wird sichergestellt, dass nur eine Instanz wird von allen Threads verwendet. Die Ausgabe des Beispiels zeigt, dass alle drei Threads verwendet, die dieselbe Instanz, und zeigt außerdem, dass die beiden anderen Instanzen von der Garbagecollection freigegeben werden können.  
  
> [!NOTE]
>  Der Einfachheit halber wird in diesem Beispiel eine globale Instanz von <xref:System.Lazy%601> verwendet, und alle Methoden sind `static` (`Shared` in Visual Basic). Dies sind keine Anforderungen für die Verwendung der verzögerten Initialisierung.  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorLTSM#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> enthält einen ungültigen Wert.</exception>
        <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(T value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory, bool isThreadSafe);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory, bool isThreadSafe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T), isThreadSafe As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory, bool isThreadSafe);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
        <Parameter Name="isThreadSafe" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Der Delegat, der aufgerufen wird, um bei Bedarf den verzögert initialisierten Wert zu erzeugen.</param>
        <param name="isThreadSafe">
          <see langword="true" />, damit diese Instanz durch mehrere Threads gleichzeitig verwendet werden kann, <see langword="false" />, damit diese Instanz nur von jeweils einem Thread verwendet werden kann.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Lazy`1" />-Klasse. Bei einer verzögerten Initialisierung werden die angegebene Initialisierungsfunktion und der angegebene Initialisierungsmodus verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Threadsicherheitsmodus eine <xref:System.Lazy%601> Instanz, die mit diesem Konstruktor initialisiert wird, ist <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> Wenn `isThreadSafe` ist `true`ist, andernfalls ist der Modus <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>. Der Threadsicherheitsmodus beschreibt das Verhalten, wenn mehrere Threads, zum Initialisieren versuchen der <xref:System.Lazy%601> Instanz.  
  
 Angeben der <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> Modus verwenden die <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> oder <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> Konstruktor.  
  
 Durch ausgelöste Ausnahmen `valueFactory` zwischengespeichert werden. Weitere Informationen finden Sie unter der <xref:System.Lazy%601>-Klasse oder unter der <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>-Enumeration.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung dieses Konstruktors verzögerten Initialisierung mit der Ausnahme, die in einem Szenario mit einem einzelnen Thread Zwischenspeichern bereitstellen. Es zeigt auch die Verwendung von der <xref:System.Lazy%601.%23ctor%2A> Konstruktor (Angeben von <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> für `mode`). Um diesen Konstruktor zu wechseln, ändern Sie einfach welcher Konstruktor auskommentiert ist.  
  
> [!NOTE]
>  Für Code, der veranschaulicht, wie dieser Konstruktor im Multithread-Szenarien (Angabe `true` für `isThreadSafe`), finden Sie im Beispiel für die <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> Konstruktor.  
  
 Im Beispiel wird eine `LargeObject`-Klasse definiert, die durch einen von mehreren Threads verzögert initialisiert wird. Die drei wichtigsten Codeabschnitte veranschaulichen die Erstellung der Initialisierer, die eigentliche Initialisierung und den Konstruktor des der `LargeObject` -Klasse, die Zwischenspeichern von Ausnahmen veranschaulicht. Zu Anfang der `Main`-Methode wird in diesem Beispiel ein threadsicherer verzögerter Initialisierer für `LargeObject` erstellt:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#newlazy)]  
  
 Im Aufruf an den Konstruktor der `isThreadSafe` Parameter ist `false`, sodass die <xref:System.Lazy%601> ist nicht threadsicher. Da sie nicht threadsicher ist, wird im Beispiel wird die <xref:System.Lazy%601.Value%2A> Eigenschaft dreimal auf dem gleichen Thread:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#valueprop)]  
  
 Im Konstruktor der der `LargeObject` -Klasse, die wichtigsten dritte Codeabschnitt löst eine Ausnahme erstmalig eine `LargeObject` Instanz erstellt, aber danach instanzerstellung auftreten können:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#largector)]  
  
 Wenn das Beispiel ausgeführt wird, wird der erste Versuch zum Erstellen einer Instanz von `LargeObject` schlägt fehl, und die Ausnahme abgefangen wird. Sie erwarten wahrscheinlich, dass der nächste Versuch erfolgreich ist, aber die <xref:System.Lazy%601> Objekt hat die Ausnahme zwischengespeichert. Aus diesem Grund werden alle drei Versuche der Ausnahme auslösen.  
  
> [!NOTE]
>  Der Einfachheit halber wird in diesem Beispiel eine globale Instanz von <xref:System.Lazy%601> verwendet, und alle Methoden sind `static` (`Shared` in Visual Basic). Dies sind keine Anforderungen für die Verwendung der verzögerten Initialisierung.  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="valueFactory" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory, System.Threading.LazyThreadSafetyMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory, valuetype System.Threading.LazyThreadSafetyMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T), mode As LazyThreadSafetyMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory, System::Threading::LazyThreadSafetyMode mode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
        <Parameter Name="mode" Type="System.Threading.LazyThreadSafetyMode" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Der Delegat, der aufgerufen wird, um bei Bedarf den verzögert initialisierten Wert zu erzeugen.</param>
        <param name="mode">Einer der Enumerationswerte, der den Threadsicherheitsmodus angibt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Lazy`1" />-Klasse, die die angegebene Initialisierungsfunktion und den angegebenen Threadsicherheitsmodus verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Threadsicherheitsmodus eine <xref:System.Lazy%601> Instanz beschreibt das Verhalten, wenn mehrere Threads, zum Initialisieren versuchen der <xref:System.Lazy%601> Instanz.  
  
 Durch ausgelöste Ausnahmen `valueFactory` zwischengespeichert werden, es sei denn, `mode` ist <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>. Weitere Informationen finden Sie unter der <xref:System.Lazy%601>-Klasse oder unter der <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>-Enumeration.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung dieses Konstruktors eine verzögerte Initialisierung zu erstellen, die können mehrere Threads Rennen verzögert ein Objekt zu erstellen. Mehrere Threads möglicherweise bei der Erstellung von Instanzen erfolgreich, doch alle Threads verwenden Sie die Instanz, die erstmalig erstellt wurde. Darüber hinaus im Beispiel wird veranschaulicht, dass Ausnahmen nicht zwischengespeichert werden, bei der Angabe <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, selbst wenn die Initialisierung von einer Funktion anstelle von durch den Standardkonstruktor des Typs verzögert erstellte ausgeführt wird.  
  
> [!NOTE]
>  Ein Beispiel für die Verwendung dieses Konstruktors in Singlethread-Szenarien veranschaulicht (Angeben von <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> für `mode`), finden Sie unter der <xref:System.Lazy%601.%23ctor%28System.Boolean%29> Konstruktor. Ein Beispiel für die Verwendung dieses Konstruktors angeben, Sperren anstelle der Racebedingungen im Multithread-Szenarien veranschaulicht (Angeben von <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> für `mode`), finden Sie unter der <xref:System.Lazy%601.%23ctor> Konstruktor.  
  
 Im Beispiel definiert eine `LargeObject` -Klasse, die von einer von mehreren Threads verzögert initialisiert wird. Die vier wichtigsten Abschnitte des Codes zu veranschaulichen, die Erstellung der Initialisierer, die eigentliche Initialisierung, die Initialisierungsfunktion und den Konstruktor und Finalizer, der die `LargeObject` Klasse. Am Anfang der `Main` -Methode, um das Beispiel erstellt die <xref:System.Lazy%601> -Objekt, das verzögerte Initialisierung von führt die `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#newlazy)]  
  
 Die verzögerte Initialisierung verwendet eine Funktion, um die Initialisierung auszuführen. In diesem Fall ist eine Funktion erforderlich, da es kein Standardkonstruktor für ist die `LargeObject` Klasse.  
  
 Das Beispiel erstellt und startet drei Threads, die eine Blockierung auf eine <xref:System.Threading.ManualResetEvent> Objekt, sodass das Beispiel die Threads gleichzeitig freigeben kann. In der `ThreadProc` -Methode, die von allen drei Threads Aufrufen verwendet wird, die <xref:System.Lazy%601.Value%2A> Eigenschaft erstellt die `LargeObject` Instanz:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#valueprop)]  
  
 Im dritten Key Abschnitt des Codes, die verzögerte Initialisierung-Funktion aufgerufen, um erstellen die `LargeObject` Instanz. Die Funktion löst eine Ausnahme das erste Mal aufgerufen wird:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#FactoryFunc](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#factoryfunc)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#FactoryFunc](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#factoryfunc)]  
  
 Bei einem anderen <xref:System.Threading.LazyThreadSafetyMode> festlegen, würde eine nicht behandelte Ausnahme in die Initialisierungsfunktion zwischengespeichert werden. Allerdings <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> unterdrückt das Zwischenspeichern von Ausnahmen. Die Ausgabe des Beispiels zeigt, erfolgreich ausgeführt wird, ein anschließenden Versuch, das Objekt zu initialisieren.  
  
> [!NOTE]
>  Die Ausnahmemeldung wird in der Regel nach den Nachrichten, die angibt, dass andere Threads das Objekt erfolgreich initialisiert haben, angezeigt. Dies ist die Verzögerung, die durch das Auslösen und Abfangen der Ausnahme eingeführt.  
  
 Da der Konstruktor für die <xref:System.Lazy%601> angegebenen Instanz <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, dürfen alle drei Threads erstellen `LargeObject` Instanzen. Das Beispiel veranschaulicht das Anzeigen von konsolenmeldungen im Konstruktor und in der Finalize-Methode der der `LargeObject` Klasse:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#CtorFinalizer](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#ctorfinalizer)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#CtorFinalizer](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#ctorfinalizer)]  
  
 Die <xref:System.Lazy%601> Objekt wird sichergestellt, dass nur eine Instanz von allen Threads (mit Ausnahme des Threads, in dem die Initialisierungsfunktion löst eine Ausnahme aus) verwendet wird. Die Ausgabe im Beispiel zeigt dies.  
  
> [!NOTE]
>  Der Einfachheit halber wird in diesem Beispiel eine globale Instanz von <xref:System.Lazy%601> verwendet, und alle Methoden sind `static` (`Shared` in Visual Basic). Dies sind keine Anforderungen für die Verwendung der verzögerten Initialisierung.  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> enthält einen ungültigen Wert.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="valueFactory" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsValueCreated">
      <MemberSignature Language="C#" Value="public bool IsValueCreated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueCreated" />
      <MemberSignature Language="DocId" Value="P:System.Lazy`1.IsValueCreated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueCreated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueCreated { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob ein Wert für diese <see cref="T:System.Lazy`1" />-Instanz erstellt wurde.</summary>
        <value>
          <see langword="true" />, wenn für diese <see cref="T:System.Lazy`1" />-Instanz ein Wert erstellt wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die verzögerter Initialisierung auftritt, für eine <xref:System.Lazy%601> Instanz er möglicherweise einen Wert, der erstellt wird oder eine Ausnahme ausgelöst. Wenn eine Ausnahme ausgelöst wird, werden nachfolgende Verhalten ist das <xref:System.Lazy%601> Instanz, hängt davon ab, ob das Zwischenspeichern von Ausnahmen aktiviert ist. Wenn die <xref:System.Lazy%601> Instanz mithilfe eines Konstruktors, der keine Initialisierungsfunktion erstellt wurde, und das Zwischenspeichern von Ausnahmen ist nicht gültig. Ein nachfolgender Versuch zum Initialisieren der <xref:System.Lazy%601> zwar erfolgreich sein, und nach der erfolgreichen Initialisierung der <xref:System.Lazy%601.IsValueCreated%2A> -Eigenschaft gibt `true`. Wenn die <xref:System.Lazy%601> Instanz mit einer Initialisierungsfunktion erstellt wurde (gemäß der `valueFactory` Parameter von der <xref:System.Lazy%601> Konstruktor), und klicken Sie dann das Zwischenspeichern von Ausnahmen von den Threadsicherheitsmodus gesteuert wird.  
  
-   Wenn der Modus ist <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> oder <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, es besteht keine zweite Möglichkeit zum Initialisieren der <xref:System.Lazy%601> Instanz. Wenn eine Ausnahme tritt auf, und wird nicht in die Initialisierungsfunktion behandelt, wird diese Ausnahme zwischengespeichert und erneut ausgelöst, bei nachfolgenden Zugriffen auf die <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> Eigenschaft. Es wird kein Wert erstellt, wenn eine Ausnahme ausgelöst wird, in einem solchen Fall <xref:System.Lazy%601.IsValueCreated%2A> gibt `false`.  
  
-   Wenn der Modus ist <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, der erste Thread, der die Initialisierungsfunktion (oder den Standardkonstruktor) erfolgreich ausführt, erstellt den Wert für die <xref:System.Lazy%601> Instanz. Wenn die Initialisierungsfunktion in einem Thread eine Ausnahme auslöst, können andere Threads trotzdem initialisiert werden, versuchen die <xref:System.Lazy%601> Instanz. Bis der Wert erstellt wird, die <xref:System.Lazy%601.IsValueCreated%2A> -Eigenschaft gibt `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine Zeichenfolgendarstellung der <see cref="P:System.Lazy`1.Value" />-Eigenschaft für diese Instanz und gibt sie zurück.</summary>
        <returns>Das Ergebnis des Aufrufs der <see cref="M:System.Object.ToString" />-Methode für die <see cref="P:System.Lazy`1.Value" />-Eigenschaft dieser Instanz, wenn der Wert erstellt wurde (d. h., wenn die <see cref="P:System.Lazy`1.IsValueCreated" />-Eigenschaft <see langword="true" /> zurückgibt). Andernfalls hat eine Zeichenfolge, die angibt, dass der Wert nicht erstellt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Aufrufen dieser Methode bewirkt keine Initialisierung.  
  
 Die <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> Eigenschaft kann `null` nach verzögerte Initialisierung, wenn die Factory-Methode ausgeführt wurde angegeben, für die `valueFactory` Parameter von der <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>, <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>, oder <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> Konstruktor zurück `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Die <see cref="P:System.Lazy`1.Value" />-Eigenschaft ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public T Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Value" />
      <MemberSignature Language="DocId" Value="P:System.Lazy`1.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T Value { T get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den verzögert initialisierten Wert der aktuellen <see cref="T:System.Lazy`1" />-Instanz ab.</summary>
        <value>Der verzögert initialisierte Wert der aktuellen <see cref="T:System.Lazy`1" />-Instanz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Lazy%601.IsValueCreated%2A?displayProperty=nameWithType> Eigenschaft `false`, den Zugriff auf die <xref:System.Lazy%601.Value%2A> Eigenschaft erzwingt die Initialisierung.  
  
 Zusätzlich zu den Ausnahmen, die aufgelistet werden, die <xref:System.Lazy%601.Value%2A> Eigenschaft festgehaltenen jede nicht behandelte Ausnahme, die von der Factorymethode ausgelöst wird, die übergeben wurde, die `valueFactory` Parameter von der <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>, <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>, oder <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> der Konstruktor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Die <see cref="T:System.Lazy`1" />-Instanz wird initialisiert, um den Standardkonstruktor des Typs zu verwenden, der verzögert initialisiert wird, und es fehlen Berechtigungen für den Zugriff auf den Konstruktor.</exception>
        <exception cref="T:System.MissingMemberException">Die <see cref="T:System.Lazy`1" />-Instanz wird initialisiert, um den Standardkonstruktor des Typs zu verwenden, der verzögert initialisiert wird. Dieser Typ besitzt keinen öffentlichen Konstruktor ohne Parameter.</exception>
        <exception cref="T:System.InvalidOperationException">Die Initialisierungsfunktion versucht, in dieser Instanz auf <see cref="P:System.Lazy`1.Value" /> zuzugreifen.</exception>
      </Docs>
    </Member>
  </Members>
</Type>