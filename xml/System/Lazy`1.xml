<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Lazy`1.xml" source-language="en-US" target-language="de-DE">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5ad53c03faf661b5a698d5ef0c4fcd9d0451bbc14.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ad53c03faf661b5a698d5ef0c4fcd9d0451bbc14</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>The type of object that is being lazily initialized.</source>
          <target state="translated">Der Typ des Objekts, das verzögert initialisiert wird.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Lazy`1">
          <source>Provides support for lazy initialization.</source>
          <target state="translated">Stellt Unterstützung für die verzögerte Initialisierung bereit.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>Use lazy initialization to defer the creation of a large or resource-intensive object, or the execution of a resource-intensive task, particularly when such creation or execution might not occur during the lifetime of the program.</source>
          <target state="translated">Verwenden Sie verzögerten Initialisierung, um die Erstellung eines großen oder ressourcenintensiven Objekts oder die Ausführung einer Aufgabe ressourcenintensiven verzögern, insbesondere dann, wenn eine solche erstellen oder die Ausführung nicht während der Lebensdauer des Programms auftreten kann.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>To prepare for lazy initialization, you create an instance of <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph>.</source>
          <target state="translated">Um für die verzögerte Initialisierung vorzubereiten, erstellen Sie eine Instanz des <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>The type argument of the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> object that you create specifies the type of the object that you want to initialize lazily.</source>
          <target state="translated">Das Typargument der <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> -Objekt, das Sie erstellen, gibt den Typ des Objekts, das verzögert initialisiert werden soll.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>The constructor that you use to create the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> object determines the characteristics of the initialization.</source>
          <target state="translated">Der Konstruktor, mit denen Sie erstellen die <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> Objekt bestimmt die Merkmale der Initialisierung.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>Lazy initialization occurs the first time the <ph id="ph1">&lt;xref:System.Lazy%601.Value%2A?displayProperty=nameWithType&gt;</ph> property is accessed.</source>
          <target state="translated">Die verzögerte Initialisierung tritt beim ersten Zugriff auf die <ph id="ph1">&lt;xref:System.Lazy%601.Value%2A?displayProperty=nameWithType&gt;</ph>-Eigenschaft auf.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>In most cases, choosing a constructor depends on your answers to two questions:</source>
          <target state="translated">In den meisten Fällen hängt die Antworten auf die zwei Fragen einen Konstruktor auswählen:</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>Will the lazily initialized object be accessed from more than one thread?</source>
          <target state="translated">Wird von mehreren Threads verzögert initialisierte Objekt werden zugegriffen?</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>If so, the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> object might create it on any thread.</source>
          <target state="translated">Wenn dies der Fall ist, die <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> Objekt möglicherweise auf einen beliebigen Thread erstellen.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>You can use one of the simple constructors whose default behavior is to create a thread-safe <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> object, so that only one instance of the lazily instantiated object is created no matter how many threads try to access it.</source>
          <target state="translated">Können Sie die einfache Konstruktoren, deren Standardverhalten besteht, erstellen Sie ein threadsicheres <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> Objekt, damit, dass nur eine Instanz des verzögert instanziierten Objekts erstellt wird, unabhängig davon, wie viele Threads versuchen, darauf zuzugreifen.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>To create a <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> object that is not thread safe, you must use a constructor that enables you to specify no thread safety.</source>
          <target state="translated">Zum Erstellen einer <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> Objekt, das nicht threadsicher ist, müssen Sie einen Konstruktor, der Ihnen ermöglicht, geben Sie keine Threadsicherheit verwenden.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>Making the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> object thread safe does not protect the lazily initialized object.</source>
          <target state="translated">Machen die <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> Objekt threadsicher schützt nicht die verzögert initialisierte Objekt.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>If multiple threads can access the lazily initialized object, you must make its properties and methods safe for multithreaded access.</source>
          <target state="translated">Wenn mehrere Threads die verzögert initialisierte Objekt zugreifen können, müssen Sie die Eigenschaften und Methoden für Multithreadzugriff sicher vornehmen.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>Does lazy initialization require a lot of code, or does the lazily initialized object have a default constructor that does everything you need and doesn't throw exceptions?</source>
          <target state="translated">Erfordert verzögerter Initialisierung viel Code oder verfügt das verzögert initialisierte Objekt über einen Standardkonstruktor, die alles, was Sie benötigen, und löst keine Ausnahmen aus?</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>If you need to write initialization code or if exceptions need to be handled, use one of the constructors that takes a factory method.</source>
          <target state="translated">Verwenden Sie Wenn Sie Initialisierungscode schreiben oder Ausnahmen behandelt werden müssen, eines Konstruktors, der eine Factorymethode akzeptiert.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>Write your initialization code in the factory method.</source>
          <target state="translated">Schreiben Sie den Initialisierungscode in der Factorymethode.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>The following table shows which constructor to choose, based on these two factors:</source>
          <target state="translated">In der folgenden Tabelle zeigt, welcher Konstruktor auf, basierend auf diese beiden Faktoren:</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>Object will be accessed by</source>
          <target state="translated">Objekt wird von den zugegriffen werden</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>If no initialization code is required (default constructor), use</source>
          <target state="translated">Wenn kein Initialisierungscode erforderlich ist (Standardkonstruktor) verwenden</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>If initialization code is required, use</source>
          <target state="translated">Wenn Code für die Initialisierung erforderlich ist, verwenden</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>Multiple threads</source>
          <target state="translated">Mehrere threads</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>One thread</source>
          <target state="translated">Ein thread</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source><ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Boolean%29&gt;</ph> with <ph id="ph2">`isThreadSafe`</ph> set to <ph id="ph3">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Boolean%29&gt;</ph> mit <ph id="ph2">`isThreadSafe`</ph> festgelegt <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source><ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29&gt;</ph> with <ph id="ph2">`isThreadSafe`</ph> set to <ph id="ph3">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29&gt;</ph> mit <ph id="ph2">`isThreadSafe`</ph> festgelegt <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>You can use a lambda expression to specify the factory method.</source>
          <target state="translated">Einen Lambda-Ausdruck können die Factory-Methode.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>This keeps all the initialization code in one place.</source>
          <target state="translated">Dadurch wird die gesamte Initialisierungscode an einem Ort.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>The lambda expression captures the context, including any arguments you pass to the lazily initialized object's constructor.</source>
          <target state="translated">Der Lambda-Ausdruck erfasst den Kontext, einschließlich der keine Argumente, die Sie den verzögert initialisierten Konstruktor des Objekts übergeben.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source><bpt id="p1">**</bpt>Exception caching<ept id="p1">**</ept> When you use factory methods, exceptions are cached.</source>
          <target state="translated"><bpt id="p1">**</bpt>Das Zwischenspeichern von Ausnahmen<ept id="p1">**</ept> bei Verwendung von Factorymethoden Ausnahmen werden zwischengespeichert.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>That is, if the factory method throws an exception the first time a thread tries to access the <ph id="ph1">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> property of the <ph id="ph2">&lt;xref:System.Lazy%601&gt;</ph> object, the same exception is thrown on every subsequent attempt.</source>
          <target state="translated">Das heißt, wenn die Factory-Methode löst eine der ersten Ausnahmezeit aus, ein Thread versucht den Zugriff auf die <ph id="ph1">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> Eigenschaft von der <ph id="ph2">&lt;xref:System.Lazy%601&gt;</ph> Objekt die gleiche Ausnahme wird bei jedem nachfolgenden Versuch ausgelöst.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>This ensures that every call to the <ph id="ph1">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> property produces the same result and avoids subtle errors that might arise if different threads get different results.</source>
          <target state="translated">Dadurch wird sichergestellt, dass jeder Aufruf der <ph id="ph1">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> Eigenschaft führt zum gleichen Ergebnis, und vermeidet Fehler auftreten, die auftreten können, wenn es sich bei verschiedenen Threads unterschiedliche Ergebnisse zu erhalten.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>The <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> stands in for an actual <ph id="ph2">`T`</ph> that otherwise would have been initialized at some earlier point, usually during startup.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> stellvertretend für ein tatsächliches <ph id="ph2">`T`</ph> , andernfalls würde initialisiert wurden zu einem früheren, in der Regel während des Starts.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>A failure at that earlier point is usually fatal.</source>
          <target state="translated">Ein Fehler auf diesen früheren Punkt wird in der Regel Schwerwiegender.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>If there is a potential for a recoverable failure, we recommend that you build the retry logic into the initialization routine (in this case, the factory method), just as you would if you weren’t using lazy initialization.</source>
          <target state="translated">Wenn es besteht die Gefahr eines Fehlers wiederhergestellt, wird empfohlen, dass die Wiederholungslogik in die Initialisierungsroutine (in diesem Fall die Factory-Methode), zu erstellen, wie Sie bei Verwendung von verzögerte Initialisierung datenträgerressourceneinstellungen wurden nicht.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source><bpt id="p1">**</bpt>Alternative to locking<ept id="p1">**</ept> In certain situations, you might want to avoid the overhead of the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> object's default locking behavior.</source>
          <target state="translated"><bpt id="p1">**</bpt>Alternative zum Sperren<ept id="p1">**</ept> In bestimmten Situationen möchten Sie möglicherweise den Aufwand zu vermeiden der <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> des Objekts Standard Sperrverhalten.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>In rare situations, there might be a potential for deadlocks.</source>
          <target state="translated">In seltenen Situationen können eine potenzielle Deadlocks vorhanden sein.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>In such cases, you can use the <ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29&gt;</ph> or <ph id="ph2">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29&gt;</ph> constructor, and specify <ph id="ph3">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">In solchen Fällen können Sie die <ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29&gt;</ph> oder <ph id="ph2">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29&gt;</ph> -Konstruktor, und geben Sie <ph id="ph3">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>This enables the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> object to create a copy of the lazily initialized object on each of several threads if the threads call the <ph id="ph2">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> property simultaneously.</source>
          <target state="translated">Dies ermöglicht die <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> Objekt, das eine Kopie der verzögert initialisierte Objekt auf jedem von mehreren Threads zu erstellen, wenn die Threads rufen die <ph id="ph2">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> Eigenschaft gleichzeitig.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>The <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> object ensures that all threads use the same instance of the lazily initialized object and discards the instances that are not used.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> Objekt wird sichergestellt, dass alle Threads dieselbe Instanz des verzögert initialisierten Objekts und verwirft die Instanzen, die nicht verwendet werden.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>Thus, the cost of reducing the locking overhead is that your program might sometimes create and discard extra copies of an expensive object.</source>
          <target state="translated">Daher ist der Aufwand verringert den Aufwand für das Sperren an, dass das Programm möglicherweise manchmal erstellen und zusätzliche Kopien ein teures Objekt zu verwerfen.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>In most cases, this is unlikely.</source>
          <target state="translated">In den meisten Fällen ist dies wahrscheinlich nicht.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>The examples for the <ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29&gt;</ph> constructors demonstrate this behavior.</source>
          <target state="translated">In den Beispielen für die <ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29&gt;</ph> und <ph id="ph2">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29&gt;</ph> Konstruktoren wird dieses Verhalten demonstriert.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>When you specify <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph>, exceptions are never cached, even if you specify a factory method.</source>
          <target state="translated">Geben Sie bei <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph>, Ausnahmen werden nie zwischengespeichert, selbst wenn Sie eine Factorymethode angeben.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source><bpt id="p1">**</bpt>Equivalent constructors<ept id="p1">**</ept> In addition to enabling the use of <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph>, the <ph id="ph2">&lt;xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29&gt;</ph> and <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29&gt;</ph> constructors can duplicate the functionality of the other constructors.</source>
          <target state="translated"><bpt id="p1">**</bpt>Entsprechende Konstruktoren<ept id="p1">**</ept> zusätzlich zum Aktivieren der Verwendung von <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29&gt;</ph> und <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29&gt;</ph> Konstruktoren können die Funktionalität der anderen Konstruktoren duplizieren.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>The following table shows the parameter values that produce equivalent behavior.</source>
          <target state="translated">Die folgende Tabelle zeigt die Parameterwerte, die ein gleichwertiges Verhalten zu erzeugen.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>To create a <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> object that is</source>
          <target state="translated">Zum Erstellen einer <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> -Objekt ab</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>For constructors that have a <ph id="ph1">`LazyThreadSafetyMode`</ph> <ph id="ph2">`mode`</ph> parameter, set <ph id="ph3">`mode`</ph> to</source>
          <target state="translated">Für Konstruktoren, haben eine <ph id="ph1">`LazyThreadSafetyMode`</ph> <ph id="ph2">`mode`</ph> Parametersatz, <ph id="ph3">`mode`</ph> an</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>For constructors that have a Boolean <ph id="ph1">`isThreadSafe`</ph> parameter, set <ph id="ph2">`isThreadSafe`</ph> to</source>
          <target state="translated">Für Konstruktoren, die einen booleschen Wert haben <ph id="ph1">`isThreadSafe`</ph> Parametersatz, <ph id="ph2">`isThreadSafe`</ph> an</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>For constructors with no thread safety parameters</source>
          <target state="translated">Konstruktoren ohne Parameter der Thread-Sicherheit</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>Fully thread safe; uses locking to ensure that only one thread initializes the value.</source>
          <target state="translated">Vollständig threadsicher; verwendet sperren, um sicherzustellen, dass nur ein Thread den Wert initialisiert.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>All such constructors are fully thread safe.</source>
          <target state="translated">Alle anderen Konstruktoren sind vollständig threadsicher.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>Not thread safe.</source>
          <target state="translated">Nicht threadsicher.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>Not applicable.</source>
          <target state="translated">Nicht zutreffend.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>Fully thread safe; threads race to initialize the value.</source>
          <target state="translated">Vollständig threadsicher; Threads Racebedingungen, um den Wert zu initialisieren.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>Not applicable.</source>
          <target state="translated">Nicht zutreffend.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>Not applicable.</source>
          <target state="translated">Nicht zutreffend.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source><bpt id="p1">**</bpt>Other capabilities<ept id="p1">**</ept> For information about the use of <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> with thread-static fields, or as the backing store for properties, see <bpt id="p2">[</bpt>Lazy Initialization<ept id="p2">](~/docs/framework/performance/lazy-initialization.md)</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>Andere Funktionen<ept id="p1">**</ept> Informationen zur Verwendung der <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> mit threadstatische Felder oder als Sicherungsspeicher für Eigenschaften, finden Sie unter <bpt id="p2">[</bpt>verzögerte Initialisierung<ept id="p2">](~/docs/framework/performance/lazy-initialization.md)</ept>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>The following example demonstrates the use of the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> class to provide lazy initialization with access from multiple threads.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die Verwendung von der <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> Klasse, um die verzögerte Initialisierung mit Zugriff von mehreren Threads bereitzustellen.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29&gt;</ph> constructor.</source>
          <target state="translated">Im Beispiel wird die <ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29&gt;</ph> Konstruktor.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>It also demonstrates the use of the <ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29&gt;</ph> constructor (specifying <ph id="ph2">`true`</ph> for <ph id="ph3">`isThreadSafe`</ph>) and the <ph id="ph4">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29&gt;</ph> constructor (specifying <ph id="ph5">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph> for <ph id="ph6">`mode`</ph>).</source>
          <target state="translated">Es zeigt auch die Verwendung von der <ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29&gt;</ph> Konstruktor (Angeben von <ph id="ph2">`true`</ph> für <ph id="ph3">`isThreadSafe`</ph>) und die <ph id="ph4">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29&gt;</ph> Konstruktor (angeben <ph id="ph5">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph> für <ph id="ph6">`mode`</ph>).</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>To switch to a different constructor, just change which constructors are commented out.</source>
          <target state="translated">Um einen anderen Konstruktor zu wechseln, ändern Sie einfach die Konstruktoren auskommentiert werden.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>For an example that demonstrates exception caching using the same constructors, see the <ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29&gt;</ph> constructor.</source>
          <target state="translated">Ein Beispiel für die Ausnahme caching mit den gleichen Konstruktoren finden Sie unter der <ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29&gt;</ph> Konstruktor.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>The example defines a <ph id="ph1">`LargeObject`</ph> class that will be initialized lazily by one of several threads.</source>
          <target state="translated">Im Beispiel wird eine <ph id="ph1">`LargeObject`</ph>-Klasse definiert, die durch einen von mehreren Threads verzögert initialisiert wird.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>The four key sections of code illustrate the creation of the initializer, the factory method, the actual initialization, and the constructor of the <ph id="ph1">`LargeObject`</ph> class, which displays a message when the object is created.</source>
          <target state="translated">Die vier wichtigsten Codeabschnitte veranschaulichen die Erstellung der Initialisierer, die Factory-Methode, die eigentliche Initialisierung und den Konstruktor des der <ph id="ph1">`LargeObject`</ph> -Klasse, die eine Meldung angezeigt, wenn das Objekt erstellt wird.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>At the beginning of the <ph id="ph1">`Main`</ph> method, the example creates the thread-safe lazy initializer for <ph id="ph2">`LargeObject`</ph>:</source>
          <target state="translated">Zu Anfang der <ph id="ph1">`Main`</ph>-Methode wird in diesem Beispiel ein threadsicherer verzögerter Initialisierer für <ph id="ph2">`LargeObject`</ph> erstellt:</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>The factory method shows the creation of the object, with a placeholder for further initialization:</source>
          <target state="translated">Die Factory-Methode veranschaulicht die Erstellung des Objekts, durch einen Platzhalter für die weitere Initialisierung:</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>Note that the first two code sections could be combined by using a lambda function, as shown here:</source>
          <target state="translated">Beachten Sie, dass die ersten beiden Codeabschnitte mithilfe einer Lambdafunktion kombiniert werden können, wie hier gezeigt:</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>The example pauses, to indicate that an indeterminate period may elapse before lazy initialization occurs.</source>
          <target state="translated">Im Beispiel wird angehalten, um anzugeben, dass für ein unbestimmter Zeitraum verstreichen kann, bevor die verzögerte Initialisierung auftritt.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>When you press the <bpt id="p1">**</bpt>Enter<ept id="p1">**</ept> key, the example creates and starts three threads.</source>
          <target state="translated">Beim Drücken der <bpt id="p1">**</bpt>EINGABETASTE<ept id="p1">**</ept> drücken, das Beispiel erstellt und startet drei Threads.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>The <ph id="ph1">`ThreadProc`</ph> method that's used by all three threads calls the <ph id="ph2">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> property.</source>
          <target state="translated">Die <ph id="ph1">`ThreadProc`</ph> -Methode, die durch Aufrufe für alle drei Threads verwendet, wird die <ph id="ph2">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>The first time this happens, the <ph id="ph1">`LargeObject`</ph> instance is created:</source>
          <target state="translated">In diesem Fall erstmalig den <ph id="ph1">`LargeObject`</ph> Instanz erstellt wird:</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>The constructor of the <ph id="ph1">`LargeObject`</ph> class, which includes the last key section of code, displays a message and records the identity of the initializing thread.</source>
          <target state="translated">Der Konstruktor, der die <ph id="ph1">`LargeObject`</ph> Klasse, die die letzte Schlüssel Codeabschnitt enthält, wird eine Meldung angezeigt, und zeichnet die Identität des beim Initialisieren des Threads.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>The output from the program appears at the end of the full code listing.</source>
          <target state="translated">Die Ausgabe des Programms wird am Ende der vollständige Beispielcode angezeigt.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>For simplicity, this example uses a global instance of <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph>, and all the methods are <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic).</source>
          <target state="translated">Der Einfachheit halber wird in diesem Beispiel eine globale Instanz von <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> verwendet, und alle Methoden sind <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>These are not requirements for the use of lazy initialization.</source>
          <target state="translated">Dies sind keine Anforderungen für die Verwendung der verzögerten Initialisierung.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>By default, all public and protected members of the <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph> class are thread safe and may be used concurrently from multiple threads.</source>
          <target state="translated">Standardmäßig werden alle öffentlichen und geschützten Member, der die <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph> Klasse sind threadsicher und können von mehreren Threads gleichzeitig verwendet werden.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Lazy`1">
          <source>These thread-safety guarantees may be removed optionally and per instance, using parameters to the type's constructors.</source>
          <target state="translated">Diese Garantien Threadsicherheit können optional und pro Instanz mit Parametern für den Konstruktoren des Typs entfernt werden.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="T:System.Lazy`1">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph> class.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph>-Klasse.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph> class.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph>-Klasse.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor">
          <source>When lazy initialization occurs, the default constructor of the target type is used.</source>
          <target state="translated">Wenn eine verzögerte Initialisierung auftritt, wird der Standardkonstruktor des Zieltyps verwendet.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor">
          <source>An instance that is created with this constructor may be used concurrently from multiple threads.</source>
          <target state="translated">Eine Instanz, die mit diesem Konstruktor erstellt wird, kann von mehreren Threads gleichzeitig verwendet werden.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor">
          <source>The thread safety mode of a <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance that is initialized with this constructor is <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Der Threadsicherheitsmodus eine <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> Instanz, die mit diesem Konstruktor initialisiert wird, ist <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor">
          <source>The thread safety mode describes the behavior when multiple threads try to initialize the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance.</source>
          <target state="translated">Der Threadsicherheitsmodus beschreibt das Verhalten, wenn mehrere Threads, zum Initialisieren versuchen der <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> Instanz.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor">
          <source>A <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance that is created with this constructor does not cache exceptions.</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> -Instanz, die mit diesem Konstruktor erstellt wird Ausnahmen nicht zwischengespeichert.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> class or the <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">Weitere Informationen finden Sie unter der <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph>-Klasse oder unter der <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType&gt;</ph>-Enumeration.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor">
          <source>The following example demonstrates the use of this constructor.</source>
          <target state="translated">Im folgende Beispiel wird die Verwendung dieses Konstruktors veranschaulicht.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor">
          <source>It also illustrates the use of the <ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Boolean%29&gt;</ph> constructor (specifying <ph id="ph2">`true`</ph> for <ph id="ph3">`isThreadSafe`</ph>) and the <ph id="ph4">&lt;xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29&gt;</ph> constructor (specifying <ph id="ph5">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph> for <ph id="ph6">`mode`</ph>).</source>
          <target state="translated">Es veranschaulicht auch die Verwendung von der <ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Boolean%29&gt;</ph> Konstruktor (Angeben von <ph id="ph2">`true`</ph> für <ph id="ph3">`isThreadSafe`</ph>) und die <ph id="ph4">&lt;xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29&gt;</ph> Konstruktor (angeben <ph id="ph5">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph> für <ph id="ph6">`mode`</ph>).</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor">
          <source>To switch to a different constructor, just change which constructors are commented out.</source>
          <target state="translated">Um einen anderen Konstruktor zu wechseln, ändern Sie einfach die Konstruktoren auskommentiert werden.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor">
          <source>The example defines a <ph id="ph1">`LargeObject`</ph> class that will be initialized lazily by one of several threads.</source>
          <target state="translated">Im Beispiel wird eine <ph id="ph1">`LargeObject`</ph>-Klasse definiert, die durch einen von mehreren Threads verzögert initialisiert wird.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor">
          <source>The two key lines of code in this example are the creation of the initializer and the actual initialization.</source>
          <target state="translated">Die zwei wichtigsten Codezeilen in diesem Beispiel werden die Erstellung von Initialisierer und die eigentliche Initialisierung.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor">
          <source>At the beginning of the <ph id="ph1">`Main`</ph> method, the example creates the thread-safe lazy initializer for <ph id="ph2">`LargeObject`</ph>:</source>
          <target state="translated">Zu Anfang der <ph id="ph1">`Main`</ph>-Methode wird in diesem Beispiel ein threadsicherer verzögerter Initialisierer für <ph id="ph2">`LargeObject`</ph> erstellt:</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor">
          <source>The example creates and starts three threads that block on a <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> object, so that the example can release the threads all at once.</source>
          <target state="translated">Das Beispiel erstellt und startet drei Threads, die eine Blockierung auf eine <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> Objekt, sodass das Beispiel die Threads gleichzeitig freigeben kann.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor">
          <source>The <ph id="ph1">`ThreadProc`</ph> method that's used by all three threads calls the <ph id="ph2">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> property to get the <ph id="ph3">`LargeObject`</ph> instance:</source>
          <target state="translated">Die <ph id="ph1">`ThreadProc`</ph> -Methode, die durch Aufrufe für alle drei Threads verwendet wird die <ph id="ph2">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> Eigenschaft, um die <ph id="ph3">`LargeObject`</ph> Instanz:</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor">
          <source>The <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> class provides locking, so that only one thread is allowed to create the <ph id="ph2">`LargeObject`</ph> instance.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> Klasse bietet sperren, sodass nur ein Thread, zum Erstellen zugelassen wird der <ph id="ph2">`LargeObject`</ph> Instanz.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor">
          <source>The example demonstrates that the other threads all get the same instance.</source>
          <target state="translated">Das Beispiel zeigt, dass andere Threads alle die gleiche Instanz abrufen.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor">
          <source>For simplicity, this example uses a global instance of <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph>, and all the methods are <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic).</source>
          <target state="translated">Der Einfachheit halber wird in diesem Beispiel eine globale Instanz von <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> verwendet, und alle Methoden sind <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor">
          <source>These are not requirements for the use of lazy initialization.</source>
          <target state="translated">Dies sind keine Anforderungen für die Verwendung der verzögerten Initialisierung.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to make this instance usable concurrently by multiple threads; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to make the instance usable by only one thread at a time.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, damit diese Instanz durch mehrere Threads gleichzeitig verwendet werden kann, <ph id="ph2">&lt;see langword="false" /&gt;</ph>, damit die Instanz nur von jeweils einem Thread verwendet werden kann.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph> class.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph>-Klasse.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Boolean)">
          <source>When lazy initialization occurs, the default constructor of the target type and the specified initialization mode are used.</source>
          <target state="translated">Bei einer verzögerten Initialisierung werden der Standardkonstruktor des Zieltyps und der angegebene Initialisierungsmodus verwendet.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Boolean)">
          <source>The thread safety mode of a <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance that is initialized with this constructor is <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph> if <ph id="ph3">`isThreadSafe`</ph> is <ph id="ph4">`true`</ph>; otherwise, the mode is <ph id="ph5">&lt;xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Der Threadsicherheitsmodus eine <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> Instanz, die mit diesem Konstruktor initialisiert wird, ist <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph> Wenn <ph id="ph3">`isThreadSafe`</ph> ist <ph id="ph4">`true`</ph>ist, andernfalls ist der Modus <ph id="ph5">&lt;xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Boolean)">
          <source>The thread safety mode describes the behavior when multiple threads try to initialize the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance.</source>
          <target state="translated">Der Threadsicherheitsmodus beschreibt das Verhalten, wenn mehrere Threads, zum Initialisieren versuchen der <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> Instanz.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Boolean)">
          <source>To specify the <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph> mode, use the <ph id="ph2">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29&gt;</ph> or <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29&gt;</ph> constructor.</source>
          <target state="translated">Angeben der <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph> Modus verwenden die <ph id="ph2">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29&gt;</ph> oder <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29&gt;</ph> Konstruktor.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Boolean)">
          <source>A <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance that is created with this constructor does not cache exceptions.</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> -Instanz, die mit diesem Konstruktor erstellt wird Ausnahmen nicht zwischengespeichert.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Boolean)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> class or the <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">Weitere Informationen finden Sie unter der <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph>-Klasse oder unter der <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType&gt;</ph>-Enumeration.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Boolean)">
          <source>The following example demonstrates the use of this constructor to create a lazy initializer that is not thread safe, for scenarios where all access to the lazily initialized object occurs on the same thread.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die Verwendung dieses Konstruktors eine verzögerte Initialisierung zu erstellen, die nicht threadsicher ist, für Szenarien ist, in der alle Zugriffe auf die verzögert initialisierte Objekt auf dem gleichen Thread auftritt.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Boolean)">
          <source>It also demonstrates the use of the <ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29&gt;</ph> constructor (specifying <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType&gt;</ph> for <ph id="ph3">`mode`</ph>.</source>
          <target state="translated">Es zeigt auch die Verwendung von der <ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29&gt;</ph> Konstruktor (Angeben von <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType&gt;</ph> für <ph id="ph3">`mode`</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Boolean)">
          <source>To switch to a different constructor, just change which constructor is commented out.</source>
          <target state="translated">Um einen anderen Konstruktor zu wechseln, ändern Sie einfach welcher Konstruktor auskommentiert ist.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Boolean)">
          <source>For code that demonstrates how to use this constructor in multithreaded scenarios (specifying <ph id="ph1">`true`</ph> for <ph id="ph2">`isThreadSafe`</ph>), see the example for the <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor&gt;</ph> constructor.</source>
          <target state="translated">Für Code, der veranschaulicht, wie dieser Konstruktor im Multithread-Szenarien (Angabe <ph id="ph1">`true`</ph> für <ph id="ph2">`isThreadSafe`</ph>), finden Sie im Beispiel für die <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor&gt;</ph> Konstruktor.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Boolean)">
          <source>The example defines a <ph id="ph1">`LargeObject`</ph> class that will be initialized lazily.</source>
          <target state="translated">Im Beispiel definiert eine <ph id="ph1">`LargeObject`</ph> -Klasse, die verzögert initialisiert wird.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Boolean)">
          <source>In the <ph id="ph1">`Main`</ph> method, the example creates a <ph id="ph2">&lt;xref:System.Lazy%601&gt;</ph> instance and then pauses.</source>
          <target state="translated">In der <ph id="ph1">`Main`</ph> -Methode, um das Beispiel erstellt eine <ph id="ph2">&lt;xref:System.Lazy%601&gt;</ph> Instanz und hält dann an.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Boolean)">
          <source>When you press the <bpt id="p1">**</bpt>Enter<ept id="p1">**</ept> key, the example accesses the <ph id="ph1">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> property of the <ph id="ph2">&lt;xref:System.Lazy%601&gt;</ph> instance, which causes initialization to occur.</source>
          <target state="translated">Beim Drücken der <bpt id="p1">**</bpt>EINGABETASTE<ept id="p1">**</ept> -Schlüssel im Beispiel greift auf die <ph id="ph1">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> Eigenschaft von der <ph id="ph2">&lt;xref:System.Lazy%601&gt;</ph> -Instanz, die führt dazu, dass bei der Initialisierung auftreten.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Boolean)">
          <source>The constructor of the <ph id="ph1">`LargeObject`</ph> class displays a console message.</source>
          <target state="translated">Der Konstruktor, der die <ph id="ph1">`LargeObject`</ph> Klasse zeigt eine konsolenmeldung an.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Boolean)">
          <source>For simplicity, this example uses a global instance of <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph>, and all the methods are <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic).</source>
          <target state="translated">Der Einfachheit halber wird in diesem Beispiel eine globale Instanz von <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> verwendet, und alle Methoden sind <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Boolean)">
          <source>These are not requirements for the use of lazy initialization.</source>
          <target state="translated">Dies sind keine Anforderungen für die Verwendung der verzögerten Initialisierung.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>The delegate that is invoked to produce the lazily initialized value when it is needed.</source>
          <target state="translated">Der Delegat, der aufgerufen wird, um bei Bedarf den verzögert initialisierten Wert zu erzeugen.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph> class.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph>-Klasse.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>When lazy initialization occurs, the specified initialization function is used.</source>
          <target state="translated">Bei einer verzögerten Initialisierung wird die angegebene Initialisierungsfunktion verwendet.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>An instance that is created with this constructor may be used concurrently from multiple threads.</source>
          <target state="translated">Eine Instanz, die mit diesem Konstruktor erstellt wird, kann von mehreren Threads gleichzeitig verwendet werden.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>The thread safety mode of a <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance that is initialized with this constructor is <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Der Threadsicherheitsmodus eine <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> Instanz, die mit diesem Konstruktor initialisiert wird, ist <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>The thread safety mode describes the behavior when multiple threads try to initialize the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance.</source>
          <target state="translated">Der Threadsicherheitsmodus beschreibt das Verhalten, wenn mehrere Threads, zum Initialisieren versuchen der <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> Instanz.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>Exceptions that are thrown by <ph id="ph1">`valueFactory`</ph> are cached.</source>
          <target state="translated">Durch ausgelöste Ausnahmen <ph id="ph1">`valueFactory`</ph> zwischengespeichert werden.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> class or the <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">Weitere Informationen finden Sie unter der <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph>-Klasse oder unter der <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType&gt;</ph>-Enumeration.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>The following example demonstrates the use of this constructor to provide lazy initialization with exception caching.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die Verwendung dieses Konstruktors verzögerte Initialisierung mit Ausnahme Zwischenspeichern bereitstellen.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>It also demonstrates the use of the <ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29&gt;</ph> constructor (specifying <ph id="ph2">`true`</ph> for <ph id="ph3">`isThreadSafe`</ph>) and the <ph id="ph4">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29&gt;</ph> constructor (specifying <ph id="ph5">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph> for <ph id="ph6">`mode`</ph>).</source>
          <target state="translated">Es zeigt auch die Verwendung von der <ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29&gt;</ph> Konstruktor (Angeben von <ph id="ph2">`true`</ph> für <ph id="ph3">`isThreadSafe`</ph>) und die <ph id="ph4">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29&gt;</ph> Konstruktor (angeben <ph id="ph5">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph> für <ph id="ph6">`mode`</ph>).</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>To switch to a different constructor, just change which constructors are commented out.</source>
          <target state="translated">Um einen anderen Konstruktor zu wechseln, ändern Sie einfach die Konstruktoren auskommentiert werden.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>The example defines a <ph id="ph1">`LargeObject`</ph> class that will be initialized lazily by one of several threads.</source>
          <target state="translated">Im Beispiel wird eine <ph id="ph1">`LargeObject`</ph>-Klasse definiert, die durch einen von mehreren Threads verzögert initialisiert wird.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>The three key sections of code illustrate the creation of the initializer, the actual initialization, and the constructor of the <ph id="ph1">`LargeObject`</ph> class, which demonstrates exception caching.</source>
          <target state="translated">Die drei wichtigsten Codeabschnitte veranschaulichen die Erstellung der Initialisierer, die eigentliche Initialisierung und den Konstruktor des der <ph id="ph1">`LargeObject`</ph> -Klasse, die Zwischenspeichern von Ausnahmen veranschaulicht.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>At the beginning of the <ph id="ph1">`Main`</ph> method, the example creates the thread-safe lazy initializer for <ph id="ph2">`LargeObject`</ph>:</source>
          <target state="translated">Zu Anfang der <ph id="ph1">`Main`</ph>-Methode wird in diesem Beispiel ein threadsicherer verzögerter Initialisierer für <ph id="ph2">`LargeObject`</ph> erstellt:</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>The example creates and starts three threads.</source>
          <target state="translated">Das Beispiel erstellt und startet drei Threads.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>The <ph id="ph1">`ThreadProc`</ph> method that's used by all three threads calls the <ph id="ph2">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> property to get the <ph id="ph3">`LargeObject`</ph> instance:</source>
          <target state="translated">Die <ph id="ph1">`ThreadProc`</ph> -Methode, die durch Aufrufe für alle drei Threads verwendet wird die <ph id="ph2">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> Eigenschaft, um die <ph id="ph3">`LargeObject`</ph> Instanz:</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>In the constructor of the <ph id="ph1">`LargeObject`</ph> class, the third key section of code throws an exception the first time a <ph id="ph2">`LargeObject`</ph> instance is created, but thereafter allows instance creation to occur:</source>
          <target state="translated">Im Konstruktor der der <ph id="ph1">`LargeObject`</ph> -Klasse, die wichtigsten dritte Codeabschnitt löst eine Ausnahme erstmalig eine <ph id="ph2">`LargeObject`</ph> Instanz erstellt, aber danach instanzerstellung auftreten können:</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>When the example is run, the first thread that tries to create an instance of <ph id="ph1">`LargeObject`</ph> fails, and the exception is caught.</source>
          <target state="translated">Wenn das Beispiel ausgeführt wird, wird den ersten Thread, der versucht, die zum Erstellen einer Instanz von <ph id="ph1">`LargeObject`</ph> schlägt fehl, und die Ausnahme abgefangen wird.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>You might expect that the next thread would successfully create an instance, but the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> object has cached the exception.</source>
          <target state="translated">Sie erwarten wahrscheinlich, dass der nächste Thread erfolgreich eine Instanz erstellen, würden jedoch <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> Objekt hat die Ausnahme zwischengespeichert.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>Because of this, all three threads throw the exception.</source>
          <target state="translated">Aus diesem Grund werden alle drei Threads die Ausnahme auslösen.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>For simplicity, this example uses a global instance of <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph>, and all the methods are <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic).</source>
          <target state="translated">Der Einfachheit halber wird in diesem Beispiel eine globale Instanz von <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> verwendet, und alle Methoden sind <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source>These are not requirements for the use of lazy initialization.</source>
          <target state="translated">Dies sind keine Anforderungen für die Verwendung der verzögerten Initialisierung.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Func{`0})">
          <source><ph id="ph1">&lt;paramref name="valueFactory" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="valueFactory" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>One of the enumeration values that specifies the thread safety mode.</source>
          <target state="translated">Einer der Enumerationswerte, der den Threadsicherheitsmodus angibt.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph> class that uses the default constructor of <ph id="ph2">&lt;paramref name="T" /&gt;</ph> and the specified thread-safety mode.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph>-Klasse, die den Standardkonstruktor von <ph id="ph2">&lt;paramref name="T" /&gt;</ph> und einen angegebenen Threadsicherheitsmodus verwendet.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>The thread safety mode of a <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance describes the behavior when multiple threads try to initialize the <ph id="ph2">&lt;xref:System.Lazy%601&gt;</ph> instance.</source>
          <target state="translated">Der Threadsicherheitsmodus eine <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> Instanz beschreibt das Verhalten, wenn mehrere Threads, zum Initialisieren versuchen der <ph id="ph2">&lt;xref:System.Lazy%601&gt;</ph> Instanz.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>A <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance that is created with this constructor does not cache exceptions.</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> -Instanz, die mit diesem Konstruktor erstellt wird Ausnahmen nicht zwischengespeichert.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> class or the <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">Weitere Informationen finden Sie unter der <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph>-Klasse oder unter der <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType&gt;</ph>-Enumeration.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>The following example demonstrates the use of this constructor to create a lazy initializer that enables multiple threads to race to create an object lazily.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die Verwendung dieses Konstruktors eine verzögerte Initialisierung zu erstellen, die können mehrere Threads Rennen verzögert ein Objekt zu erstellen.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>Multiple threads might succeed in creating instances, but all threads use the instance that was created first.</source>
          <target state="translated">Mehrere Threads möglicherweise bei der Erstellung von Instanzen erfolgreich, doch alle Threads verwenden Sie die Instanz, die erstmalig erstellt wurde.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>For an example that demonstrates how to use this constructor in single-threaded scenarios (specifying <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType&gt;</ph> for <ph id="ph2">`mode`</ph>), see the <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor%28System.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">Ein Beispiel für die Verwendung dieses Konstruktors in Singlethread-Szenarien veranschaulicht (Angeben von <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType&gt;</ph> für <ph id="ph2">`mode`</ph>), finden Sie unter der <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor%28System.Boolean%29&gt;</ph> Konstruktor.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>For an example that demonstrates how to use this constructor to provide locking instead of race conditions in multithreaded scenarios (specifying <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph> for <ph id="ph2">`mode`</ph>), see the <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor&gt;</ph> constructor.</source>
          <target state="translated">Ein Beispiel für die Verwendung dieses Konstruktors angeben, Sperren anstelle der Racebedingungen im Multithread-Szenarien veranschaulicht (Angeben von <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph> für <ph id="ph2">`mode`</ph>), finden Sie unter der <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor&gt;</ph> Konstruktor.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>The example defines a <ph id="ph1">`LargeObject`</ph> class that will be initialized lazily by any of several threads.</source>
          <target state="translated">Im Beispiel definiert eine <ph id="ph1">`LargeObject`</ph> -Klasse, die von einer von mehreren Threads verzögert initialisiert wird.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>The three key sections of code illustrate the creation of the initializer, the actual initialization, and the constructor and finalizer of the <ph id="ph1">`LargeObject`</ph> class.</source>
          <target state="translated">Die drei wichtigsten Codeabschnitte veranschaulichen die Erstellung der Initialisierer, die eigentliche Initialisierung und den Konstruktor und Finalizer des der <ph id="ph1">`LargeObject`</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>At the beginning of the <ph id="ph1">`Main`</ph> method, the example creates the <ph id="ph2">&lt;xref:System.Lazy%601&gt;</ph> object that performs lazy initialization of the <ph id="ph3">`LargeObject`</ph>:</source>
          <target state="translated">Am Anfang der <ph id="ph1">`Main`</ph> -Methode, um das Beispiel erstellt die <ph id="ph2">&lt;xref:System.Lazy%601&gt;</ph> -Objekt, das verzögerte Initialisierung von führt die <ph id="ph3">`LargeObject`</ph>:</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>The example creates and starts three threads that block on a <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> object, so that the example can release the threads all at once.</source>
          <target state="translated">Das Beispiel erstellt und startet drei Threads, die eine Blockierung auf eine <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> Objekt, sodass das Beispiel die Threads gleichzeitig freigeben kann.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>In the <ph id="ph1">`ThreadProc`</ph> method that's used by all three threads, calling the <ph id="ph2">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> property creates the <ph id="ph3">`LargeObject`</ph> instance:</source>
          <target state="translated">In der <ph id="ph1">`ThreadProc`</ph> -Methode, die von allen drei Threads Aufrufen verwendet wird, die <ph id="ph2">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> Eigenschaft erstellt die <ph id="ph3">`LargeObject`</ph> Instanz:</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>Because the constructor for the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance specified <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph>, all three threads are allowed to create <ph id="ph3">`LargeObject`</ph> instances.</source>
          <target state="translated">Da der Konstruktor für die <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> angegebenen Instanz <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph>, dürfen alle drei Threads erstellen <ph id="ph3">`LargeObject`</ph> Instanzen.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>The example demonstrates this by displaying console messages in the constructor and in the finalizer of the <ph id="ph1">`LargeObject`</ph> class:</source>
          <target state="translated">Das Beispiel veranschaulicht das Anzeigen von konsolenmeldungen im Konstruktor und in der Finalize-Methode der der <ph id="ph1">`LargeObject`</ph> Klasse:</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>However, the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> object ensures that only one instance is used by all threads.</source>
          <target state="translated">Allerdings die <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> Objekt wird sichergestellt, dass nur eine Instanz wird von allen Threads verwendet.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>The output from the example shows that all three threads use the same instance, and also shows that the other two instances can be reclaimed by garbage collection.</source>
          <target state="translated">Die Ausgabe des Beispiels zeigt, dass alle drei Threads verwendet, die dieselbe Instanz, und zeigt außerdem, dass die beiden anderen Instanzen von der Garbagecollection freigegeben werden können.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>For simplicity, this example uses a global instance of <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph>, and all the methods are <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic).</source>
          <target state="translated">Der Einfachheit halber wird in diesem Beispiel eine globale Instanz von <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> verwendet, und alle Methoden sind <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source>These are not requirements for the use of lazy initialization.</source>
          <target state="translated">Dies sind keine Anforderungen für die Verwendung der verzögerten Initialisierung.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> contains an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> enthält einen ungültigen Wert.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>The delegate that is invoked to produce the lazily initialized value when it is needed.</source>
          <target state="translated">Der Delegat, der aufgerufen wird, um bei Bedarf den verzögert initialisierten Wert zu erzeugen.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to make this instance usable concurrently by multiple threads; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to make this instance usable by only one thread at a time.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, damit diese Instanz durch mehrere Threads gleichzeitig verwendet werden kann, <ph id="ph2">&lt;see langword="false" /&gt;</ph>, damit diese Instanz nur von jeweils einem Thread verwendet werden kann.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph> class.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph>-Klasse.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>When lazy initialization occurs, the specified initialization function and initialization mode are used.</source>
          <target state="translated">Bei einer verzögerten Initialisierung werden die angegebene Initialisierungsfunktion und der angegebene Initialisierungsmodus verwendet.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>The thread safety mode of a <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance that is initialized with this constructor is <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph> if <ph id="ph3">`isThreadSafe`</ph> is <ph id="ph4">`true`</ph>; otherwise, the mode is <ph id="ph5">&lt;xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Der Threadsicherheitsmodus eine <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> Instanz, die mit diesem Konstruktor initialisiert wird, ist <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph> Wenn <ph id="ph3">`isThreadSafe`</ph> ist <ph id="ph4">`true`</ph>ist, andernfalls ist der Modus <ph id="ph5">&lt;xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>The thread safety mode describes the behavior when multiple threads try to initialize the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance.</source>
          <target state="translated">Der Threadsicherheitsmodus beschreibt das Verhalten, wenn mehrere Threads, zum Initialisieren versuchen der <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> Instanz.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>To specify the <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph> mode, use the <ph id="ph2">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29&gt;</ph> or <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29&gt;</ph> constructor.</source>
          <target state="translated">Angeben der <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph> Modus verwenden die <ph id="ph2">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29&gt;</ph> oder <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29&gt;</ph> Konstruktor.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>Exceptions that are thrown by <ph id="ph1">`valueFactory`</ph> are cached.</source>
          <target state="translated">Durch ausgelöste Ausnahmen <ph id="ph1">`valueFactory`</ph> zwischengespeichert werden.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> class or the <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">Weitere Informationen finden Sie unter der <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph>-Klasse oder unter der <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType&gt;</ph>-Enumeration.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>The following example demonstrates the use of this constructor to provide lazy initialization with exception caching, in a scenario with a single thread.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die Verwendung dieses Konstruktors verzögerten Initialisierung mit der Ausnahme, die in einem Szenario mit einem einzelnen Thread Zwischenspeichern bereitstellen.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>It also demonstrates the use of the  <ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%2A&gt;</ph> constructor (specifying <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType&gt;</ph> for <ph id="ph3">`mode`</ph>).</source>
          <target state="translated">Es zeigt auch die Verwendung von der <ph id="ph1">&lt;xref:System.Lazy%601.%23ctor%2A&gt;</ph> Konstruktor (Angeben von <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType&gt;</ph> für <ph id="ph3">`mode`</ph>).</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>To switch to that constructor, just change which constructor is commented out.</source>
          <target state="translated">Um diesen Konstruktor zu wechseln, ändern Sie einfach welcher Konstruktor auskommentiert ist.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>For code that demonstrates how to use this constructor in multithreaded scenarios (specifying <ph id="ph1">`true`</ph> for <ph id="ph2">`isThreadSafe`</ph>), see the example for the <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29&gt;</ph> constructor.</source>
          <target state="translated">Für Code, der veranschaulicht, wie dieser Konstruktor im Multithread-Szenarien (Angabe <ph id="ph1">`true`</ph> für <ph id="ph2">`isThreadSafe`</ph>), finden Sie im Beispiel für die <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29&gt;</ph> Konstruktor.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>The example defines a <ph id="ph1">`LargeObject`</ph> class that will be initialized lazily by one of several threads.</source>
          <target state="translated">Im Beispiel wird eine <ph id="ph1">`LargeObject`</ph>-Klasse definiert, die durch einen von mehreren Threads verzögert initialisiert wird.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>The three key sections of code illustrate the creation of the initializer, the actual initialization, and the constructor of the <ph id="ph1">`LargeObject`</ph> class, which demonstrates exception caching.</source>
          <target state="translated">Die drei wichtigsten Codeabschnitte veranschaulichen die Erstellung der Initialisierer, die eigentliche Initialisierung und den Konstruktor des der <ph id="ph1">`LargeObject`</ph> -Klasse, die Zwischenspeichern von Ausnahmen veranschaulicht.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>At the beginning of the <ph id="ph1">`Main`</ph> method, the example creates the thread-safe lazy initializer for <ph id="ph2">`LargeObject`</ph>:</source>
          <target state="translated">Zu Anfang der <ph id="ph1">`Main`</ph>-Methode wird in diesem Beispiel ein threadsicherer verzögerter Initialisierer für <ph id="ph2">`LargeObject`</ph> erstellt:</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>In the call to the constructor, the <ph id="ph1">`isThreadSafe`</ph> parameter is <ph id="ph2">`false`</ph>, so the <ph id="ph3">&lt;xref:System.Lazy%601&gt;</ph> is not thread safe.</source>
          <target state="translated">Im Aufruf an den Konstruktor der <ph id="ph1">`isThreadSafe`</ph> Parameter ist <ph id="ph2">`false`</ph>, sodass die <ph id="ph3">&lt;xref:System.Lazy%601&gt;</ph> ist nicht threadsicher.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>Because it's not thread safe, the example calls the <ph id="ph1">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> property three times on the same thread:</source>
          <target state="translated">Da sie nicht threadsicher ist, wird im Beispiel wird die <ph id="ph1">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> Eigenschaft dreimal auf dem gleichen Thread:</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>In the constructor of the <ph id="ph1">`LargeObject`</ph> class, the third key section of code throws an exception the first time a <ph id="ph2">`LargeObject`</ph> instance is created, but thereafter allows instance creation to occur:</source>
          <target state="translated">Im Konstruktor der der <ph id="ph1">`LargeObject`</ph> -Klasse, die wichtigsten dritte Codeabschnitt löst eine Ausnahme erstmalig eine <ph id="ph2">`LargeObject`</ph> Instanz erstellt, aber danach instanzerstellung auftreten können:</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>When the example is run, the first attempt to create an instance of <ph id="ph1">`LargeObject`</ph> fails, and the exception is caught.</source>
          <target state="translated">Wenn das Beispiel ausgeführt wird, wird der erste Versuch zum Erstellen einer Instanz von <ph id="ph1">`LargeObject`</ph> schlägt fehl, und die Ausnahme abgefangen wird.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>You might expect that the next attempt would succeed, but the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> object has cached the exception.</source>
          <target state="translated">Sie erwarten wahrscheinlich, dass der nächste Versuch erfolgreich ist, aber die <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> Objekt hat die Ausnahme zwischengespeichert.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>Because of this, all three attempts throw the exception.</source>
          <target state="translated">Aus diesem Grund werden alle drei Versuche der Ausnahme auslösen.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>For simplicity, this example uses a global instance of <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph>, and all the methods are <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic).</source>
          <target state="translated">Der Einfachheit halber wird in diesem Beispiel eine globale Instanz von <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> verwendet, und alle Methoden sind <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source>These are not requirements for the use of lazy initialization.</source>
          <target state="translated">Dies sind keine Anforderungen für die Verwendung der verzögerten Initialisierung.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="valueFactory" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="valueFactory" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>The delegate that is invoked to produce the lazily initialized value when it is needed.</source>
          <target state="translated">Der Delegat, der aufgerufen wird, um bei Bedarf den verzögert initialisierten Wert zu erzeugen.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>One of the enumeration values that specifies the thread safety mode.</source>
          <target state="translated">Einer der Enumerationswerte, der den Threadsicherheitsmodus angibt.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph> class that uses the specified initialization function and thread-safety mode.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph>-Klasse, die die angegebene Initialisierungsfunktion und den angegebenen Threadsicherheitsmodus verwendet.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>The thread safety mode of a <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance describes the behavior when multiple threads try to initialize the <ph id="ph2">&lt;xref:System.Lazy%601&gt;</ph> instance.</source>
          <target state="translated">Der Threadsicherheitsmodus eine <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> Instanz beschreibt das Verhalten, wenn mehrere Threads, zum Initialisieren versuchen der <ph id="ph2">&lt;xref:System.Lazy%601&gt;</ph> Instanz.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>Exceptions that are thrown by <ph id="ph1">`valueFactory`</ph> are cached, unless <ph id="ph2">`mode`</ph> is <ph id="ph3">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Durch ausgelöste Ausnahmen <ph id="ph1">`valueFactory`</ph> zwischengespeichert werden, es sei denn, <ph id="ph2">`mode`</ph> ist <ph id="ph3">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> class or the <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">Weitere Informationen finden Sie unter der <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph>-Klasse oder unter der <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType&gt;</ph>-Enumeration.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>The following example demonstrates the use of this constructor to create a lazy initializer that enables multiple threads to race to create an object lazily.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die Verwendung dieses Konstruktors eine verzögerte Initialisierung zu erstellen, die können mehrere Threads Rennen verzögert ein Objekt zu erstellen.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>Multiple threads might succeed in creating instances, but all threads use the instance that was created first.</source>
          <target state="translated">Mehrere Threads möglicherweise bei der Erstellung von Instanzen erfolgreich, doch alle Threads verwenden Sie die Instanz, die erstmalig erstellt wurde.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>In addition, the example demonstrates that exceptions are never cached when you specify <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph>, even if initialization is performed by a function instead of by the default constructor of the lazily created type.</source>
          <target state="translated">Darüber hinaus im Beispiel wird veranschaulicht, dass Ausnahmen nicht zwischengespeichert werden, bei der Angabe <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph>, selbst wenn die Initialisierung von einer Funktion anstelle von durch den Standardkonstruktor des Typs verzögert erstellte ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>For an example that demonstrates how to use this constructor in single-threaded scenarios (specifying <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType&gt;</ph> for <ph id="ph2">`mode`</ph>), see the <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor%28System.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">Ein Beispiel für die Verwendung dieses Konstruktors in Singlethread-Szenarien veranschaulicht (Angeben von <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType&gt;</ph> für <ph id="ph2">`mode`</ph>), finden Sie unter der <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor%28System.Boolean%29&gt;</ph> Konstruktor.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>For an example that demonstrates how to use this constructor to provide locking instead of race conditions in multithreaded scenarios (specifying <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph> for <ph id="ph2">`mode`</ph>), see the <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor&gt;</ph> constructor.</source>
          <target state="translated">Ein Beispiel für die Verwendung dieses Konstruktors angeben, Sperren anstelle der Racebedingungen im Multithread-Szenarien veranschaulicht (Angeben von <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph> für <ph id="ph2">`mode`</ph>), finden Sie unter der <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor&gt;</ph> Konstruktor.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>The example defines a <ph id="ph1">`LargeObject`</ph> class that will be initialized lazily by any of several threads.</source>
          <target state="translated">Im Beispiel definiert eine <ph id="ph1">`LargeObject`</ph> -Klasse, die von einer von mehreren Threads verzögert initialisiert wird.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>The four key sections of code illustrate the creation of the initializer, the actual initialization, the initialization function, and the constructor and finalizer of the <ph id="ph1">`LargeObject`</ph> class.</source>
          <target state="translated">Die vier wichtigsten Abschnitte des Codes zu veranschaulichen, die Erstellung der Initialisierer, die eigentliche Initialisierung, die Initialisierungsfunktion und den Konstruktor und Finalizer, der die <ph id="ph1">`LargeObject`</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>At the beginning of the <ph id="ph1">`Main`</ph> method, the example creates the <ph id="ph2">&lt;xref:System.Lazy%601&gt;</ph> object that performs lazy initialization of the <ph id="ph3">`LargeObject`</ph>:</source>
          <target state="translated">Am Anfang der <ph id="ph1">`Main`</ph> -Methode, um das Beispiel erstellt die <ph id="ph2">&lt;xref:System.Lazy%601&gt;</ph> -Objekt, das verzögerte Initialisierung von führt die <ph id="ph3">`LargeObject`</ph>:</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>The lazy initializer uses a function to perform the initialization.</source>
          <target state="translated">Die verzögerte Initialisierung verwendet eine Funktion, um die Initialisierung auszuführen.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>In this case, a function is required because there is no default constructor for the <ph id="ph1">`LargeObject`</ph> class.</source>
          <target state="translated">In diesem Fall ist eine Funktion erforderlich, da es kein Standardkonstruktor für ist die <ph id="ph1">`LargeObject`</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>The example creates and starts three threads that block on a <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> object, so that the example can release the threads all at once.</source>
          <target state="translated">Das Beispiel erstellt und startet drei Threads, die eine Blockierung auf eine <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> Objekt, sodass das Beispiel die Threads gleichzeitig freigeben kann.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>In the <ph id="ph1">`ThreadProc`</ph> method that's used by all three threads, calling the <ph id="ph2">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> property creates the <ph id="ph3">`LargeObject`</ph> instance:</source>
          <target state="translated">In der <ph id="ph1">`ThreadProc`</ph> -Methode, die von allen drei Threads Aufrufen verwendet wird, die <ph id="ph2">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> Eigenschaft erstellt die <ph id="ph3">`LargeObject`</ph> Instanz:</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>In the third key section of code, the lazy initialization function is called to create the <ph id="ph1">`LargeObject`</ph> instance.</source>
          <target state="translated">Im dritten Key Abschnitt des Codes, die verzögerte Initialisierung-Funktion aufgerufen, um erstellen die <ph id="ph1">`LargeObject`</ph> Instanz.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>The function throws an exception the first time it's called:</source>
          <target state="translated">Die Funktion löst eine Ausnahme das erste Mal aufgerufen wird:</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>With any other <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode&gt;</ph> setting, an unhandled exception in the initialization function would be cached.</source>
          <target state="translated">Bei einem anderen <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode&gt;</ph> festlegen, würde eine nicht behandelte Ausnahme in die Initialisierungsfunktion zwischengespeichert werden.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>However, <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph> suppresses exception caching.</source>
          <target state="translated">Allerdings <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph> unterdrückt das Zwischenspeichern von Ausnahmen.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>The output from the example demonstrates that a subsequent attempt to initialize the object succeeds.</source>
          <target state="translated">Die Ausgabe des Beispiels zeigt, erfolgreich ausgeführt wird, ein anschließenden Versuch, das Objekt zu initialisieren.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>The exception message usually appears after messages indicating that other threads have successfully initialized the object.</source>
          <target state="translated">Die Ausnahmemeldung wird in der Regel nach den Nachrichten, die angibt, dass andere Threads das Objekt erfolgreich initialisiert haben, angezeigt.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>This is because of the delay introduced by throwing and catching the exception.</source>
          <target state="translated">Dies ist die Verzögerung, die durch das Auslösen und Abfangen der Ausnahme eingeführt.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>Because the constructor for the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance specified <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph>, all three threads are allowed to create <ph id="ph3">`LargeObject`</ph> instances.</source>
          <target state="translated">Da der Konstruktor für die <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> angegebenen Instanz <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph>, dürfen alle drei Threads erstellen <ph id="ph3">`LargeObject`</ph> Instanzen.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>The example demonstrates this by displaying console messages in the constructor and in the finalizer of the <ph id="ph1">`LargeObject`</ph> class:</source>
          <target state="translated">Das Beispiel veranschaulicht das Anzeigen von konsolenmeldungen im Konstruktor und in der Finalize-Methode der der <ph id="ph1">`LargeObject`</ph> Klasse:</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>The <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> object ensures that only one instance is used by all threads (except the thread where the initialization function throws an exception).</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> Objekt wird sichergestellt, dass nur eine Instanz von allen Threads (mit Ausnahme des Threads, in dem die Initialisierungsfunktion löst eine Ausnahme aus) verwendet wird.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>The output from the example shows this.</source>
          <target state="translated">Die Ausgabe im Beispiel zeigt dies.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>For simplicity, this example uses a global instance of <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph>, and all the methods are <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic).</source>
          <target state="translated">Der Einfachheit halber wird in diesem Beispiel eine globale Instanz von <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> verwendet, und alle Methoden sind <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source>These are not requirements for the use of lazy initialization.</source>
          <target state="translated">Dies sind keine Anforderungen für die Verwendung der verzögerten Initialisierung.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> contains an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> enthält einen ungültigen Wert.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)">
          <source><ph id="ph1">&lt;paramref name="valueFactory" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="valueFactory" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="P:System.Lazy`1.IsValueCreated">
          <source>Gets a value that indicates whether a value has been created for this <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph> instance.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob ein Wert für diese <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph>-Instanz erstellt wurde.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Lazy`1.IsValueCreated">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if a value has been created for this <ph id="ph2">&lt;see cref="T:System.Lazy`1" /&gt;</ph> instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn für diese <ph id="ph2">&lt;see cref="T:System.Lazy`1" /&gt;</ph>-Instanz ein Wert erstellt wurde, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Lazy`1.IsValueCreated">
          <source>When lazy initialization occurs for a <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance, it may result in either a value being created or an exception being thrown.</source>
          <target state="translated">Wenn die verzögerter Initialisierung auftritt, für eine <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> Instanz er möglicherweise einen Wert, der erstellt wird oder eine Ausnahme ausgelöst.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Lazy`1.IsValueCreated">
          <source>If an exception is thrown, subsequent behavior of the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance depends on whether exception caching is in effect.</source>
          <target state="translated">Wenn eine Ausnahme ausgelöst wird, werden nachfolgende Verhalten ist das <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> Instanz, hängt davon ab, ob das Zwischenspeichern von Ausnahmen aktiviert ist.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Lazy`1.IsValueCreated">
          <source>If the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance was created by using a constructor that does not specify an initialization function, then exception caching is not in effect.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> Instanz mithilfe eines Konstruktors, der keine Initialisierungsfunktion erstellt wurde, und das Zwischenspeichern von Ausnahmen ist nicht gültig.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Lazy`1.IsValueCreated">
          <source>A subsequent attempt to initialize the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> might succeed, and after successful initialization the <ph id="ph2">&lt;xref:System.Lazy%601.IsValueCreated%2A&gt;</ph> property returns <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Ein nachfolgender Versuch zum Initialisieren der <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> zwar erfolgreich sein, und nach der erfolgreichen Initialisierung der <ph id="ph2">&lt;xref:System.Lazy%601.IsValueCreated%2A&gt;</ph> -Eigenschaft gibt <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Lazy`1.IsValueCreated">
          <source>If the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance was created with an initialization function (specified by the <ph id="ph2">`valueFactory`</ph> parameter of the <ph id="ph3">&lt;xref:System.Lazy%601&gt;</ph> constructor), then exception caching is controlled by the thread safety mode.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> Instanz mit einer Initialisierungsfunktion erstellt wurde (gemäß der <ph id="ph2">`valueFactory`</ph> Parameter von der <ph id="ph3">&lt;xref:System.Lazy%601&gt;</ph> Konstruktor), und klicken Sie dann das Zwischenspeichern von Ausnahmen von den Threadsicherheitsmodus gesteuert wird.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Lazy`1.IsValueCreated">
          <source>If the mode is <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType&gt;</ph>, there is no second chance to initialize the <ph id="ph3">&lt;xref:System.Lazy%601&gt;</ph> instance.</source>
          <target state="translated">Wenn der Modus ist <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType&gt;</ph> oder <ph id="ph2">&lt;xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType&gt;</ph>, es besteht keine zweite Möglichkeit zum Initialisieren der <ph id="ph3">&lt;xref:System.Lazy%601&gt;</ph> Instanz.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Lazy`1.IsValueCreated">
          <source>If an exception occurs and is unhandled in the initialization function, that exception is cached and rethrown on subsequent accesses of the <ph id="ph1">&lt;xref:System.Lazy%601.Value%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Wenn eine Ausnahme tritt auf, und wird nicht in die Initialisierungsfunktion behandelt, wird diese Ausnahme zwischengespeichert und erneut ausgelöst, bei nachfolgenden Zugriffen auf die <ph id="ph1">&lt;xref:System.Lazy%601.Value%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Lazy`1.IsValueCreated">
          <source>No value is created if an exception is thrown, so in such cases <ph id="ph1">&lt;xref:System.Lazy%601.IsValueCreated%2A&gt;</ph> returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Es wird kein Wert erstellt, wenn eine Ausnahme ausgelöst wird, in einem solchen Fall <ph id="ph1">&lt;xref:System.Lazy%601.IsValueCreated%2A&gt;</ph> gibt <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Lazy`1.IsValueCreated">
          <source>If the mode is <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph>, the first thread that succeeds in running the initialization function (or the default constructor) creates the value for the <ph id="ph2">&lt;xref:System.Lazy%601&gt;</ph> instance.</source>
          <target state="translated">Wenn der Modus ist <ph id="ph1">&lt;xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType&gt;</ph>, der erste Thread, der die Initialisierungsfunktion (oder den Standardkonstruktor) erfolgreich ausführt, erstellt den Wert für die <ph id="ph2">&lt;xref:System.Lazy%601&gt;</ph> Instanz.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Lazy`1.IsValueCreated">
          <source>If the initialization function throws an exception on one thread, other threads can still try to initialize the <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> instance.</source>
          <target state="translated">Wenn die Initialisierungsfunktion in einem Thread eine Ausnahme auslöst, können andere Threads trotzdem initialisiert werden, versuchen die <ph id="ph1">&lt;xref:System.Lazy%601&gt;</ph> Instanz.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Lazy`1.IsValueCreated">
          <source>Until the value is created, the <ph id="ph1">&lt;xref:System.Lazy%601.IsValueCreated%2A&gt;</ph> property returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Bis der Wert erstellt wird, die <ph id="ph1">&lt;xref:System.Lazy%601.IsValueCreated%2A&gt;</ph> -Eigenschaft gibt <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.ToString">
          <source>Creates and returns a string representation of the <ph id="ph1">&lt;see cref="P:System.Lazy`1.Value" /&gt;</ph> property for this instance.</source>
          <target state="translated">Erstellt eine Zeichenfolgendarstellung der <ph id="ph1">&lt;see cref="P:System.Lazy`1.Value" /&gt;</ph>-Eigenschaft für diese Instanz und gibt sie zurück.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.ToString">
          <source>The result of calling the <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> method on the <ph id="ph2">&lt;see cref="P:System.Lazy`1.Value" /&gt;</ph> property for this instance, if the value has been created (that is, if the <ph id="ph3">&lt;see cref="P:System.Lazy`1.IsValueCreated" /&gt;</ph> property returns <ph id="ph4">&lt;see langword="true" /&gt;</ph>).</source>
          <target state="translated">Das Ergebnis des Aufrufs der <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph>-Methode für die <ph id="ph2">&lt;see cref="P:System.Lazy`1.Value" /&gt;</ph>-Eigenschaft dieser Instanz, wenn der Wert erstellt wurde (d. h., wenn die <ph id="ph3">&lt;see cref="P:System.Lazy`1.IsValueCreated" /&gt;</ph>-Eigenschaft <ph id="ph4">&lt;see langword="true" /&gt;</ph> zurückgibt).</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.ToString">
          <source>Otherwise, a string indicating that the value has not been created.</source>
          <target state="translated">Andernfalls hat eine Zeichenfolge, die angibt, dass der Wert nicht erstellt wurde.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.ToString">
          <source>Calling this method does not cause initialization.</source>
          <target state="translated">Beim Aufrufen dieser Methode bewirkt keine Initialisierung.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Lazy`1.ToString">
          <source>The <ph id="ph1">&lt;xref:System.Lazy%601.Value%2A?displayProperty=nameWithType&gt;</ph> property can be <ph id="ph2">`null`</ph> after lazy initialization if the factory method that was specified for the <ph id="ph3">`valueFactory`</ph> parameter of the <ph id="ph4">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29&gt;</ph>, <ph id="ph5">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29&gt;</ph>, or <ph id="ph6">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29&gt;</ph> constructor returns <ph id="ph7">`null`</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Lazy%601.Value%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft kann <ph id="ph2">`null`</ph> nach verzögerte Initialisierung, wenn die Factory-Methode ausgeführt wurde angegeben, für die <ph id="ph3">`valueFactory`</ph> Parameter von der <ph id="ph4">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29&gt;</ph>, <ph id="ph5">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29&gt;</ph>, oder <ph id="ph6">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29&gt;</ph> Konstruktor zurück <ph id="ph7">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Lazy`1.ToString">
          <source>The <ph id="ph1">&lt;see cref="P:System.Lazy`1.Value" /&gt;</ph> property is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="P:System.Lazy`1.Value" /&gt;</ph>-Eigenschaft ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="P:System.Lazy`1.Value">
          <source>Gets the lazily initialized value of the current <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph> instance.</source>
          <target state="translated">Ruft den verzögert initialisierten Wert der aktuellen <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph>-Instanz ab.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Lazy`1.Value">
          <source>The lazily initialized value of the current <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph> instance.</source>
          <target state="translated">Der verzögert initialisierte Wert der aktuellen <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph>-Instanz.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Lazy`1.Value">
          <source>If the <ph id="ph1">&lt;xref:System.Lazy%601.IsValueCreated%2A?displayProperty=nameWithType&gt;</ph> property is <ph id="ph2">`false`</ph>, accessing the <ph id="ph3">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> property forces initialization.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Lazy%601.IsValueCreated%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft <ph id="ph2">`false`</ph>, den Zugriff auf die <ph id="ph3">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> Eigenschaft erzwingt die Initialisierung.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Lazy`1.Value">
          <source>In addition to the exceptions that are listed, the <ph id="ph1">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> property can throw any unhandled exception that is thrown by the factory method that was passed to the <ph id="ph2">`valueFactory`</ph> parameter of the <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29&gt;</ph>, <ph id="ph4">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29&gt;</ph>, or <ph id="ph5">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">Zusätzlich zu den Ausnahmen, die aufgelistet werden, die <ph id="ph1">&lt;xref:System.Lazy%601.Value%2A&gt;</ph> Eigenschaft festgehaltenen jede nicht behandelte Ausnahme, die von der Factorymethode ausgelöst wird, die übergeben wurde, die <ph id="ph2">`valueFactory`</ph> Parameter von der <ph id="ph3">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29&gt;</ph>, <ph id="ph4">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29&gt;</ph>, oder <ph id="ph5">&lt;xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29&gt;</ph> der Konstruktor.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="P:System.Lazy`1.Value">
          <source>The <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph> instance is initialized to use the default constructor of the type that is being lazily initialized, and permissions to access the constructor are missing.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph>-Instanz wird initialisiert, um den Standardkonstruktor des Typs zu verwenden, der verzögert initialisiert wird, und es fehlen Berechtigungen für den Zugriff auf den Konstruktor.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="P:System.Lazy`1.Value">
          <source>The <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph> instance is initialized to use the default constructor of the type that is being lazily initialized, and that type does not have a public, parameterless constructor.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="T:System.Lazy`1" /&gt;</ph>-Instanz wird initialisiert, um den Standardkonstruktor des Typs zu verwenden, der verzögert initialisiert wird. Dieser Typ besitzt keinen öffentlichen Konstruktor ohne Parameter.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="P:System.Lazy`1.Value">
          <source>The initialization function tries to access <ph id="ph1">&lt;see cref="P:System.Lazy`1.Value" /&gt;</ph> on this instance.</source>
          <target state="translated">Die Initialisierungsfunktion versucht, in dieser Instanz auf <ph id="ph1">&lt;see cref="P:System.Lazy`1.Value" /&gt;</ph> zuzugreifen.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>