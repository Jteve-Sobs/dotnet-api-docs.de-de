<Type Name="Lazy&lt;T&gt;" FullName="System.Lazy&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8a08e490433f3e23816cdfd6030b67d5925db996" /><Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="11/29/2018" /><Meta Name="ms.locfileid" Value="52590399" /></Metadata><TypeSignature Language="C#" Value="public class Lazy&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Lazy`1&lt;T&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Lazy`1" />
  <TypeSignature Language="VB.NET" Value="Public Class Lazy(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class Lazy" />
  <TypeSignature Language="F#" Value="type Lazy&lt;'T&gt; = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("ThreadSafetyMode={Mode}, IsValueCreated={IsValueCreated}, IsValueFaulted={IsValueFaulted}, Value={ValueForDebugDisplay}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.System_LazyDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Der Typ des Objekts, das verzögert initialisiert wird.</typeparam>
    <summary>Stellt Unterstützung für die verzögerte Initialisierung bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie verzögerten Initialisierung, um die Erstellung einer großen oder ressourcenintensiven-Objekts, oder die Ausführung einer Aufgabe mit großem Ressourcenaufwand verzögern, insbesondere dann, wenn eine solche erstellen oder die Ausführung nicht während der Lebensdauer des Programms auftreten kann.  
  
 Zur Vorbereitung der verzögerten Initialisierung, die Sie erstellen eine Instanz des <xref:System.Lazy%601>. Das Typargument, der die <xref:System.Lazy%601> -Objekt, das Sie erstellen, gibt den Typ des Objekts, das verzögert initialisiert werden soll. Der Konstruktor, mit denen Sie erstellen die <xref:System.Lazy%601> Objekts bestimmen die Eigenschaften der Initialisierung. Die verzögerte Initialisierung tritt beim ersten Zugriff auf die <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType>-Eigenschaft auf.  
  
 In den meisten Fällen hängt die Antworten auf zwei Fragen einen Konstruktor auswählen:  
  
-   Wird die verzögert initialisierte Objekt von mehreren Threads werden zugegriffen? Wenn dies der Fall ist, die <xref:System.Lazy%601> Objekt können sie auf einem beliebigen Thread erstellen. Können Sie eines einfachen Konstruktors, deren Standardverhalten ist, erstellen Sie eine threadsichere <xref:System.Lazy%601> Objekt, so dass nur eine Instanz des verzögert instanziierten Objekts erstellt wird, unabhängig davon, wie viele Threads versuchen, darauf zuzugreifen. Zum Erstellen einer <xref:System.Lazy%601> Objekt, das nicht threadsicher ist, müssen Sie einen Konstruktor, der Ihnen ermöglicht, geben Sie keine Threadsicherheit verwenden.  
  
    > [!CAUTION]
    >  Wodurch die <xref:System.Lazy%601> Objekt threadsicher bietet keinen Schutz für die verzögert initialisierte Objekt. Wenn mehrere Threads, die verzögert initialisierte Objekt zugreifen können, müssen Sie die Eigenschaften und Methoden für Speicherzugriffs in Multithreadanwendungen.  
  
-   Erfordert verzögerter Initialisierung viel Code, oder verfügt das verzögert initialisierte Objekt über einen Standardkonstruktor, die alles, was Sie benötigen, und löst keine Ausnahmen aus? Verwenden Sie Wenn Sie Code zum Initialisieren der schreiben müssen oder Ausnahmen behandelt werden müssen, einen der Konstruktoren, die eine Factorymethode verwendet. Schreiben Sie den Initialisierungscode in der Factorymethode.  
  
 Die folgende Tabelle zeigt die Konstruktor auf, basierend auf diesen zwei Faktoren:  
  
|Objekt wird vom zugegriffen werden|Wenn kein Code für die Initialisierung erforderlich ist (Standard-Konstruktor) verwenden|Wenn der Code für die Initialisierung erforderlich ist, verwenden|  
|--------------------------------|------------------------------------------------------------------------|---------------------------------------------|  
|Mehrere threads|<xref:System.Lazy%601.%23ctor>|<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>|  
|Ein thread|<xref:System.Lazy%601.%23ctor%28System.Boolean%29> mit `isThreadSafe` festgelegt `false`.|<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> mit `isThreadSafe` festgelegt `false`.|  
  
 Sie können einen Lambda-Ausdruck verwenden, an die Factorymethode. Auf diese Weise die gesamte Initialisierungscode in einem zentralen Ort. Der Lambda-Ausdruck erfasst den Kontext, einschließlich von Argumenten, die Sie an den verzögert initialisierten Konstruktor des Objekts übergeben.  
  
 **Zwischenspeichern von Ausnahmen** bei Verwendung von Factorymethoden Ausnahmen werden zwischengespeichert. D.h., wenn die Factory-Methode löst eine Ausnahme beim ersten Mal aus, ein Thread versucht, Zugriff auf die <xref:System.Lazy%601.Value%2A> Eigenschaft der <xref:System.Lazy%601> Objekt ist, wird die gleiche Ausnahme wird bei jedem nachfolgenden Versuch ausgelöst. Dadurch wird sichergestellt, dass für jeden Aufruf der <xref:System.Lazy%601.Value%2A> Eigenschaft führt zum gleichen Ergebnis, und vermeidet Fehler auftreten, die auftreten können, wenn unterschiedliche Threads verschiedene Ergebnisse zu erhalten. Die <xref:System.Lazy%601> stellvertretend für eine tatsächliche `T` , andernfalls würde initialisiert wurden zu einem früheren Zeitpunkt, in der Regel während des Starts. An diesem Punkt früheren ist in der Regel Schwerwiegender. Wenn es besteht die Gefahr für eine wiederherstellbare Fehler, empfehlen wir, dass Sie die Wiederholungslogik in der Initialisierungsroutine (in diesem Fall die Factorymethode), integrieren, wie wenn Sie die verzögerten Initialisierung verwenden würden.  
  
 **Alternative zum Sperren** In bestimmten Situationen möchten Sie möglicherweise den Mehraufwand zu vermeiden der <xref:System.Lazy%601> des Objekts Standard Sperrverhaltens. In seltenen Fällen liegt möglicherweise ein Potenzial für Deadlocks. In solchen Fällen können Sie die <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> oder <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> -Konstruktor, und geben Sie <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>. Dies ermöglicht die <xref:System.Lazy%601> Objekt, das eine Kopie des Objekts verzögert initialisierte auf jedem von mehreren Threads zu erstellen, wenn die Threads rufen die <xref:System.Lazy%601.Value%2A> Eigenschaft gleichzeitig. Die <xref:System.Lazy%601> Objekt wird sichergestellt, dass alle Threads dieselbe Instanz des Objekts verzögert initialisierte und verwirft die Instanzen, die nicht verwendet werden. Daher ist die Kosten der Aufwand für Sperren zu reduzieren, dass das Programm möglicherweise manchmal erstellen und zusätzliche Kopien ein teures Objekt zu verwerfen. In den meisten Fällen ist dies wahrscheinlich nicht. Die Beispiele für die <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> und <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> Konstruktoren wird dieses Verhalten demonstriert.  
  
> [!IMPORTANT]
>  Beim Angeben von <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, Ausnahmen werden nie zwischengespeichert, selbst wenn Sie eine Factorymethode angeben.  
  
 **Entsprechende Konstruktoren** zusätzlich zum Aktivieren der Verwendung von <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> und <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> Konstruktoren können die Funktionalität von den anderen Konstruktoren duplizieren. Die folgende Tabelle zeigt die Werte der Parameter, die entsprechende Verhalten zu erzeugen.  
  
|Zum Erstellen einer <xref:System.Lazy%601> -Standardobjekt ab|Für Konstruktoren, die eine `LazyThreadSafetyMode` `mode` Parametersatz, `mode` auf|Für Konstruktoren, die einen booleschen Wert haben `isThreadSafe` Parametersatz, `isThreadSafe` auf|Für Konstruktoren mit keine Threadsicherheitsparameter|  
|-------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------|-------------------------------------------------------|  
|Vollständig threadsicher; verwendet sperren, um sicherzustellen, dass nur ein Thread auf den Wert initialisiert.|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|Alle diese Konstruktoren sind vollständig threadsicher.|  
|Nicht threadsicher.|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|Nicht zutreffend.|  
|Vollständig threadsicher; Threads Rennen um den Wert zu initialisieren.|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|Nicht zutreffend.|Nicht zutreffend.|  
  
 **Andere Funktionen** Informationen zur Verwendung von <xref:System.Lazy%601> mit threadstatische Felder oder als Sicherungsspeicher für Eigenschaften, finden Sie unter [verzögerte Initialisierung](~/docs/framework/performance/lazy-initialization.md).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Verwendung der <xref:System.Lazy%601> Klasse, um verzögerte Initialisierung, beim Zugriff von mehreren Threads bereitzustellen.  
  
> [!NOTE]
>  Im Beispiel wird die <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> Konstruktor. Es zeigt auch die Verwendung von der <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> Konstruktor (Angeben von `true` für `isThreadSafe`) und die <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> Konstruktor (angeben <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> für `mode`). Um in einen anderen Konstruktor wechseln, ändern Sie einfach die Konstruktoren auskommentiert werden.  
>   
>  Ein Beispiel für die Ausnahme mithilfe der gleichen Konstruktoren, finden Sie unter den <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> Konstruktor.  
  
 Im Beispiel wird eine `LargeObject`-Klasse definiert, die durch einen von mehreren Threads verzögert initialisiert wird. Die vier wichtigsten Abschnitte des Codes veranschaulichen die Erstellung der Initialisierer, die Factorymethode, die eigentliche Initialisierung und den Konstruktor der `LargeObject` -Klasse, die eine Meldung angezeigt, wenn das Objekt erstellt wird. Zu Anfang der `Main`-Methode wird in diesem Beispiel ein threadsicherer verzögerter Initialisierer für `LargeObject` erstellt:  
  
 [!code-csharp[System.Lazy\`1#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#newlazy)]  
  
 Die Factorymethode zeigt die Erstellung des Objekts, mit einem Platzhalter für die weitere Initialisierung:  
  
 [!code-csharp[System.Lazy\`1#FactoryFunc](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#factoryfunc)]
 [!code-vb[System.Lazy\`1#FactoryFunc](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#factoryfunc)]  
  
 Beachten Sie, dass die ersten beiden Codeabschnitten mithilfe einer Lambdafunktion kombiniert werden können, wie hier gezeigt:  
  
 [!code-csharp[System.Lazy\`1#InitWithLambda](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/lambda.cs#initwithlambda)]
 [!code-vb[System.Lazy\`1#InitWithLambda](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/lambda.vb#initwithlambda)]  
  
 Im Beispiel wird angehalten, um anzugeben, dass für ein unbestimmter Zeitraum abläuft, bevor die verzögerte Initialisierung auftritt. Beim Drücken der **EINGABETASTE** Schlüssel, das Beispiel erstellt und startet drei Threads. Die `ThreadProc` -Methode, die durch Aufrufe für alle drei Threads verwendet, wird die <xref:System.Lazy%601.Value%2A> Eigenschaft. Beim ersten in diesem Fall die `LargeObject` Instanz erstellt wird:  
  
 [!code-csharp[System.Lazy\`1#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#valueprop)]  
  
 Der Konstruktor, der die `LargeObject` -Klasse, die wichtigsten letzten Abschnitt des Codes enthält, wird eine Meldung angezeigt, und zeichnet die Identität des Threads wird initialisiert. Am Ende das vollständige Codebeispiel wird die Ausgabe des Programms angezeigt.  
  
 [!code-csharp[System.Lazy\`1#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#largector)]  
  
> [!NOTE]
>  Der Einfachheit halber wird in diesem Beispiel eine globale Instanz von <xref:System.Lazy%601> verwendet, und alle Methoden sind `static` (`Shared` in Visual Basic). Dies sind keine Anforderungen für die Verwendung der verzögerten Initialisierung.  
  
 [!code-csharp[System.Lazy\`1#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#all)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Standardmäßig werden alle öffentlichen und geschützten Member, der die <see cref="T:System.Lazy`1" /> Klasse sind threadsicher und können von mehreren Threads gleichzeitig verwendet werden. Diese Garantien für Threadsicherheit können optional und pro Instanz, die mit Parametern für den Konstruktoren des Typs entfernt werden.</threadsafe>
    <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
    <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Verzögerte Initialisierung</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Lazy`1" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Lazy`1" />-Klasse. Wenn eine verzögerte Initialisierung auftritt, wird der Standardkonstruktor des Zieltyps verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Instanz, die mit diesem Konstruktor erstellt wird, kann von mehreren Threads gleichzeitig verwendet werden.  
  
 Der Threadsicherheitsmodus eine <xref:System.Lazy%601> Instanz, die mit diesem Konstruktor initialisiert wird, ist <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>. Der Threadsicherheitsmodus beschreibt das Verhalten, wenn mehrere Threads, zum Initialisieren versuchen der <xref:System.Lazy%601> Instanz.  
  
 Ein <xref:System.Lazy%601> -Instanz, die mit diesem Konstruktor erstellt wird werden die Ausnahmen nicht zwischengespeichert. Weitere Informationen finden Sie unter der <xref:System.Lazy%601>-Klasse oder unter der <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>-Enumeration.  
  
   
  
## Examples  
 Im folgende Beispiel wird die Verwendung dieses Konstruktors veranschaulicht. Es veranschaulicht auch die Verwendung von der <xref:System.Lazy%601.%23ctor%28System.Boolean%29> Konstruktor (Angeben von `true` für `isThreadSafe`) und die <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> Konstruktor (angeben <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> für `mode`). Um in einen anderen Konstruktor wechseln, ändern Sie einfach die Konstruktoren auskommentiert werden.  
  
 Im Beispiel wird eine `LargeObject`-Klasse definiert, die durch einen von mehreren Threads verzögert initialisiert wird. Die beiden wichtigsten Zeilen des Codes in diesem Beispiel werden die Erstellung der Initialisierer und die eigentliche Initialisierung. Zu Anfang der `Main`-Methode wird in diesem Beispiel ein threadsicherer verzögerter Initialisierer für `LargeObject` erstellt:  
  
 [!code-csharp[System.Lazy\`1.ctor#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctor#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#newlazy)]  
  
 Das Beispiel erstellt und startet drei Threads, die eine Blockierung auf einem <xref:System.Threading.ManualResetEvent> Objekt, um das Beispiel die Threads gleichzeitig freigeben kann. Die `ThreadProc` -Methode, die durch Aufrufe für alle drei Threads verwendet wird die <xref:System.Lazy%601.Value%2A> -Eigenschaft zum Abrufen der `LargeObject` Instanz:  
  
 [!code-csharp[System.Lazy\`1.ctor#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctor#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#valueprop)]  
  
 Die <xref:System.Lazy%601> Klasse bietet sperren, sodass nur ein Thread, zum Erstellen zugreifen kann der `LargeObject` Instanz. Das Beispiel zeigt, dass die anderen Threads, die alle die gleiche Instanz zu erhalten.  
  
> [!NOTE]
>  Der Einfachheit halber wird in diesem Beispiel eine globale Instanz von <xref:System.Lazy%601> verwendet, und alle Methoden sind `static` (`Shared` in Visual Basic). Dies sind keine Anforderungen für die Verwendung der verzögerten Initialisierung.  
  
 [!code-csharp[System.Lazy\`1.ctor#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctor#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Verzögerte Initialisierung</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (bool isThreadSafe);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool isThreadSafe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (isThreadSafe As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(bool isThreadSafe);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : bool -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; isThreadSafe" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="isThreadSafe" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isThreadSafe"><see langword="true" />, damit diese Instanz gleichzeitig von mehreren Threads verwendet werden kann; <see langword="false" />, damit die Instanz jeweils nur von einem Thread verwendet werden kann.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Lazy`1" />-Klasse. Bei einer verzögerten Initialisierung werden der Standardkonstruktor des Zieltyps und der angegebene Initialisierungsmodus verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Threadsicherheitsmodus eine <xref:System.Lazy%601> Instanz, die mit diesem Konstruktor initialisiert wird, ist <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> Wenn `isThreadSafe` ist `true`ist, andernfalls wird der Modus <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>. Der Threadsicherheitsmodus beschreibt das Verhalten, wenn mehrere Threads, zum Initialisieren versuchen der <xref:System.Lazy%601> Instanz. Angeben der <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> Modus der <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> oder <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> Konstruktor.  
  
 Ein <xref:System.Lazy%601> -Instanz, die mit diesem Konstruktor erstellt wird werden die Ausnahmen nicht zwischengespeichert. Weitere Informationen finden Sie unter der <xref:System.Lazy%601>-Klasse oder unter der <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>-Enumeration.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung dieses Konstruktors eine verzögerte Initialisierung zu erstellen, die nicht threadsicher ist, für Szenarien, in dem alle Zugriffe auf die verzögert initialisierte Objekt auf dem gleichen Thread auftritt. Es zeigt auch die Verwendung der <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> Konstruktor (Angeben von <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> für `mode`. Um in einen anderen Konstruktor wechseln, ändern Sie einfach die Konstruktor auskommentiert ist.  
  
> [!NOTE]
>  Für Code, der zeigt, wie Sie diesen Konstruktor in Multithread-Szenarien verwenden (Angeben von `true` für `isThreadSafe`), siehe das Beispiel für die <xref:System.Lazy%601.%23ctor> Konstruktor.  
  
 Das Beispiel definiert eine `LargeObject` -Klasse, die verzögert initialisiert wird. In der `Main` -Methode, um das Beispiel erstellt eine <xref:System.Lazy%601> -Instanz und hält dann an. Beim Drücken der **EINGABETASTE** drücken, im Beispiel wird auf die <xref:System.Lazy%601.Value%2A> Eigenschaft der <xref:System.Lazy%601> -Instanz, die Initialisierung ausgeführt wird. Der Konstruktor, der die `LargeObject` Klasse zeigt eine konsolenmeldung an.  
  
> [!NOTE]
>  Der Einfachheit halber wird in diesem Beispiel eine globale Instanz von <xref:System.Lazy%601> verwendet, und alle Methoden sind `static` (`Shared` in Visual Basic). Dies sind keine Anforderungen für die Verwendung der verzögerten Initialisierung.  
  
 [!code-csharp[System.Lazy\`1.ctorBool#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorbool/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorBool#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorbool/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Verzögerte Initialisierung</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; valueFactory" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Der Delegat, der aufgerufen wird, um bei Bedarf den verzögert initialisierten Wert zu erzeugen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Lazy`1" />-Klasse. Bei einer verzögerten Initialisierung wird die angegebene Initialisierungsfunktion verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Instanz, die mit diesem Konstruktor erstellt wird, kann von mehreren Threads gleichzeitig verwendet werden.  
  
 Der Threadsicherheitsmodus eine <xref:System.Lazy%601> Instanz, die mit diesem Konstruktor initialisiert wird, ist <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>. Der Threadsicherheitsmodus beschreibt das Verhalten, wenn mehrere Threads, zum Initialisieren versuchen der <xref:System.Lazy%601> Instanz.  
  
 Ausnahmen, die ausgelöst werden, indem `valueFactory` zwischengespeichert werden. Weitere Informationen finden Sie unter der <xref:System.Lazy%601>-Klasse oder unter der <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>-Enumeration.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung dieses Konstruktors für die verzögerten Initialisierung mit Zwischenspeichern von Ausnahmen angeben. Es zeigt auch die Verwendung von der <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> Konstruktor (Angeben von `true` für `isThreadSafe`) und die <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> Konstruktor (angeben <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> für `mode`). Um in einen anderen Konstruktor wechseln, ändern Sie einfach die Konstruktoren auskommentiert werden.  
  
 Im Beispiel wird eine `LargeObject`-Klasse definiert, die durch einen von mehreren Threads verzögert initialisiert wird. Die drei wichtigsten Abschnitte des Codes veranschaulichen die Erstellung der Initialisierer, die eigentliche Initialisierung und den Konstruktor der `LargeObject` -Klasse, die Zwischenspeichern von Ausnahmen veranschaulicht. Zu Anfang der `Main`-Methode wird in diesem Beispiel ein threadsicherer verzögerter Initialisierer für `LargeObject` erstellt:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFunc#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#newlazy)]  
  
 Das Beispiel erstellt und startet drei Threads. Die `ThreadProc` -Methode, die durch Aufrufe für alle drei Threads verwendet wird die <xref:System.Lazy%601.Value%2A> -Eigenschaft zum Abrufen der `LargeObject` Instanz:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFunc#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#valueprop)]  
  
 Im Konstruktor des der `LargeObject` -Klasse, die dritte wichtige Codeabschnitt löst eine Ausnahme beim ersten ein `LargeObject` Instanz wird erstellt, aber danach ermöglicht das Erstellen von Instanz auftreten:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1.ctorFunc#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#largector)]  
  
 Wenn das Beispiel ausgeführt wird, wird den ersten Thread, der versucht, eine Instanz erstellen `LargeObject` schlägt fehl, und die Ausnahme abgefangen wird. Sie erwarten wahrscheinlich, dass der nächste Thread wurde erfolgreich eine Instanz erstellen, würde aber die <xref:System.Lazy%601> Objekt hat die Ausnahme zwischengespeichert. Aus diesem Grund werden alle drei Threads die Ausnahme auslösen.  
  
> [!NOTE]
>  Der Einfachheit halber wird in diesem Beispiel eine globale Instanz von <xref:System.Lazy%601> verwendet, und alle Methoden sind `static` (`Shared` in Visual Basic). Dies sind keine Anforderungen für die Verwendung der verzögerten Initialisierung.  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFunc#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="valueFactory" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Verzögerte Initialisierung</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (System.Threading.LazyThreadSafetyMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LazyThreadSafetyMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mode As LazyThreadSafetyMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(System::Threading::LazyThreadSafetyMode mode);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : System.Threading.LazyThreadSafetyMode -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; mode" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mode" Type="System.Threading.LazyThreadSafetyMode" />
      </Parameters>
      <Docs>
        <param name="mode">Einer der Enumerationswerte, der den Threadsicherheitsmodus angibt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Lazy`1" />-Klasse, die den Standardkonstruktor von <paramref name="T" /> und den angegebenen Threadsicherheitsmodus verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Threadsicherheitsmodus eine <xref:System.Lazy%601> Instanz beschreibt das Verhalten, wenn mehrere Threads, zum Initialisieren versuchen der <xref:System.Lazy%601> Instanz.  
  
 Ein <xref:System.Lazy%601> -Instanz, die mit diesem Konstruktor erstellt wird werden die Ausnahmen nicht zwischengespeichert. Weitere Informationen finden Sie unter der <xref:System.Lazy%601>-Klasse oder unter der <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>-Enumeration.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung dieses Konstruktors einen verzögerten Initialisierer zu erstellen, der können von mehreren Threads, um ein Objekt erstellen, verzögert die man anfliegt. Mehrere Threads möglicherweise bei der Erstellung von Instanzen erfolgreich, aber alle Threads verwenden Sie die Instanz, die zuerst erstellt wurde.  
  
> [!NOTE]
>  Ein Beispiel für die veranschaulicht, wie Sie diesen Konstruktor in Singlethread-Szenarios verwenden (Angeben von <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> für `mode`), finden Sie unter den <xref:System.Lazy%601.%23ctor%28System.Boolean%29> Konstruktor. Für ein Beispiel, das veranschaulicht, wie Sie diesen Konstruktor verwenden, zu Sperren anstelle der Racebedingungen im Multithread-Szenarien (Angeben von <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> für `mode`), finden Sie unter der <xref:System.Lazy%601.%23ctor> Konstruktor.  
  
 Das Beispiel definiert eine `LargeObject` -Klasse, die von einer von mehreren Threads verzögert initialisiert wird. Die drei wichtigsten Abschnitte des Codes veranschaulichen die Erstellung der Initialisierer, die eigentliche Initialisierung aus, und der Konstruktor und Finalizer, der die `LargeObject` Klasse. Am Anfang der `Main` -Methode, um das Beispiel erstellt die <xref:System.Lazy%601> -Objekt, das verzögerte Initialisierung von führt die `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorLTSM#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#newlazy)]  
  
 Das Beispiel erstellt und startet drei Threads, die eine Blockierung auf einem <xref:System.Threading.ManualResetEvent> Objekt, um das Beispiel die Threads gleichzeitig freigeben kann. In der `ThreadProc` -Methode, die von allen drei Threads Aufrufen verwendet wird, die <xref:System.Lazy%601.Value%2A> Eigenschaft erstellt die `LargeObject` Instanz:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorLTSM#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#valueprop)]  
  
 Da der Konstruktor für die <xref:System.Lazy%601> angegebenen Instanz <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, dürfen alle drei Threads erstellen `LargeObject` Instanzen. Das Beispiel veranschaulicht dies, indem konsolennachrichten angezeigt, in den Konstruktor und in der Finalizer von der `LargeObject` Klasse:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#CtorFinalizer](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#ctorfinalizer)]
 [!code-vb[System.Lazy\`1.ctorLTSM#CtorFinalizer](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#ctorfinalizer)]  
  
 Allerdings die <xref:System.Lazy%601> Objekt wird sichergestellt, dass nur eine Instanz wird von allen Threads verwendet. Die Ausgabe des Beispiels zeigt, dass alle drei Threads verwendet werden, die dieselbe Instanz, und zeigt außerdem, dass die anderen beiden Instanzen von der Garbagecollection freigegeben werden können.  
  
> [!NOTE]
>  Der Einfachheit halber wird in diesem Beispiel eine globale Instanz von <xref:System.Lazy%601> verwendet, und alle Methoden sind `static` (`Shared` in Visual Basic). Dies sind keine Anforderungen für die Verwendung der verzögerten Initialisierung.  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorLTSM#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> enthält einen ungültigen Wert.</exception>
        <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Verzögerte Initialisierung</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(T value);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : 'T -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory, bool isThreadSafe);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory, bool isThreadSafe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T), isThreadSafe As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory, bool isThreadSafe);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; * bool -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; (valueFactory, isThreadSafe)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
        <Parameter Name="isThreadSafe" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Der Delegat, der aufgerufen wird, um bei Bedarf den verzögert initialisierten Wert zu erzeugen.</param>
        <param name="isThreadSafe"><see langword="true" />, damit diese Instanz gleichzeitig von mehreren Threads verwendet werden kann, <see langword="false" /> damit diese Instanz jeweils nur von einem Thread verwendet werden kann.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Lazy`1" />-Klasse. Bei einer verzögerten Initialisierung werden die angegebene Initialisierungsfunktion und der angegebene Initialisierungsmodus verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Threadsicherheitsmodus eine <xref:System.Lazy%601> Instanz, die mit diesem Konstruktor initialisiert wird, ist <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> Wenn `isThreadSafe` ist `true`ist, andernfalls wird der Modus <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>. Der Threadsicherheitsmodus beschreibt das Verhalten, wenn mehrere Threads, zum Initialisieren versuchen der <xref:System.Lazy%601> Instanz.  
  
 Angeben der <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> Modus der <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> oder <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> Konstruktor.  
  
 Ausnahmen, die ausgelöst werden, indem `valueFactory` zwischengespeichert werden. Weitere Informationen finden Sie unter der <xref:System.Lazy%601>-Klasse oder unter der <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>-Enumeration.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung dieses Konstruktors für die Ausnahme, die Zwischenspeicherung in einem Szenario mit einem einzelnen Thread verzögerten Initialisierung bereit. Es zeigt auch die Verwendung der <xref:System.Lazy%601.%23ctor%2A> Konstruktor (Angeben von <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> für `mode`). Um diesen Konstruktor zu wechseln, ändern Sie einfach die Konstruktor auskommentiert ist.  
  
> [!NOTE]
>  Für Code, der zeigt, wie Sie diesen Konstruktor in Multithread-Szenarien verwenden (Angeben von `true` für `isThreadSafe`), siehe das Beispiel für die <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> Konstruktor.  
  
 Im Beispiel wird eine `LargeObject`-Klasse definiert, die durch einen von mehreren Threads verzögert initialisiert wird. Die drei wichtigsten Abschnitte des Codes veranschaulichen die Erstellung der Initialisierer, die eigentliche Initialisierung und den Konstruktor der `LargeObject` -Klasse, die Zwischenspeichern von Ausnahmen veranschaulicht. Zu Anfang der `Main`-Methode wird in diesem Beispiel ein threadsicherer verzögerter Initialisierer für `LargeObject` erstellt:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#newlazy)]  
  
 Im Aufruf an den Konstruktor der `isThreadSafe` Parameter `false`, sodass die <xref:System.Lazy%601> ist nicht threadsicher. Da es nicht threadsicher ist, wird im Beispiel wird die <xref:System.Lazy%601.Value%2A> Eigenschaft drei Mal auf dem gleichen Thread:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#valueprop)]  
  
 Im Konstruktor des der `LargeObject` -Klasse, die dritte wichtige Codeabschnitt löst eine Ausnahme beim ersten ein `LargeObject` Instanz wird erstellt, aber danach ermöglicht das Erstellen von Instanz auftreten:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#largector)]  
  
 Wenn das Beispiel ausgeführt wird, wird den ersten Versuch zum Erstellen einer Instanz von `LargeObject` schlägt fehl, und die Ausnahme abgefangen wird. Sie erwarten wahrscheinlich, dass der nächste Versuch erfolgreich ist, würde, aber die <xref:System.Lazy%601> Objekt hat die Ausnahme zwischengespeichert. Aus diesem Grund werden alle drei Versuche der Ausnahme auslösen.  
  
> [!NOTE]
>  Der Einfachheit halber wird in diesem Beispiel eine globale Instanz von <xref:System.Lazy%601> verwendet, und alle Methoden sind `static` (`Shared` in Visual Basic). Dies sind keine Anforderungen für die Verwendung der verzögerten Initialisierung.  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="valueFactory" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Verzögerte Initialisierung</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory, System.Threading.LazyThreadSafetyMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory, valuetype System.Threading.LazyThreadSafetyMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T), mode As LazyThreadSafetyMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory, System::Threading::LazyThreadSafetyMode mode);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; * System.Threading.LazyThreadSafetyMode -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; (valueFactory, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
        <Parameter Name="mode" Type="System.Threading.LazyThreadSafetyMode" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Der Delegat, der aufgerufen wird, um bei Bedarf den verzögert initialisierten Wert zu erzeugen.</param>
        <param name="mode">Einer der Enumerationswerte, der den Threadsicherheitsmodus angibt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Lazy`1" />-Klasse, die die angegebene Initialisierungsfunktion und den angegebenen Threadsicherheitsmodus verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Threadsicherheitsmodus eine <xref:System.Lazy%601> Instanz beschreibt das Verhalten, wenn mehrere Threads, zum Initialisieren versuchen der <xref:System.Lazy%601> Instanz.  
  
 Ausnahmen, die ausgelöst werden, indem `valueFactory` zwischengespeichert werden, es sei denn, `mode` ist <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>. Weitere Informationen finden Sie unter der <xref:System.Lazy%601>-Klasse oder unter der <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>-Enumeration.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung dieses Konstruktors einen verzögerten Initialisierer zu erstellen, der können von mehreren Threads, um ein Objekt erstellen, verzögert die man anfliegt. Mehrere Threads möglicherweise bei der Erstellung von Instanzen erfolgreich, aber alle Threads verwenden Sie die Instanz, die zuerst erstellt wurde. Darüber hinaus im Beispiel wird veranschaulicht, dass Ausnahmen nicht zwischengespeichert werden, bei der Angabe <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, auch wenn die Initialisierung von einer Funktion nicht vom Standardkonstruktor des Typs verzögert erstellte ausgeführt wird.  
  
> [!NOTE]
>  Ein Beispiel für die veranschaulicht, wie Sie diesen Konstruktor in Singlethread-Szenarios verwenden (Angeben von <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> für `mode`), finden Sie unter den <xref:System.Lazy%601.%23ctor%28System.Boolean%29> Konstruktor. Für ein Beispiel, das veranschaulicht, wie Sie diesen Konstruktor verwenden, zu Sperren anstelle der Racebedingungen im Multithread-Szenarien (Angeben von <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> für `mode`), finden Sie unter der <xref:System.Lazy%601.%23ctor> Konstruktor.  
  
 Das Beispiel definiert eine `LargeObject` -Klasse, die von einer von mehreren Threads verzögert initialisiert wird. Die vier wichtigsten Abschnitte des Codes veranschaulichen die Erstellung der Initialisierer, die eigentliche Initialisierung, die Initialisierungsfunktion, und der Konstruktor und Finalizer, der die `LargeObject` Klasse. Am Anfang der `Main` -Methode, um das Beispiel erstellt die <xref:System.Lazy%601> -Objekt, das verzögerte Initialisierung von führt die `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#newlazy)]  
  
 Die verzögerte Initialisierung verwendet die Funktion zum Ausführen der Initialisierung. In diesem Fall ist eine Funktion erforderlich, da es kein Standardkonstruktor für ist die `LargeObject` Klasse.  
  
 Das Beispiel erstellt und startet drei Threads, die eine Blockierung auf einem <xref:System.Threading.ManualResetEvent> Objekt, um das Beispiel die Threads gleichzeitig freigeben kann. In der `ThreadProc` -Methode, die von allen drei Threads Aufrufen verwendet wird, die <xref:System.Lazy%601.Value%2A> Eigenschaft erstellt die `LargeObject` Instanz:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#valueprop)]  
  
 Im dritten wichtige Abschnitt des Codes, die verzögerte Initialisierung-Funktion aufgerufen, um das Erstellen der `LargeObject` Instanz. Die Funktion löst eine Ausnahme beim ersten Mal aufgerufen wird:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#FactoryFunc](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#factoryfunc)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#FactoryFunc](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#factoryfunc)]  
  
 Bei einem anderen <xref:System.Threading.LazyThreadSafetyMode> festlegen, wird eine nicht behandelte Ausnahme in der Initialisierungsfunktion zwischengespeichert werden. Allerdings <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> unterdrückt Zwischenspeichern von Ausnahmen. Die Ausgabe des Beispiels zeigt, dass es sich bei ein weiteren Versuch zum Initialisieren des Objekts erfolgreich ausgeführt wird.  
  
> [!NOTE]
>  Die Ausnahmemeldung wird in der Regel nach Nachrichten, die angibt, dass andere Threads das Objekt erfolgreich initialisiert haben, angezeigt. Dies ist aufgrund der Verzögerung durch Auslösen und Abfangen der Ausnahme.  
  
 Da der Konstruktor für die <xref:System.Lazy%601> angegebenen Instanz <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, dürfen alle drei Threads erstellen `LargeObject` Instanzen. Das Beispiel veranschaulicht dies, indem konsolennachrichten angezeigt, in den Konstruktor und in der Finalizer von der `LargeObject` Klasse:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#CtorFinalizer](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#ctorfinalizer)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#CtorFinalizer](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#ctorfinalizer)]  
  
 Die <xref:System.Lazy%601> Objekt wird sichergestellt, dass nur eine Instanz wird verwendet, von allen Threads (mit Ausnahme der Thread, in denen die Initialisierungsfunktion löst eine Ausnahme aus). Die Ausgabe aus dem Beispiel zeigt dies.  
  
> [!NOTE]
>  Der Einfachheit halber wird in diesem Beispiel eine globale Instanz von <xref:System.Lazy%601> verwendet, und alle Methoden sind `static` (`Shared` in Visual Basic). Dies sind keine Anforderungen für die Verwendung der verzögerten Initialisierung.  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> enthält einen ungültigen Wert.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="valueFactory" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Verzögerte Initialisierung</related>
      </Docs>
    </Member>
    <Member MemberName="IsValueCreated">
      <MemberSignature Language="C#" Value="public bool IsValueCreated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueCreated" />
      <MemberSignature Language="DocId" Value="P:System.Lazy`1.IsValueCreated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueCreated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueCreated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueCreated : bool" Usage="System.Lazy&lt;'T&gt;.IsValueCreated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob ein Wert für diese <see cref="T:System.Lazy`1" />-Instanz erstellt wurde.</summary>
        <value><see langword="true" />, wenn ein Wert für diese <see cref="T:System.Lazy`1" />-Instanz erstellt wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die verzögerter Initialisierung auftritt, für eine <xref:System.Lazy%601> Instanz es möglicherweise ein Wert, der erstellt wird oder eine Ausnahme ausgelöst wird. Wenn eine Ausnahme ausgelöst wird, werden nachfolgende Verhalten ist das <xref:System.Lazy%601> Instanz hängt davon ab, ob Zwischenspeichern von Ausnahmen in Kraft ist. Wenn die <xref:System.Lazy%601> Instanz mithilfe eines Konstruktors, der keine Initialisierungsfunktion nicht erstellt wurde und das Zwischenspeichern von Ausnahmen ist nicht aktiv. Einen weiteren Versuch zum Initialisieren der <xref:System.Lazy%601> möglicherweise erfolgreich ausgeführt werden, und nach der erfolgreichen Initialisierung der <xref:System.Lazy%601.IsValueCreated%2A> -Eigenschaft gibt `true`. Wenn die <xref:System.Lazy%601> Instanz mit einer Initialisierungsfunktion erstellt wurde (gemäß der `valueFactory` Parameter, der die <xref:System.Lazy%601> Konstruktor), und Zwischenspeichern von Ausnahmen von den Threadsicherheitsmodus gesteuert wird.  
  
-   Wenn der Modus <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> oder <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, es gibt keine zweite Chance zum Initialisieren der <xref:System.Lazy%601> Instanz. Wenn eine Ausnahme tritt auf, und wird nicht in die Initialisierungsfunktion behandelt, die Ausnahme zwischengespeichert und erneut ausgelöst, bei nachfolgenden Zugriffen auf die <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> Eigenschaft. Es wird kein Wert erstellt, wenn eine Ausnahme wird ausgelöst, also in solchen Fällen <xref:System.Lazy%601.IsValueCreated%2A> gibt `false`.  
  
-   Wenn der Modus <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, der erste Thread, der erfolgreich ausführt, die Initialisierungsfunktion (oder die Standard-Konstruktor) erstellt, den Wert für die <xref:System.Lazy%601> Instanz. Wenn die Initialisierungsfunktion für einen Thread eine Ausnahme auslöst, andere Threads können trotzdem versuchen, initialisieren Sie die <xref:System.Lazy%601> Instanz. Wenn der Wert erstellt wurde, die <xref:System.Lazy%601.IsValueCreated%2A> -Eigenschaft gibt `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Verzögerte Initialisierung</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="lazy.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine Zeichenfolgendarstellung der <see cref="P:System.Lazy`1.Value" />-Eigenschaft für diese Instanz und gibt diese zurück.</summary>
        <returns>Das Ergebnis des Aufrufs der <see cref="M:System.Object.ToString" />-Methode für die <see cref="P:System.Lazy`1.Value" />-Eigenschaft für diese Instanz, wenn der Wert erstellt wurde (d. h., wenn die <see cref="P:System.Lazy`1.IsValueCreated" />-Eigenschaft <see langword="true" /> zurückgibt ). Andernfalls hat eine Zeichenfolge, die angibt, dass der Wert nicht erstellt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen dieser Methode löst keine Initialisierung.  
  
 Die <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> Eigenschaft kann sein, `null` nach verzögerte Initialisierung, die bei der Factorymethode für angegebene der `valueFactory` Parameter der <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>, <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>, oder <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> Konstruktor zurück, `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Die <see cref="P:System.Lazy`1.Value" />-Eigenschaft ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public T Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Value" />
      <MemberSignature Language="DocId" Value="P:System.Lazy`1.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T Value { T get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : 'T" Usage="System.Lazy&lt;'T&gt;.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den verzögert initialisierten Wert der aktuellen <see cref="T:System.Lazy`1" />-Instanz ab.</summary>
        <value>Der verzögert initialisierte Wert der aktuellen <see cref="T:System.Lazy`1" />-Instanz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Lazy%601.IsValueCreated%2A?displayProperty=nameWithType> Eigenschaft `false`, den Zugriff auf die <xref:System.Lazy%601.Value%2A> Eigenschaft erzwingt die Initialisierung.  
  
 Zusätzlich zu den Ausnahmen, die aufgelistet werden, die <xref:System.Lazy%601.Value%2A> Eigenschaft kann jede nicht behandelte Ausnahme, die von der Factorymethode ausgelöst wird, der an übergebene Auslösen der `valueFactory` Parameter der <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>, <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>, oder <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> Konstruktor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Die <see cref="T:System.Lazy`1" />-Instanz wird initialisiert, um den Standardkonstruktor des Typs zu verwenden, der verzögert initialisiert wird, und es sind keine Berechtigungen für den Zugriff auf den Konstruktor vorhanden.</exception>
        <exception cref="T:System.MissingMemberException">Die <see cref="T:System.Lazy`1" />-Instanz wird initialisiert, um den Standardkonstruktor des Typs zu verwenden, der verzögert initialisiert wird, und dieser Typ weist keinen öffentlichen Konstruktor ohne Parameter auf.</exception>
        <exception cref="T:System.InvalidOperationException">Die Initialisierungsfunktion versucht, in dieser Instanz auf <see cref="P:System.Lazy`1.Value" /> zuzugreifen.</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Verzögerte Initialisierung</related>
      </Docs>
    </Member>
  </Members>
</Type>