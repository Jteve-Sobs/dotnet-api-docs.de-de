<Type Name="Span&lt;T&gt;" FullName="System.Span&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ff32875a0bdb3fdef802a55a8ab626dc8da147fb" />
    <Meta Name="ms.sourcegitcommit" Value="81d387351cc43c342755705908f4a5eb8af153d3" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/04/2018" />
    <Meta Name="ms.locfileid" Value="34568232" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Span&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Span`1&lt;T&gt; extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.Span`1" />
  <TypeSignature Language="VB.NET" Value="Public Structure Span(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public value class Span" />
  <AssemblyInfo>
    <AssemblyName>System.Memory</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.IsByRefLike</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">
      <span data-ttu-id="45ff5-101">Der Typ der Elemente in der <see cref="System.Span`1" />.</span>
      <span class="sxs-lookup">
        <span data-stu-id="45ff5-101">The type of items in the <see cref="System.Span`1" />.</span>
      </span>
    </typeparam>
    <summary>
      <span data-ttu-id="45ff5-102">Dieser enthält eine typ- und arbeitsspeichersichere Darstellung einer zusammenhängenden Region von beliebigem Arbeitsspeicher.</span>
      <span class="sxs-lookup">
        <span data-stu-id="45ff5-102">Provides a type- and memory-safe representation of a contiguous region of arbitrary memory.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  

<span data-ttu-id="45ff5-103">`Span<T>` ist eine [Verweisstruktur](~/docs/csharp/reference-semantics-with-value-types.md#ref-struct-type) , die auf dem Stapel statt auf dem verwalteten Heap zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="45ff5-103">`Span<T>` is a [ref struct](~/docs/csharp/reference-semantics-with-value-types.md#ref-struct-type) that is allocated on the stack rather than on the managed heap.</span></span> <span data-ttu-id="45ff5-104">REF Strukturtypen haben eine Reihe von Einschränkungen, um sicherzustellen, dass sie auf den verwalteten Heap, einschließlich nicht geschachtelt werden und ihnen können nicht zugewiesen werden, um Variablen vom Typ heraufgestuft werden können <xref:System.Object>, `dynamic`, und klicken Sie auf einen beliebigen anderen Schnittstellentyp.</span><span class="sxs-lookup"><span data-stu-id="45ff5-104">Ref struct types have a number of restrictions to ensure that they cannot be promoted to the managed heap, including that they can't be boxed and they can't be assigned to variables of type <xref:System.Object>, `dynamic`, and to any interface type.</span></span>

<span data-ttu-id="45ff5-105">Ein `Span<T>` Instanz wird häufig verwendet, um die Elemente eines Arrays oder eines Teils eines Arrays enthalten.</span><span class="sxs-lookup"><span data-stu-id="45ff5-105">A `Span<T>` instance is often used to hold the elements of an array or a portion of an array.</span></span> <span data-ttu-id="45ff5-106">Im Gegensatz zu einem Array, jedoch eine `Span<T>` Instanz kann auf verwalteten Arbeitsspeicher, systemeigenen Speicher oder Arbeitsspeicher verwaltet, auf dem Stapel.</span><span class="sxs-lookup"><span data-stu-id="45ff5-106">Unlike an array, however, a `Span<T>` instance can point to managed memory, native memory, or memory managed on the stack.</span></span>

      ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Span (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.#ctor(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span(cli::array &lt;T&gt; ^ array);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="45ff5-107">Das Array, aus dem das <see cref="T:System.Span`1" />-Objekt erstellt werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-107">The array from which to create the <see cref="T:System.Span`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45ff5-108">Erstellt ein neues <see cref="T:System.Span`1" />-Objekt über das gesamte angegebene Array.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-108">Creates a new <see cref="T:System.Span`1" /> object over the entirety of a specified array.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="45ff5-109">Wenn `array` ist `null`, diesen Konstruktor gibt eine `null` `Span<T>`.</span><span class="sxs-lookup"><span data-stu-id="45ff5-109">If `array` is `null`, this constructor returns a `null` `Span<T>`.</span></span>

      ]]></format>
        </remarks>
        <exception cref="T:System.TypeMismatchException">
          <span data-ttu-id="45ff5-110">
            <paramref name="T" /> ist ein Verweistyp, und <paramref name="array" /> ist kein Array des Typs <paramref name="T" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-110">
              <paramref name="T" /> is a reference type, and <paramref name="array" /> is not an array of type <paramref name="T" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Span (void* pointer, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(void* pointer, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.#ctor(System.Void*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span(void* pointer, int length);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pointer" Type="System.Void*" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pointer">
          <span data-ttu-id="45ff5-111">Ein Zeiger zur Startadresse einer angegebenen Anzahl von Bytes im Arbeitsspeicher.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-111">A pointer to the starting address of a specified number of bytes in memory.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="45ff5-112">Die Anzahl von Bytes, die in <see cref="T:System.Span`1" /> eingeschlossen werden sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-112">The number of bytes to be included in the <see cref="T:System.Span`1" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45ff5-113">Erstellt ein neues <see cref="T:System.Span`1" />-Objekt aus einer angegebenen Anzahl von Bytes. Dabei wird an der angegebenen Speicheradresse begonnen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-113">Creates a new <see cref="T:System.Span`1" /> object  from a specified number of bytes starting at a specified memory address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

        This constructor should be used with care, since it creates arbitrarily typed `T`s from a `void*`-typed block of memory, and `length` is not checked. However, if the constructor succeeds in creating a new <xref:System.Span%601> object, all subsequent uses are correct.        

      ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="45ff5-114">
            <paramref name="T" /> ist ein Verweistyp oder enthält Zeiger und kann deshalb nicht in nicht verwaltetem Arbeitsspeicher gespeichert werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-114">
              <paramref name="T" /> is a reference type or contains pointers and therefore cannot be stored in unmanaged memory.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="45ff5-115">
            <paramref name="length" /> ist ein negativer Wert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-115">
              <paramref name="length" /> is negative.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Span (T[] array, int start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T[] array, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.#ctor(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (array As T(), start As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span(cli::array &lt;T&gt; ^ array, int start);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="45ff5-116">Das Quellarray.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-116">The source array.</span>
          </span>
        </param>
        <param name="start">
          <span data-ttu-id="45ff5-117">Der Index des ersten Elements im Array, das in das <see cref="T:System.Span`1" />-Objekt eingeschlossen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-117">The index of the first element in the array to include in the <see cref="T:System.Span`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45ff5-118">Erstellt ein neues <see cref="T:System.Span`1" />-Objekt aus einem angegebenen Array. Die Erstellung beginnt an einer angegebenen Indexposition und wird bis zum Ende des Arrays fortgesetzt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-118">Creates a new <see cref="T:System.Span`1" /> object from a specified array starting at a specifed index position and continuing to the end of the array.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Span (T[] array, int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T[] array, int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.#ctor(`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (array As T(), start As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span(cli::array &lt;T&gt; ^ array, int start, int length);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="45ff5-119">Das Quellarray.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-119">The source array.</span>
          </span>
        </param>
        <param name="start">
          <span data-ttu-id="45ff5-120">Der Index des ersten Elements, das im neuen <see cref="T:System.Span`1" />-Element enthalten sein soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-120">The index of the first element to include in the new <see cref="T:System.Span`1" />.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="45ff5-121">Die Anzahl von Elementen, die in das neue <see cref="T:System.Span`1" />-Element eingeschlossen werden sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-121">The number of elements to include in the new <see cref="T:System.Span`1" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45ff5-122">Erstellt ein neues <see cref="T:System.Span`1" />-Objekt, das eine angegebene Anzahl von Elementen aus einem Array enthält. Dabei wird an einem angegebenen Index begonnen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-122">Creates a new <see cref="T:System.Span`1" /> object that includes a specified number of elements of an array starting at a specified index.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="45ff5-123">
            <paramref name="array" /> ist gleich <see langword="null" />, aber <paramref name="start" /> oder <paramref name="length" /> ist nicht 0 (null).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-123">
              <paramref name="array" /> is <see langword="null" />, but <paramref name="start" /> or <paramref name="length" /> is non-zero.</span>
          </span>
          <p />
          <span data-ttu-id="45ff5-124">– oder –</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-124">--or--</span>
          </span>
          <p />
          <span data-ttu-id="45ff5-125">
            <paramref name="start" /> liegt außerhalb der Grenzen des Arrays.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-125">
              <paramref name="start" /> is outside the bounds of the array.</span>
          </span>
          <p />
          <span data-ttu-id="45ff5-126">– oder –</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-126">--or--</span>
          </span>
          <p />
          <span data-ttu-id="45ff5-127">
            <paramref name="start" /> und <paramref name="length" /> überschreiten die Anzahl von Elementen im Array.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-127">
              <paramref name="start" /> and <paramref name="length" /> exceeds the number of elements in the array.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeMismatchException">
          <span data-ttu-id="45ff5-128">
            <paramref name="T" /> ist ein Verweistyp, und <paramref name="array" /> ist kein Array des Typs <paramref name="T" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-128">
              <paramref name="T" /> is a reference type, and <paramref name="array" /> is not an array of type <paramref name="T" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="45ff5-129">Löscht den Inhalt dieses <see cref="T:System.Span`1" />-Objekts.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-129">Clears the contents of this <see cref="T:System.Span`1" /> object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="45ff5-130">Die `Clear` Methode legt die Elemente der <xref:System.Span%601> Objekt mit ihren Standardwerten.</span><span class="sxs-lookup"><span data-stu-id="45ff5-130">The `Clear` method sets the items in the <xref:System.Span%601> object to their default values.</span></span> <span data-ttu-id="45ff5-131">Es werden keine entfernt Elemente aus der <xref:System.Span%601>.</span><span class="sxs-lookup"><span data-stu-id="45ff5-131">It does not remove items from the <xref:System.Span%601>.</span></span>  

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Span&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(valuetype System.Span`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.CopyTo(System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (destination As Span(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <summary>
          <span data-ttu-id="45ff5-132">Kopiert die Inhalte dieses <see cref="System.Span`1" />-Elements in ein <see cref="System.Span`1" />-Zielelement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-132">Copies the contents of this <see cref="System.Span`1" /> into a destination <see cref="System.Span`1" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="45ff5-133">Diese Methode kopiert alle `source` auf `destination` selbst wenn `source` und `destination` überlappen.</span><span class="sxs-lookup"><span data-stu-id="45ff5-133">This method copies all of `source` to `destination` even if `source` and `destination` overlap.</span></span>

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="45ff5-134">
            <paramref name="destination" /> ist kürzer als das <see cref="System.Span`1" />-Quellelement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-134">
              <paramref name="destination" /> is shorter than the source <see cref="System.Span`1" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DangerousCreate">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; DangerousCreate (object obj, ref T objectData, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!T&gt; DangerousCreate(object obj, !T&amp; objectData, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.DangerousCreate(System.Object,`0@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DangerousCreate (obj As Object, ByRef objectData As T, length As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Span&lt;T&gt; DangerousCreate(System::Object ^ obj, T % objectData, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="objectData" Type="T&amp;" RefType="ref" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <param name="objectData">To be added.</param>
        <param name="length">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DangerousGetPinnableReference">
      <MemberSignature Language="C#" Value="public T DangerousGetPinnableReference ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T DangerousGetPinnableReference() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.DangerousGetPinnableReference" />
      <MemberSignature Language="VB.NET" Value="Public Function DangerousGetPinnableReference () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T % DangerousGetPinnableReference();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T@</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; Empty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Span`1&lt;!T&gt; Empty" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Empty As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Span&lt;T&gt; Empty { Span&lt;T&gt; get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45ff5-135">Gibt ein leeres <see cref="T:System.Span`1" />-Objekt zurück.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-135">Returns an empty <see cref="T:System.Span`1" /> object.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="45ff5-136">Ein leeres <see cref="T:System.Span`1" />-Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-136">An empty <see cref="T:System.Span`1" /> object.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Equals() on Span will always throw an exception. Use == instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="45ff5-137">Wird nicht unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-137">Not supported.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45ff5-138">Das Aufrufen dieser Methode wird nicht unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-138">Calls to this method are not supported.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45ff5-139">Das Aufrufen dieser Methode wird nicht unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-139">Calls to this method are not supported.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
<span data-ttu-id="45ff5-140">Aufrufe von der <xref:System.Span%601.Equals%2A> Methode werden nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="45ff5-140">Calls to the <xref:System.Span%601.Equals%2A> method are not supported.</span></span> <span data-ttu-id="45ff5-141">Aufrufe von der < xref:System.Span%601.Equals%2A Methoden erzeugen eine der beiden Ergebnisse:</span><span class="sxs-lookup"><span data-stu-id="45ff5-141">Calls to the <xref:System.Span%601.Equals%2A methods produce either of two results:</span></span>

- <span data-ttu-id="45ff5-142">Wenn `obj` ist eine <xref:System.Span%601>, dem Aufruf der Methode generiert Compilerfehler CS1503 einher: "Konvertierung von"System.Span"in"Object"." Grund hierfür ist, <xref:System.Span%601> ist ein [Verweisstruktur](~/docs/csharp/reference-semantics-with-value-types.md#ref-struct-type) , die nicht geschachtelt werden und daher nicht konvertiert werden, um eine <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="45ff5-142">If `obj` is a <xref:System.Span%601>, the method call generates compiler error CS1503: "cannot convert from 'System.Span' to 'object'." This is because <xref:System.Span%601> is a [ref struct](~/docs/csharp/reference-semantics-with-value-types.md#ref-struct-type) that cannot be boxed and therefore cannot be converted to an <xref:System.Object>.</span></span>

- <span data-ttu-id="45ff5-143">Wenn der Typ des `obj` keine <xref:System.Span%601>, löst der Methodenaufruf eine <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="45ff5-143">If the type of `obj` is not a <xref:System.Span%601>, the method call throws a <xref:System.NotSupportedException>.</span></span> 

<span data-ttu-id="45ff5-144">Um zwei <xref:System.Span%601> -Objekte auf Gleichheit, verwenden die <xref:System.Span%601.op_Equality%2A> Vergleichsoperator.</span><span class="sxs-lookup"><span data-stu-id="45ff5-144">To compare two <xref:System.Span%601> objects for equality, use the <xref:System.Span%601.op_Equality%2A> comparison operator.</span></span>

        ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="45ff5-145">Das Aufrufen dieser Methode wird nicht unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-145">Calls to this method are not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public void Fill (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Fill(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Fill(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Fill (value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Fill(T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="45ff5-146">Der Wert, der jedem Element des Span-Elements zugewiesen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-146">The value to assign to each element of the span.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45ff5-147">Füllt die Elemente dieses Span-Elements mit einem angegebenen Wert auf.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-147">Fills the elements of this span with a specified value.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As Span(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="45ff5-148">Gibt einen Enumerator für dieses <see cref="T:System.Span`1" />-Element zurück.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-148">Returns an enumerator for this <see cref="T:System.Span`1" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45ff5-149">Ruft einen Enumerator für dieses Span-Element ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-149">An enumerator for this span.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
<span data-ttu-id="45ff5-150">Statt die <xref:System.Span%601.GetEnumerator%2A> Methode direkt, Sie können die C#- `foreach` -Anweisung und die Visual Basic `For Each`... `Next` Konstrukt zum Aufzählen einer <xref:System.Span%601>.</span><span class="sxs-lookup"><span data-stu-id="45ff5-150">Instead of calling the <xref:System.Span%601.GetEnumerator%2A> method directly, you can use the C# `foreach` statement and the Visual Basic `For Each`...`Next` construct to enumerate a <xref:System.Span%601>.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("GetHashCode() on Span will always throw an exception.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="45ff5-151">Löst eine <see cref="T:System.NotSupportedException" /> aus.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-151">Throws a <see cref="T:System.NotSupportedException" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45ff5-152">Beim Aufrufen dieser Methode wird immer <see cref="T:System.NotSupportedException" /> ausgelöst.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-152">Calls to this method always throw a <see cref="T:System.NotSupportedException" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="45ff5-153">Das Aufrufen dieser Methode wird nicht unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-153">Calls to this method are not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetPinnableReference">
      <MemberSignature Language="C#" Value="public T GetPinnableReference ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T GetPinnableReference() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.GetPinnableReference" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPinnableReference () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T % GetPinnableReference();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T@</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="45ff5-154">Gibt einen Verweis auf das Element von <see cref="T:System.Span`1" /> zurück, das sich am Index 0 befindet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-154">Returns a reference to the element of the <see cref="T:System.Span`1" /> at index zero.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45ff5-155">Ein Verweis auf das Element von <see cref="T:System.Span`1" /> am Index 0, oder <see langword="null" />, wenn <see cref="M:System.Span`1.IsEmpty" /> gleich <see langword="true" /> ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-155">A reference to the element of the <see cref="T:System.Span`1" /> at index zero, or <see langword="null" /> if <see cref="M:System.Span`1.IsEmpty" /> is  <see langword="true" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="45ff5-156">Die `GetPinnableReference` Methode gibt ein [Verweisstruktur](~/docs/csharp/reference-semantics-with-value-types.md#ref-struct-type).</span><span class="sxs-lookup"><span data-stu-id="45ff5-156">The `GetPinnableReference` method returns a [ref struct](~/docs/csharp/reference-semantics-with-value-types.md#ref-struct-type).</span></span> <span data-ttu-id="45ff5-157">Es kann verwendet werden, für das anheften einer <xref:System.Span%601> im Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="45ff5-157">It can be used for pinning a <xref:System.Span%601> in memory.</span></span> <span data-ttu-id="45ff5-158">Es ist erforderlich, um die Verwendung von unterstützt eine <xref:System.Span%601> innerhalb einer [behoben](~/docs/csharp/language-reference/keywords/fixed-statement.md) Anweisung.</span><span class="sxs-lookup"><span data-stu-id="45ff5-158">It is required to support the use of a <xref:System.Span%601> within a [fixed](~/docs/csharp/language-reference/keywords/fixed-statement.md) statement.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.IsEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEmpty { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45ff5-159">Gibt einen Wert zurück, der angibt, ob das aktuelle <see cref="T:System.Span`1" />-Element leer ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-159">Returns a value that indicates whether the current <see cref="T:System.Span`1" /> is empty.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="45ff5-160">
            <see langword="true" /> Wenn die aktuelle Spanne leer ist; andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-160">
              <see langword="true" /> if the current span is empty; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(index As Integer) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T % default[int] { T % get(int index); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T@</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>
          <span data-ttu-id="45ff5-161">Ruft das Element am angegebenen nullbasierten Index ab oder legt dieses fest.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-161">Gets or sets the element at the specified zero-based index.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="45ff5-162">Das Element am angegebenen Index.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-162">The element at the specified index.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="45ff5-163">
            <paramref name="index" /> ist kleiner als 0 (null) oder größer oder gleich <see cref="P:System.Span`1.Length" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-163">
              <paramref name="index" /> is less then zero or greater than or equal to <see cref="P:System.Span`1.Length" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45ff5-164">Gibt die Länge des aktuellen Span-Elements fest.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-164">Returns the length of the current span.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="45ff5-165">Die Länge der aktuellen Spanne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-165">The length of the current span.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Span&lt;T&gt; left, Span&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Span`1&lt;!T&gt; left, valuetype System.Span`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Equality(System.Span{`0},System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Span(Of T), right As Span(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Span&lt;T&gt; left, Span&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Span&lt;T&gt;" />
        <Parameter Name="right" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="45ff5-166">Das erste zu vergleichende Span-Element.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-166">The first span to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="45ff5-167">Das zweite zu vergleichende Span-Element.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-167">The second span to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45ff5-168">Gibt einen Wert zurück, der angibt, ob zwei <see cref="T:System.Span`1" />-Objekte gleich sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-168">Returns a value that indicates whether two <see cref="T:System.Span`1" /> objects are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45ff5-169">
            <see langword="true" />, wenn die beiden <see cref="T:System.Span`1" />-Objekte gleich sind, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-169">
              <see langword="true" /> if the two <see cref="T:System.Span`1" /> objects are equal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="45ff5-170">Zwei <xref:System.Span%601> Objekte sind gleich, wenn sie die gleiche Länge und die entsprechenden Elemente der bieten `left` und `right` zeigen Sie auf den gleichen Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="45ff5-170">Two <xref:System.Span%601> objects are equal if they have the same length and the corresponding elements of `left` and `right` point to the same memory.</span></span> <span data-ttu-id="45ff5-171">Beachten Sie, dass der Test auf Gleichheit *nicht* versucht zu bestimmen, ob der Inhalt gleich sind.</span><span class="sxs-lookup"><span data-stu-id="45ff5-171">Note that the test for equality does *not* attempt to determine whether the contents are equal.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;T&gt; (Span&lt;T&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;!T&gt; op_Implicit(valuetype System.Span`1&lt;!T&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Implicit(System.Span{`0})~System.ReadOnlySpan{`0}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (span As Span(Of T)) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;T&gt;(Span&lt;T&gt; span);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="span">
          <span data-ttu-id="45ff5-172">Das in eine <see cref="T:System.ReadOnlySpan`1" /> zu konvertierende Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-172">The object to convert to a <see cref="T:System.ReadOnlySpan`1" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45ff5-173">Definiert eine implizite Konvertierung von <see cref="T:System.Span`1" /> in <see cref="T:System.ReadOnlySpan`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-173">Defines an implicit conversion of a <see cref="T:System.Span`1" /> to a <see cref="T:System.ReadOnlySpan`1" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45ff5-174">Ein schreibgeschütztes Span-Element, das dem aktuellen Attribut entspricht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-174">A read-only span that corresponds to the current instance.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator Span&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Span`1&lt;!T&gt; op_Implicit(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Implicit(`0[])~System.Span{`0}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (array As T()) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator Span&lt;T&gt;(cli::array &lt;T&gt; ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="45ff5-175">Das Array, das in <see cref="T:System.Span`1" /> konvertiert werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-175">The array to convert to a <see cref="T:System.Span`1" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45ff5-176">Definiert eine implizite Konvertierung eines Arrays in <see cref="T:System.Span`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-176">Defines an implicit conversion of an array to a <see cref="T:System.Span`1" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45ff5-177">Das Span-Element, das <paramref name="array" /> entspricht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-177">The span that corresponds to <paramref name="array" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator Span&lt;T&gt; (ArraySegment&lt;T&gt; arraySegment);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Span`1&lt;!T&gt; op_Implicit(valuetype System.ArraySegment`1&lt;!T&gt; arraySegment) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (arraySegment As ArraySegment(Of T)) As Span(Of T)" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator Span&lt;T&gt;(ArraySegment&lt;T&gt; arraySegment);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C#" Value="public static implicit operator Span&lt;T&gt; (ArraySegment&lt;T&gt; segment);" FrameworkAlternate="netcore-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Span`1&lt;!T&gt; op_Implicit(valuetype System.ArraySegment`1&lt;!T&gt; segment) cil managed" FrameworkAlternate="netcore-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Implicit(System.ArraySegment{`0})~System.Span{`0}" FrameworkAlternate="netcore-2.1;netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (segment As ArraySegment(Of T)) As Span(Of T)" FrameworkAlternate="netcore-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator Span&lt;T&gt;(ArraySegment&lt;T&gt; segment);" FrameworkAlternate="netcore-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arraySegment" Type="System.ArraySegment&lt;T&gt;" Index="0" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" Index="0" FrameworkAlternate="netcore-2.1" />
      </Parameters>
      <Docs>
        <param name="arraySegment">
          <span data-ttu-id="45ff5-178">Das Segment des Arrays, das in <see cref="T:System.Span`1" /> konvertiert werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-178">The array segment to be converted to a <see cref="T:System.Span`1" />.</span>
          </span>
        </param>
        <param name="segment">
          <span data-ttu-id="45ff5-179">Das Segment des Arrays, das in <see cref="T:System.Span`1" /> konvertiert werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-179">The array segment to be converted to a <see cref="T:System.Span`1" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45ff5-180">Definiert eine implizite Konvertierung von <see cref="T:System.ArraySegment`1" /> in <see cref="T:System.Span`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-180">Defines an implicit conversion of an <see cref="T:System.ArraySegment`1" /> to a <see cref="T:System.Span`1" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45ff5-181">Ein Span-Element, das dem Segment des Arrays entspricht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-181">A span that corresponds to the array segment.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Span&lt;T&gt; left, Span&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Span`1&lt;!T&gt; left, valuetype System.Span`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Inequality(System.Span{`0},System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Span(Of T), right As Span(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Span&lt;T&gt; left, Span&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Span&lt;T&gt;" />
        <Parameter Name="right" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="45ff5-182">Das erste zu vergleichende Span-Element.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-182">The first span to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="45ff5-183">Das zweite zu vergleichende Span-Element.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-183">The second span to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45ff5-184">Gibt einen Wert zurück, der angibt, ob zwei <see cref="T:System.Span`1" />-Objekte ungleich sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-184">Returns a value that indicates whether two <see cref="T:System.Span`1" /> objects are not equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45ff5-185">
            <see langword="true" />, wenn die beiden <see cref="T:System.Span`1" />-Objekte ungleich sind, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-185">
              <see langword="true" /> if the two <see cref="T:System.Span`1" /> objects are not equal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="45ff5-186">Zwei <xref:System.Span%601> -Objekte gleich sind, wenn sie unterschiedliche Längen aufweisen oder die entsprechenden Elemente der `left` und `right` zeigen nicht auf den gleichen Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="45ff5-186">Two <xref:System.Span%601> objects are equal if they have different lengths or if the corresponding elements of `left` and `right` do not point to the same memory.</span></span> 

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt; Slice (int start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1&lt;!T&gt; Slice(int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Slice(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Slice (start As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt; Slice(int start);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">
          <span data-ttu-id="45ff5-187">Der Index, an dem der Slice beginnen soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-187">The index at which to begin the slice.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45ff5-188">Bildet einen Slice aus dem aktuellen Span-Element, das an einem angegebenen Index beginnt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-188">Forms a slice out of the current span that begins at a specified index.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45ff5-189">Ein Span-Element, das aus allen Elementen des aktuellen Span-Elements von <paramref name="index" /> bis zum Ende des Span-Elements besteht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-189">A span that consists of all elements of the current span from <paramref name="index" /> to the end of the span.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="45ff5-190">
            <paramref name="index" /> ist kleiner als 0 (null) oder größer oder gleich <see cref="T:System.Span`1.Length" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-190">
              <paramref name="index" /> is less than zero or greater than or equal to <see cref="T:System.Span`1.Length" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt; Slice (int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1&lt;!T&gt; Slice(int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Slice(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Slice (start As Integer, length As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt; Slice(int start, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">
          <span data-ttu-id="45ff5-191">Der Index, an dem dieser Slice beginnen soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-191">The index at which to begin this slice.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="45ff5-192">Die gewünschte Länge des Slices.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-192">The desired length for the slice.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45ff5-193">Bildet einen Slice aus dem aktuellen Span-Element. Dabei wird an einem angegebenen Index für eine angegebene Länge begonnen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-193">Forms a slice out of the current span starting at a specified index for a specified length.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45ff5-194">Ein Span-Element, das aus allen <paramref name="length" />-Elementen des aktuellen Span-Elements besteht. Dabei wird bei <paramref name="index" /> begonnen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-194">&gt;A span that consists of <paramref name="length" /> elements from the current span starting at <paramref name="index" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="45ff5-195">
            <paramref name="start" /> oder <paramref name="start" /> + <paramref name="index" /> ist kleiner als 0 (null) oder größer als <see cref="T:System.Span`1.Length" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-195">
              <paramref name="start" /> or <paramref name="start" /> + <paramref name="index" /> is less than zero or greater than <see cref="T:System.Span`1.Length" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="45ff5-196">Kopiert die Inhalte dieses Span-Elements in ein neues Array.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-196">Copies the contents of this span into a new array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45ff5-197">Ein Array das die Daten des aktuellen Span-Elements enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-197">An array containing the data in the current span.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="45ff5-198">Diese Methode führt eine Heapzuordnung und sollten daher nach Möglichkeit vermieden werden.</span><span class="sxs-lookup"><span data-stu-id="45ff5-198">This method performs a heap allocation and therefore should be avoided if possible.</span></span> <span data-ttu-id="45ff5-199">Es manchmal notwendig, wenn APIs unterstützen <xref:System.Span%601> Objekte sind nicht verfügbar, jedoch sind APIs, die mit Arrays arbeiten.</span><span class="sxs-lookup"><span data-stu-id="45ff5-199">It it sometimes necessary when APIs that support <xref:System.Span%601> objects are not available but APIs that work with arrays are.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="45ff5-200">Gibt die Zeichenfolgendarstellung dieses <see cref="T:System.Span`1" />-Objekts zurück.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-200">Returns the string representation of this <see cref="T:System.Span`1" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45ff5-201">Die Zeichenfolgendarstellung dieses <see cref="T:System.Span`1" />-Objekts.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-201">The string representation of this <see cref="T:System.Span`1" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
<span data-ttu-id="45ff5-202">Für eine `Span<Char>`, `ToString` Methode gibt ein <xref:System.String> , enthält die Zeichen, die durch die <xref:System.Span%601>.</span><span class="sxs-lookup"><span data-stu-id="45ff5-202">For a `Span<Char>`, the `ToString` method returns a <xref:System.String> that contains the characters pointed to by the <xref:System.Span%601>.</span></span> <span data-ttu-id="45ff5-203">Zurückgegeben, andernfalls ein <xref:System.String> mit dem Namen des Typs und die Anzahl der Elemente, die die <xref:System.Span%601> enthält.</span><span class="sxs-lookup"><span data-stu-id="45ff5-203">Otherwise, it returns a <xref:System.String> with the name of the type and the number of elements that the <xref:System.Span%601> contains.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCopyTo">
      <MemberSignature Language="C#" Value="public bool TryCopyTo (Span&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryCopyTo(valuetype System.Span`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.TryCopyTo(System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryCopyTo (destination As Span(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryCopyTo(Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="destination">
          <span data-ttu-id="45ff5-204">Das Ziel des Kopiervorgangs.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-204">The target of the copy operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45ff5-205">Versucht, das aktuelle <see cref="T:System.Span`1" />-Element in ein <see cref="T:System.Span`1" />-Zielelement zu kopieren und gibt einen Wert zurück, der angibt, ob der Kopiervorgang erfolgreich war.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-205">Attempts to copy the current <see cref="T:System.Span`1" /> to a destination <see cref="T:System.Span`1" /> and returns a value that indicates whether the copy operation succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45ff5-206">
            <see langword="true" />, wenn der Kopiervorgang erfolgreich war; andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45ff5-206">
              <see langword="true" /> if the copy operation succeeded; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="45ff5-207">Diese Methode kopiert alle `source` auf `destination` selbst wenn `source` und `destination` überlappen.</span><span class="sxs-lookup"><span data-stu-id="45ff5-207">This method copies all of `source` to `destination` even if `source` and `destination` overlap.</span></span>

<span data-ttu-id="45ff5-208">Wenn `destination` ist kürzer als die Quelle <xref:System.Span%601>, gibt diese Methode `false`, und keine Daten geschrieben `destination`.</span><span class="sxs-lookup"><span data-stu-id="45ff5-208">If `destination` is shorter than the source <xref:System.Span%601>, this method returns `false`, and no data is written to `destination`.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>