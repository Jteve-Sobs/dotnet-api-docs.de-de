<Type Name="Span&lt;T&gt;" FullName="System.Span&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c61e6b59e39fd9f77ea203c0bdabd7429fb24683" /><Meta Name="ms.sourcegitcommit" Value="2dd0eede6edd6dd3d2aa8f79010848658b967609" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="04/18/2019" /><Meta Name="ms.locfileid" Value="59472182" /></Metadata><TypeSignature Language="C#" Value="public struct Span&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Span`1&lt;T&gt; extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.Span`1" />
  <TypeSignature Language="VB.NET" Value="Public Structure Span(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public value class Span" />
  <TypeSignature Language="F#" Value="type Span&lt;'T&gt; = struct" />
  <AssemblyInfo>
    <AssemblyName>System.Memory</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.2;netcore-2.1;netcore-3.0;netstandard-2.1">
      <AttributeName>System.Runtime.CompilerServices.IsByRefLike</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.2;netcore-2.1;netcore-3.0;netstandard-2.1">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Der Typ der Elemente in der <see cref="System.Span`1" />.</typeparam>
    <summary>Dieser enthält eine typ- und arbeitsspeichersichere Darstellung einer zusammenhängenden Region von beliebigem Arbeitsspeicher.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  

`Span<T>` ist eine [Referenzstruktur](~/docs/csharp/language-reference/keywords/ref.md#ref-struct-types) , die auf dem Stapel und nicht auf dem verwalteten Heap zugeordnet ist. Ref Struct-Typen haben eine Reihe von Einschränkungen, um sicherzustellen, dass sie können nicht auf den verwalteten Heap, einschließlich der, dass sie die nicht geschachtelt werden können, sie können nicht zugewiesen werden, die Variablen vom Typ heraufgestuft werden <xref:System.Object>, `dynamic` oder auf einen beliebigen anderen Schnittstellentyp, können sie nicht werden Felder in einem Verweistyp, und sie können nicht verwendet werden, über `await` und `yield` Grenzen. Darüber hinaus Aufrufe von zwei Methoden, <xref:System.Span%601.Equals(System.Object)> und <xref:System.Span%601.GetHashCode%2A>, lösen eine <xref:System.NotSupportedException>. 

> [!IMPORTANT]
> Da es sich um einen Typ ausschließlich stapelbezogene ist `Span<T>` für viele Szenarien, die erfordern, Speichern von Verweisen auf Puffer auf dem Heap nicht geeignet ist. Dies gilt, z. B. von Routinen, die Methodenaufrufe Asynchrous vornehmen. In solchen Fällen können Sie die kostenlose <xref:System.Memory%601?displayProperty=nameWithType> und <xref:System.ReadOnlyMemory%601?displayProperty=nameWithType> Typen.

Verwenden Sie für Span-Elemente, die unveränderliche oder schreibgeschützte Strukturen darstellen, <xref:System.ReadOnlySpan%601?displayProperty=nameWithType>.

## <a name="spant-and-memory"></a>Spanne\<T > und Arbeitsspeicher

Ein `Span<T>` stellt einen zusammenhängenden Bereich von beliebigen Speichers dar. Ein `Span<T>` Instanz wird häufig verwendet, um die Elemente eines Arrays oder einen Teil eines Arrays zu speichern. Im Gegensatz zu einem Array, jedoch eine `Span<T>` Instanz kann auf verwalteten Speicher, systemeigenen Speicher oder Arbeitsspeicher verwaltet, auf dem Stapel. Das folgende Beispiel erstellt eine `Span<Byte>` aus einem Array:

[!code-csharp[Creating a Span\<Byte> from an array](~/samples/snippets/csharp/api/system/span/program.cs#1)]
     
Das folgende Beispiel erstellt eine `Span<Byte>` zwischen 100 Byte des systemeigenen Speicher:

[!code-csharp[Creating a Span\<Byte> from native memory](~/samples/snippets/csharp/api/system/span/program.cs#2)]

Im folgenden Beispiel wird die C# ["stackalloc"](~/docs/csharp/language-reference/keywords/stackalloc.md) Schlüsselwort, um 100 Bytes im Arbeitsspeicher auf dem Stapel zugeordnet:

[!code-csharp[Creating a Span\<Byte> from stack-allocated memory](~/samples/snippets/csharp/api/system/span/program.cs#3)]

Da `Span<T>` ist eine Abstraktion über ein beliebiger Speicherblock, Methoden der `Span<T>` -Klasse und Methoden mit `Span<T>` Parameter ausgeführt werden, auf einem `Span<T>` Objekt unabhängig von der Art des Arbeitsspeichers, die diese kapselt. Beispielsweise zeigt jede separate Abschnitte des Codes, die die Spanne zu initialisieren und zu berechnen, dass die Summe der Elemente in die einmalige Initialisierung und Berechnungsmethoden, wie im folgenden Beispiel geändert werden kann:

[!code-csharp[Creating a Span\<Byte> from stack-allocated memory](~/samples/snippets/csharp/api/system/span/program.cs#4)]

## <a name="spant-and-arrays"></a>Spanne\<T > und Arrays

Wenn es dient als Wrapper für ein Array, `Span<T>` kann ein ganzes Array, umschließen, wie zuvor in den Beispielen in den [Spanne\<T > und Arbeitsspeicher](#spant-and-memory) Abschnitt. Da es unterstützt das Aufteilen in Slices, `Span<T>` können auch auf alle zusammenhängenden Bereich innerhalb des Arrays zeigen.  

Das folgende Beispiel erstellt einen Slice von der mittleren fünf Elemente eines Arrays aus 10 Elementen ganze Zahl. Beachten Sie, dass der Code die Werte der jede Ganzzahl im Segment verdoppelt. Die Ausgabe zeigt, werden die Änderungen durch die Spanne in die Werte des Arrays angezeigt.

[!code-csharp[Creating a slice from a portion of a span](~/samples/snippets/csharp/api/system/span/slice/program.cs)]

## <a name="spant-and-slices"></a>Spanne\<T > und Slices

`Span<T>` enthält zwei Überladungen der <xref:System.Span%601.Slice%2A> Methode, die einen Slice aus der aktuellen Spanne zu bilden, die an einem angegebenen Index beginnt. Dies ermöglicht es, behandeln die Daten in eine `Span<T>` als einen Satz von logischen Segmente, die verarbeitet werden können, wie Teile eine datenverarbeitungspipeline mit Auswirkungen auf die minimale Leistung benötigt. Da moderne Serverprotokolle häufig textbasiert sind, ist z. B. Bearbeiten von Zeichenfolgen und Teilzeichenfolgen besonders wichtig. In der <xref:System.String> Klasse, die wichtige Methode für das Extrahieren von Teilzeichenfolgen ist <xref:System.String.Substring%2A>. Für Datenpipelines, die auf umfangreichen zeichenfolgenbearbeitung basieren, bietet die Verwendung einige Leistungseinbußen zur Folge haben, da sie:

1. Erstellt eine neue Zeichenfolge zum Speichern der Teilzeichenfolge.

2. Kopiert eine Teilmenge der Zeichen aus der ursprünglichen Zeichenfolge in die neue Zeichenfolge.

Dieser Vorgang Zuordnung und kopieren kann behoben werden, indem Sie entweder `Span<T>` oder <xref:System.ReadOnlySpan%601>, wie im folgende Beispiel gezeigt:

[!code-csharp[Creating a slice from a substring](~/samples/snippets/csharp/api/system/span/slice2/program.cs)]


      ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Span (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.#ctor(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="new Span&lt;'T&gt; : 'T[] -&gt; Span&lt;'T&gt;" Usage="new System.Span&lt;'T&gt; array" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array">Das Array, aus dem das <see cref="T:System.Span`1" />-Objekt erstellt werden soll.</param>
        <summary>Erstellt ein neues <see cref="T:System.Span`1" />-Objekt über das gesamte angegebene Array.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Wenn `array` ist `null`, diesen Konstruktor gibt eine `null` `Span<T>`.

      ]]></format>
        </remarks>
        <exception cref="T:System.TypeMismatchException"><paramref name="T" /> ist ein Verweistyp, und <paramref name="array" /> ist kein Array des Typs <paramref name="T" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Span (void* pointer, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(void* pointer, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.#ctor(System.Void*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span(void* pointer, int length);" />
      <MemberSignature Language="F#" Value="new Span&lt;'T&gt; : nativeptr&lt;unit&gt; * int -&gt; Span&lt;'T&gt;" Usage="new System.Span&lt;'T&gt; (pointer, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.2;netcore-2.1;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pointer" Type="System.Void*" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pointer">Ein Zeiger auf die Startadresse einer angegebenen Anzahl von <typeparamref name="T" />-Elementen im Arbeitsspeicher.</param>
        <param name="length">Die Anzahl von <typeparamref name="T" />-Elementen, die in <see cref="T:System.Span`1" /> eingeschlossen werden sollen.</param>
        <summary>Erstellt ein neues <see cref="T:System.Span`1" />-Objekt aus einer angegebenen Anzahl von <typeparamref name="T" />-Elementen. Dabei wird an der angegebenen Speicheradresse begonnen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

        This constructor should be used with care, since it creates arbitrarily typed `T`s from a `void*`-typed block of memory, and `length` is not checked. However, if the constructor succeeds in creating a new <xref:System.Span%601> object, all subsequent uses are correct.        

      ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="T" /> ist ein Verweistyp oder enthält Zeiger und kann deshalb nicht in nicht verwaltetem Arbeitsspeicher gespeichert werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length" /> ist ein negativer Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Span (T[] array, int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T[] array, int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.#ctor(`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (array As T(), start As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span(cli::array &lt;T&gt; ^ array, int start, int length);" />
      <MemberSignature Language="F#" Value="new Span&lt;'T&gt; : 'T[] * int * int -&gt; Span&lt;'T&gt;" Usage="new System.Span&lt;'T&gt; (array, start, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das Quellarray.</param>
        <param name="start">Der Index des ersten Elements, das im neuen <see cref="T:System.Span`1" />-Element enthalten sein soll.</param>
        <param name="length">Die Anzahl von Elementen, die in das neue <see cref="T:System.Span`1" />-Element eingeschlossen werden sollen.</param>
        <summary>Erstellt ein neues <see cref="T:System.Span`1" />-Objekt, das eine angegebene Anzahl von Elementen aus einem Array enthält. Dabei wird an einem angegebenen Index begonnen.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="array" /> ist gleich <see langword="null" />, aber <paramref name="start" /> oder <paramref name="length" /> ist nicht 0 (null).

- oder -

<paramref name="start" /> liegt außerhalb der Grenzen des Arrays.

- oder -

<paramref name="start" /> und <paramref name="length" /> überschreiten die Anzahl von Elementen im Array.</exception>
        <exception cref="T:System.TypeMismatchException"><paramref name="T" /> ist ein Verweistyp, und <paramref name="array" /> ist kein Array des Typs <paramref name="T" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="span.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht den Inhalt dieses <see cref="T:System.Span`1" />-Objekts.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Die `Clear` Methode legt die Elemente der <xref:System.Span%601> Objekt auf ihre Standardwerte zurück. Es werden keine entfernt Elemente aus der <xref:System.Span%601>.  

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Span&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(valuetype System.Span`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.CopyTo(System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (destination As Span(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Span&lt;T&gt; destination);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : Span&lt;'T&gt; -&gt; unit" Usage="span.CopyTo destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="destination">Das <see cref="System.Span`1" />-Zielobjekt.</param>
        <summary>Kopiert die Inhalte dieses <see cref="System.Span`1" />-Elements in ein <see cref="System.Span`1" />-Zielelement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Diese Methode kopiert alle `source` zu `destination` selbst wenn `source` und `destination` überlappen.

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="destination" /> ist kürzer als das <see cref="System.Span`1" />-Quellelement.</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; Empty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Span`1&lt;!T&gt; Empty" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Empty As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Span&lt;T&gt; Empty { Span&lt;T&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Empty : Span&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.Empty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt ein leeres <see cref="T:System.Span`1" />-Objekt zurück.</summary>
        <value>Ein leeres <see cref="T:System.Span`1" />-Objekt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="span.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Equals() on Span will always throw an exception. Use == instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Wird nicht unterstützt.</param>
        <summary>Das Aufrufen dieser Methode wird nicht unterstützt.</summary>
        <returns>Das Aufrufen dieser Methode wird nicht unterstützt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
Aufrufe von der <xref:System.Span%601.Equals%2A> Methode werden nicht unterstützt. Aufrufe von der <xref:System.Span%601.Equals%2A> Methoden generieren eine von zwei Ergebnissen:

- Wenn `obj` ist eine <xref:System.Span%601>, Aufruf der Methode generiert den Compilerfehler CS1503: "Konvertierung von 'System.Span' in 'Object'." Grund hierfür ist, <xref:System.Span%601> ist eine [Referenzstruktur](~/docs/csharp/reference-semantics-with-value-types.md#ref-struct-type) , die nicht geschachtelt werden und daher nicht konvertiert werden, um eine <xref:System.Object>.

- Wenn der Typ des `obj` keine <xref:System.Span%601>, löst der Methodenaufruf eine <xref:System.NotSupportedException>. 

Zum Vergleichen zweier <xref:System.Span%601> Objekte auf Gleichheit, verwenden die <xref:System.Span%601.op_Equality%2A> Vergleichsoperator.

        ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Das Aufrufen dieser Methode wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public void Fill (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Fill(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Fill(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Fill (value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Fill(T value);" />
      <MemberSignature Language="F#" Value="member this.Fill : 'T -&gt; unit" Usage="span.Fill value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der jedem Element des Span-Elements zugewiesen werden soll.</param>
        <summary>Füllt die Elemente dieses Span-Elements mit einem angegebenen Wert auf.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As Span(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; Span&lt;'T&gt;.Enumerator" Usage="span.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator für dieses <see cref="T:System.Span`1" />-Element zurück.</summary>
        <returns>Ruft einen Enumerator für dieses Span-Element ab.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
Statt die <xref:System.Span%601.GetEnumerator%2A> Methode direkt verwenden, können Sie die C#- `foreach` -Anweisung und die Visual Basic `For Each`... `Next` -Konstrukt zum Aufzählen einer <xref:System.Span%601>.

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="span.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("GetHashCode() on Span will always throw an exception.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löst eine <see cref="T:System.NotSupportedException" /> aus.</summary>
        <returns>Beim Aufrufen dieser Methode wird immer <see cref="T:System.NotSupportedException" /> ausgelöst.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Das Aufrufen dieser Methode wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPinnableReference">
      <MemberSignature Language="C#" Value="public T GetPinnableReference ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T GetPinnableReference() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.GetPinnableReference" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPinnableReference () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T % GetPinnableReference();" />
      <MemberSignature Language="F#" Value="member this.GetPinnableReference : unit -&gt; " Usage="span.GetPinnableReference " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T@</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Verweis auf das Element von <see cref="T:System.Span`1" /> zurück, das sich am Index 0 befindet.</summary>
        <returns>Ein Verweis auf das Element von <see cref="T:System.Span`1" /> am Index 0, oder <see langword="null" />, wenn <see cref="M:System.Span`1.IsEmpty" /> gleich <see langword="true" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Die `GetPinnableReference` Methode gibt eine [Referenzstruktur](~/docs/csharp/reference-semantics-with-value-types.md#ref-struct-type). Es kann verwendet werden, für das Fixieren von einem <xref:System.Span%601> im Arbeitsspeicher. Es ist erforderlich, um die Verwendung von unterstützen eine <xref:System.Span%601> innerhalb einer [behoben](~/docs/csharp/language-reference/keywords/fixed-statement.md) Anweisung.

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.IsEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEmpty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEmpty : bool" Usage="System.Span&lt;'T&gt;.IsEmpty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob das aktuelle <see cref="T:System.Span`1" />-Element leer ist.</summary>
        <value><see langword="true" /> Wenn die aktuelle Spanne leer ist; andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[Index index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(valuetype System.Index)" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Item(System.Index)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(index As Index) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T % default[Index] { T % get(Index index); };" />
      <MemberSignature Language="F#" Value="member this.Item(Index) : " Usage="System.Span&lt;'T&gt;.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Index" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(index As Integer) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T % default[int] { T % get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : " Usage="System.Span&lt;'T&gt;.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index des Elements.</param>
        <summary>Ruft das Element am angegebenen nullbasierten Index ab.</summary>
        <value>Das Element am angegebenen Index.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> ist kleiner als 0 (null) oder größer oder gleich <see cref="P:System.Span`1.Length" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt; this[Range range] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Span`1&lt;!T&gt; Item(valuetype System.Range)" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Item(System.Range)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(range As Range) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Span&lt;T&gt; default[Range] { Span&lt;T&gt; get(Range range); };" />
      <MemberSignature Language="F#" Value="member this.Item(Range) : Span&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Range" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="range">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.Span&lt;'T&gt;.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die Länge des aktuellen Span-Elements fest.</summary>
        <value>Die Länge des die aktuelle Spanne.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Span&lt;T&gt; left, Span&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Span`1&lt;!T&gt; left, valuetype System.Span`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Equality(System.Span{`0},System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Span(Of T), right As Span(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Span&lt;T&gt; left, Span&lt;T&gt; right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Span&lt;'T&gt; * Span&lt;'T&gt; -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Span&lt;T&gt;" />
        <Parameter Name="right" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="left">Das erste zu vergleichende Span-Element.</param>
        <param name="right">Das zweite zu vergleichende Span-Element.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei <see cref="T:System.Span`1" />-Objekte gleich sind.</summary>
        <returns><see langword="true" />, wenn die beiden <see cref="T:System.Span`1" />-Objekte gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Zwei <xref:System.Span%601> Objekte sind gleich, wenn die gleiche Länge und die entsprechenden Elemente der wurden `left` und `right` zeigen Sie auf den gleichen Speicher. Beachten Sie, dass der Test auf Gleichheit *nicht* versucht zu bestimmen, ob der Inhalt gleich sind.

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator Span&lt;T&gt; (ArraySegment&lt;T&gt; arraySegment);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Span`1&lt;!T&gt; op_Implicit(valuetype System.ArraySegment`1&lt;!T&gt; arraySegment) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (arraySegment As ArraySegment(Of T)) As Span(Of T)" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator Span&lt;T&gt;(ArraySegment&lt;T&gt; arraySegment);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C#" Value="public static implicit operator Span&lt;T&gt; (ArraySegment&lt;T&gt; segment);" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Span`1&lt;!T&gt; op_Implicit(valuetype System.ArraySegment`1&lt;!T&gt; segment) cil managed" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Implicit(System.ArraySegment{`0})~System.Span{`0}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (segment As ArraySegment(Of T)) As Span(Of T)" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator Span&lt;T&gt;(ArraySegment&lt;T&gt; segment);" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="static member op_Implicit : ArraySegment&lt;'T&gt; -&gt; Span&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.op_Implicit segment" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="segment">Das Segment des Arrays, das in <see cref="T:System.Span`1" /> konvertiert werden soll.</param>
        <summary>Definiert eine implizite Konvertierung von <see cref="T:System.ArraySegment`1" /> in <see cref="T:System.Span`1" />.</summary>
        <returns>Ein Span-Element, das dem Segment des Arrays entspricht.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;T&gt; (Span&lt;T&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;!T&gt; op_Implicit(valuetype System.Span`1&lt;!T&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Implicit(System.Span{`0})~System.ReadOnlySpan{`0}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (span As Span(Of T)) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;T&gt;(Span&lt;T&gt; span);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : Span&lt;'T&gt; -&gt; ReadOnlySpan&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.op_Implicit span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="span">Das in eine <see cref="T:System.ReadOnlySpan`1" /> zu konvertierende Objekt.</param>
        <summary>Definiert eine implizite Konvertierung von <see cref="T:System.Span`1" /> in <see cref="T:System.ReadOnlySpan`1" />.</summary>
        <returns>Ein schreibgeschütztes Span-Element, das dem aktuellen Attribut entspricht.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator Span&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Span`1&lt;!T&gt; op_Implicit(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Implicit(`0[])~System.Span{`0}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (array As T()) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator Span&lt;T&gt;(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : 'T[] -&gt; Span&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.op_Implicit array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array">Das Array, das in <see cref="T:System.Span`1" /> konvertiert werden soll.</param>
        <summary>Definiert eine implizite Konvertierung eines Arrays in <see cref="T:System.Span`1" />.</summary>
        <returns>Das Span-Element, das <paramref name="array" /> entspricht.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Span&lt;T&gt; left, Span&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Span`1&lt;!T&gt; left, valuetype System.Span`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Inequality(System.Span{`0},System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Span(Of T), right As Span(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Span&lt;T&gt; left, Span&lt;T&gt; right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Span&lt;'T&gt; * Span&lt;'T&gt; -&gt; bool" Usage="System.Span&lt;'T&gt;.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Span&lt;T&gt;" />
        <Parameter Name="right" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="left">Das erste zu vergleichende Span-Element.</param>
        <param name="right">Das zweite zu vergleichende Span-Element.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei <see cref="T:System.Span`1" />-Objekte ungleich sind.</summary>
        <returns><see langword="true" />, wenn die beiden <see cref="T:System.Span`1" />-Objekte ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Zwei <xref:System.Span%601> Objekte sind gleich, wenn sie unterschiedlich lang sind oder wenn die entsprechenden Elemente der `left` und `right` zeigen nicht auf den gleichen Speicher. 

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt; Slice (Index startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1&lt;!T&gt; Slice(valuetype System.Index startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Slice(System.Index)" />
      <MemberSignature Language="VB.NET" Value="Public Function Slice (startIndex As Index) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt; Slice(Index startIndex);" />
      <MemberSignature Language="F#" Value="member this.Slice : Index -&gt; Span&lt;'T&gt;" Usage="span.Slice startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Index" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="startIndex">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt; Slice (int start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1&lt;!T&gt; Slice(int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Slice(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Slice (start As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt; Slice(int start);" />
      <MemberSignature Language="F#" Value="member this.Slice : int -&gt; Span&lt;'T&gt;" Usage="span.Slice start" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">Der Index, an dem der Slice beginnen soll.</param>
        <summary>Bildet einen Slice aus dem aktuellen Span-Element, das an einem angegebenen Index beginnt.</summary>
        <returns>Ein Span-Element, das aus allen Elementen des aktuellen Span-Elements von <paramref name="index" /> bis zum Ende des Span-Elements besteht.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0 (null) oder größer oder gleich <see cref="T:System.Span`1.Length" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt; Slice (Range range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1&lt;!T&gt; Slice(valuetype System.Range range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Slice(System.Range)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt; Slice(Range range);" />
      <MemberSignature Language="F#" Value="member this.Slice : Range -&gt; Span&lt;'T&gt;" Usage="span.Slice range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Range" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="range">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt; Slice (int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1&lt;!T&gt; Slice(int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Slice(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Slice (start As Integer, length As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt; Slice(int start, int length);" />
      <MemberSignature Language="F#" Value="member this.Slice : int * int -&gt; Span&lt;'T&gt;" Usage="span.Slice (start, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">Der Index, an dem dieser Slice beginnen soll.</param>
        <param name="length">Die gewünschte Länge des Slices.</param>
        <summary>Bildet einen Slice aus dem aktuellen Span-Element. Dabei wird an einem angegebenen Index für eine angegebene Länge begonnen.</summary>
        <returns>Ein Span-Element besteht aus <paramref name="length" />-Elementen des aktuellen Span-Elements. Dabei wird bei <paramref name="index" /> begonnen.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="start" /> oder <paramref name="start" /> + <paramref name="index" /> ist kleiner als 0 (null) oder größer als <see cref="T:System.Span`1.Length" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="span.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kopiert die Inhalte dieses Span-Elements in ein neues Array.</summary>
        <returns>Ein Array das die Daten des aktuellen Span-Elements enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Diese Methode führt eine Heapzuordnung und kann aus diesem Grund sollte möglichst vermieden werden. Es manchmal notwendig, wenn Unterstützung für APIs, die <xref:System.Span%601> Objekte sind nicht verfügbar, jedoch sind APIs, die mit Arrays arbeiten.

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="span.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die Zeichenfolgendarstellung dieses <see cref="T:System.Span`1" />-Objekts zurück.</summary>
        <returns>Die Zeichenfolgendarstellung dieses <see cref="T:System.Span`1" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
Für eine `Span<Char>`, `ToString` Methode gibt eine <xref:System.String> , enthält die Zeichen, verweist der <xref:System.Span%601>. Andernfalls wird eine <xref:System.String> mit dem Namen des Typs und die Anzahl der Elemente, die die <xref:System.Span%601> enthält.

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCopyTo">
      <MemberSignature Language="C#" Value="public bool TryCopyTo (Span&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryCopyTo(valuetype System.Span`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.TryCopyTo(System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryCopyTo (destination As Span(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryCopyTo(Span&lt;T&gt; destination);" />
      <MemberSignature Language="F#" Value="member this.TryCopyTo : Span&lt;'T&gt; -&gt; bool" Usage="span.TryCopyTo destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="destination">Das Ziel des Kopiervorgangs.</param>
        <summary>Versucht, das aktuelle <see cref="T:System.Span`1" />-Element in ein <see cref="T:System.Span`1" />-Zielelement zu kopieren und gibt einen Wert zurück, der angibt, ob der Kopiervorgang erfolgreich war.</summary>
        <returns><see langword="true" />, wenn der Kopiervorgang erfolgreich war; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Diese Methode kopiert alle `source` zu `destination` selbst wenn `source` und `destination` überlappen.

Wenn `destination` ist kürzer als die Quelle <xref:System.Span%601>, gibt diese Methode `false`, und keine Daten geschrieben werden, um `destination`.

         ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>