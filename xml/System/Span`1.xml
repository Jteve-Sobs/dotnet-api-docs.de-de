<Type Name="Span&lt;T&gt;" FullName="System.Span&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ed04128e65524eee587eec2d84c3879e4073a91a" />
    <Meta Name="ms.sourcegitcommit" Value="9dda17222b9f7d3edf130133bfb1370d5b410a4b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="09/22/2018" />
    <Meta Name="ms.locfileid" Value="46640996" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Span&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Span`1&lt;T&gt; extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.Span`1" />
  <TypeSignature Language="VB.NET" Value="Public Structure Span(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public value class Span" />
  <TypeSignature Language="F#" Value="type Span&lt;'T&gt; = struct" />
  <AssemblyInfo>
    <AssemblyName>System.Memory</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.1">
      <AttributeName>System.Runtime.CompilerServices.IsByRefLike</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.1">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Der Typ der Elemente in der <see cref="System.Span`1" />.</typeparam>
    <summary>Dieser enthält eine typ- und arbeitsspeichersichere Darstellung einer zusammenhängenden Region von beliebigem Arbeitsspeicher.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  

`Span<T>` ist eine [Referenzstruktur](~/docs/csharp/reference-semantics-with-value-types.md#ref-struct-type) , die auf dem Stapel und nicht auf dem verwalteten Heap zugeordnet ist. Ref Struct-Typen haben eine Reihe von Einschränkungen, um sicherzustellen, dass sie können nicht auf den verwalteten Heap, einschließlich der, dass nicht geschachtelt werden, und sie nicht werden, die Variablen vom Typ zugewiesen können heraufgestuft werden <xref:System.Object>, `dynamic`, und klicken Sie auf einen beliebigen anderen Schnittstellentyp.

Ein `Span<T>` Instanz wird häufig verwendet, um die Elemente eines Arrays oder einen Teil eines Arrays zu speichern. Im Gegensatz zu einem Array, jedoch eine `Span<T>` Instanz kann auf verwalteten Speicher, systemeigenen Speicher oder Arbeitsspeicher verwaltet, auf dem Stapel.

      ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Span (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.#ctor(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="new Span&lt;'T&gt; : 'T[] -&gt; Span&lt;'T&gt;" Usage="new System.Span&lt;'T&gt; array" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array">Das Array, aus dem das <see cref="T:System.Span`1" />-Objekt erstellt werden soll.</param>
        <summary>Erstellt ein neues <see cref="T:System.Span`1" />-Objekt über das gesamte angegebene Array.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Wenn `array` ist `null`, diesen Konstruktor gibt eine `null` `Span<T>`.

      ]]></format>
        </remarks>
        <exception cref="T:System.TypeMismatchException">
          <paramref name="T" /> ist ein Verweistyp, und <paramref name="array" /> ist kein Array des Typs <paramref name="T" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Span (void* pointer, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(void* pointer, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.#ctor(System.Void*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span(void* pointer, int length);" />
      <MemberSignature Language="F#" Value="new Span&lt;'T&gt; : nativeptr&lt;unit&gt; * int -&gt; Span&lt;'T&gt;" Usage="new System.Span&lt;'T&gt; (pointer, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pointer" Type="System.Void*" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pointer">Ein Zeiger zur Startadresse einer angegebenen Anzahl von Bytes im Arbeitsspeicher.</param>
        <param name="length">Die Anzahl von Bytes, die in <see cref="T:System.Span`1" /> eingeschlossen werden sollen.</param>
        <summary>Erstellt ein neues <see cref="T:System.Span`1" />-Objekt aus einer angegebenen Anzahl von Bytes. Dabei wird an der angegebenen Speicheradresse begonnen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

        This constructor should be used with care, since it creates arbitrarily typed `T`s from a `void*`-typed block of memory, and `length` is not checked. However, if the constructor succeeds in creating a new <xref:System.Span%601> object, all subsequent uses are correct.        

      ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="T" /> ist ein Verweistyp oder enthält Zeiger und kann deshalb nicht in nicht verwaltetem Arbeitsspeicher gespeichert werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> ist ein negativer Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Span (T[] array, int start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T[] array, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.#ctor(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (array As T(), start As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span(cli::array &lt;T&gt; ^ array, int start);" />
      <MemberSignature Language="F#" Value="new Span&lt;'T&gt; : 'T[] * int -&gt; Span&lt;'T&gt;" Usage="new System.Span&lt;'T&gt; (array, start)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das Quellarray.</param>
        <param name="start">Der Index des ersten Elements im Array, das in das <see cref="T:System.Span`1" />-Objekt eingeschlossen werden soll.</param>
        <summary>Erstellt ein neues <see cref="T:System.Span`1" />-Objekt aus einem angegebenen Array. Die Erstellung beginnt an einer angegebenen Indexposition und wird bis zum Ende des Arrays fortgesetzt.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Span (T[] array, int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T[] array, int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.#ctor(`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (array As T(), start As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span(cli::array &lt;T&gt; ^ array, int start, int length);" />
      <MemberSignature Language="F#" Value="new Span&lt;'T&gt; : 'T[] * int * int -&gt; Span&lt;'T&gt;" Usage="new System.Span&lt;'T&gt; (array, start, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das Quellarray.</param>
        <param name="start">Der Index des ersten Elements, das im neuen <see cref="T:System.Span`1" />-Element enthalten sein soll.</param>
        <param name="length">Die Anzahl von Elementen, die in das neue <see cref="T:System.Span`1" />-Element eingeschlossen werden sollen.</param>
        <summary>Erstellt ein neues <see cref="T:System.Span`1" />-Objekt, das eine angegebene Anzahl von Elementen aus einem Array enthält. Dabei wird an einem angegebenen Index begonnen.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="array" /> ist gleich <see langword="null" />, aber <paramref name="start" /> oder <paramref name="length" /> ist nicht 0 (null).<p />
– oder –<p /><paramref name="start" /> liegt außerhalb der Grenzen des Arrays. <p />
– oder –<p /><paramref name="start" /> und <paramref name="length" /> überschreiten die Anzahl von Elementen im Array.</exception>
        <exception cref="T:System.TypeMismatchException">
          <paramref name="T" /> ist ein Verweistyp, und <paramref name="array" /> ist kein Array des Typs <paramref name="T" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="span.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht den Inhalt dieses <see cref="T:System.Span`1" />-Objekts.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Die `Clear` Methode legt die Elemente der <xref:System.Span%601> Objekt auf ihre Standardwerte zurück. Es werden keine entfernt Elemente aus der <xref:System.Span%601>.  

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Span&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(valuetype System.Span`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.CopyTo(System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (destination As Span(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Span&lt;T&gt; destination);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : Span&lt;'T&gt; -&gt; unit" Usage="span.CopyTo destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <summary>Kopiert die Inhalte dieses <see cref="System.Span`1" />-Elements in ein <see cref="System.Span`1" />-Zielelement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Diese Methode kopiert alle `source` zu `destination` selbst wenn `source` und `destination` überlappen.

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destination" /> ist kürzer als das <see cref="System.Span`1" />-Quellelement.</exception>
      </Docs>
    </Member>
    <Member MemberName="DangerousCreate">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; DangerousCreate (object obj, ref T objectData, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!T&gt; DangerousCreate(object obj, !T&amp; objectData, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.DangerousCreate(System.Object,`0@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DangerousCreate (obj As Object, ByRef objectData As T, length As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Span&lt;T&gt; DangerousCreate(System::Object ^ obj, T % objectData, int length);" />
      <MemberSignature Language="F#" Value="static member DangerousCreate : obj *  * int -&gt; Span&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.DangerousCreate (obj, objectData, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="objectData" Type="T" RefType="ref" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <param name="objectData">To be added.</param>
        <param name="length">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DangerousGetPinnableReference">
      <MemberSignature Language="C#" Value="public T DangerousGetPinnableReference ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T DangerousGetPinnableReference() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.DangerousGetPinnableReference" />
      <MemberSignature Language="VB.NET" Value="Public Function DangerousGetPinnableReference () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T % DangerousGetPinnableReference();" />
      <MemberSignature Language="F#" Value="member this.DangerousGetPinnableReference : unit -&gt; " Usage="span.DangerousGetPinnableReference " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; Empty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Span`1&lt;!T&gt; Empty" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Empty As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Span&lt;T&gt; Empty { Span&lt;T&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Empty : Span&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.Empty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt ein leeres <see cref="T:System.Span`1" />-Objekt zurück.</summary>
        <value>Ein leeres <see cref="T:System.Span`1" />-Objekt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="span.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1">
          <AttributeName>System.Obsolete("Equals() on Span will always throw an exception. Use == instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Wird nicht unterstützt.</param>
        <summary>Das Aufrufen dieser Methode wird nicht unterstützt.</summary>
        <returns>Das Aufrufen dieser Methode wird nicht unterstützt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
Aufrufe von der <xref:System.Span%601.Equals%2A> Methode werden nicht unterstützt. Aufrufe von der < xref:System.Span%601.Equals%2A-Methoden generieren eine von zwei Ergebnissen:

- Wenn `obj` ist eine <xref:System.Span%601>, Aufruf der Methode generiert den Compilerfehler CS1503: "Konvertierung von 'System.Span' in 'Object'." Grund hierfür ist, <xref:System.Span%601> ist eine [Referenzstruktur](~/docs/csharp/reference-semantics-with-value-types.md#ref-struct-type) , die nicht geschachtelt werden und daher nicht konvertiert werden, um eine <xref:System.Object>.

- Wenn der Typ des `obj` keine <xref:System.Span%601>, löst der Methodenaufruf eine <xref:System.NotSupportedException>. 

Zum Vergleichen zweier <xref:System.Span%601> Objekte auf Gleichheit, verwenden die <xref:System.Span%601.op_Equality%2A> Vergleichsoperator.

        ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Das Aufrufen dieser Methode wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public void Fill (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Fill(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Fill(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Fill (value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Fill(T value);" />
      <MemberSignature Language="F#" Value="member this.Fill : 'T -&gt; unit" Usage="span.Fill value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der jedem Element des Span-Elements zugewiesen werden soll.</param>
        <summary>Füllt die Elemente dieses Span-Elements mit einem angegebenen Wert auf.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As Span(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; Span&lt;'T&gt;.Enumerator" Usage="span.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator für dieses <see cref="T:System.Span`1" />-Element zurück.</summary>
        <returns>Ruft einen Enumerator für dieses Span-Element ab.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
Statt die <xref:System.Span%601.GetEnumerator%2A> Methode direkt verwenden, können Sie die C#- `foreach` -Anweisung und die Visual Basic `For Each`... `Next` -Konstrukt zum Aufzählen einer <xref:System.Span%601>.

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="span.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1">
          <AttributeName>System.Obsolete("GetHashCode() on Span will always throw an exception.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löst eine <see cref="T:System.NotSupportedException" /> aus.</summary>
        <returns>Beim Aufrufen dieser Methode wird immer <see cref="T:System.NotSupportedException" /> ausgelöst.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Das Aufrufen dieser Methode wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPinnableReference">
      <MemberSignature Language="C#" Value="public T GetPinnableReference ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T GetPinnableReference() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.GetPinnableReference" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPinnableReference () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T % GetPinnableReference();" />
      <MemberSignature Language="F#" Value="member this.GetPinnableReference : unit -&gt; " Usage="span.GetPinnableReference " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T@</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Verweis auf das Element von <see cref="T:System.Span`1" /> zurück, das sich am Index 0 befindet.</summary>
        <returns>Ein Verweis auf das Element von <see cref="T:System.Span`1" /> am Index 0, oder <see langword="null" />, wenn <see cref="M:System.Span`1.IsEmpty" /> gleich <see langword="true" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Die `GetPinnableReference` Methode gibt eine [Referenzstruktur](~/docs/csharp/reference-semantics-with-value-types.md#ref-struct-type). Es kann verwendet werden, für das Fixieren von einem <xref:System.Span%601> im Arbeitsspeicher. Es ist erforderlich, um die Verwendung von unterstützen eine <xref:System.Span%601> innerhalb einer [behoben](~/docs/csharp/language-reference/keywords/fixed-statement.md) Anweisung.

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.IsEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEmpty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEmpty : bool" Usage="System.Span&lt;'T&gt;.IsEmpty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob das aktuelle <see cref="T:System.Span`1" />-Element leer ist.</summary>
        <value>
          <see langword="true" /> Wenn die aktuelle Spanne leer ist; andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(index As Integer) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T % default[int] { T % get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : " Usage="System.Span&lt;'T&gt;.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>Ruft das Element am angegebenen nullbasierten Index ab oder legt dieses fest.</summary>
        <value>Das Element am angegebenen Index.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null) oder größer oder gleich <see cref="P:System.Span`1.Length" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.Span&lt;'T&gt;.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die Länge des aktuellen Span-Elements fest.</summary>
        <value>Die Länge des die aktuelle Spanne.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Span&lt;T&gt; left, Span&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Span`1&lt;!T&gt; left, valuetype System.Span`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Equality(System.Span{`0},System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Span(Of T), right As Span(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Span&lt;T&gt; left, Span&lt;T&gt; right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Span&lt;'T&gt; * Span&lt;'T&gt; -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Span&lt;T&gt;" />
        <Parameter Name="right" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="left">Das erste zu vergleichende Span-Element.</param>
        <param name="right">Das zweite zu vergleichende Span-Element.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei <see cref="T:System.Span`1" />-Objekte gleich sind.</summary>
        <returns>
          <see langword="true" />, wenn die beiden <see cref="T:System.Span`1" />-Objekte gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Zwei <xref:System.Span%601> Objekte sind gleich, wenn die gleiche Länge und die entsprechenden Elemente der wurden `left` und `right` zeigen Sie auf den gleichen Speicher. Beachten Sie, dass der Test auf Gleichheit *nicht* versucht zu bestimmen, ob der Inhalt gleich sind.

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;T&gt; (Span&lt;T&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;!T&gt; op_Implicit(valuetype System.Span`1&lt;!T&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Implicit(System.Span{`0})~System.ReadOnlySpan{`0}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (span As Span(Of T)) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;T&gt;(Span&lt;T&gt; span);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : Span&lt;'T&gt; -&gt; ReadOnlySpan&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.op_Implicit span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="span">Das in eine <see cref="T:System.ReadOnlySpan`1" /> zu konvertierende Objekt.</param>
        <summary>Definiert eine implizite Konvertierung von <see cref="T:System.Span`1" /> in <see cref="T:System.ReadOnlySpan`1" />.</summary>
        <returns>Ein schreibgeschütztes Span-Element, das dem aktuellen Attribut entspricht.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator Span&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Span`1&lt;!T&gt; op_Implicit(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Implicit(`0[])~System.Span{`0}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (array As T()) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator Span&lt;T&gt;(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : 'T[] -&gt; Span&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.op_Implicit array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array">Das Array, das in <see cref="T:System.Span`1" /> konvertiert werden soll.</param>
        <summary>Definiert eine implizite Konvertierung eines Arrays in <see cref="T:System.Span`1" />.</summary>
        <returns>Das Span-Element, das <paramref name="array" /> entspricht.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator Span&lt;T&gt; (ArraySegment&lt;T&gt; arraySegment);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Span`1&lt;!T&gt; op_Implicit(valuetype System.ArraySegment`1&lt;!T&gt; arraySegment) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (arraySegment As ArraySegment(Of T)) As Span(Of T)" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator Span&lt;T&gt;(ArraySegment&lt;T&gt; arraySegment);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C#" Value="public static implicit operator Span&lt;T&gt; (ArraySegment&lt;T&gt; segment);" FrameworkAlternate="netcore-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Span`1&lt;!T&gt; op_Implicit(valuetype System.ArraySegment`1&lt;!T&gt; segment) cil managed" FrameworkAlternate="netcore-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Implicit(System.ArraySegment{`0})~System.Span{`0}" FrameworkAlternate="netcore-2.1;netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (segment As ArraySegment(Of T)) As Span(Of T)" FrameworkAlternate="netcore-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator Span&lt;T&gt;(ArraySegment&lt;T&gt; segment);" FrameworkAlternate="netcore-2.1" />
      <MemberSignature Language="F#" Value="static member op_Implicit : ArraySegment&lt;'T&gt; -&gt; Span&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.op_Implicit segment" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arraySegment" Type="System.ArraySegment&lt;T&gt;" Index="0" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" Index="0" FrameworkAlternate="netcore-2.1" />
      </Parameters>
      <Docs>
        <param name="arraySegment">Das Segment des Arrays, das in <see cref="T:System.Span`1" /> konvertiert werden soll.</param>
        <param name="segment">Das Segment des Arrays, das in <see cref="T:System.Span`1" /> konvertiert werden soll.</param>
        <summary>Definiert eine implizite Konvertierung von <see cref="T:System.ArraySegment`1" /> in <see cref="T:System.Span`1" />.</summary>
        <returns>Ein Span-Element, das dem Segment des Arrays entspricht.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Span&lt;T&gt; left, Span&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Span`1&lt;!T&gt; left, valuetype System.Span`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Inequality(System.Span{`0},System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Span(Of T), right As Span(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Span&lt;T&gt; left, Span&lt;T&gt; right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Span&lt;'T&gt; * Span&lt;'T&gt; -&gt; bool" Usage="System.Span&lt;'T&gt;.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Span&lt;T&gt;" />
        <Parameter Name="right" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="left">Das erste zu vergleichende Span-Element.</param>
        <param name="right">Das zweite zu vergleichende Span-Element.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei <see cref="T:System.Span`1" />-Objekte ungleich sind.</summary>
        <returns>
          <see langword="true" />, wenn die beiden <see cref="T:System.Span`1" />-Objekte ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Zwei <xref:System.Span%601> Objekte sind gleich, wenn sie unterschiedlich lang sind oder wenn die entsprechenden Elemente der `left` und `right` zeigen nicht auf den gleichen Speicher. 

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt; Slice (int start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1&lt;!T&gt; Slice(int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Slice(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Slice (start As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt; Slice(int start);" />
      <MemberSignature Language="F#" Value="member this.Slice : int -&gt; Span&lt;'T&gt;" Usage="span.Slice start" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">Der Index, an dem der Slice beginnen soll.</param>
        <summary>Bildet einen Slice aus dem aktuellen Span-Element, das an einem angegebenen Index beginnt.</summary>
        <returns>Ein Span-Element, das aus allen Elementen des aktuellen Span-Elements von <paramref name="index" /> bis zum Ende des Span-Elements besteht.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als 0 (null) oder größer oder gleich <see cref="T:System.Span`1.Length" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt; Slice (int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1&lt;!T&gt; Slice(int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Slice(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Slice (start As Integer, length As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt; Slice(int start, int length);" />
      <MemberSignature Language="F#" Value="member this.Slice : int * int -&gt; Span&lt;'T&gt;" Usage="span.Slice (start, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">Der Index, an dem dieser Slice beginnen soll.</param>
        <param name="length">Die gewünschte Länge des Slices.</param>
        <summary>Bildet einen Slice aus dem aktuellen Span-Element. Dabei wird an einem angegebenen Index für eine angegebene Länge begonnen.</summary>
        <returns>&gt;Ein Span-Element besteht aus <paramref name="length" />-Elementen des aktuellen Span-Elements. Dabei wird bei <paramref name="index" /> begonnen.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="start" /> oder <paramref name="start" /> + <paramref name="index" /> ist kleiner als 0 (null) oder größer als <see cref="T:System.Span`1.Length" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="span.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kopiert die Inhalte dieses Span-Elements in ein neues Array.</summary>
        <returns>Ein Array das die Daten des aktuellen Span-Elements enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Diese Methode führt eine Heapzuordnung und kann aus diesem Grund sollte möglichst vermieden werden. Es manchmal notwendig, wenn Unterstützung für APIs, die <xref:System.Span%601> Objekte sind nicht verfügbar, jedoch sind APIs, die mit Arrays arbeiten.

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="span.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die Zeichenfolgendarstellung dieses <see cref="T:System.Span`1" />-Objekts zurück.</summary>
        <returns>Die Zeichenfolgendarstellung dieses <see cref="T:System.Span`1" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
Für eine `Span<Char>`, `ToString` Methode gibt eine <xref:System.String> , enthält die Zeichen, verweist der <xref:System.Span%601>. Andernfalls wird eine <xref:System.String> mit dem Namen des Typs und die Anzahl der Elemente, die die <xref:System.Span%601> enthält.

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCopyTo">
      <MemberSignature Language="C#" Value="public bool TryCopyTo (Span&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryCopyTo(valuetype System.Span`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.TryCopyTo(System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryCopyTo (destination As Span(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryCopyTo(Span&lt;T&gt; destination);" />
      <MemberSignature Language="F#" Value="member this.TryCopyTo : Span&lt;'T&gt; -&gt; bool" Usage="span.TryCopyTo destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="destination">Das Ziel des Kopiervorgangs.</param>
        <summary>Versucht, das aktuelle <see cref="T:System.Span`1" />-Element in ein <see cref="T:System.Span`1" />-Zielelement zu kopieren und gibt einen Wert zurück, der angibt, ob der Kopiervorgang erfolgreich war.</summary>
        <returns>
          <see langword="true" />, wenn der Kopiervorgang erfolgreich war; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Diese Methode kopiert alle `source` zu `destination` selbst wenn `source` und `destination` überlappen.

Wenn `destination` ist kürzer als die Quelle <xref:System.Span%601>, gibt diese Methode `false`, und keine Daten geschrieben werden, um `destination`.

         ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>