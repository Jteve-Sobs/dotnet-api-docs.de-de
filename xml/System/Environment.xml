<Type Name="Environment" FullName="System.Environment">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5f96e4916ee795fe08ea4d82b79db4cdfbbc3b65" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36431952" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Environment" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Environment extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Environment" />
  <TypeSignature Language="VB.NET" Value="Public Class Environment" />
  <TypeSignature Language="C++ CLI" Value="public ref class Environment abstract sealed" />
  <TypeSignature Language="F#" Value="type Environment = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Provides information about, and means to manipulate, the current environment and platform. This class cannot be inherited.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Environment> Klasse zum Abrufen von Informationen wie z. B. Befehlszeilenargumente, Exitcode, umgebungsvariableneinstellungen, Inhalt der Aufrufliste, die Zeit seit dem letzten Systemstarts, und die Version der common Language Runtime.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine Liste mit Informationen über die aktuelle Umgebung angezeigt.  
  
 [!code-cpp[environment.class#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.class/CPP/env0.cpp#1)]
 [!code-csharp[environment.class#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.class/CS/env0.cs#1)]
 [!code-vb[environment.class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.class/VB/env0.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CommandLine">
      <MemberSignature Language="C#" Value="public static string CommandLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommandLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CommandLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommandLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommandLine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommandLine : string" Usage="System.Environment.CommandLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the command line for this process.</summary>
        <value>Eine Zeichenfolge mit den Befehlszeilenargumenten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ermöglicht den Zugriff auf den Programmnamen und keine Argumente in der Befehlszeile angegeben werden, wenn der aktuelle Prozess gestartet wurde.  
  
 Der Name des Programms Pfadinformationen enthalten kann, aber ist nicht erforderlich. Verwenden der <xref:System.Environment.GetCommandLineArgs%2A> Methode zum Abrufen der Befehlszeile Informationen analysiert und in ein Array von Zeichenfolgen gespeichert.  
  
 Die maximale Größe des Puffers Befehlszeile wird nicht auf einer bestimmten Anzahl von Zeichen festgelegt. Es hängt von der Windows-Betriebssystems, die auf dem Computer ausgeführt wird.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine eigenen Befehlszeile an.  
  
 [!code-cpp[environment.commandline#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.CommandLine/CPP/commandline.cpp#1)]
 [!code-csharp[environment.commandline#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.CommandLine/CS/commandline.cs#1)]
 [!code-vb[environment.commandline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.CommandLine/VB/commandline.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für den Lesezugriff auf die PATH-Umgebungsvariable. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetCommandLineArgs" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDirectory">
      <MemberSignature Language="C#" Value="public static string CurrentDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string CurrentDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CurrentDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDirectory : string with get, set" Usage="System.Environment.CurrentDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the fully qualified path of the current working directory.</summary>
        <value>Eine Zeichenfolge mit einem Verzeichnispfad.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per Definition dieser Prozessstart im Stammverzeichnis eines lokalen oder einem Netzlaufwerk, der Wert dieser Eigenschaft ist den Namen des Laufwerks gefolgt von einem nachgestellten Schrägstrich (z. B. "C:\\"). Wenn dieser Prozess in einem Unterverzeichnis gestartet wird, ist der Wert dieser Eigenschaft den Pfad Laufwerk und Unterverzeichnis, ohne einen nachstehenden Schrägstrich (z. B. "C:\mySubDirectory").  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Festlegen der <xref:System.Environment.CurrentDirectory%2A> Eigenschaft.  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Attempted to set to an empty string ("").</exception>
        <exception cref="T:System.ArgumentNullException">Attempted to set to <see langword="null." /></exception>
        <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Attempted to set a local path that cannot be found.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the appropriate permission.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Schreiben in Dateien oder Verzeichnisse in einem Set-Vorgang. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Informationen in den Pfad in eine Get-Vorgang. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentManagedThreadId">
      <MemberSignature Language="C#" Value="public static int CurrentManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CurrentManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CurrentManagedThreadId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentManagedThreadId : int" Usage="System.Environment.CurrentManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a unique identifier for the current managed thread.</summary>
        <value>Eine Ganzzahl, die einen eindeutigen Bezeichner für diesen verwalteten Thread darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.Exit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (exitCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(int exitCode);" />
      <MemberSignature Language="F#" Value="static member Exit : int -&gt; unit" Usage="System.Environment.Exit exitCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="exitCode">The exit code to return to the operating system. Use 0 (zero) to indicate that the process completed successfully.</param>
        <summary>Terminates this process and returns an exit code to the operating system.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für die `exitCode` Parameter verwendet eine nicht-NULL-Anzahl einen Fehler an. In der Anwendung können Sie eigene Fehlercodes in einer Enumeration definieren und den Rückgabecode entsprechende Fehler basierend auf dem Szenario. Beispielsweise den Wert 1, um anzugeben, dass die erforderliche Datei nicht vorhanden ist und den Wert 2, um anzugeben, dass die Datei in das falsche Format zurück. Eine Liste der Exitcodes von Windows-Betriebssystems verwendet werden, finden Sie unter [Systemfehlercodes](http://msdn.microsoft.com/library/ms681381.aspx) in der Windows-Dokumentation.  
  
 Aufrufen der <xref:System.Environment.Exit%2A> -Methode unterscheidet sich von der Programmiersprache Ihrer Wahl des `return` Anweisung auf folgende Weise:  
  
-   <xref:System.Environment.Exit%2A> eine Anwendung beendet immer. Mithilfe der `return` -Anweisung kann eine Anwendung beendet werden nur dann, wenn er in den Einstiegspunkt der Anwendung, z. B. in dient der `Main` Methode.  
  
-   <xref:System.Environment.Exit%2A> eine Anwendung beendet sofort, selbst wenn andere Threads ausgeführt werden. Wenn die `return` Anweisung in den Einstiegspunkt der Anwendung aufgerufen wird, durch die Anwendung beenden, nachdem alle Vordergrundthreads beendet haben.  
  
-   <xref:System.Environment.Exit%2A> erfordert, dass der Aufrufer über die Berechtigung zum Aufrufen von nicht verwalteten Codes. Die `return` Anweisung hingegen nicht.  
  
-   Wenn <xref:System.Environment.Exit%2A> aus aufgerufen wird eine `try` oder `catch` blockieren, den Code in einem `finally` Block wird nicht ausgeführt. Wenn die `return` Anweisung verwendet wird, den Code in der `finally` Block wird ausgeführt.  
  
-   Wenn <xref:System.Environment.Exit%2A> wird aufgerufen, wenn im code eine [eingeschränkten Ausführungsbereich](~/docs/framework/performance/constrained-execution-regions.md) (CER) ausgeführt wird, CER ist nicht vollständig ausgeführt werden. Wenn die `return` Anweisung verwendet wird, CER wird die Ausführung beendet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The caller does not have sufficient security permission to perform this function.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Für die Fähigkeit, nicht verwalteten Code aufrufen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public static int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ExitCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int with get, set" Usage="System.Environment.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the exit code of the process.</summary>
        <value>Eine 32-Bit-Ganzzahl mit Vorzeichen, die den Exitcode enthält. Der Standardwert ist 0 (null), was angibt, dass der Prozess erfolgreich abgeschlossen wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die `Main` -Methode zurückkehrt `void`, können Sie diese Eigenschaft den Exitcode festlegen, die an die aufrufende Umgebung zurückgegeben werden. Wenn `Main` keinen zurückgibt `void`, diese Eigenschaft wird ignoriert. Der Anfangswert für diese Eigenschaft ist 0 (null).  
  
> [!WARNING]
>  Die <xref:System.Environment.ExitCode%2A> Eigenschaft ist eine 32-Bit-Ganzzahl mit Vorzeichen. Um zu verhindern, dass die Eigenschaft einen negativen Exitcode zurückgeben, sollten Sie nicht die Werte größer als oder gleich 0 x 80000000 verwenden.  
  
 Verwenden Sie eine Zahl ungleich 0 (null), einen Fehler an. In der Anwendung können Sie eigene Fehlercodes in einer Enumeration definieren und den Rückgabecode entsprechende Fehler basierend auf dem Szenario. Beispielsweise zurück, der Wert 1, um anzugeben, dass die erforderliche Datei nicht vorhanden ist und den Wert 2, um anzugeben, dass die Datei in das falsche Format. Eine Liste der Exitcodes von Windows-Betriebssystems verwendet werden, finden Sie unter [Systemfehlercodes](http://msdn.microsoft.com/library/ms681381\(v=vs.85\)) in der Windows-Dokumentation.  
  
   
  
## Examples  
 Im folgenden finden eine einfache app, die mit dem Namen Double.exe, die einen Ganzzahlwert, der als Befehlszeilenargument übergeben verdoppelt. Der Wert weist Fehlercodes der <xref:System.Environment.ExitCode%2A> Eigenschaft, um fehlerbedingungen anzuzeigen. Beachten Sie, dass Sie einen Verweis auf die Assembly System.Numerics.dll, um das Beispiel zu kompilieren hinzufügen müssen.  
  
 [!code-csharp[System.Environment.ExitCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double.cs#1)]
 [!code-vb[System.Environment.ExitCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double.vb#1)]  
  
 Im Beispiel kann dann aufgerufen werden, z. B. Folgendes ein, was die Fehlercodes zugegriffen werden kann mithilfe einer Batchdatei aus der `ERRORLEVEL` Befehl.  
  
```  
  
echo off  
Double.exe %1  
If errorlevel 1639 goto NoArg   
if errorlevel 534 goto Overflow  
if errorlevel 160 goto BadArg  
if errorlevel 0 echo Completed Successfully   
goto :EOF  
  
:NoArg  
echo Missing argument  
goto :EOF  
  
: Overflow  
echo Arithmetic overflow  
goto :EOF  
  
:BadArg  
echo Invalid argument  
goto :EOF  
  
```  
  
 Das folgende Beispiel zeigt eine Beispielausgabe an, durch Aufrufen der Batchdatei, erstellt.  
  
```Output  
  
>getdouble 123>echo offResult: 246Completed Successfully>getdouble 5912323109093>echo offArithmetic overflow>getdouble>echo offMissing argument>getdouble "a string">echo offInvalid argument  
  
```  
  
 Beachten Sie diesen Code für Double.exe in der Funktion im folgenden Beispiel identisch ist, mit dem Unterschied, dass der erste Wert einen Einstiegspunkt mit dem Namen definiert `Main` hat, die keinen Wert zurückgibt, während dieses Beispiel einen Einstiegspunkt mit dem Namen definiert `Main` , eine ganze Zahl zurückgibt.  
  
 [!code-csharp[System.Environment.ExitCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double1.cs#2)]
 [!code-vb[System.Environment.ExitCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpandEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static string ExpandEnvironmentVariables (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ExpandEnvironmentVariables(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.ExpandEnvironmentVariables(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExpandEnvironmentVariables (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ExpandEnvironmentVariables(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member ExpandEnvironmentVariables : string -&gt; string" Usage="System.Environment.ExpandEnvironmentVariables name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">A string containing the names of zero or more environment variables. Each environment variable is quoted with the percent sign character (%).</param>
        <summary>Replaces the name of each environment variable embedded in the specified string with the string equivalent of the value of the variable, then returns the resulting string.</summary>
        <returns>A string with each environment variable replaced by its value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 COM-Interop wird verwendet, um die Umgebungsvariablen mithilfe des Betriebssystems abzurufen. Die Umgebungsvariablen aufgrund eines COM-Fehlers nicht abgerufen werden können, verwendet das HRESULT, das die Ursache des Fehlers erklärt wird von mehreren möglichen Ausnahmen generiert. Das HRESULT, also abhängig die Ausnahme. Weitere Informationen zur Verarbeitung von HRESULT finden Sie im Abschnitt "Hinweise" der <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A?displayProperty=nameWithType> Methode.  
  
 Ersetzung erfolgt nur für Umgebungsvariablen, die festgelegt werden. Nehmen wir beispielsweise an `name` ist "MyENV = % MyENV%". Wenn die Umgebungsvariable MyENV auf 42 festgelegt ist, gibt diese Methode "MyENV = 42". Wenn MyENV nicht festgelegt ist, tritt keine Änderung; Diese Methode gibt "MyENV = % MyENV%".  
  
 Die Größe des Rückgabewerts ist auf 32 KB beschränkt.  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie das Systemlaufwerk und Stamm Systemvariablen abgerufen.  
  
 [!code-cpp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CPP/expandenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CS/expandenvironmentvariables.cs#1)]
 [!code-vb[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/VB/expandenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für den Zugriff auf die Umgebungsvariablen in <paramref name="name" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="FailFast">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Immediately terminates a process after writing a message to the Windows Application event log, and then includes the message and optional exception information in error reporting to Microsoft.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FailFast (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FailFast(System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member FailFast : string -&gt; unit" Usage="System.Environment.FailFast message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">A message that explains why the process was terminated, or <see langword="null" /> if no explanation is provided.</param>
        <summary>Immediately terminates a process after writing a message to the Windows Application event log, and then includes the message in error reporting to Microsoft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode beendet einen Prozess ohne aktive `try` / `finally` Blöcke oder Finalizer.  
  
 Die <xref:System.Environment.FailFast%2A> -Methode schreibt den `message` Zeichenfolge in der Windows-Anwendungsereignisprotokoll wird ein Speicherabbild der Anwendung erstellt und beendet dann den aktuellen Prozess. Die `message` Zeichenfolge ist auch in Fehlerberichte an Microsoft enthalten.  
  
 Verwenden der <xref:System.Environment.FailFast%2A> -Methode anstelle der <xref:System.Environment.Exit%2A> Methode, um die Anwendung zu beenden, wenn der Zustand der Anwendung irreparabel beschädigt ist und der Anwendungsverzeichnis ausführen `try` / `finally` Blöcke und Finalizer Programmressourcen wird beschädigt werden.  
  
 Informationen wird an Microsoft gemeldet werden, mithilfe der Windows-Fehlerberichterstattung. Weitere Informationen finden Sie unter [Windows-Fehlerberichterstattung: Erste Schritte](http://msdn.microsoft.com/library/windows/hardware/dn641144.aspx).  
  
   
  
## Examples  
 Das folgende Beispiel schreibt einen Protokolleintrag in die Windows-Anwendungsereignisprotokoll und beendet den aktuellen Prozess.  
  
 [!code-csharp[environment.FailFast#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.FailFast/cs/ff.cs#1)]
 [!code-vb[environment.FailFast#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.FailFast/vb/ff.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message, Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message, class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String,System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FailFast(System::String ^ message, Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FailFast : string * Exception -&gt; unit" Usage="System.Environment.FailFast (message, exception)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">A message that explains why the process was terminated, or <see langword="null" /> if no explanation is provided.</param>
        <param name="exception">An exception that represents the error that caused the termination. This is typically the exception in a <see langword="catch" /> block.</param>
        <summary>Immediately terminates a process after writing a message to the Windows Application event log, and then includes the message and exception information in error reporting to Microsoft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode beendet den Prozess, ohne aktive `try` / `finally` Blöcke oder Finalizer.  
  
 Die <xref:System.Environment.FailFast%2A> -Methode schreibt den `message` Zeichenfolge in der Windows-Anwendungsereignisprotokoll wird ein Speicherabbild der Anwendung erstellt und beendet dann den aktuellen Prozess.  
  
 Informationen wird an Microsoft gemeldet werden, mithilfe der Windows-Fehlerberichterstattung. Weitere Informationen finden Sie unter [Windows-Fehlerberichterstattung: Erste Schritte](http://msdn.microsoft.com/library/windows/hardware/dn641144.aspx). Fehlerberichte an Microsoft enthält `message` und `exception` Informationen, die Details zum Klassifizieren des Fehlers bereitstellt. Obwohl `exception` wird nicht behandelt, da der Prozess beendet wird, die Kontextinformationen, die die Ausnahme ausgelöst hat weiterhin abgerufen wird.  
  
 Wenn `exception` ist `null`, oder wenn `exception` wird nicht ausgelöst, diese Methode funktioniert genauso wie die <xref:System.Environment.FailFast%28System.String%29> -methodenüberladung.  
  
 Verwenden der <xref:System.Environment.FailFast%2A> -Methode anstelle der <xref:System.Environment.Exit%2A> Methode, um die Anwendung zu beenden, wenn der Zustand der Anwendung irreparabel beschädigt ist und der Anwendungsverzeichnis ausführen `try` / `finally` Blöcke und Finalizer Programmressourcen wird beschädigt werden.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCommandLineArgs">
      <MemberSignature Language="C#" Value="public static string[] GetCommandLineArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetCommandLineArgs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetCommandLineArgs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCommandLineArgs () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetCommandLineArgs();" />
      <MemberSignature Language="F#" Value="static member GetCommandLineArgs : unit -&gt; string[]" Usage="System.Environment.GetCommandLineArgs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a string array containing the command-line arguments for the current process.</summary>
        <returns>An array of string where each element contains a command-line argument. The first element is the executable file name, and the following zero or more elements contain the remaining command-line arguments.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das erste Element im Array enthält den Dateinamen des ausgeführten Programms an. Wenn der Dateiname nicht verfügbar ist, ist das erste Element gleich <xref:System.String.Empty?displayProperty=nameWithType>. Die übrigen Elemente enthalten, zusätzlichen Token in der Befehlszeile eingegeben wird.  
  
 Den Namen der Programmdatei kann, aber es ist nicht erforderlich, Pfadinformationen enthalten.  
  
 Befehlszeilenargumente werden durch Leerzeichen getrennt. Doppelte Anführungszeichen (") können Sie die Leerzeichen in einem Argument enthalten. Das einfache Anführungszeichen ('), stellt diese Funktionalität jedoch nicht bereit.  
  
 Wenn ein doppeltes Anführungszeichen auf zwei oder eine gerade Anzahl umgekehrter Schrägstriche folgt, wird jedes vorhergehende Paar umgekehrter wird durch einen umgekehrten Schrägstrich ersetzt, und das doppelte Anführungszeichen wird entfernt. Wenn ein doppeltes Anführungszeichen auf eine ungerade Anzahl umgekehrter Schrägstriche, z. B. nur einen beachtet jedes vorangehende-Paar wird durch einen umgekehrten Schrägstrich ersetzt, und der verbleibenden umgekehrten Schrägstrich wird entfernt; in diesem Fall wird das Anführungszeichen jedoch nicht entfernt.  
  
 In der folgenden Tabelle wird gezeigt, wie Befehlszeilenargumente begrenzt werden können, und es wird davon ausgegangen `MyApp` wie die aktuelle ausgeführte Anwendung.  
  
|Geben Sie an der Befehlszeile|Resultierende Befehlszeilenargumente|  
|-------------------------------|--------------------------------------|  
|`MyApp alpha beta`|`MyApp, alpha, beta`|  
|`MyApp "alpha with spaces" "beta with spaces"`|`MyApp, alpha with spaces, beta with spaces`|  
|`MyApp 'alpha with spaces' beta`|`MyApp, 'alpha, with, spaces', beta`|  
|`MyApp \\\alpha \\\\"beta`|`MyApp, \\\alpha, \\beta`|  
|`MyApp \\\\\"alpha \"beta`|`MyApp, \\"alpha, "beta`|  
  
 Verwenden Sie zum Abrufen der Befehlszeile als einzelne Zeichenfolge die <xref:System.Environment.CommandLine%2A> Eigenschaft.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Anwendung Befehlszeilenargumente.  
  
 [!code-cpp[Environment.GetCommandLineArgs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CPP/getcommandlineargs.cpp#1)]
 [!code-csharp[Environment.GetCommandLineArgs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CS/getcommandlineargs.cs#1)]
 [!code-vb[Environment.GetCommandLineArgs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetCommandLineArgs/VB/getcommandlineargs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The system does not support command-line arguments.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für den Lesezugriff auf die PATH-Umgebungsvariable. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.CommandLine" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnvironmentVariable">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retrieves the value of an environment variable.</summary>
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariable (variable As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEnvironmentVariable(System::String ^ variable);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariable : string -&gt; string" Usage="System.Environment.GetEnvironmentVariable variable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="variable">The name of the environment variable.</param>
        <summary>Retrieves the value of an environment variable from the current process.</summary>
        <returns>The value of the environment variable specified by <paramref name="variable" />, or <see langword="null" /> if the environment variable is not found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Environment.GetEnvironmentVariable%28System.String%29> Methode ruft eine Umgebungsvariable aus der Umgebungsblock, der nur den aktuellen Prozess ab. Dies entspricht dem Aufrufen der <xref:System.Environment.GetEnvironmentVariable%28System.String%2CSystem.EnvironmentVariableTarget%29> Methode mit einer `target` Wert <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>. Der Umgebungsblock des aktuellen Prozesses umfasst die folgenden Umgebungsvariablen:  
  
-   Alle pro Computer Umgebungsvariablen, die zum Zeitpunkt der Prozess, die zusammen mit ihren Werten erstellt wurde definiert sind.  
  
-   Alle benutzerspezifische Umgebungsvariablen, die zum Zeitpunkt definiert sind wird der Prozess, mit den entsprechenden Werten erstellt.  
  
-   Alle Variablen, die an den prozessblock hinzugefügt werden, während der Prozess ausgeführt wird, durch den Aufruf eines der <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> Methode oder die <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> Methode mit einem `target` Wert <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>.  
  
 Wenn Umgebungsvariablen erstellt werden, nachdem der Prozess gestartet wurde, können Sie diese Methode verwenden, um nur diese Variablen abzurufen, die durch den Aufruf erstellt wurden die <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> Methode oder die <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> Methode mit einem `target` Wert.<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>.  
  
 Um alle Umgebungsvariablen zusammen mit ihren Werten abzurufen, rufen Sie die <xref:System.Environment.GetEnvironmentVariables%2A> Methode.  
  
 Umgebungsvariablen wird die Groß-/Kleinschreibung nicht berücksichtigt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Environment.GetEnvironmentVariable%2A> Methode zum Abrufen der `windir` Umgebungsvariable, die den Pfad des Windows-Verzeichnisses enthält.  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 Im folgenden Beispiel wird versucht, den Wert einer Umgebungsvariablen mit dem Namen des abzurufenden `Test1` aus dem Prozess Umgebung-Block. Im Beispiel wird erstellt, wenn die Variable nicht vorhanden ist, dessen und seinen Wert abruft. Das Beispiel zeigt den Wert der Variablen. Wenn im Beispiel wird die Variable erstellt wird, ruft er auch die <xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29> Methode mit dem jedes Mitglied der <xref:System.EnvironmentVariableTarget> Enumeration, die überprüft wird, ob die Variable nur von der aktuellen Umgebung prozessblock abgerufen werden kann. Abschließend, wenn im Beispiel wird die Variable erstellt, es wird gelöscht.  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs#2)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission to perform this operation.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für den Zugriff auf den Wert der Lesen <paramref name="variable" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable, EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariable (variable As String, target As EnvironmentVariableTarget) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEnvironmentVariable(System::String ^ variable, EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariable : string * EnvironmentVariableTarget -&gt; string" Usage="System.Environment.GetEnvironmentVariable (variable, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" />
      </Parameters>
      <Docs>
        <param name="variable">The name of an environment variable.</param>
        <param name="target">One of the <see cref="T:System.EnvironmentVariableTarget" /> values.</param>
        <summary>Retrieves the value of an environment variable from the current process or from the Windows operating system registry key for the current user or local machine.</summary>
        <returns>The value of the environment variable specified by the <paramref name="variable" /> and <paramref name="target" /> parameters, or <see langword="null" /> if the environment variable is not found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `target` Parameter gibt an, ob die Umgebungsvariable vom aktuellen Prozess oder aus dem Registrierungsschlüssel des Windows-Betriebssystems für den aktuellen Benutzer oder den lokalen Computer abgerufen wird. Alle Umgebungsvariablen Erweiterungen pro Benutzer und pro Computer werden automatisch in den Umgebungsblock des aktuellen Prozesses kopiert. Beibehalten, jedoch nur hinzugefügt, um den Umgebungsblock des aktuellen Prozesses Umgebungsvariablen nur für die Dauer des Prozesses.  
  
 Um alle Umgebungsvariablen zusammen mit ihren Werten abzurufen, rufen Sie die <xref:System.Environment.GetEnvironmentVariables%2A> Methode.  
  
 Umgebungsvariablen wird die Groß-/Kleinschreibung nicht berücksichtigt.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt die Umgebungsvariablen für die Ziele Prozess, Benutzer und Computer, überprüft, ob die Registrierung des Betriebssystems die Umgebungsvariablen für die Benutzer und Computer enthält, und die Umgebungsvariablen löscht.  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> is not a valid <see cref="T:System.EnvironmentVariableTarget" /> value.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission to perform this operation.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für den Zugriff auf den Wert der Lesen <paramref name="variable" /> Wenn <paramref name="target" /> ist <see cref="F:System.EnvironmentVariableTarget.Process" /> (zugeordnete Enumeration: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" />), oder für vollständigen Zugriff auf Umgebungsvariablen Wenn <paramref name="target" /> ist <see cref="F:System.EnvironmentVariableTarget.User" /> oder <see cref="F:System.EnvironmentVariableTarget.Machine" /> (zugeordnet sind Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />).</permission>
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnvironmentVariables">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retrieves all environment variable names and their values.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariables () As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IDictionary ^ GetEnvironmentVariables();" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariables : unit -&gt; System.Collections.IDictionary" Usage="System.Environment.GetEnvironmentVariables " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retrieves all environment variable names and their values from the current process.</summary>
        <returns>A dictionary that contains all environment variable names and their values; otherwise, an empty dictionary if no environment variables are found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Namen und Werte für die Umgebungsvariablen werden gespeichert als Schlüssel-Wert-Paare in der zurückgegebenen <xref:System.Collections.IDictionary>.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Environment.GetEnvironmentVariables%2A> Methode.  
  
 [!code-cpp[Environment.GetEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CPP/getenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.GetEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CS/getenvironmentvariables.cs#1)]
 [!code-vb[Environment.GetEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetEnvironmentVariables/VB/getenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission to perform this operation.</exception>
        <exception cref="T:System.OutOfMemoryException">The buffer is out of memory.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für die Fähigkeit zum Lesen der Namen und Werte der Umgebungsvariablen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables (EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables(valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariables (target As EnvironmentVariableTarget) As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IDictionary ^ GetEnvironmentVariables(EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariables : EnvironmentVariableTarget -&gt; System.Collections.IDictionary" Usage="System.Environment.GetEnvironmentVariables target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" />
      </Parameters>
      <Docs>
        <param name="target">One of the <see cref="T:System.EnvironmentVariableTarget" /> values.</param>
        <summary>Retrieves all environment variable names and their values from the current process, or from the Windows operating system registry key for the current user or local machine.</summary>
        <returns>A dictionary that contains all environment variable names and their values from the source specified by the <paramref name="target" /> parameter; otherwise, an empty dictionary if no environment variables are found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `target` Parameter gibt an, ob die Quelle des aktuellen Prozesses, den Registrierungsschlüssel für den aktuellen Benutzer oder die Registrierungsschlüssel für den lokalen Computer ist.  
  
 Die Namen und Werte der Umgebungsvariablen werden als Schlüssel/Wert-Paare in der zurückgegebenen gespeichert <xref:System.Collections.IDictionary> Objekt.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt die Umgebungsvariablen für die Ziele Prozess, Benutzer und Computer, überprüft, ob die Registrierung des Betriebssystems die Umgebungsvariablen für die Benutzer und Computer enthält, und die Umgebungsvariablen löscht.  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission to perform this operation for the specified value of <paramref name="target" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> contains an illegal value.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für den Zugriff auf die Namen und Werte der Umgebungsvariablen Wenn lesen <paramref name="target" /> ist <see cref="F:System.EnvironmentVariableTarget.Process" /> (zugeordnete Enumeration: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" />), oder für vollständigen Zugriff auf Umgebungsvariablen Wenn <paramref name="target" /> ist <see cref="F:System.EnvironmentVariableTarget.User" /> oder <see cref="F:System.EnvironmentVariableTarget.Machine" /> () Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />).</permission>
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFolderPath">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets the path to the system special folder that is identified by the specified enumeration.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFolderPath (folder As Environment.SpecialFolder) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFolderPath(Environment::SpecialFolder folder);" />
      <MemberSignature Language="F#" Value="static member GetFolderPath : Environment.SpecialFolder -&gt; string" Usage="System.Environment.GetFolderPath folder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" />
      </Parameters>
      <Docs>
        <param name="folder">An enumerated constant that identifies a system special folder.</param>
        <summary>Gets the path to the system special folder that is identified by the specified enumeration.</summary>
        <returns>The path to the specified system special folder, if that folder physically exists on your computer; otherwise, an empty string ("").  A folder will not physically exist if the operating system did not create it, the existing folder was deleted, or the folder is a virtual directory, such as My Computer, which does not correspond to a physical path.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft den Pfad auf einen besonderen Systemordner, z. B. Programme, Programme, System oder starten, die Zugriff auf gemeinsame Daten verwendet werden kann. Besondere Ordner werden standardmäßig vom System oder explizit vom Benutzer festgelegt, wenn eine Version von Windows installieren.  
  
 Die `folder` -Parameter kennzeichnet den speziellen Ordner zum Abrufen und muss einen der Werte in der <xref:System.Environment.SpecialFolder> -Enumeration, einer anderen Wert löst eine Ausnahme aus.  
  
 Weitere Informationen zu speziellen Ordnern finden Sie unter der [CSIDL](http://go.microsoft.com/fwlink/?LinkId=116664) Werte Thema.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Environment.GetFolderPath%2A> Methode zum Zurückgeben und Anzeigen des zugeordnete Pfads der `folder` Parameter.  
  
 [!code-cpp[Environment.GetFolderPath#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetFolderPath/CPP/getfolderpath.cpp#1)]
 [!code-csharp[Environment.GetFolderPath#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetFolderPath/CS/getfolderpath.cs#1)]
 [!code-vb[Environment.GetFolderPath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetFolderPath/VB/getfolderpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="folder" /> is not a member of <see cref="T:System.Environment.SpecialFolder" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The current platform is not supported.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Informationen in den Pfad selbst. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder, Environment.SpecialFolderOption option);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder, valuetype System.Environment/SpecialFolderOption option) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder,System.Environment.SpecialFolderOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFolderPath (folder As Environment.SpecialFolder, option As Environment.SpecialFolderOption) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFolderPath(Environment::SpecialFolder folder, Environment::SpecialFolderOption option);" />
      <MemberSignature Language="F#" Value="static member GetFolderPath : Environment.SpecialFolder * Environment.SpecialFolderOption -&gt; string" Usage="System.Environment.GetFolderPath (folder, option)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" />
        <Parameter Name="option" Type="System.Environment+SpecialFolderOption" />
      </Parameters>
      <Docs>
        <param name="folder">An enumerated constant that identifies a system special folder.</param>
        <param name="option">Specifies options to use for accessing a special folder.</param>
        <summary>Gets the path to the system special folder that is identified by the specified enumeration, and uses a specified option for accessing special folders.</summary>
        <returns>The path to the specified system special folder, if that folder physically exists on your computer; otherwise, an empty string ("").  A folder will not physically exist if the operating system did not create it, the existing folder was deleted, or the folder is a virtual directory, such as My Computer, which does not correspond to a physical path.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft den Pfad auf einen besonderen Systemordner, z. B. Programme, Programme, System oder starten, die Zugriff auf gemeinsame Daten verwendet werden kann. Besondere Ordner werden standardmäßig vom System oder explizit vom Benutzer festgelegt, wenn eine Version von Windows installieren.  
  
 Die `folder` -Parameter kennzeichnet den speziellen Ordner zum Abrufen und muss einen der Werte in der <xref:System.Environment.SpecialFolder> -Enumeration, einer anderen Wert löst eine Ausnahme aus.  
  
 Weitere Informationen zu speziellen Ordnern finden Sie unter der [CSIDL](http://go.microsoft.com/fwlink/?LinkId=116664) Werte Thema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="folder" /> is not a member of <see cref="T:System.Environment.SpecialFolder" /></exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.PlatformNotSupportedException" />
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Informationen in den Pfad selbst. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetLogicalDrives">
      <MemberSignature Language="C#" Value="public static string[] GetLogicalDrives ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetLogicalDrives() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetLogicalDrives" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLogicalDrives () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetLogicalDrives();" />
      <MemberSignature Language="F#" Value="static member GetLogicalDrives : unit -&gt; string[]" Usage="System.Environment.GetLogicalDrives " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an array of string containing the names of the logical drives on the current computer.</summary>
        <returns>An array of strings where each element contains the name of a logical drive. For example, if the computer's hard drive is the first logical drive, the first element returned is "C:\\".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt die Vorgehensweise beim Anzeigen von logischen Laufwerke des aktuellen Computers mithilfe der <xref:System.Environment.GetLogicalDrives%2A> Methode.  
  
 [!code-cpp[Environment.GetLogicalDrives#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetLogicalDrives/CPP/getlogicaldrives.cpp#1)]
 [!code-csharp[Environment.GetLogicalDrives#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetLogicalDrives/CS/getlogicaldrives.cs#1)]
 [!code-vb[Environment.GetLogicalDrives#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetLogicalDrives/VB/getlogicaldrives.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">An I/O error occurs.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permissions.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für Vollzugriff auf die durch diese Berechtigung geschützte Ressource. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownStarted">
      <MemberSignature Language="C#" Value="public static bool HasShutdownStarted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool HasShutdownStarted" />
      <MemberSignature Language="DocId" Value="P:System.Environment.HasShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property HasShutdownStarted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool HasShutdownStarted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasShutdownStarted : bool" Usage="System.Environment.HasShutdownStarted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the current application domain is being unloaded or the common language runtime (CLR) is shutting down.</summary>
        <value>
          <see langword="true" />, wenn die aktuelle Anwendungsdomäne entladen oder die CLR heruntergefahren wird, andernfalls <see langword="false." />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die CLR eine Anwendungsdomäne entladen wurde, wird der Finalizer für alle Objekte, die über einen Finalizer-Methode in der Anwendungsdomäne ausgeführt. Wenn die CLR heruntergefahren wird, wird für alle Objekte, die über einen Finalizer-Methode im Finalizer-Thread gestartet. Die <xref:System.Environment.HasShutdownStarted%2A> -Eigenschaft gibt `true` nur, nachdem der Finalizer-Thread gestartet wurde. Wenn die Eigenschaft zurückgibt `true`, können Sie bestimmen, ob eine Anwendungsdomäne entladen wird oder die CLR selbst wird durch den Aufruf heruntergefahren die <xref:System.AppDomain.IsFinalizingForUnload%2A?displayProperty=nameWithType> Methode. Diese Methode gibt `true` wenn Finalizer aufgerufen werden, da die Anwendungsdomäne entladen wird oder `false` , wenn die CLR heruntergefahren wird.  
  
 Die <xref:System.Environment.HasShutdownStarted%2A> -Eigenschaft gibt `false` Wenn im Finalizer-Thread nicht gestartet wurde.  
  
 Mithilfe dieser Eigenschaft können Sie bestimmt, ob Sie den Zugriff auf statische Variablen in Ihrem Code zur Finalisierung verfolgt. Wenn eine Anwendungsdomäne oder die CLR heruntergefahren wird, können nicht zuverlässig greifen Sie jedes Objekt, das über eine Methode zur Finalisierung verfolgt verfügt und, auf das von einem statischen Feld verwiesen wird. Dies ist, wenn diese Objekte möglicherweise bereits freigegeben wurde.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsFinalizingForUnload" />
      </Docs>
    </Member>
    <Member MemberName="Is64BitOperatingSystem">
      <MemberSignature Language="C#" Value="public static bool Is64BitOperatingSystem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitOperatingSystem" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitOperatingSystem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Is64BitOperatingSystem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Is64BitOperatingSystem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Is64BitOperatingSystem : bool" Usage="System.Environment.Is64BitOperatingSystem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether the current operating system is a 64-bit operating system.</summary>
        <value>
          <see langword="true" />, wenn das aktuelle Betriebssystem ein 64-Bit-Betriebssystem ist, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Is64BitProcess">
      <MemberSignature Language="C#" Value="public static bool Is64BitProcess { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitProcess" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Is64BitProcess As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Is64BitProcess { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Is64BitProcess : bool" Usage="System.Environment.Is64BitProcess" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether the current process is a 64-bit process.</summary>
        <value>
          <see langword="true" />, wenn der aktuelle Prozess ein 64-Bit-Prozess ist, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public static string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Environment.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the NetBIOS name of this local computer.</summary>
        <value>Eine Zeichenfolge mit dem Namen dieses Computers.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Name dieses Computers wird beim Systemstart eingerichtet, wenn der Name aus der Registrierung gelesen werden. Wenn diese Computer ein Knoten in einem Cluster ist, wird der Name des Knotens zurückgegeben.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Namen des Computers, der das Codebeispiel ausgeführt wird. (Der Name des Computers wird in der Beispielausgabe aus Sicherheitsgründen weggelassen.)  
  
 [!code-cpp[environment.machinename#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.MachineName/CPP/machinename.cpp#1)]
 [!code-csharp[environment.machinename#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.MachineName/CS/machinename.cs#1)]
 [!code-vb[environment.machinename#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.MachineName/VB/machinename.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The name of this computer cannot be obtained.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für den Lesezugriff auf die COMPUTERNAME-Umgebungsvariable. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="NewLine">
      <MemberSignature Language="C#" Value="public static string NewLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string NewLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.NewLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property NewLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ NewLine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NewLine : string" Usage="System.Environment.NewLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the newline string defined for this environment.</summary>
        <value>Eine Zeichenfolge für Nicht-Unix-Plattformen, die "\r\n" enthält, oder eine Zeichenfolge für Unix-Plattformen, die "\n" enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Eigenschaftswert des <xref:System.Environment.NewLine%2A> ist eine Konstante, die speziell für die aktuelle Plattform und Implementierung von .NET Framework angepasst wird. Weitere Informationen über die Escapezeichen in den Wert der Eigenschaft finden Sie unter [Escapezeichen](~/docs/standard/base-types/character-escapes-in-regular-expressions.md).  
  
 Die Funktionalität von bereitgestellten <xref:System.Environment.NewLine%2A> ist oft, was mit den Begriffen Zeilenumbruch, Zeilenvorschub, Zeilenumbruch, Carriage return, Wagenrücklauf, CRLF und Zeilenende gemeint ist.  
  
 <xref:System.Environment.NewLine%2A> in Verbindung mit sprachspezifischen neue-Zeile-Unterstützung, z. B. das Escapezeichen "\r" und "\n" in Microsoft C#- und C/C++ verwendet werden können oder `vbCrLf` in Microsoft Visual Basic.  
  
 <xref:System.Environment.NewLine%2A> wird automatisch angefügt Text verarbeitet, indem Sie die <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> und <xref:System.Text.StringBuilder.AppendLine%2A?displayProperty=nameWithType> Methoden.  
  
   
  
## Examples  
 Im folgende Beispiel werden drei durch Zeilenumbrüche getrennte Zeilen angezeigt.  
  
 [!code-cpp[environment.newline#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.NewLine/CPP/newline.cpp#1)]
 [!code-csharp[environment.newline#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.NewLine/CS/newline.cs#1)]
 [!code-vb[environment.newline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.NewLine/VB/newline.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OSVersion">
      <MemberSignature Language="C#" Value="public static OperatingSystem OSVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.OperatingSystem OSVersion" />
      <MemberSignature Language="DocId" Value="P:System.Environment.OSVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSVersion As OperatingSystem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property OperatingSystem ^ OSVersion { OperatingSystem ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OSVersion : OperatingSystem" Usage="System.Environment.OSVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.OperatingSystem</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an <see cref="T:System.OperatingSystem" /> object that contains the current platform identifier and version number.</summary>
        <value>Ein Objekt, das den Bezeichner und die Versionsnummer der Plattform enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Beginnend mit Windows 8 die <xref:System.Environment.OSVersion%2A> Eigenschaft gibt die gleiche Haupt-und Nebenversionsnummern Zahlen für alle Windows-Plattformen. Aus diesem Grund wird nicht empfohlen, dass Sie den Wert dieser Eigenschaft bestimmt die Version des Betriebssystems abzurufen.  
  
 In der Regel die <xref:System.Environment.OSVersion%2A> Eigenschaft wird verwendet, um sicherzustellen, dass eine app auf einigen Basisversion der ein älteres Betriebssystem ausgeführt wird, in denen eine bestimmte Funktion eingeführt wurde. Wenn dies der Fall ist, sollten Sie eine Überprüfung der Version ausführen, indem Sie testen, ob die aktuelle Betriebssystemversion zurückgegebene der <xref:System.Environment.OSVersion%2A> Eigenschaft ist gleich oder größer als die basisbetriebssystemversion. Weitere Informationen finden Sie unter der <xref:System.Version> klassenthema.  
  
 Über Windows 8 die <xref:System.Environment.OSVersion%2A> Eigenschaft gibt die Version von Windows gemeldeten [GetVersionEx](http://msdn.microsoft.com/library/windows/desktop/ms724451\(v=vs.85\).aspx) Funktion. Eine Liste der Versionen des Windows-desktop-Betriebssystem und ihre zugehörigen Versionsnummern, finden Sie unter [Betriebssystemversion](https://msdn.microsoft.com/library/windows/desktop/ms724832.aspx) im Windows Developer Center.  
  
> [!NOTE]
>  Die <xref:System.Environment.OSVersion%2A> -Eigenschaft meldet die gleichen Versionsnummer (6.2.0.0) für beide [!INCLUDE[win8](~/includes/win8-md.md)] und [!INCLUDE[win81](~/includes/win81-md.md)] und die gleiche Haupt-und Nebenversionsnummern Anzahl für Windows 10.  
  
 In einigen Fällen die <xref:System.Environment.OSVersion%2A> Eigenschaft möglicherweise nicht die Version des Betriebssystems, die die für die Funktion "Windows-Anwendungskompatibilität Modus" angegebenen Version entspricht zurück.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Plattform-ID und die Versionsnummer des Computers, der das Codebeispiel ausgeführt wird.  
  
 [!code-cpp[environment.osversion#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.OSVersion/CPP/osversion.cpp#1)]
 [!code-csharp[environment.osversion#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.OSVersion/CS/osversion.cs#1)]
 [!code-vb[environment.osversion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.OSVersion/VB/osversion.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">This property was unable to obtain the system version.  -or-  The obtained platform identifier is not a member of <see cref="T:System.PlatformID" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessorCount">
      <MemberSignature Language="C#" Value="public static int ProcessorCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ProcessorCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ProcessorCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProcessorCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ProcessorCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorCount : int" Usage="System.Environment.ProcessorCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of processors on the current machine.</summary>
        <value>Die 32-Bit-Ganzzahl mit Vorzeichen, die die Anzahl von Prozessoren im aktuellen Computer angibt. Es ist kein Standardwert vorhanden. Wenn der aktuelle Computer mehrere Prozessorgruppen enthält, gibt diese Eigenschaft die Anzahl logischer Prozessoren zurück, die für die Common Language Runtime (CLR) verfügbar sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zu Prozessorgruppen und logischen Prozessoren, finden Sie unter [Prozessorgruppen](http://msdn.microsoft.com/library/windows/desktop/dd405503.aspx).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Environment.ProcessorCount%2A> Eigenschaft.  
  
 [!code-cpp[environment.processorcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.processorcount/CPP/pc.cpp#1)]
 [!code-csharp[environment.processorcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.processorcount/CS/pc.cs#1)]
 [!code-vb[environment.processorcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.processorcount/VB/pc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetEnvironmentVariable">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates, modifies, or deletes an environment variable.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetEnvironmentVariable (variable As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEnvironmentVariable(System::String ^ variable, System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member SetEnvironmentVariable : string * string -&gt; unit" Usage="System.Environment.SetEnvironmentVariable (variable, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="variable">The name of an environment variable.</param>
        <param name="value">A value to assign to <c>variable</c>.</param>
        <summary>Creates, modifies, or deletes an environment variable stored in the current process.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Aufrufen dieser Methode entspricht dem Aufrufen der <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> -Überladung mit dem Wert des <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> für die `target` Argument.  
  
 Wenn die `value` Argument ist nicht leer (siehe die Erläuterung des Löschens einer Umgebungsvariablen weiter unten in diesem Abschnitt für die Definition von ein leerer Wert) und die Umgebungsvariable benannt, indem die `variable` Parameter nicht vorhanden ist, die Umgebung Variable wird erstellt und dem Inhalt von zugewiesen `value`. Wenn sie vorhanden ist, wird ihr Wert geändert werden. Da die Umgebungsvariable in der Umgebungsblock, der nur den aktuellen Prozess definiert ist, bleibt er nicht bestehen, nachdem der Prozess beendet wurde.  
  
 Wenn `variable` enthält ein nicht anfängliches Hexadezimalzeichen 0 (null) Zeichen, die Zeichen, bevor die Zeichen 0 werden der Name der Umgebungsvariablen berücksichtigt und alle nachfolgende Zeichen werden ignoriert.  
  
 Wenn `value` enthält ein nicht anfängliches Hexadezimalzeichen 0 (null) Zeichen, die Zeichen, bevor die Zeichen 0 der Umgebungsvariablen zugewiesen sind, und alle nachfolgende Zeichen werden ignoriert.  
  
 Wenn `value` leer ist und die Umgebungsvariable mit dem Namen von `variable` vorhanden ist, wird die Umgebungsvariable gelöscht. Wenn `variable` vorhanden ist, tritt kein Fehler auf, obwohl der Vorgang kann nicht ausgeführt werden. `value` ist leer, wenn eine der folgenden Bedingungen berücksichtigt:  
  
-   Es ist `null`.  
  
-   Es ist <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Er besteht aus einem einzelnen Zeichen, dessen Wert U + 0000 ist.  
  
   
  
## Examples  
 Das folgende Beispiel testet, ob eine Umgebungsvariable namens `APPDOMAIN` im aktuellen Prozess vorhanden ist. Wenn dies nicht der Fall ist, wird erstellt und legt seinen Wert auf "True" fest. Wenn der Wert des der `APPDOMAIN` Umgebungsvariable ist "True", ruft es die `Message.Display` Methode in eine neue Anwendungsdomäne. Andernfalls führt er die `Message.Display` Methode in der aktuellen Anwendungsdomäne.  
  
 [!code-csharp[System.Environment.SetEnvironmentVariable#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.setenvironmentvariable/cs/setenvironmentvariable1.cs#1)]
 [!code-vb[System.Environment.SetEnvironmentVariable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.setenvironmentvariable/vb/setenvironmentvariable1.vb#1)]  
  
 Wenn Sie das Beispiel zum ersten Mal ausführen, zeigt die Meldung "In der Domäne Domäne2 wird ausgeführt" in der Konsole. Wenn Sie die Umgebungsvariable mit dem Befehl über die Befehlszeile festlegen:  
  
 `Set AppDomain=False`  
  
 Das Beispiel zeigt die Meldung "in der Domäne ausführen *Programmname*.exe", wobei *Programmname* ist der Name der ausführbaren Datei.  
  
 Im folgenden Beispiel wird versucht, den Wert einer Umgebungsvariablen mit dem Namen des abzurufenden `Test1` aus dem Prozess Umgebung-Block. Wenn die Variable nicht vorhanden ist, wird im Beispiel erstellt die Variable und ihren Wert abruft. Das Beispiel zeigt den Wert der Variablen. Wenn im Beispiel wird die Variable erstellt wird, ruft er auch die <xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29> Methode mit dem jedes Mitglied der <xref:System.EnvironmentVariableTarget> Enumeration, die überprüft wird, ob die Variable nur von der aktuellen Umgebung prozessblock abgerufen werden kann. Abschließend, wenn im Beispiel wird die Variable erstellt, es wird gelöscht.  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs#2)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="variable" /> contains a zero-length string, an initial hexadecimal zero character (0x00), or an equal sign ("=").  -or-  The length of <paramref name="variable" /> or <paramref name="value" /> is greater than or equal to 32,767 characters.  -or-  An error occurred during the execution of this operation.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission to perform this operation.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für Vollzugriff auf Umgebungsvariablen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
      </Docs>
    </Member>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value, EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetEnvironmentVariable (variable As String, value As String, target As EnvironmentVariableTarget)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEnvironmentVariable(System::String ^ variable, System::String ^ value, EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member SetEnvironmentVariable : string * string * EnvironmentVariableTarget -&gt; unit" Usage="System.Environment.SetEnvironmentVariable (variable, value, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" />
      </Parameters>
      <Docs>
        <param name="variable">The name of an environment variable.</param>
        <param name="value">A value to assign to <c>variable</c>.</param>
        <param name="target">One of the enumeration values that specifies the location of the environment variable.</param>
        <summary>Creates, modifies, or deletes an environment variable stored in the current process or in the Windows operating system registry key reserved for the current user or local machine.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> Methode können Sie eine Umgebungsvariable zu definieren, die für alle Prozesse verfügbar ist, die auf einem Computer ausgeführt (die <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> Wert), an alle Prozesse, die von einem Benutzer ausgeführt (die <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> Wert), oder für den aktuellen Prozess (der <xref:System.EnvironmentVariableTarget.Process> Wert). Umgebungsvariablen pro Computer und pro Benutzer werden in der Umgebungsblock, der den aktuellen Prozess kopiert. Umgebungsvariablen, die für den aktuellen Prozess Umgebungsblock eindeutig sind jedoch beibehalten, nur verwendet werden, bis der Prozess beendet wird.  
  
 Wenn die `value` Argument ist nicht leer (siehe die Erläuterung des Löschens einer Umgebungsvariablen weiter unten in diesem Abschnitt für die Definition von ein leerer Wert) und die Umgebungsvariable benannt, indem die `variable` Parameter nicht vorhanden ist, die Umgebung Variable wird erstellt und dem Inhalt von zugewiesen `value`.  Wenn sie vorhanden ist, wird ihr Wert geändert werden.  
  
 Wenn `variable` enthält ein nicht anfängliches Hexadezimalzeichen 0 (null) Zeichen, die Zeichen, bevor die Zeichen 0 werden der Name der Umgebungsvariablen berücksichtigt und alle nachfolgende Zeichen werden ignoriert.  
  
 Wenn `value` enthält ein nicht anfängliches Hexadezimalzeichen 0 (null) Zeichen, die Zeichen, bevor die Zeichen 0 der Umgebungsvariablen zugewiesen sind, und alle nachfolgende Zeichen werden ignoriert.  
  
 Wenn `value` leer ist und die Umgebungsvariable mit dem Namen von `variable` vorhanden ist, wird die Umgebungsvariable gelöscht. `value` ist leer, wenn eine der folgenden Bedingungen berücksichtigt:  
  
-   Es ist `null`.  
  
-   Es ist <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Er besteht aus einem einzelnen Zeichen, dessen Wert U + 0000 ist.  
  
 Wenn `variable` vorhanden ist, tritt kein Fehler auf, obwohl der Vorgang kann nicht ausgeführt werden. Seien Sie vorsichtig, wenn `target` ist <xref:System.EnvironmentVariableTarget.Machine>, weil Sie versehentlich eine Umgebungsvariable löschen können, die den gesamten lokalen Computer, nicht nur den aktuellen Prozess oder Benutzer betreffen.  
  
 Wenn `target` ist <xref:System.EnvironmentVariableTarget.User>, wird die Umgebungsvariable im Schlüssel HKEY_CURRENT_USER\Environment der Registrierung des lokalen Computers gespeichert. Es wird auch in Instanzen von Datei-Explorer kopiert, die als aktueller Benutzer ausgeführt werden. Die Umgebungsvariable wird dann durch alle neue Prozesse geerbt, die der Benutzer vom Datei-Explorer startet.  
  
 Auf ähnliche Weise, wenn `target` ist <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>, wird die Umgebungsvariable im HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Session Manager\Environment Schlüssel der Registrierung des lokalen Computers gespeichert. Es wird auch für alle Instanzen von Datei-Explorer kopiert. Die Umgebungsvariable wird dann durch alle neue Prozesse geerbt, die vom Datei-Explorer gestartet werden.  
  
 Wenn `target` ist <xref:System.EnvironmentVariableTarget.User> oder <xref:System.EnvironmentVariableTarget.Machine>, andere Anwendungen werden benachrichtigt, von der Set-Vorgang durch einen Windows- `WM_SETTINGCHANGE` Nachricht.  
  
 Wenn `target` ist <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> oder <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>, es wird empfohlen, die die Länge der `value` weniger als 2048 Zeichen lang sein.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt die Umgebungsvariablen für die <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>, <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>, und <xref:System.EnvironmentVariableTarget.Machine> ausgerichtet ist, es wird überprüft, ob die Registrierung des Betriebssystems der Benutzer und Computer-Umgebungsvariablen enthält, und die Umgebung löscht Variablen.  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="variable" /> contains a zero-length string, an initial hexadecimal zero character (0x00), or an equal sign ("=").  -or-  The length of <paramref name="variable" /> is greater than or equal to 32,767 characters.  -or-  <paramref name="target" /> is not a member of the <see cref="T:System.EnvironmentVariableTarget" /> enumeration.  -or-  <paramref name="target" /> is <see cref="F:System.EnvironmentVariableTarget.Machine" /> or <see cref="F:System.EnvironmentVariableTarget.User" />, and the length of <paramref name="variable" /> is greater than or equal to 255.  -or-  <paramref name="target" /> is <see cref="F:System.EnvironmentVariableTarget.Process" /> and the length of <paramref name="value" /> is greater than or equal to 32,767 characters.  -or-  An error occurred during the execution of this operation.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission to perform this operation.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für Vollzugriff auf Umgebungsvariablen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public static string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Environment.StackTrace" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StackTrace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StackTrace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StackTrace : string" Usage="System.Environment.StackTrace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets current stack trace information.</summary>
        <value>Eine Zeichenfolge, die Stapelüberwachungsinformationen enthält. Dieser Wert kann <see cref="F:System.String.Empty" /> sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Environment.StackTrace%2A> Eigenschaft Listen Methodenaufrufe in umgekehrter chronologischer Reihenfolge, d. h. den letzte Aufruf der Methode wird zunächst beschrieben und Stapelüberwachungsinformationen eine Zeile für jeden Methodenaufruf auf dem Stapel aufgeführt ist. Allerdings die <xref:System.Environment.StackTrace%2A> Eigenschaft möglicherweise nicht so viele Methodenaufrufe erwartungsgemäß da der Code, die auftreten, während der Optimierung gemeldet.  
  
> [!NOTE]
>  Verwenden Sie für eine hierarchische Ansicht der Stapelüberwachungsinformationen von-Klasse, die <xref:System.Diagnostics.StackTrace> Klasse.  
  
 Die <xref:System.Environment.StackTrace%2A> Eigenschaft formatiert die Stapelüberwachungsinformationen für jeden Methodenaufruf wie folgt:  
  
 "am `FullClassName`.`MethodName` (`MethodParams`) in `FileName` : Linie `LineNumber` "  
  
 Das Literal "at" drei Leerzeichen vorangestellt ist, und die gesamte Teilzeichenfolge, beginnend mit "in" wird ausgelassen, wenn keine Debugsymbole verfügbar sind. Die Platzhalter `FullClassName`, `MethodName`, `MethodParams`, `FileName`, und `LineNumber`, durch tatsächliche Werte ersetzt werden und wie folgt definiert:  
  
 FullClassName  
 Der vollständige Name der Klasse, einschließlich des Namespaces.  
  
 `MethodName`  
 Der Name der Methode.  
  
 `MethodParams`  
 Die Liste der Typnamen/Parameterpaaren. Jedes Paar wird getrennt durch ein Komma (","). Diese Informationen werden ausgelassen, wenn `MethodName` nimmt keine Parameter.  
  
 `FileName`  
 Der Name der Quelle-Datei, in der `MethodName` -Methode deklariert ist. Diese Informationen werden ausgelassen, wenn keine Debugsymbole verfügbar sind.  
  
 `LineNumber`  
 Die Nummer der Zeile im `FileName` , enthält den Quellcode aus `MethodName` für die Anweisung, die in der Aufrufliste ist. Diese Informationen werden ausgelassen, wenn keine Debugsymbole verfügbar sind.  
  
 Die <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> Zeichenfolge beendet, wird jede Zeile der stapelüberwachung.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Environment.StackTrace%2A> Eigenschaft.  
  
 [!code-cpp[environment.stacktrace#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.StackTrace/CPP/stacktrace.cpp#1)]
 [!code-csharp[environment.stacktrace#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.StackTrace/CS/stacktrace.cs#1)]
 [!code-vb[environment.stacktrace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.StackTrace/VB/stacktrace.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für Vollzugriff auf die durch die Berechtigung geschützten Ressource. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SystemDirectory">
      <MemberSignature Language="C#" Value="public static string SystemDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string SystemDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SystemDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SystemDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SystemDirectory : string" Usage="System.Environment.SystemDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the fully qualified path of the system directory.</summary>
        <value>Eine Zeichenfolge mit einem Verzeichnispfad.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Beispiel des zurückgegebenen Werts ist die Zeichenfolge "C:\WinNT\System32".  
  
   
  
## Examples  
 Das folgende Beispiel zeigt das Systemverzeichnis des Computers, der das Codebeispiel ausgeführt wird. (Das Verzeichnis "System" wird in der Beispielausgabe aus Sicherheitsgründen weggelassen.)  
  
 [!code-cpp[environment.systemdirectory#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.SystemDirectory/CPP/systemdirectory.cpp#1)]
 [!code-csharp[environment.systemdirectory#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.SystemDirectory/CS/systemdirectory.cs#1)]
 [!code-vb[environment.systemdirectory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.SystemDirectory/VB/systemdirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Informationen in den Pfad selbst. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SystemPageSize">
      <MemberSignature Language="C#" Value="public static int SystemPageSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 SystemPageSize" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemPageSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SystemPageSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int SystemPageSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SystemPageSize : int" Usage="System.Environment.SystemPageSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of bytes in the operating system's memory page.</summary>
        <value>Die Anzahl der Bytes in einer Arbeitsspeicherauslagerung des Betriebssystems.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Informationen kann nützlich sein, wenn bestimmt wird, ob verwendet die <xref:System.IO.MemoryMappedFiles.MemoryMappedFileOptions.DelayAllocatePages?displayProperty=nameWithType> option bei der Arbeit mit Speicherabbilddateien.  
  
 In Windows, dieser Wert ist die `dwPageSize` Element in der `SYSTEM_INFO` Struktur.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für den Zugriff auf System- und Umgebungsvariablen. Zugeordnete Ausnahme:  <see cref="P:System.Security.SecurityException.PermissionState" /></permission>
      </Docs>
    </Member>
    <Member MemberName="TickCount">
      <MemberSignature Language="C#" Value="public static int TickCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 TickCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.TickCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TickCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int TickCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.TickCount : int" Usage="System.Environment.TickCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of milliseconds elapsed since the system started.</summary>
        <value>Eine 32-Bit-Ganzzahl mit Vorzeichen, die die seit dem letzten Start des Computers vergangene Zeit in Millisekunden enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Eigenschaft wird von der systemtimer abgeleitet und wird als eine 32-Bit-Ganzzahl mit Vorzeichen gespeichert. Beachten Sie Folgendes: Da Systemzeitgeber, der Auflösung des abgeleitet ist die <xref:System.Environment.TickCount%2A> Eigenschaft ist auf die Auflösung des Systemzeitgebers, in der Regel im Bereich von 10 bis 16 Millisekunden beschränkt.  
  
> [!IMPORTANT]
>  Da der Wert des der <xref:System.Environment.TickCount%2A> Eigenschaftswert ist eine 32-Bit-Ganzzahl mit Vorzeichen, wenn das System ständig ausgeführt wird <xref:System.Environment.TickCount%2A> erhöht, von 0 bis <xref:System.Int32.MaxValue?displayProperty=nameWithType> ca. 24,9 Tage, gehen Sie dann zu <xref:System.Int32.MinValue?displayProperty=nameWithType>, ist eine negative Zahl Erhöhen Sie dann wieder auf 0 (null), während der nächsten 24,9 Tage. Sie können dieses Problem umgehen, indem die Windows [z. B.](https://msdn.microsoft.com/library/windows/desktop/ms724408.aspx) -Funktion, die setzt auf 0 (null), nach ungefähr 49,7 Tage oder durch Aufrufen der [GetTickCount64](https://msdn.microsoft.com/library/windows/desktop/ms724411.aspx) Funktion.  
  
 <xref:System.Environment.TickCount%2A> unterscheidet sich von der <xref:System.DateTime.Ticks%2A?displayProperty=nameWithType> Eigenschaft, die die Anzahl der 100-Nanosekunden-Intervalle darstellt, die seit 1/1/0001, 00:00 Uhr vergangen sind.  
  
 Verwenden der <xref:System.DateTime.Now%2A?displayProperty=nameWithType> Eigenschaft, die das aktuelle Datum und die Uhrzeit auf diesem Computer abgerufen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die positiven zurückgegebene Wertebereich Abrufen der <xref:System.Environment.TickCount%2A> Eigenschaft. Die <xref:System.Environment.TickCount%2A> Eigenschaft Zyklen zwischen <xref:System.Int32.MinValue?displayProperty=nameWithType>, dies ist eine negative Zahl ist, und <xref:System.Int32.MaxValue?displayProperty=nameWithType> alle 49,8 Tage. In diesem Codebeispiel wird das Vorzeichenbit, um eine nicht negative Zahl, die zwischen 0 (null) navigieren entfernt und <xref:System.Int32.MaxValue> einmal 24,9 Tagen.  
  
 [!code-cpp[environment.tickcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.TickCount/CPP/tickcount.cpp#1)]
 [!code-csharp[environment.tickcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.TickCount/CS/tickcount.cs#1)]
 [!code-vb[environment.tickcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.TickCount/VB/tickcount.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserDomainName">
      <MemberSignature Language="C#" Value="public static string UserDomainName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserDomainName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserDomainName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserDomainName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserDomainName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserDomainName : string" Usage="System.Environment.UserDomainName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the network domain name associated with the current user.</summary>
        <value>Der Netzwerkdomänenname, der dem aktuellen Benutzer zugeordnet ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Anmeldeinformationen des Domänenkontos für einen Benutzer werden als Domänenname des Benutzers, formatiert die "\\" Zeichen und seinen Benutzernamen ein. Verwenden der <xref:System.Environment.UserDomainName%2A> -Eigenschaft zum Abrufen der Domänenname des Benutzers, ohne den Benutzernamen und das <xref:System.Environment.UserName%2A> Eigenschaft, um den Benutzernamen ohne den Domänennamen zu erhalten.  Wenn der Domänenname und Benutzername eines Benutzers CORPORATENETWORK\john, sind beispielsweise die <xref:System.Environment.UserDomainName%2A> Eigenschaft gibt "CORPORATENETWORK" zurück.  
  
 Die <xref:System.Environment.UserDomainName%2A> -Eigenschaft versucht zunächst, die Domäne-Komponente des Windows-Kontoname für den aktuellen Benutzer abrufen. Wenn dieser Versuch fehlschlägt, wird diese Eigenschaft zum Abrufen der Domänenname, der vom angegebenen Benutzernamen zugeordnet versucht die <xref:System.Environment.UserName%2A> Eigenschaft. Wenn dieser Versuch schlägt fehl, da der Host-Computer nicht zu einer Domäne angehört, wird der Name des Hostcomputers zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The operating system does not support retrieving the network domain name.</exception>
        <exception cref="T:System.InvalidOperationException">The network domain name cannot be retrieved.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für den Lesezugriff auf die USERDOMAIN-Umgebungsvariable. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.UserName" />
      </Docs>
    </Member>
    <Member MemberName="UserInteractive">
      <MemberSignature Language="C#" Value="public static bool UserInteractive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UserInteractive" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserInteractive" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserInteractive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UserInteractive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UserInteractive : bool" Usage="System.Environment.UserInteractive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the current process is running in user interactive mode.</summary>
        <value>
          <see langword="true" />, wenn der aktuelle Prozess im interaktiven Modus ausgeführt wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Environment.UserInteractive%2A> Eigenschaftsberichte `false` für einen Windows-Prozess oder einen Dienst wie IIS, der ohne Benutzeroberfläche ausgeführt wird. Wenn diese Eigenschaft ist `false`, modale Dialogfelder nicht anzeigen oder Meldungsfelder, da keine grafische Benutzeroberfläche für den Benutzer für die Interaktion mit vorhanden ist.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, ob der aktuelle Prozess im interaktiven Modus ausgeführt wird.  
  
 [!code-cpp[Environment.UserInteractive#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserInteractive/CPP/userinteractive.cpp#1)]
 [!code-csharp[Environment.UserInteractive#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserInteractive/CS/userinteractive.cs#1)]
 [!code-vb[Environment.UserInteractive#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserInteractive/VB/userinteractive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UserName">
      <MemberSignature Language="C#" Value="public static string UserName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserName : string" Usage="System.Environment.UserName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the user name of the person who is currently logged on to the operating system.</summary>
        <value>Der Benutzername der Person, die für das Betriebssystem angemeldet ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die <xref:System.Environment.UserName%2A> Eigenschaft zur Identifizierung des Benutzers für den aktuellen Thread, für das System und Anwendung für die Sicherheit oder Access. Sie können auch verwendet werden, um eine bestimmte Anwendung für jeden Benutzer anzupassen.  
 
 Unter Windows die <xref:System.Environment.UserName%2A> Eigenschaft dient als Wrapper für einen Aufruf an eine Windows [GetUserName](http://msdn.microsoft.com/library/windows/desktop/ms724432.aspx) Funktion. Die Anmeldeinformationen des Domänenkontos für einen Benutzer werden als Domänenname des Benutzers, formatiert die "\\" Zeichen und seinen Benutzernamen ein. Verwenden der <xref:System.Environment.UserDomainName%2A> -Eigenschaft zum Abrufen der Domäne des Benutzernamens und der <xref:System.Environment.UserName%2A> Eigenschaft, um den Benutzernamen zu erhalten.  
 
 Auf Unix-Plattformen die <xref:System.Environment.UserName%2A> Eigenschaft dient als Wrapper für einen Aufruf der `getpwuid_r` Funktion.
 
 Wenn eine ASP.NET-Anwendung in einer Entwicklungsumgebung ausgeführt wird. die <xref:System.Environment.UserName%2A> Eigenschaft gibt den Namen des aktuellen Benutzers zurück. In einer veröffentlichten ASP.NET-Anwendung gibt diese Eigenschaft den Namen der das Konto des Anwendungspools (z. B. Default AppPool).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Benutzernamen der Person, die den aktuellen Thread gestartet.  
  
 [!code-cpp[Environment.UserName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserName/CPP/username.cpp#1)]
 [!code-csharp[Environment.UserName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserName/CS/username.cs#1)]
 [!code-vb[Environment.UserName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserName/VB/username.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für den Lesezugriff auf die USERNAME-Umgebungsvariable. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.UserDomainName" />
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public static Version Version { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Version Version" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Version" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Version As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Version ^ Version { Version ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Version : Version" Usage="System.Environment.Version" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a <see cref="T:System.Version" /> object that describes the major, minor, build, and revision numbers of the common language runtime.</summary>
        <value>Ein Objekt, das die Version der Common Language Runtime anzeigt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei den .NET Framework-Versionen 4, 4.5, 4.5.1 und 4.5.2 gibt die <xref:System.Environment.Version%2A?displayProperty=nameWithType>Eigenschaft ein <xref:System.Version>-Objekt zurück, dessen Zeichenfolgedarstellung die Form `4.0.30319.xxxxx`besitzt. Für die .NET Framework 4.6 und höher, er hat das Format `4.0.30319.42000`.  
  
> [!WARNING]
>  Für die [!INCLUDE[net_v45](~/includes/net-v45-md.md)] und höher, wir empfehlen nicht mit der <xref:System.Environment.Version%2A> Eigenschaft zum Erkennen von der Version der Laufzeit; stattdessen können Sie die Version der common Language Runtime zu bestimmen, durch Abfragen der Registrierungs. Weitere Informationen finden Sie unter [wie: Bestimmen der installierten .NET Framework-Versionen sind](~/docs/framework/migration-guide/how-to-determine-which-versions-are-installed.md).  
  
 Weitere Informationen über die Version der common Language Runtime, die mit jeder Version von .NET Framework installiert ist, finden Sie unter [-Versionen und-Abhängigkeiten](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Version der common Language Runtime. (Die Version wird in der Beispielausgabe aus Sicherheitsgründen weggelassen.)  
  
 [!code-cpp[Environment.Version#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.Version/CPP/version.cpp#1)]
 [!code-csharp[Environment.Version#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.Version/CS/version.cs#1)]
 [!code-vb[Environment.Version#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.Version/VB/version.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public static long WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Environment.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property WorkingSet As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long WorkingSet { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int64" Usage="System.Environment.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of physical memory mapped to the process context.</summary>
        <value>Eine 64-Bit-Ganzzahl mit Vorzeichen, die die Größe des dem Prozesskontext zugeordneten physischen Speichers in Bytes angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt die Größe des Workingsets des Computers, der das Codebeispiel ausgeführt wird.  
  
 [!code-cpp[Environment.WorkingSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.WorkingSet/CPP/workingset.cpp#1)]
 [!code-csharp[Environment.WorkingSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.WorkingSet/CS/workingset.cs#1)]
 [!code-vb[Environment.WorkingSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.WorkingSet/VB/workingset.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für Vollzugriff auf die durch diese Berechtigung geschützte Ressource. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>