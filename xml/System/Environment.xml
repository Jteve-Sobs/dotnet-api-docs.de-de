<Type Name="Environment" FullName="System.Environment">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5dc9ac9466ea4ea16f08203acac2a967cedd6c42" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57928723" /></Metadata><TypeSignature Language="C#" Value="public static class Environment" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Environment extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Environment" />
  <TypeSignature Language="VB.NET" Value="Public Class Environment" />
  <TypeSignature Language="C++ CLI" Value="public ref class Environment abstract sealed" />
  <TypeSignature Language="F#" Value="type Environment = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt Informationen und Veränderungsmöglichkeiten für die aktuelle Umgebung und Plattform zur Verfügung. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Environment> -Klasse zum Abrufen von Informationen wie z. B. Befehlszeilenargumenten, Exitcode, umgebungsvariableneinstellungen, Inhalt von der Aufrufliste, die Zeit seit dem letzten Systemstart und die Version der common Language Runtime.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine Liste mit Informationen über die aktuelle Umgebung angezeigt.  
  
 [!code-cpp[environment.class#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.class/CPP/env0.cpp#1)]
 [!code-csharp[environment.class#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.class/CS/env0.cs#1)]
 [!code-vb[environment.class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.class/VB/env0.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CommandLine">
      <MemberSignature Language="C#" Value="public static string CommandLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommandLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CommandLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommandLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommandLine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommandLine : string" Usage="System.Environment.CommandLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Befehlszeile für diesen Prozess ab.</summary>
        <value>Eine Zeichenfolge mit den Befehlszeilenargumenten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft bietet Zugriff auf den Namen des Programms und alle Argumente, die in der Befehlszeile angegeben werden, wenn der aktuelle Prozess gestartet wurde.  
  
 Der Programmname kann Pfadinformationen, ist aber nicht erforderlich. Verwenden der <xref:System.Environment.GetCommandLineArgs%2A> Methode zum Abrufen der Befehlszeile Informationen analysiert und in ein Array von Zeichenfolgen gespeichert.  
  
 Die maximale Größe der Befehlszeilen-Puffer ist nicht auf eine bestimmte Anzahl von Zeichen festgelegt. Es variiert abhängig von der Windows-Betriebssystem, das auf dem Computer ausgeführt wird.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt einen eigenen Befehlszeile an.  
  
 [!code-cpp[environment.commandline#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.CommandLine/CPP/commandline.cpp#1)]
 [!code-csharp[environment.commandline#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.CommandLine/CS/commandline.cs#1)]
 [!code-vb[environment.commandline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.CommandLine/VB/commandline.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für den Lesezugriff auf die PATH-Umgebungsvariablen angegeben. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetCommandLineArgs" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDirectory">
      <MemberSignature Language="C#" Value="public static string CurrentDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string CurrentDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CurrentDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDirectory : string with get, set" Usage="System.Environment.CurrentDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den vollqualifizierten Pfad des aktuellen Arbeitsverzeichnisses ab oder legt diesen fest.</summary>
        <value>Eine Zeichenfolge mit einem Verzeichnispfad.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per Definition, wenn dieser Prozess gestartet, im Stammverzeichnis eines lokalen oder einem Netzlaufwerk wird, der Wert dieser Eigenschaft ist den Namen des Laufwerks, gefolgt von einem nachgestellten Schrägstrich (z. B. "C:\\"). Wenn dieser Prozess in einem Unterverzeichnis gestartet wird, ist der Wert dieser Eigenschaft den Laufwerk und Unterverzeichnis Pfad ohne nachgestellten Schrägstrich (z. B. "C:\mySubDirectory").  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Festlegen der <xref:System.Environment.CurrentDirectory%2A> Eigenschaft.  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Es wurde versucht, auf eine leere Zeichenfolge ("") festzulegen.</exception>
        <exception cref="T:System.ArgumentNullException">Es wurde versucht, auf <see langword="null." /> fetszulegen.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Es wurde versucht, auf einen lokalen Pfad festzulegen, der nicht gefunden werden kann.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer hat nicht die entsprechende Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Schreiben in Dateien oder Verzeichnisse in einem Set-Vorgang. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Informationen in den Pfad in eine Get-Vorgang. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentManagedThreadId">
      <MemberSignature Language="C#" Value="public static int CurrentManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CurrentManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CurrentManagedThreadId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentManagedThreadId : int" Usage="System.Environment.CurrentManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen eindeutigen Bezeichner für den aktuellen verwalteten Thread ab.</summary>
        <value>Eine Ganzzahl, die einen eindeutigen Bezeichner für diesen verwalteten Thread darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.Exit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (exitCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(int exitCode);" />
      <MemberSignature Language="F#" Value="static member Exit : int -&gt; unit" Usage="System.Environment.Exit exitCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="exitCode">Der an das Betriebssystem zurückzugebende Exitcode. Verwenden Sie 0 (null), um anzugeben, dass der Prozess erfolgreich abgeschlossen wurde.</param>
        <summary>Beendet den Prozess und gibt einen Exitcode an das Betriebssystem zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für die `exitCode` Parameter mit einem von Null abweichenden Anzahl einen Fehler an. In Ihrer Anwendung können Sie eigene Fehlercodes in einer Enumeration zu definieren und zurückgeben den entsprechende Fehlercode anhand des Szenarios. Der Wert 1, um anzugeben, dass die erforderliche Datei nicht vorhanden ist und den Wert 2, um anzugeben, dass die Datei im falschen Format z. B. zurück. Eine Liste der Exitcodes, die von der Windows-Betriebssystem verwendet, finden Sie unter [Systemfehlercodes](https://msdn.microsoft.com/library/ms681381.aspx) in der Windows-Dokumentation.  
  
 Aufrufen der <xref:System.Environment.Exit%2A> Methode unterscheidet sich von Ihrer Programmiersprache verwenden `return` Anweisung auf folgende Weise:  
  
-   <xref:System.Environment.Exit%2A> eine Anwendung beendet immer. Mithilfe der `return` -Anweisung kann eine Anwendung beendet werden nur dann, wenn es in den Einstiegspunkt der Anwendung, z. B. in verwendet wird die `Main` Methode.  
  
-   <xref:System.Environment.Exit%2A> eine Anwendung beendet sofort, selbst wenn andere Threads ausgeführt werden. Wenn die `return` Anweisung im Einstiegspunkt Anwendung aufgerufen wird, wird es durch die Anwendung beendet nur, wenn alle Vordergrundthreads beendet wurden.  
  
-   <xref:System.Environment.Exit%2A> muss der Aufrufer die Berechtigung zum nicht verwalteten Code aufrufen. Die `return` Anweisung hingegen nicht.  
  
-   Wenn <xref:System.Environment.Exit%2A> aufgerufen wird eine `try` oder `catch` -Block wird der Code in einem `finally` Block wird nicht ausgeführt. Wenn die `return` Anweisung verwendet wird, den Code in die `finally` Block wird ausgeführt.  
  
-   Wenn <xref:System.Environment.Exit%2A> wird aufgerufen, wenn Sie code in einem [eingeschränkten Ausführungsbereich](~/docs/framework/performance/constrained-execution-regions.md) (CER) ausgeführt wird, CER wird die Ausführung nicht abgeschlossen. Wenn die `return` -Anweisung wird verwendet, die der CER Ausführung beendet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über ausreichende Sicherheitsberechtigungen zum Ausführen dieser Funktion.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">die Möglichkeit zum Aufrufen von nicht verwalteten Codes. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public static int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ExitCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int with get, set" Usage="System.Environment.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Exitcode des Prozesses ab oder legt diesen fest.</summary>
        <value>Eine 32-Bit-Ganzzahl mit Vorzeichen, die den Exitcode enthält. Der Standardwert ist 0 (null), was angibt, dass der Prozess erfolgreich abgeschlossen wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die `Main` Methodenrückgabe `void`, können Sie diese Eigenschaft den Exitcode fest, die an die aufrufende Umgebung zurückgegeben werden. Wenn `Main` keinen zurückgibt `void`, diese Eigenschaft wird ignoriert. Der anfängliche Wert dieser Eigenschaft ist 0 (null).  
  
> [!WARNING]
>  Die <xref:System.Environment.ExitCode%2A> -Eigenschaft ist eine 32-Bit-Ganzzahl mit Vorzeichen. Um zu verhindern, dass die Eigenschaft einen negativer Exitcode zurückgeben, sollten Sie keine Werte größer als oder gleich 0 x 80000000 verwenden.  
  
 Verwenden Sie eine Zahl ungleich NULL, um einen Fehler anzugeben. In Ihrer Anwendung können Sie eigene Fehlercodes in einer Enumeration zu definieren und zurückgeben den entsprechende Fehlercode anhand des Szenarios. Z. B. zurück, der Wert 1, um anzugeben, dass die erforderliche Datei nicht vorhanden ist und den Wert 2, um anzugeben, dass die Datei in das falsche Format. Eine Liste der Exitcodes, die von der Windows-Betriebssystem verwendet, finden Sie unter [Systemfehlercodes](https://msdn.microsoft.com/library/ms681381\(v=vs.85\)) in der Windows-Dokumentation.  
  
   
  
## Examples  
 Im folgenden finden eine einfache app mit dem Namen Double.exe, die einen ganzzahligen Wert als Befehlszeilenargument übergeben verdoppelt. Der Wert weist den Fehlercodes der <xref:System.Environment.ExitCode%2A> Eigenschaft, um fehlerbedingungen anzuzeigen. Beachten Sie, dass Sie einen Verweis auf die Assembly System.Numerics.dll, um das Beispiel zu kompilieren hinzufügen müssen.  
  
 [!code-csharp[System.Environment.ExitCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double.cs#1)]
 [!code-vb[System.Environment.ExitCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double.vb#1)]  
  
 Im Beispiel kann dann aufgerufen werden, aus einer Batchdatei wie z. B. die folgenden, die Fehlercodes zugänglich, mithilfe macht der `ERRORLEVEL` Befehl.  
  
```  
  
echo off  
Double.exe %1  
If errorlevel 1639 goto NoArg   
if errorlevel 534 goto Overflow  
if errorlevel 160 goto BadArg  
if errorlevel 0 echo Completed Successfully   
goto :EOF  
  
:NoArg  
echo Missing argument  
goto :EOF  
  
: Overflow  
echo Arithmetic overflow  
goto :EOF  
  
:BadArg  
echo Invalid argument  
goto :EOF  
  
```  
  
 Das folgende Beispiel zeigt eine Beispielausgabe an, durch den Aufruf der Batchdatei, erstellt.  
  
```Output  
  
>getdouble 123>echo offResult: 246Completed Successfully>getdouble 5912323109093>echo offArithmetic overflow>getdouble>echo offMissing argument>getdouble "a string">echo offInvalid argument  
  
```  
  
 Beachten Sie diesen Code aus, für die Double.exe identisch zu dem folgenden Beispiel wird mit dem Unterschied, dass die vorherige Einstiegspunkt mit dem Namen definiert `Main` hat, die keinen Wert zurückgibt, während in diesem Beispiel wird einen Einstiegspunkt mit dem Namen definiert `Main` , die eine ganze Zahl zurückgibt.  
  
 [!code-csharp[System.Environment.ExitCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double1.cs#2)]
 [!code-vb[System.Environment.ExitCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpandEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static string ExpandEnvironmentVariables (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ExpandEnvironmentVariables(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.ExpandEnvironmentVariables(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExpandEnvironmentVariables (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ExpandEnvironmentVariables(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member ExpandEnvironmentVariables : string -&gt; string" Usage="System.Environment.ExpandEnvironmentVariables name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Eine Zeichenfolge, die die Namen von 0 (null) oder mehr Umgebungsvariablen enthält. Jede Umgebungsvariable wird mit dem Prozentzeichen (%) angegeben.</param>
        <summary>Ersetzt den Namen aller Umgebungsvariablen, die in die angegebene Zeichenfolge eingebettet sind, durch die Zeichenfolgenentsprechung für den Wert der Variablen und gibt anschließend das Ergebnis als Zeichenfolge zurück.</summary>
        <returns>Eine Zeichenfolge, bei der alle Umgebungsvariablen durch ihren Wert ersetzt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 COM-Interop wird verwendet, um die Umgebungsvariablen vom Betriebssystem abzurufen. Wenn Umgebungsvariablen für die aufgrund eines COM-Fehlers nicht abgerufen werden können, verwendet das HRESULT, der die Ursache des Fehlers erklärt wird eine von mehreren möglichen Ausnahmen generiert. die Ausnahme hängt, also den HRESULT-Wert. Weitere Informationen zur Verarbeitung von des HRESULT-Wert ist, finden Sie im Abschnitt "Hinweise" der <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A?displayProperty=nameWithType> Methode.  
  
 Ersetzung findet nur statt, Umgebungsvariablen, die festgelegt werden. Nehmen wir beispielsweise an `name` ist "MyENV MyENV% =". Wenn die Umgebungsvariable MyENV auf 42 festgelegt ist, gibt diese Methode "MyENV = 42". Wenn MyENV nicht festgelegt ist, tritt keine Änderung; Diese Methode gibt "MyENV MyENV% =".  
  
 Die Größe des Rückgabewerts ist auf 32 KB beschränkt.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie das Systemlaufwerk und Systemvariablen für Stamm abgerufen wird.  
  
 [!code-cpp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CPP/expandenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CS/expandenvironmentvariables.cs#1)]
 [!code-vb[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/VB/expandenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für den Zugriff auf die Umgebungsvariablen in <paramref name="name" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="FailFast">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Beendet einen Prozess sofort, nachdem eine Meldung in das Windows-Anwendungsereignisprotokoll geschrieben wurde, und schließt dann die Meldung und optionale Ausnahmeinformationen in Fehlerberichte an Microsoft ein.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FailFast (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FailFast(System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member FailFast : string -&gt; unit" Usage="System.Environment.FailFast message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="message">Eine Meldung, die erklärt, warum der Prozess beendet wurde, oder <see langword="null" />, wenn keine Erklärung gegeben wird.</param>
        <summary>Beendet einen Prozess sofort, nachdem eine Meldung in das Windows-Anwendungsereignisprotokoll geschrieben wurde, und schließt dann die Meldung in Fehlerberichte an Microsoft ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode beendet einen Prozess ohne aktive `try` / `finally` Blöcke oder Finalizer.  
  
 Die <xref:System.Environment.FailFast%2A> Methode schreibt die `message` Zeichenfolge, die die Windows-Anwendungsereignisprotokoll erstellt ein Abbild Ihrer Anwendung, und klicken Sie dann den aktuellen Prozess beendet. Die `message` Zeichenfolge ist auch in Fehlerberichte an Microsoft enthalten.  
  
 Verwenden der <xref:System.Environment.FailFast%2A> -Methode anstelle der <xref:System.Environment.Exit%2A> Methode, um die Anwendung zu beenden, wenn der Zustand der Anwendung irreparabel beschädigt ist und Ausführen Ihrer Anwendungsverzeichnis `try` / `finally` Blöcke und Finalizer Programmressourcen wird beschädigt werden.  
  
 Informationen wird an Microsoft gemeldet werden, mithilfe der Windows-Fehlerberichterstattung. Weitere Informationen finden Sie unter [Windows-Fehlerberichterstattung: Erste Schritte](https://msdn.microsoft.com/library/windows/hardware/dn641144.aspx).  
  
   
  
## Examples  
 Im folgenden Beispiel schreibt einen Protokolleintrag in die Windows-Anwendungsereignisprotokoll und beendet den aktuellen Prozess.  
  
 [!code-csharp[environment.FailFast#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.FailFast/cs/ff.cs#1)]
 [!code-vb[environment.FailFast#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.FailFast/vb/ff.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message, Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message, class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String,System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FailFast(System::String ^ message, Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FailFast : string * Exception -&gt; unit" Usage="System.Environment.FailFast (message, exception)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="exception" Type="System.Exception" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="message">Eine Meldung, die erklärt, warum der Prozess beendet wurde, oder <see langword="null" />, wenn keine Erklärung gegeben wird.</param>
        <param name="exception">Eine Ausnahme, die den Fehler darstellt, der die Beendigung verursacht hat. Dies ist in der Regel die Ausnahme in einem <see langword="catch" />-Block.</param>
        <summary>Beendet einen Prozess sofort, nachdem eine Meldung in das Windows-Anwendungsereignisprotokoll geschrieben wurde, und schließt dann die Meldung und Ausnahmeinformationen in Fehlerberichte an Microsoft ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode beendet den Prozess ohne aktive `try` / `finally` Blöcke oder Finalizer.  
  
 Die <xref:System.Environment.FailFast%2A> Methode schreibt die `message` Zeichenfolge, die die Windows-Anwendungsereignisprotokoll erstellt ein Abbild Ihrer Anwendung, und klicken Sie dann den aktuellen Prozess beendet.  
  
 Informationen wird an Microsoft gemeldet werden, mithilfe der Windows-Fehlerberichterstattung. Weitere Informationen finden Sie unter [Windows-Fehlerberichterstattung: Erste Schritte](https://msdn.microsoft.com/library/windows/hardware/dn641144.aspx). Fehlerberichte an Microsoft enthält `message` und `exception` Informationen Details verwendet liefert, um den Fehler zu klassifizieren. Obwohl `exception` wird nicht behandelt, da der Prozess beendet wird, das die Kontextinformationen, die die Ausnahme ausgelöst hat weiterhin abgerufen wird.  
  
 Wenn `exception` ist `null`, oder wenn `exception` wird nicht ausgelöst, diese Methode funktioniert Analog den <xref:System.Environment.FailFast%28System.String%29> -methodenüberladung.  
  
 Verwenden der <xref:System.Environment.FailFast%2A> -Methode anstelle der <xref:System.Environment.Exit%2A> Methode, um die Anwendung zu beenden, wenn der Zustand der Anwendung irreparabel beschädigt ist und Ausführen Ihrer Anwendungsverzeichnis `try` / `finally` Blöcke und Finalizer Programmressourcen wird beschädigt werden.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCommandLineArgs">
      <MemberSignature Language="C#" Value="public static string[] GetCommandLineArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetCommandLineArgs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetCommandLineArgs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCommandLineArgs () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetCommandLineArgs();" />
      <MemberSignature Language="F#" Value="static member GetCommandLineArgs : unit -&gt; string[]" Usage="System.Environment.GetCommandLineArgs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein Zeichenfolgenarray mit den Befehlszeilenargumenten für den aktuellen Prozess zurück.</summary>
        <returns>Ein Array von Zeichenfolgen, in dem jedes Element ein Befehlszeilenargument enthält. Das erste Element ist der Name der ausführbaren Datei. Falls nachfolgende Elemente vorhanden sind, enthalten sie die restlichen Befehlszeilenargumente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das erste Element im Array enthält den Namen des ausgeführten Programms an. Wenn der Dateiname nicht verfügbar ist, ist das erste Element gleich <xref:System.String.Empty?displayProperty=nameWithType>. Die übrigen Elemente enthalten, zusätzlichen Token in der Befehlszeile eingegeben wird.  
  
 Den Namen der Programmdatei kann, aber es ist nicht erforderlich, um Pfadinformationen enthalten.  
  
 Befehlszeilenargumente werden durch Leerzeichen getrennt. Sie können doppelte Anführungszeichen (") verwenden, um Leerzeichen im Argument enthalten. Das einfache Anführungszeichen ('), bietet diese Funktionalität jedoch nicht.  
  
 Wenn ein doppeltes Anführungszeichen auf zwei oder eine gerade Anzahl umgekehrter Schrägstriche folgt, wird jedes Paar umgekehrter Schrägstrich aus Sie den Vorgang fortsetzen, wird durch einen umgekehrten Schrägstrich ersetzt, und das doppelte Anführungszeichen wird entfernt. Wenn ein doppeltes Anführungszeichen auf eine ungerade Anzahl umgekehrter Schrägstriche, nur ein einziges, einschließlich folgt jedes Paar aus vorherigen wird durch einen umgekehrten Schrägstrich ersetzt und verbleibende umgekehrten Schrägstrich entfernt wird; in diesem Fall wird das Anführungszeichen jedoch nicht entfernt.  
  
 In der folgende Tabelle wird gezeigt, wie Befehlszeilenargumente durch Trennzeichen getrennte werden können, und geht davon aus `MyApp` wie die aktuelle ausgeführte Anwendung.  
  
|Geben Sie in der Befehlszeile|Resultierende Befehlszeilenargumente|  
|-------------------------------|--------------------------------------|  
|`MyApp alpha beta`|`MyApp, alpha, beta`|  
|`MyApp "alpha with spaces" "beta with spaces"`|`MyApp, alpha with spaces, beta with spaces`|  
|`MyApp 'alpha with spaces' beta`|`MyApp, 'alpha, with, spaces', beta`|  
|`MyApp \\\alpha \\\\"beta`|`MyApp, \\\alpha, \\beta`|  
|`MyApp \\\\\"alpha \"beta`|`MyApp, \\"alpha, "beta`|  
  
 Verwenden Sie zum Abrufen der Befehlszeile als einzelne Zeichenfolge die <xref:System.Environment.CommandLine%2A> Eigenschaft.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Befehlszeilenargumente der Anwendung.  
  
 [!code-cpp[Environment.GetCommandLineArgs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CPP/getcommandlineargs.cpp#1)]
 [!code-csharp[Environment.GetCommandLineArgs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CS/getcommandlineargs.cs#1)]
 [!code-vb[Environment.GetCommandLineArgs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetCommandLineArgs/VB/getcommandlineargs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Das System unterstützt keine Befehlszeilenargumente.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für den Lesezugriff auf die PATH-Umgebungsvariablen angegeben. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.CommandLine" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnvironmentVariable">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den Wert einer Umgebungsvariable ab.</summary>
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariable (variable As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEnvironmentVariable(System::String ^ variable);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariable : string -&gt; string" Usage="System.Environment.GetEnvironmentVariable variable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="variable">Der Name der Umgebungsvariablen.</param>
        <summary>Ruft den Wert einer Umgebungsvariablen vom aktuellen Prozess ab.</summary>
        <returns>Der Wert der von <paramref name="variable" /> angegebenen Umgebungsvariablen oder <see langword="null" />, wenn die Umgebungsvariable nicht gefunden wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Die <xref:System.Environment.GetEnvironmentVariable%28System.String%29> Methode ruft eine Umgebungsvariable in dem Umgebungsblock, der nur den aktuellen Prozess ab. Dies entspricht dem Aufrufen der <xref:System.Environment.GetEnvironmentVariable%28System.String%2CSystem.EnvironmentVariableTarget%29> -Methode mit einer `target` Wert <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>. 

Um alle Umgebungsvariablen zusammen mit ihren Werten abzurufen, rufen die <xref:System.Environment.GetEnvironmentVariables%2A> Methode.  
  
Umgebungsvariablen werden Groß-/Kleinschreibung beachtet, Linux und MacOS sind jedoch nicht Groß-/Kleinschreibung für Windows.  
 
### <a name="on-windows-systems"></a>Auf Windows-Systemen

 Für Windows-Systemen, schließt der Umgebungsblock, der den aktuellen Prozess:
 
- Alle Umgebungsvariablen, die es vom übergeordneten Prozess bereitgestellt werden, die sie erstellt haben. Beispielsweise erbt eine .NET-Anwendung, die in einem Konsolenfenster gestartet alle Umgebungsvariablen für das Konsolenfenster. 

  Liegt keine übergeordneten Prozess, werden Umgebungsvariablen pro Computer und pro Benutzer stattdessen verwendet. Beispielsweise weist ein neues Konsolenfenster alle computerspezifischen und benutzerspezifische Umgebungsvariablen definiert, zu dem Zeitpunkt, die sie gestartet wurde.

- Alle Variablen, die auf der Process-Block hinzugefügt werden, während der Prozess ausgeführt wird, durch Aufrufen von entweder die <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> Methode oder die <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> -Methode mit einer `target` Wert <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>. Diese Umgebungsvariablen wird beibehalten, bis die Anwendung .NET beendet wird.  
  
Wenn Umgebungsvariablen erstellt werden, nachdem der Prozess gestartet wurde, können Sie diese Methode verwenden, um nur diese Variablen abzurufen, die durch den Aufruf erstellt wurden die <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> Methode oder die <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> -Methode mit einem `target` Wert.<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>.  

### <a name="on-macos-and-linux-systems"></a>Unter MacOS und Linux-Systeme

Unter MacOS und Linux enthält der Umgebungsblock, der den aktuellen Prozess die folgenden Umgebungsvariablen:

- Alle Umgebungsvariablen, die es vom übergeordneten Prozess bereitgestellt werden, die sie erstellt haben. Für .NET-Anwendungen über eine Shell gestartet schließt dies alle Umgebungsvariablen in der Shell.

- Alle Variablen, die auf der Process-Block hinzugefügt werden, während der Prozess ausgeführt wird, durch Aufrufen von entweder die <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> Methode oder die <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> -Methode mit einer `target` Wert <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>. Diese Umgebungsvariablen wird beibehalten, bis die Anwendung .NET beendet wird.  

.NET Core unter MacOS und Linux unterstützt keine Variablen pro Computer oder pro Benutzer.   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Environment.GetEnvironmentVariable%2A> Methode zum Abrufen der `windir` Umgebungsvariable, die den Pfad des Windows-Verzeichnisses enthält.  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 Im folgenden Beispiel wird versucht, den Wert einer Umgebungsvariablen mit dem Namen des abzurufenden `Test1` in dem Umgebungsblock Prozess. Wenn die Variable nicht vorhanden ist, wird das Beispiel erstellt die und seinen Wert abruft. Das Beispiel zeigt den Wert der Variablen. Wenn im Beispiel wird die Variable erstellt, ruft sie auch die <xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29> -Methode mit dem jedes Element der <xref:System.EnvironmentVariableTarget> Enumeration, die überprüft wird, ob die Variable nur aus der aktuellen Umgebung prozessblock abgerufen werden kann. Schließlich im Beispiel wird die Variable erstellt, löscht sie es.  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs#2)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="variable" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer hat nicht die erforderliche Berechtigung zum Ausführen dieses Vorgangs.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für die Möglichkeit, lesen den Wert der <paramref name="variable" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable, EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariable (variable As String, target As EnvironmentVariableTarget) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEnvironmentVariable(System::String ^ variable, EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariable : string * EnvironmentVariableTarget -&gt; string" Usage="System.Environment.GetEnvironmentVariable (variable, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="variable">Der Name einer Umgebungsvariablen.</param>
        <param name="target">Einer der <see cref="T:System.EnvironmentVariableTarget" />-Werte.</param>
        <summary>Ruft den Wert einer Umgebungsvariablen vom aktuellen Prozess oder aus dem Registrierungsschlüssel des Windows-Betriebssystems für den aktuellen Benutzer oder den lokalen Computer ab.</summary>
        <returns>Der Wert der von den Parametern <paramref name="variable" /> und <paramref name="target" /> angegebenen Umgebungsvariablen oder <see langword="null" />, wenn die Umgebungsvariable nicht gefunden wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks 

Um alle Umgebungsvariablen zusammen mit ihren Werten abzurufen, rufen die <xref:System.Environment.GetEnvironmentVariables%2A> Methode.  
  
Umgebungsvariablen werden Groß-/Kleinschreibung beachtet, Linux und MacOS sind jedoch nicht Groß-/Kleinschreibung für Windows. 

### <a name="on-windows-systems"></a>Auf Windows-Systemen

Auf Windows die `target` Parameter gibt an, ob der Umgebungsvariablen vom aktuellen Prozess oder aus dem Registrierungsschlüssel des Windows-Betriebssystem für den aktuellen Benutzer oder den lokalen Computer abgerufen wird. Alle Umgebungsvariablen pro Benutzer und pro Computer werden automatisch in der Umgebungsblock, der den aktuellen Prozess, kopiert, ebenso wie aller anderen Umgebungsvariablen, die für den übergeordneten Prozess verfügbar sind, die den Prozess für .NET erstellt hat. Allerdings Umgebungsvariablen hinzugefügt nur der Umgebungsblock, der den aktuellen Prozess durch Aufrufen von entweder die <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> Methode oder der <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> -Methode mit einer `target` Wert <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> werden nur für die Dauer des Prozesses.  
  
### <a name="on-macos-and-linux-systems"></a>Unter MacOS und Linux-Systeme

Unter MacOS und Linux die `GetEnvironmentVariable(String, EnvironmentVariableTarget)` -Datentypmethode unterstützt eine `target` Wert <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithtype> nur. Ruft mit einer `target` Wert <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithtype> oder <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithtype> werden nicht unterstützt und zurückgeben `null`. 

Pro-Prozess-Umgebungsvariablen sind:

- Die geerbten aus dem übergeordneten Prozess, in der Regel die Shell, die zum Aufrufen `dotnet.exe` oder zum Starten der Anwendung für .NET.

- Durch Aufrufen von entweder definiert die <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> Methode oder die <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> -Methode mit einer `target` Wert <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>. Diese Umgebungsvariablen nur bis zum Beibehalten der `dotnet` Prozess oder die Anwendung .NET beendet wird.   
  
## Examples  
 Das folgende Beispiel erstellt die Umgebungsvariablen für den Prozess, Benutzer und Computer-Ziele, überprüft, ob die Registrierung des Betriebssystems die Umgebungsvariablen für Benutzer und Computer enthält, und löscht dann die Umgebungsvariablen.  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="variable" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> ist kein gültiger <see cref="T:System.EnvironmentVariableTarget" />-Wert.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer hat nicht die erforderliche Berechtigung zum Ausführen dieses Vorgangs.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für die Möglichkeit, lesen den Wert der <paramref name="variable" /> Wenn <paramref name="target" /> ist <see cref="F:System.EnvironmentVariableTarget.Process" /> (zugeordnete Enumeration: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" />), 
oder 
für vollständigen Zugriff auf Umgebungsvariablen Wenn <paramref name="target" /> ist <see cref="F:System.EnvironmentVariableTarget.User" /> oder <see cref="F:System.EnvironmentVariableTarget.Machine" /> (zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />).</permission>
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnvironmentVariables">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft die Namen und Werte aller Umgebungsvariablen ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariables () As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IDictionary ^ GetEnvironmentVariables();" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariables : unit -&gt; System.Collections.IDictionary" Usage="System.Environment.GetEnvironmentVariables " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft alle Namen und Werte der Umgebungsvariablen vom aktuellen Prozess ab.</summary>
        <returns>Ein Wörterbuch, das die Namen und Werte aller Umgebungsvariablen enthält, andernfalls ein leeres Wörterbuch, wenn keine Umgebungsvariablen gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Namen und Werte für die Umgebungsvariablen werden als Schlüssel-Wert-Paare in der zurückgegebenen gespeichert <xref:System.Collections.IDictionary>.  
  
### <a name="on-windows-systems"></a>Auf Windows-Systemen

Auf Windows-Systemen die `GetEnvironmentVariables` Methode gibt zurück, die folgenden Variablen der Umgebung:
  
- Alle computerspezifischen Umgebungsvariablen, die zum Zeitpunkt der Prozess, die zusammen mit ihren Werten erstellt wird definiert sind.  
  
- Alle pro-Benutzer-Umgebungsvariablen, die zum Zeitpunkt definiert sind ist der Prozess, zusammen mit ihren Werten erstellt.  

- Alle Variablen, geerbt von der übergeordnete Prozess, von dem die Anwendung .NET gestartet oder während der Prozess ausgeführt wird der Process-Block hinzugefügt wurde. Umgebungsvariablen werden hinzugefügt, während der Prozess ausgeführt wird, durch Aufrufen von entweder die <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> Methode oder der <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> -Methode mit einer `target` Wert <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>.  

### <a name="on-macos-and-linux-systems"></a>Unter MacOS und Linux-Systeme

Unter MacOS und Linux die `GetEnvironmentVariables` Methode ruft den Namen und Wert, der alle Umgebungsvariablen, die aus dem übergeordneten Prozess geerbt werden, die gestartet der `dotnet` ausgeführt werden oder werden innerhalb des Bereichs definiert die `dotnet` selbst zu verarbeiten. Sobald die `dotnet` Prozess beendet, diese zweite Umgebungsvariablen sind nicht mehr vorhanden. 

.NET Core unterstützt keine Variablen pro Computer oder pro Benutzer.   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Environment.GetEnvironmentVariables%2A> Methode.  
  
 [!code-cpp[Environment.GetEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CPP/getenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.GetEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CS/getenvironmentvariables.cs#1)]
 [!code-vb[Environment.GetEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetEnvironmentVariables/VB/getenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer hat nicht die erforderliche Berechtigung zum Ausführen dieses Vorgangs.</exception>
        <exception cref="T:System.OutOfMemoryException">Im Puffer ist nicht genügend Arbeitsspeicher.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für die Fähigkeit zum Lesen der Namen und Werte der Umgebungsvariablen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables (EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables(valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariables (target As EnvironmentVariableTarget) As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IDictionary ^ GetEnvironmentVariables(EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariables : EnvironmentVariableTarget -&gt; System.Collections.IDictionary" Usage="System.Environment.GetEnvironmentVariables target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target">Einer der <see cref="T:System.EnvironmentVariableTarget" />-Werte.</param>
        <summary>Ruft die Namen und Werte aller Umgebungsvariablen vom aktuellen Prozess oder aus dem Registrierungsschlüssel des Windows-Betriebssystems für den aktuellen Benutzer oder den lokalen Computer ab.</summary>
        <returns>Ein Wörterbuch, das die Namen und Werte aller Umgebungsvariablen aus der durch den <paramref name="target" />-Parameter angegebenen Quelle enthält, andernfalls ein leeres Wörterbuch, wenn keine Umgebungsvariablen gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Die Namen und Werte der Umgebungsvariablen werden als Schlüssel/Wert-Paare in der zurückgegebenen gespeichert <xref:System.Collections.IDictionary> Objekt.  

### <a name="on-windows-systems"></a>Auf Windows-Systemen

Auf Windows-Systemen die `target` Parameter gibt an, ob die Quelle des aktuellen Prozesses, den Registrierungsschlüssel für den aktuellen Benutzer oder die Registrierungsschlüssel für den lokalen Computer ist.  

### <a name="on-macos-and-linux-systems"></a>Unter MacOS und Linux-Systeme

Unter MacOS und Linux, nur eine `target` Wert <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> wird unterstützt. Pro Prozess Umgebungsvariablen werden geerbt, aus dem übergeordneten Prozess (normalerweise die Shell), das zum Starten verwendet die `dotnet` verarbeiten oder werden innerhalb des Bereichs definiert die `dotnet` selbst zu verarbeiten. Nach der Dotnet-Prozess beendet, beendet diese zweite Umgebungsvariablen vorhanden sind.  

Umgebungsvariablen pro Computer und pro Benutzer werden nicht unterstützt. Ein `target` Wert <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> oder <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> ein leeres Array zurück.
  
## Examples  
 Das folgende Beispiel erstellt die Umgebungsvariablen für den Prozess, Benutzer und Computer-Ziele, überprüft, ob die Registrierung des Betriebssystems die Umgebungsvariablen für Benutzer und Computer enthält, und löscht dann die Umgebungsvariablen.  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer hat für den angegebenen Wert von <paramref name="target" /> nicht die erforderliche Berechtigung zum Ausführen dieses Vorgangs.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> enthält einen unzulässigen Wert.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">die Möglichkeit, lesen Sie die Namen und Werte von Umgebungsvariablen Wenn <paramref name="target" /> ist <see cref="F:System.EnvironmentVariableTarget.Process" /> (zugeordnete Enumeration: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" />), 
oder 
für vollständigen Zugriff auf Umgebungsvariablen Wenn <paramref name="target" /> ist <see cref="F:System.EnvironmentVariableTarget.User" /> oder <see cref="F:System.EnvironmentVariableTarget.Machine" /> (zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />).</permission>
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFolderPath">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den Pfad des durch die angegebene Enumeration bezeichneten besonderen Systemordners ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFolderPath (folder As Environment.SpecialFolder) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFolderPath(Environment::SpecialFolder folder);" />
      <MemberSignature Language="F#" Value="static member GetFolderPath : Environment.SpecialFolder -&gt; string" Usage="System.Environment.GetFolderPath folder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="folder">Einer der Enumerationswerte, die eine besonderen Systemordner bezeichnen.</param>
        <summary>Ruft den Pfad des durch die angegebene Enumeration bezeichneten besonderen Systemordners ab.</summary>
        <returns>Der Pfad zum angegebenen besonderen Systemordner, sofern dieser auf dem Computer physisch vorhanden ist, andernfalls eine leere Zeichenfolge ("").  
  
Ein Ordner ist physisch nicht vorhanden, wenn er nicht vom Betriebssystem erstellt wurde, wenn der vorhandene Ordner gelöscht wurde oder wenn der Ordner ein virtuelles Verzeichnis ist, z. B. Arbeitsplatz, das keinem physischen Pfad entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft den Pfad zu einer besonderen Systemordner, z. B. Program Files "," Programme "," System "oder" Start, das Zugriff auf gemeinsame Daten verwendet werden kann. Ordner mit Sonderfunktionen werden standardmäßig vom System oder explizit vom Benutzer festgelegt, wenn eine Version von Windows zu installieren.  
  
 Die `folder` -Parameter kennzeichnet spezielle Ordners zum Abrufen und muss einen der Werte in der <xref:System.Environment.SpecialFolder> -Enumeration, die einer anderen Wert löst eine Ausnahme aus.  
  
 Weitere Informationen zu dem Ordner mit Sonderfunktionen, finden Sie unter den [CSIDL](https://go.microsoft.com/fwlink/?LinkId=116664) Werte Thema.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Environment.GetFolderPath%2A> Methode zum Zurückgeben und Anzeigen des zugeordnete Pfads der `folder` Parameter.  
  
 [!code-cpp[Environment.GetFolderPath#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetFolderPath/CPP/getfolderpath.cpp#1)]
 [!code-csharp[Environment.GetFolderPath#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetFolderPath/CS/getfolderpath.cs#1)]
 [!code-vb[Environment.GetFolderPath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetFolderPath/VB/getfolderpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="folder" /> ist kein Member von <see cref="T:System.Environment.SpecialFolder" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die aktuelle Plattform wird nicht unterstützt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Informationen im Pfad selbst. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder, Environment.SpecialFolderOption option);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder, valuetype System.Environment/SpecialFolderOption option) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder,System.Environment.SpecialFolderOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFolderPath (folder As Environment.SpecialFolder, option As Environment.SpecialFolderOption) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFolderPath(Environment::SpecialFolder folder, Environment::SpecialFolderOption option);" />
      <MemberSignature Language="F#" Value="static member GetFolderPath : Environment.SpecialFolder * Environment.SpecialFolderOption -&gt; string" Usage="System.Environment.GetFolderPath (folder, option)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="option" Type="System.Environment+SpecialFolderOption" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="folder">Einer der Enumerationswerte, die einen besonderen Systemordner bezeichnen.</param>
        <param name="option">Einer der Enumerationswerte, die Optionen zum Zugreifen auf einen besonderen Ordner angeben.</param>
        <summary>Ruft den Pfad zum besonderen Systemordner ab, der von der angegebenen Enumeration bezeichnet wird, und verwendet eine angegebene Option zum Zugreifen auf besondere Ordner.</summary>
        <returns>Der Pfad zum angegebenen besonderen Systemordner, sofern dieser auf dem Computer physisch vorhanden ist, andernfalls eine leere Zeichenfolge ("").  
  
Ein Ordner ist physisch nicht vorhanden, wenn er nicht vom Betriebssystem erstellt wurde, wenn der vorhandene Ordner gelöscht wurde oder wenn der Ordner ein virtuelles Verzeichnis ist, z. B. Arbeitsplatz, das keinem physischen Pfad entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft den Pfad zu einer besonderen Systemordner, z. B. Program Files "," Programme "," System "oder" Start, das Zugriff auf gemeinsame Daten verwendet werden kann. Ordner mit Sonderfunktionen werden standardmäßig vom System oder explizit vom Benutzer festgelegt, wenn eine Version von Windows zu installieren.  
  
 Die `folder` -Parameter kennzeichnet spezielle Ordners zum Abrufen und muss einen der Werte in der <xref:System.Environment.SpecialFolder> -Enumeration, die einer anderen Wert löst eine Ausnahme aus.  
  
 Weitere Informationen zu dem Ordner mit Sonderfunktionen, finden Sie unter den [CSIDL](https://go.microsoft.com/fwlink/?LinkId=116664) Werte Thema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="folder" /> ist kein Member von <see cref="T:System.Environment.SpecialFolder" />.
- oder -

<paramref name="options" /> ist kein Member von <see cref="T:System.Environment.SpecialFolderOption" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die aktuelle Plattform wird nicht unterstützt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Informationen im Pfad selbst. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetLogicalDrives">
      <MemberSignature Language="C#" Value="public static string[] GetLogicalDrives ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetLogicalDrives() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetLogicalDrives" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLogicalDrives () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetLogicalDrives();" />
      <MemberSignature Language="F#" Value="static member GetLogicalDrives : unit -&gt; string[]" Usage="System.Environment.GetLogicalDrives " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein Zeichenfolgenarray mit den Namen der logischen Laufwerke des aktuellen Computers zurück.</summary>
        <returns>Ein Array von Zeichenfolgen, in dem jedes Element den Namen eines logischen Laufwerks enthält. Wenn z.B. die Festplatte das erste logische Laufwerk eines Computers ist, lautet das erste zurückgegebene Element "C:\\".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt die Vorgehensweise beim Anzeigen von logischen Laufwerke des aktuellen Computers mithilfe der <xref:System.Environment.GetLogicalDrives%2A> Methode.  
  
 [!code-cpp[Environment.GetLogicalDrives#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetLogicalDrives/CPP/getlogicaldrives.cpp#1)]
 [!code-csharp[Environment.GetLogicalDrives#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetLogicalDrives/CS/getlogicaldrives.cs#1)]
 [!code-vb[Environment.GetLogicalDrives#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetLogicalDrives/VB/getlogicaldrives.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für vollständigen Zugriff auf die durch diese Berechtigung geschützte Ressource. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownStarted">
      <MemberSignature Language="C#" Value="public static bool HasShutdownStarted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool HasShutdownStarted" />
      <MemberSignature Language="DocId" Value="P:System.Environment.HasShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property HasShutdownStarted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool HasShutdownStarted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasShutdownStarted : bool" Usage="System.Environment.HasShutdownStarted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die derzeitige Anwendungsdomäne entladen wird oder die Common Language Runtime (CLR) heruntergefahren wird.</summary>
        <value><see langword="true" /> Wenn die aktuelle Anwendungsdomäne entladen wird oder die CLR heruntergefahren wird nach unten; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die CLR eine Anwendungsdomäne entladen wird, wird der Finalizer für alle Objekte, die eine Finalizer-Methode in dieser Anwendungsdomäne ausgeführt. Wenn die CLR heruntergefahren wird, wird den Finalizer-Thread für alle Objekte, die eine Finalizer-Methode gestartet. Die <xref:System.Environment.HasShutdownStarted%2A> -Eigenschaft gibt `true` nur, nachdem der Finalizer-Thread gestartet wurde. Wenn die Eigenschaft zurückgegeben `true`, können Sie bestimmen, ob eine Anwendungsdomäne entladen wird, oder die CLR selbst, durch den Aufruf heruntergefahren wird der <xref:System.AppDomain.IsFinalizingForUnload%2A?displayProperty=nameWithType> Methode. Diese Methode gibt `true` wenn Finalizer aufgerufen werden, da die Anwendungsdomäne entladen wird oder `false` Wenn die CLR heruntergefahren wird.  
  
 Die <xref:System.Environment.HasShutdownStarted%2A> -Eigenschaft gibt `false` , wenn der Finalizer-Thread nicht gestartet wurde.  
  
 Mithilfe dieser Eigenschaft können Sie den Zugriff auf statische Variablen in Ihrem Finalisierungscode bestimmen, ob. Wenn entweder eine Anwendungsdomäne oder die CLR heruntergefahren wird, kann nicht zuverlässiger Zugriff auf alle Objekte, die eine Finalisierungsmethode hat und auf den verwiesen wird von einem statischen Feld. Dies ist, da diese Objekte möglicherweise bereits beendet wurde.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsFinalizingForUnload" />
      </Docs>
    </Member>
    <Member MemberName="Is64BitOperatingSystem">
      <MemberSignature Language="C#" Value="public static bool Is64BitOperatingSystem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitOperatingSystem" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitOperatingSystem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Is64BitOperatingSystem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Is64BitOperatingSystem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Is64BitOperatingSystem : bool" Usage="System.Environment.Is64BitOperatingSystem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bestimmt, ob das aktuelle Betriebssystem ein 64-Bit-Betriebssystem ist.</summary>
        <value><see langword="true" />, wenn das aktuelle Betriebssystem ein 64-Bit-Betriebssystem ist, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Is64BitProcess">
      <MemberSignature Language="C#" Value="public static bool Is64BitProcess { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitProcess" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Is64BitProcess As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Is64BitProcess { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Is64BitProcess : bool" Usage="System.Environment.Is64BitProcess" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bestimmt, ob der aktuelle Prozess ein 64-Bit-Prozess ist.</summary>
        <value><see langword="true" />, wenn der aktuelle Prozess ein 64-Bit-Prozess ist, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public static string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Environment.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den NetBIOS-Namen dieses lokalen Computers ab.</summary>
        <value>Eine Zeichenfolge mit dem Namen dieses Computers.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Name des Computers wird beim Systemstart eingerichtet, wenn der Name aus der Registrierung gelesen werden. Wenn dieser Computer ein Knoten in einem Cluster ist, wird der Name des Knotens zurückgegeben.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Namen des Computers, der im Codebeispiel ausgeführt wird. (Der Name des Computers wird in der Beispielausgabe aus Sicherheitsgründen weggelassen.)  
  
 [!code-cpp[environment.machinename#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.MachineName/CPP/machinename.cpp#1)]
 [!code-csharp[environment.machinename#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.MachineName/CS/machinename.cs#1)]
 [!code-vb[environment.machinename#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.MachineName/VB/machinename.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Name dieses Computers kann nicht abgerufen werden.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für den Lesezugriff auf die COMPUTERNAME-Umgebungsvariable. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="NewLine">
      <MemberSignature Language="C#" Value="public static string NewLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string NewLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.NewLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property NewLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ NewLine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NewLine : string" Usage="System.Environment.NewLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die für diese Umgebung definierte Zeichenfolge für einen Zeilenumbruch ab.</summary>
        <value>Eine Zeichenfolge für Nicht-Unix-Plattformen, die "\r\n" enthält, oder eine Zeichenfolge für Unix-Plattformen, die "\n" enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Eigenschaftswert des <xref:System.Environment.NewLine%2A> ist eine Konstante, die speziell für die aktuelle Plattform und die Implementierung von .NET Framework angepasst. Weitere Informationen über die Escapezeichen in den Wert der Eigenschaft finden Sie unter [Escapezeichen](~/docs/standard/base-types/character-escapes-in-regular-expressions.md).  
  
 Die Funktionalität von bereitgestellten <xref:System.Environment.NewLine%2A> ist oft, was die Begriffe Zeilenumbruch, Zeilenvorschub, Zeilenumbruch, Carriage return, Wagenrücklauf, CRLF und Ende der Zeile bedeutet.  
  
 <xref:System.Environment.NewLine%2A> kann verwendet werden, zusammen mit sprachspezifischen neue-Zeile-Unterstützung, z. B. die Escape-Zeichen '\r' und '\n' in Microsoft C#- und C/C++ oder `vbCrLf` in Microsoft Visual Basic.  
  
 <xref:System.Environment.NewLine%2A> wird automatisch angefügt Text verarbeitet, indem Sie die <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> und <xref:System.Text.StringBuilder.AppendLine%2A?displayProperty=nameWithType> Methoden.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt drei Zeilen, die durch Zeilenumbrüche getrennt.  
  
 [!code-cpp[environment.newline#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.NewLine/CPP/newline.cpp#1)]
 [!code-csharp[environment.newline#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.NewLine/CS/newline.cs#1)]
 [!code-vb[environment.newline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.NewLine/VB/newline.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OSVersion">
      <MemberSignature Language="C#" Value="public static OperatingSystem OSVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.OperatingSystem OSVersion" />
      <MemberSignature Language="DocId" Value="P:System.Environment.OSVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSVersion As OperatingSystem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property OperatingSystem ^ OSVersion { OperatingSystem ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OSVersion : OperatingSystem" Usage="System.Environment.OSVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.OperatingSystem</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.OperatingSystem" />-Objekt ab, das den Bezeichner und die Versionsnummer der aktuellen Plattform enthält.</summary>
        <value>Ein Objekt, das den Bezeichner und die Versionsnummer der Plattform enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

Die `Environment.OSVersion` Eigenschaft stellt keine zuverlässige Möglichkeit, um die genaue Betriebssystem und dessen Version zu identifizieren. Aus diesem Grund empfehlen wir nicht, dass Sie diese Methode verwenden. Stattdessen: 

- Verwenden Sie zum Identifizieren der Plattform des Betriebssystems die <xref:System.Runtime.InteropServices.RuntimeInformation.IsOSPlatform%2A?displayProperty=nameWithType> Methode. 

- Vermeiden Sie das Schreiben von Code, von denen eine gemeldeten Betriebssystemversion abhängt. Überprüfen Sie stattdessen für die Verfügbarkeit der Features, die Ihre Anwendung benötigt.

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Eigenschaft war nicht in der Lage, die Systemversion abzurufen.  
  
- oder - 
Der abgerufene Plattformbezeichner ist kein Mitglied von <see cref="T:System.PlatformID" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessorCount">
      <MemberSignature Language="C#" Value="public static int ProcessorCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ProcessorCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ProcessorCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProcessorCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ProcessorCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorCount : int" Usage="System.Environment.ProcessorCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl von Prozessoren im aktuellen Computer ab.</summary>
        <value>Die 32-Bit-Ganzzahl mit Vorzeichen, die die Anzahl von Prozessoren im aktuellen Computer angibt. Es ist kein Standardwert vorhanden. Wenn der aktuelle Computer mehrere Prozessorgruppen enthält, gibt diese Eigenschaft die Anzahl logischer Prozessoren zurück, die für die Common Language Runtime (CLR) verfügbar sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zu Prozessorgruppen und logischen Prozessoren finden Sie unter [Prozessorgruppen](https://msdn.microsoft.com/library/windows/desktop/dd405503.aspx).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.Environment.ProcessorCount%2A> Eigenschaft.  
  
 [!code-cpp[environment.processorcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.processorcount/CPP/pc.cpp#1)]
 [!code-csharp[environment.processorcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.processorcount/CS/pc.cs#1)]
 [!code-vb[environment.processorcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.processorcount/VB/pc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetEnvironmentVariable">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt, ändert oder löscht eine Umgebungsvariable.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetEnvironmentVariable (variable As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEnvironmentVariable(System::String ^ variable, System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member SetEnvironmentVariable : string * string -&gt; unit" Usage="System.Environment.SetEnvironmentVariable (variable, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="variable">Der Name einer Umgebungsvariablen.</param>
        <param name="value">Ein Wert, der <paramref name="variable" /> zugewiesen werden soll.</param>
        <summary>Erstellt, ändert oder löscht eine im aktuellen Prozess gespeicherte Umgebungsvariable.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen dieser Methode entspricht dem Aufrufen der <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> Überladung mit einem Wert von <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> für die `target` Argument.  
  
 Wenn die `value` Argument ist nicht leer (siehe die Erläuterung der Löschen einer Umgebungsvariablen, die weiter unten in diesem Abschnitt für die Definition von ein leerer Wert) und die Umgebungsvariable mit dem Namen, indem die `variable` Parameter nicht vorhanden ist, die Umgebung Variable wird erstellt und dem Inhalt von zugewiesen `value`. Wenn sie vorhanden ist, wird ihr Wert geändert werden. Da die Umgebungsvariable in der Umgebungsblock, der nur den aktuellen Prozess definiert ist, behält es nicht, nachdem der Prozess beendet wurde.  
  
 Wenn `variable` enthält ein nicht anfängliches Hexadezimalzeichen 0 (null) Zeichen, die Zeichen, bevor das Nullzeichen werden als Name der Umgebungsvariablen betrachtet und alle nachfolgende Zeichen werden ignoriert.  
  
 Wenn `value` enthält ein nicht anfängliches Hexadezimalzeichen 0 (null) Zeichen, die Zeichen, bevor das Nullzeichen werden der Umgebungsvariablen zugewiesen, und alle nachfolgende Zeichen werden ignoriert.  
  
 Wenn `value` leer ist und die Umgebungsvariable mit dem Namen von `variable` vorhanden ist, wird die Umgebungsvariable gelöscht. Wenn `variable` ist nicht vorhanden, kein Fehler auftritt, obwohl der Vorgang kann nicht ausgeführt werden. `value` wird unter einer der folgenden Bedingungen leer betrachtet:  
  
-   Es ist `null`.  
  
-   Es ist <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Es besteht aus einem einzelnen Zeichen, dessen Wert U + 0000 ist.  
  
   
  
## Examples  
 Das folgende Beispiel testet, ob eine Umgebungsvariable namens `APPDOMAIN` im aktuellen Prozess vorhanden ist. Wenn dies nicht der Fall ist, wird erstellt, und legt seinen Wert auf "True" fest. Wenn der Wert des der `APPDOMAIN` Umgebungsvariable ist "True", ruft es die `Message.Display` -Methode in einer neuen Anwendungsdomäne. Andernfalls führt es die `Message.Display` -Methode in der aktuellen Anwendungsdomäne.  
  
 [!code-csharp[System.Environment.SetEnvironmentVariable#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.setenvironmentvariable/cs/setenvironmentvariable1.cs#1)]
 [!code-vb[System.Environment.SetEnvironmentVariable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.setenvironmentvariable/vb/setenvironmentvariable1.vb#1)]  
  
 Wenn Sie das Beispiel zum ersten Mal ausführen, zeigt die Meldung "In der Domäne Domäne2 wird ausgeführt" in der Konsole an. Wenn Sie die Umgebungsvariable über die Befehlszeile mit dem Befehl festlegen:  
  
 `Set AppDomain=False`  
  
 Im Beispiel wird die Meldung "in der Domäne ausführen *Programmname*.exe", wobei *Programmname* ist der Name der ausführbaren Datei.  
  
 Im folgenden Beispiel wird versucht, den Wert einer Umgebungsvariablen mit dem Namen des abzurufenden `Test1` in dem Umgebungsblock Prozess. Wenn die Variable nicht vorhanden ist, wird im Beispiel wird die Variable erstellt, und ruft den Wert ab. Das Beispiel zeigt den Wert der Variablen. Wenn im Beispiel wird die Variable erstellt, ruft sie auch die <xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29> -Methode mit dem jedes Element der <xref:System.EnvironmentVariableTarget> Enumeration, die überprüft wird, ob die Variable nur aus der aktuellen Umgebung prozessblock abgerufen werden kann. Schließlich im Beispiel wird die Variable erstellt, löscht sie es.  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs#2)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="variable" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="variable" /> enthält eine leere Zeichenfolge („“), ein anfängliches Hexadezimalzeichen 0 (0x00) oder ein Gleichheitszeichen ("=").  
  
- oder - 
Die Länge von <paramref name="variable" /> oder <paramref name="value" /> ist größer gleich 32.767 Zeichen.  
  
- oder - 
Während der Ausführung dieses Vorgangs ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer hat nicht die erforderliche Berechtigung zum Ausführen dieses Vorgangs.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für vollständigen Zugriff auf Umgebungsvariablen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
      </Docs>
    </Member>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value, EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetEnvironmentVariable (variable As String, value As String, target As EnvironmentVariableTarget)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEnvironmentVariable(System::String ^ variable, System::String ^ value, EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member SetEnvironmentVariable : string * string * EnvironmentVariableTarget -&gt; unit" Usage="System.Environment.SetEnvironmentVariable (variable, value, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="variable">Der Name einer Umgebungsvariablen.</param>
        <param name="value">Ein Wert, der <paramref name="variable" /> zugewiesen werden soll.</param>
        <param name="target">Einer der Enumerationswerte, der den Standort der Umgebungsvariablen angibt.</param>
        <summary>Erstellt, ändert oder löscht eine Umgebungsvariable, die im aktuellen Prozess oder im Registrierungsschlüssel des für den aktuellen Benutzer oder den lokalen Computer reservierten Windows-Betriebssystems gespeichert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Die <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> Methode können Sie eine Umgebungsvariable zu definieren, die für den aktuellen Prozess verfügbar ist (die <xref:System.EnvironmentVariableTarget.Process> Wert). Umgebungsvariablen, die der aktuelle Block des Prozess-Umgebung eindeutig sind bestehen, nur verwendet werden, bis der Prozess beendet.

Darüber hinaus auf Windows-Systemen nur die <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> Methode können Sie eine Umgebungsvariable zu definieren, die für alle Prozesse verfügbar ist, die auf einem Computer ausgeführt (die <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> Wert) und für alle Prozesse, die von einem Benutzer ausgeführt wird (die <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> Wert). Pro Computer und benutzerspezifische Umgebungsvariablen werden in der Umgebungsblock, der den aktuellen Prozess kopiert.  
 
Aufrufe in .NET Core unter MacOS und Linux-Systeme, die <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> Methode mit einem Wert von <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> oder <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> werden ignoriert. 
  
 Wenn die `value` Argument ist nicht leer (siehe die Erläuterung der Löschen einer Umgebungsvariablen, die weiter unten in diesem Abschnitt für die Definition von ein leerer Wert) und die Umgebungsvariable mit dem Namen, indem die `variable` Argument ist nicht vorhanden, die Umgebung Variable wird erstellt und dem Inhalt von zugewiesen `value`.  Wenn sie vorhanden ist, wird ihr Wert geändert werden.  
  
 Wenn `variable` enthält ein nicht anfängliches Hexadezimalzeichen 0 (null) Zeichen, die Zeichen, bevor das Nullzeichen werden als Name der Umgebungsvariablen betrachtet und alle nachfolgende Zeichen werden ignoriert.  
  
 Wenn `value` enthält ein nicht anfängliches Hexadezimalzeichen 0 (null) Zeichen, die Zeichen, bevor das Nullzeichen werden der Umgebungsvariablen zugewiesen, und alle nachfolgende Zeichen werden ignoriert.  
  
 Wenn `value` leer ist und die Umgebungsvariable mit dem Namen von `variable` vorhanden ist, wird die Umgebungsvariable gelöscht. `value` wird unter einer der folgenden Bedingungen leer betrachtet:  
  
-   Es ist `null`.  
  
-   Es ist <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Es besteht aus einem einzelnen Zeichen, dessen Wert U + 0000 ist.  
  
 Wenn `variable` ist nicht vorhanden, kein Fehler auftritt, obwohl der Vorgang kann nicht ausgeführt werden. Seien Sie vorsichtig beim `target` ist <xref:System.EnvironmentVariableTarget.Machine>, da Sie versehentlich eine Umgebungsvariable löschen können, die den gesamten lokalen Computer, nicht nur den aktuellen Prozess oder Benutzer betreffen.  

### <a name="environmentvariabletargetmachine-and-environmentvariabletargetuser-on-windows-systems"></a>EnvironmentVariableTarget.Machine und EnvironmentVariableTarget.User auf Windows-Systemen

Wenn `target` ist <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>, die Umgebungsvariable im Schlüssel HKEY_CURRENT_USER\Environment für die Registrierung des lokalen Computers gespeichert ist. Es wird ebenfalls auf Instanzen von Datei-Explorer kopiert, die als aktueller Benutzer ausgeführt werden. Die Umgebungsvariable wird dann durch alle neue Prozesse geerbt, die der Benutzer im Datei-Explorer startet.  
  
 Auf ähnliche Weise, wenn `target` ist <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>, die Umgebungsvariable im HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Session Manager\Environment Schlüssel für die Registrierung des lokalen Computers gespeichert ist. Es wird auch für alle Instanzen des Datei-Explorers kopiert. Die Umgebungsvariable wird dann durch alle neue Prozesse geerbt, die im Datei-Explorer gestartet werden.  
  
 Wenn `target` ist <xref:System.EnvironmentVariableTarget.User> oder <xref:System.EnvironmentVariableTarget.Machine>, andere Anwendungen des Vorgangs zum Festlegen informiert Sie über eine Windows `WM_SETTINGCHANGE` Nachricht.  
  
 Wenn `target` ist <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> oder <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>, es wird empfohlen, die die Länge des `value` weniger als 2048 Zeichen sein.  
  
## Examples  
 Das folgende Beispiel erstellt die Umgebungsvariablen für die <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>, <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>, und <xref:System.EnvironmentVariableTarget.Machine> ausgerichtet ist, überprüft, ob die Registrierung des Betriebssystems, die Benutzer und Computer-Umgebungsvariablen enthält, und löscht dann die Umgebung Variablen.  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="variable" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="variable" /> enthält eine leere Zeichenfolge („“), ein anfängliches Hexadezimalzeichen 0 (0x00) oder ein Gleichheitszeichen ("=").  
  
- oder - 
Die Länge von <paramref name="variable" /> ist größer gleich 32.767 Zeichen.  
  
- oder - 
 <paramref name="target" /> ist kein Member der <see cref="T:System.EnvironmentVariableTarget" />-Enumeration.  
  
- oder - 
 <paramref name="target" /> ist gleich <see cref="F:System.EnvironmentVariableTarget.Machine" /> oder gleich <see cref="F:System.EnvironmentVariableTarget.User" />, und die Länge von <paramref name="variable" /> ist größer gleich 255.  
  
- oder - 
 <paramref name="target" /> ist gleich <see cref="F:System.EnvironmentVariableTarget.Process" />, und die Länge von <paramref name="value" /> ist größer gleich 32,767.  
  
- oder - 
Während der Ausführung dieses Vorgangs ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer hat nicht die erforderliche Berechtigung zum Ausführen dieses Vorgangs.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für vollständigen Zugriff auf Umgebungsvariablen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public static string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Environment.StackTrace" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StackTrace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StackTrace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StackTrace : string" Usage="System.Environment.StackTrace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die aktuellen Stapelüberwachungsinformationen ab.</summary>
        <value>Eine Zeichenfolge, die Stapelüberwachungsinformationen enthält. Dieser Wert kann <see cref="F:System.String.Empty" /> sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Environment.StackTrace%2A> Eigenschaftenlisten Methodenaufrufe in umgekehrter chronologischer Reihenfolge, d. h. der letzte Methodenaufruf wird zunächst beschrieben und Stapelüberwachungsinformationen eine Zeile für jeden Aufruf einer Methode auf dem Stapel aufgelistet ist. Allerdings die <xref:System.Environment.StackTrace%2A> Eigenschaft meldet möglicherweise nicht wie erwartet, die auftreten, während der Optimierung so viele Methodenaufrufe.  
  
> [!NOTE]
>  Verwenden Sie für eine hierarchische Ansicht der Informationen der stapelüberwachung von-Klasse, die <xref:System.Diagnostics.StackTrace> Klasse.  
  
 Die <xref:System.Environment.StackTrace%2A> -Eigenschaft formatiert die Stapelüberwachungsinformationen für jeden Aufruf einer Methode wie folgt:  
  
 "am `FullClassName`.`MethodName` (`MethodParams`) in `FileName` : Zeile `LineNumber` "  
  
 Das Literal "at" drei Leerzeichen vorangestellt ist, und die gesamte Teilzeichenfolge, beginnend mit "in" wird weggelassen, wenn keine Debugsymbole verfügbar sind. Die Platzhalter `FullClassName`, `MethodName`, `MethodParams`, `FileName`, und `LineNumber`durch tatsächliche Werte ersetzt werden und sind wie folgt definiert:  
  
 FullClassName  
 Der vollständige Name der Klasse, einschließlich des Namespaces.  
  
 `MethodName`  
 Der Name der Methode.  
  
 `MethodParams`  
 Die Liste der Typnamen /-Parameterpaaren. Jedes Paar wird getrennt durch ein Komma (","). Diese Informationen werden ausgelassen, wenn `MethodName` nimmt keine Parameter.  
  
 `FileName`  
 Der Name der Quelle der Datei, in der `MethodName` Methode deklariert ist. Diese Informationen werden ausgelassen, wenn keine Debugsymbole verfügbar sind.  
  
 `LineNumber`  
 Die Nummer der Zeile im `FileName` , enthält den Quellcode aus `MethodName` für die Anweisung, die in der Aufrufliste befindet. Diese Informationen werden ausgelassen, wenn keine Debugsymbole verfügbar sind.  
  
 Die <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> Zeichenfolge beendet, wird jede Zeile der stapelüberwachung.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.Environment.StackTrace%2A> Eigenschaft.  
  
 [!code-cpp[environment.stacktrace#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.StackTrace/CPP/stacktrace.cpp#1)]
 [!code-csharp[environment.stacktrace#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.StackTrace/CS/stacktrace.cs#1)]
 [!code-vb[environment.stacktrace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.StackTrace/VB/stacktrace.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für den Vollzugriff auf die durch die Berechtigung geschützte Ressource. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SystemDirectory">
      <MemberSignature Language="C#" Value="public static string SystemDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string SystemDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SystemDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SystemDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SystemDirectory : string" Usage="System.Environment.SystemDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den voll gekennzeichneten Pfad des Systemverzeichnisses ab.</summary>
        <value>Eine Zeichenfolge mit einem Verzeichnispfad.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Beispiel der zurückgegebene Wert ist die Zeichenfolge "C:\WinNT\System32".  
  
   
  
## Examples  
 Das folgende Beispiel zeigt das Systemverzeichnis des Computers, der im Codebeispiel ausgeführt wird. (Das Systemverzeichnis wird in der Beispielausgabe aus Sicherheitsgründen weggelassen.)  
  
 [!code-cpp[environment.systemdirectory#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.SystemDirectory/CPP/systemdirectory.cpp#1)]
 [!code-csharp[environment.systemdirectory#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.SystemDirectory/CS/systemdirectory.cs#1)]
 [!code-vb[environment.systemdirectory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.SystemDirectory/VB/systemdirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Informationen im Pfad selbst. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SystemPageSize">
      <MemberSignature Language="C#" Value="public static int SystemPageSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 SystemPageSize" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemPageSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SystemPageSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int SystemPageSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SystemPageSize : int" Usage="System.Environment.SystemPageSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Bytes in der Speicherseite des Betriebssystems ab.</summary>
        <value>Die Anzahl der Bytes in einer Arbeitsspeicherauslagerung des Betriebssystems.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Informationen kann nützlich sein, wenn bestimmt wird, ob Sie verwenden die <xref:System.IO.MemoryMappedFiles.MemoryMappedFileOptions.DelayAllocatePages?displayProperty=nameWithType> option bei der Arbeit mit Speicherabbilddateien.  
  
 In Windows, dieser Wert ist die `dwPageSize` Element in der `SYSTEM_INFO` Struktur.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für den Zugriff auf System- und Umgebungsvariablen. Zugeordnete Ausnahme: 
 <see cref="P:System.Security.SecurityException.PermissionState" /></permission>
      </Docs>
    </Member>
    <Member MemberName="TickCount">
      <MemberSignature Language="C#" Value="public static int TickCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 TickCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.TickCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TickCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int TickCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.TickCount : int" Usage="System.Environment.TickCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Millisekunden ab, die seit dem Systemstart verstrichen sind.</summary>
        <value>Eine 32-Bit-Ganzzahl mit Vorzeichen, die die seit dem letzten Start des Computers vergangene Zeit in Millisekunden enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Eigenschaft stammt aus dem Systemzeitgeber und wird als eine 32-Bit-Ganzzahl mit Vorzeichen gespeichert. Beachten Sie, dass, weil sie aus den systemtimer, die Auflösung abgeleitet der <xref:System.Environment.TickCount%2A> Eigenschaft ist nur mit der Auflösung des Systemzeitgebers, in der Regel im Bereich von 10 bis 16 Millisekunden.  
  
> [!IMPORTANT]
>  Da der Wert des der <xref:System.Environment.TickCount%2A> Eigenschaftswert ist eine 32-Bit-Ganzzahl mit Vorzeichen, wenn das System kontinuierlich ausgeführt wird <xref:System.Environment.TickCount%2A> erhöht, von 0 bis <xref:System.Int32.MaxValue?displayProperty=nameWithType> bei ungefähr 24,9 Tage, klicken Sie dann zu springen, <xref:System.Int32.MinValue?displayProperty=nameWithType>, dies ist eine negative Zahl ist, Klicken Sie dann wieder auf 0 (null), während der nächsten 24,9 Tage erhöht. Sie können dieses Problem umgehen, durch den Aufruf der Windows [GetTickCount](https://msdn.microsoft.com/library/windows/desktop/ms724408.aspx) -Funktion, die 0 (null), nach ungefähr 49,7 Tage oder durch Aufrufen von setzt die [GetTickCount64](https://msdn.microsoft.com/library/windows/desktop/ms724411.aspx) Funktion.  
  
 <xref:System.Environment.TickCount%2A> unterscheidet sich von der <xref:System.DateTime.Ticks%2A?displayProperty=nameWithType> Eigenschaft, die die Anzahl der 100-Nanosekunden-Intervalle, die seit 1/1/0001, 00:00 Uhr verstrichen sind.  
  
 Verwenden der <xref:System.DateTime.Now%2A?displayProperty=nameWithType> Eigenschaft, um die aktuelle lokale Datum und Uhrzeit auf diesem Computer zu erhalten.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie zum Abrufen des positiven Bereichs der Rückgabewerte die <xref:System.Environment.TickCount%2A> Eigenschaft. Die <xref:System.Environment.TickCount%2A> Eigenschaft wechselt zwischen <xref:System.Int32.MinValue?displayProperty=nameWithType>, dies ist eine negative Zahl ist, und <xref:System.Int32.MaxValue?displayProperty=nameWithType> alle 49,8 Tage. In diesem Codebeispiel wird das Vorzeichenbit um eine nicht negative Zahl, die zwischen 0 (null) Zyklen entfernt und <xref:System.Int32.MaxValue> alle 24,9 Tage.  
  
 [!code-cpp[environment.tickcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.TickCount/CPP/tickcount.cpp#1)]
 [!code-csharp[environment.tickcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.TickCount/CS/tickcount.cs#1)]
 [!code-vb[environment.tickcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.TickCount/VB/tickcount.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserDomainName">
      <MemberSignature Language="C#" Value="public static string UserDomainName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserDomainName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserDomainName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserDomainName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserDomainName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserDomainName : string" Usage="System.Environment.UserDomainName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Netzwerkdomänennamen ab, der dem aktuellen Benutzer zugeordnet ist.</summary>
        <value>Der Netzwerkdomänenname, der dem aktuellen Benutzer zugeordnet ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anmeldeinformationen des Domänenkontos für einen Benutzer werden als Domänenname des Benutzers, formatiert der "\\'-Zeichen, und den Benutzernamen ein. Verwenden der <xref:System.Environment.UserDomainName%2A> -Eigenschaft zum Abrufen der Domänenname des Benutzers, ohne den Benutzernamen ein, und die <xref:System.Environment.UserName%2A> Eigenschaft, um den Benutzernamen ohne den Domänennamen zu erhalten.  Wenn der Domänenname und Benutzername eines Benutzers CORPORATENETWORK\john, sind z. B. die <xref:System.Environment.UserDomainName%2A> -Eigenschaft gibt "CORPORATENETWORK" zurück.  
  
 Die <xref:System.Environment.UserDomainName%2A> Eigenschaft zuerst versucht wird, um die Domänennamenkomponente von der Windows-Kontoname für den aktuellen Benutzer zu erhalten. Wenn dieser Versuch fehlschlägt, versucht diese Eigenschaft um den Domänennamen, die mit dem Benutzernamen, die von bereitgestellte erhalten die <xref:System.Environment.UserName%2A> Eigenschaft. Wenn dieser Versuch schlägt fehl, da der Hostcomputer nicht zu einer Domäne angehört, wird der Name des Hostcomputers zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Das Betriebssystem unterstützt nicht das Abrufen des Netzwerkdomänennamens.</exception>
        <exception cref="T:System.InvalidOperationException">Der Netzwerkdomänenname kann nicht abgerufen werden.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für den Lesezugriff auf die Umgebungsvariable BENUTZERDOMÄNE. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.UserName" />
      </Docs>
    </Member>
    <Member MemberName="UserInteractive">
      <MemberSignature Language="C#" Value="public static bool UserInteractive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UserInteractive" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserInteractive" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserInteractive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UserInteractive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UserInteractive : bool" Usage="System.Environment.UserInteractive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Prozess im interaktiven Modus ausgeführt wird.</summary>
        <value><see langword="true" />, wenn der aktuelle Prozess im interaktiven Modus ausgeführt wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Environment.UserInteractive%2A> Eigenschaftsberichte `false` für einen Windows-Prozess oder einen Dienst wie IIS, die ohne Benutzeroberfläche ausgeführt wird. Wenn diese Eigenschaft `false`, modale Dialogfelder werden nicht angezeigt oder Meldungsfelder, da keine grafische Benutzeroberfläche für den Benutzer für die Interaktion mit vorhanden ist.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, ob der aktuelle Prozess im interaktiven Modus ausgeführt wird.  
  
 [!code-cpp[Environment.UserInteractive#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserInteractive/CPP/userinteractive.cpp#1)]
 [!code-csharp[Environment.UserInteractive#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserInteractive/CS/userinteractive.cs#1)]
 [!code-vb[Environment.UserInteractive#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserInteractive/VB/userinteractive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UserName">
      <MemberSignature Language="C#" Value="public static string UserName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserName : string" Usage="System.Environment.UserName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Benutzernamen der Person ab, die derzeit beim Betriebssystem angemeldet ist.</summary>
        <value>Der Benutzername der Person, die für das Betriebssystem angemeldet ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die <xref:System.Environment.UserName%2A> Eigenschaft zur Identifizierung des Benutzers für den aktuellen Thread, für das System und Anwendung für Sicherheits- oder Access. Sie können auch verwendet werden, um eine bestimmte Anwendung für jeden Benutzer anzupassen.  
 
 Unter Windows die <xref:System.Environment.UserName%2A> Eigenschaft umschließt einen Aufruf der Windows [GetUserName](https://msdn.microsoft.com/library/windows/desktop/ms724432.aspx) Funktion. Anmeldeinformationen des Domänenkontos für einen Benutzer werden als Domänenname des Benutzers, formatiert der "\\'-Zeichen, und den Benutzernamen ein. Verwenden der <xref:System.Environment.UserDomainName%2A> Eigenschaft, um den Namen des Benutzers Domäne zu erhalten und die <xref:System.Environment.UserName%2A> Eigenschaft, um den Benutzernamen zu erhalten.  
 
 Auf Unix-Plattformen die <xref:System.Environment.UserName%2A> Eigenschaft umschließt einen Aufruf der `getpwuid_r` Funktion.
 
 Wenn eine ASP.NET-Anwendung in einer Entwicklungsumgebung ausgeführt wird. die <xref:System.Environment.UserName%2A> Eigenschaft gibt den Namen des aktuellen Benutzers zurück. In einer veröffentlichten ASP.NET-Anwendung gibt diese Eigenschaft den Namen des dem Anwendungspoolkonto (z. B. AppPool Standard).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Benutzernamen der Person, die den aktuellen Thread gestartet hat.  
  
 [!code-cpp[Environment.UserName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserName/CPP/username.cpp#1)]
 [!code-csharp[Environment.UserName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserName/CS/username.cs#1)]
 [!code-vb[Environment.UserName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserName/VB/username.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für den Lesezugriff auf die USERNAME-Umgebungsvariable. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.UserDomainName" />
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public static Version Version { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Version Version" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Version" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Version As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Version ^ Version { Version ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Version : Version" Usage="System.Environment.Version" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Version" />-Objekt ab, das die Nummern für Haupt- und Nebenversion, Build und Revision der Common Language Runtime beschreibt.</summary>
        <value>Ein Objekt, das die Version der Common Language Runtime anzeigt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei den .NET Framework-Versionen 4, 4.5, 4.5.1 und 4.5.2 gibt die <xref:System.Environment.Version%2A?displayProperty=nameWithType>Eigenschaft ein <xref:System.Version>-Objekt zurück, dessen Zeichenfolgedarstellung die Form `4.0.30319.xxxxx`besitzt. Für die .NET Framework 4.6 und höher, er hat das Format `4.0.30319.42000`.  
  
> [!WARNING]
>  Für die [!INCLUDE[net_v45](~/includes/net-v45-md.md)] und höher, wir empfehlen nicht mit der <xref:System.Environment.Version%2A> Eigenschaft zum Ermitteln der Version der Laufzeit; stattdessen können Sie die Versionsnummer der common Language Runtime ermitteln, durch Abfragen der Registrierung. Weitere Informationen finden Sie unter [Vorgehensweise: Determine Which .NET Framework Versions Are Installed](~/docs/framework/migration-guide/how-to-determine-which-versions-are-installed.md) (Bestimmen der installierten .NET Framework-Versionen).  
  
 Weitere Informationen zu der Version der common Language Runtime, die mit jeder Version von .NET Framework installiert ist, finden Sie unter [-Versionen und-Abhängigkeiten](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Version der common Language Runtime. (Die Version wird in der Beispielausgabe aus Sicherheitsgründen weggelassen.)  
  
 [!code-cpp[Environment.Version#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.Version/CPP/version.cpp#1)]
 [!code-csharp[Environment.Version#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.Version/CS/version.cs#1)]
 [!code-vb[Environment.Version#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.Version/VB/version.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public static long WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Environment.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property WorkingSet As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long WorkingSet { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int64" Usage="System.Environment.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe des physischen Speichers ab, der dem Prozesskontext zugeordnet ist.</summary>
        <value>Eine 64-Bit-Ganzzahl mit Vorzeichen, die die Größe des dem Prozesskontext zugeordneten physischen Speichers in Bytes angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt die Größe des Arbeitssatzes des Computers, der im Codebeispiel ausgeführt wird.  
  
 [!code-cpp[Environment.WorkingSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.WorkingSet/CPP/workingset.cpp#1)]
 [!code-csharp[Environment.WorkingSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.WorkingSet/CS/workingset.cs#1)]
 [!code-vb[Environment.WorkingSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.WorkingSet/VB/workingset.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für vollständigen Zugriff auf die durch diese Berechtigung geschützte Ressource. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>