<Type Name="Environment" FullName="System.Environment">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3889c1ec46d77b527d424d8d5a1b855a7404857e" /><Meta Name="ms.sourcegitcommit" Value="56c9ea57513a1911348fcf3404d44be4c29880cf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="09/20/2019" /><Meta Name="ms.locfileid" Value="71151902" /></Metadata><TypeSignature Language="C#" Value="public static class Environment" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Environment extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Environment" />
  <TypeSignature Language="VB.NET" Value="Public Class Environment" />
  <TypeSignature Language="C++ CLI" Value="public ref class Environment abstract sealed" />
  <TypeSignature Language="F#" Value="type Environment = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt Informationen und Veränderungsmöglichkeiten für die aktuelle Umgebung und Plattform zur Verfügung. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie <xref:System.Environment> die-Klasse, um Informationen wie z. b. Befehlszeilenargumente, den Exitcode, Umgebungsvariablen Einstellungen, den Inhalt der Aufruf Stapel, den Zeitpunkt seit dem letzten Systemstart und die Version der Common Language Runtime abzurufen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Liste mit Informationen über die aktuelle Umgebung angezeigt.  
  
 [!code-cpp[environment.class#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.class/CPP/env0.cpp#1)]
 [!code-csharp[environment.class#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.class/CS/env0.cs#1)]
 [!code-vb[environment.class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.class/VB/env0.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CommandLine">
      <MemberSignature Language="C#" Value="public static string CommandLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommandLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CommandLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommandLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommandLine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommandLine : string" Usage="System.Environment.CommandLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Befehlszeile für diesen Prozess ab.</summary>
        <value>Eine Zeichenfolge mit den Befehlszeilenargumenten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ermöglicht den Zugriff auf den Programmnamen und alle Argumente, die beim Starten des aktuellen Prozesses in der Befehlszeile angegeben wurden.  
  
 Der Programmname kann Pfadinformationen enthalten, dies ist jedoch nicht erforderlich. Verwenden Sie <xref:System.Environment.GetCommandLineArgs%2A> die-Methode, um die in einem Zeichen folgen Array analysierten und gespeicherten Befehlszeilen Informationen abzurufen.  
  
 Die maximale Größe des Befehlszeilen Puffers ist nicht auf eine bestimmte Anzahl von Zeichen festgelegt. Dies variiert abhängig vom Windows-Betriebssystem, das auf dem Computer ausgeführt wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die eigene Befehlszeile angezeigt.  
  
 [!code-cpp[environment.commandline#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.CommandLine/CPP/commandline.cpp#1)]
 [!code-csharp[environment.commandline#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.CommandLine/CS/commandline.cs#1)]
 [!code-vb[environment.commandline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.CommandLine/VB/commandline.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für den Lesezugriff auf die PATH-Umgebungsvariable. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetCommandLineArgs" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDirectory">
      <MemberSignature Language="C#" Value="public static string CurrentDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string CurrentDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CurrentDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDirectory : string with get, set" Usage="System.Environment.CurrentDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den vollqualifizierten Pfad des aktuellen Arbeitsverzeichnisses ab oder legt diesen fest.</summary>
        <value>Eine Zeichenfolge mit einem Verzeichnispfad.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn dieser Prozess im Stammverzeichnis eines lokalen oder Netz Laufwerks gestartet wird, ist der Wert dieser Eigenschaft definitionsgemäß der Laufwerk Name, gefolgt von einem nachgestellten Schrägstrich (z. b. "\\C:"). Wenn dieser Prozess in einem Unterverzeichnis gestartet wird, ist der Wert dieser Eigenschaft der Pfad des Laufwerks und des Unterverzeichnisses ohne nachfolgenden Schrägstrich (z. b. "c:\meinsubverzeichnis").  
  
   
  
## Examples  
 Im folgenden Beispiel wird das Festlegen <xref:System.Environment.CurrentDirectory%2A> der-Eigenschaft veranschaulicht.  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Es wurde versucht, auf eine leere Zeichenfolge ("") festzulegen.</exception>
        <exception cref="T:System.ArgumentNullException">Es wurde versucht, auf <see langword="null." /> fetszulegen.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Es wurde versucht, auf einen lokalen Pfad festzulegen, der nicht gefunden werden kann.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer hat nicht die entsprechende Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Schreiben in Dateien oder Verzeichnisse in einem Set-Vorgang. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Informationen im Pfad selbst in einem Get-Vorgang. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentManagedThreadId">
      <MemberSignature Language="C#" Value="public static int CurrentManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CurrentManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CurrentManagedThreadId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentManagedThreadId : int" Usage="System.Environment.CurrentManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen eindeutigen Bezeichner für den aktuellen verwalteten Thread ab.</summary>
        <value>Eine Ganzzahl, die einen eindeutigen Bezeichner für diesen verwalteten Thread darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.Exit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (exitCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(int exitCode);" />
      <MemberSignature Language="F#" Value="static member Exit : int -&gt; unit" Usage="System.Environment.Exit exitCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Diagnostics.CodeAnalysis.DoesNotReturn</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="exitCode">Der an das Betriebssystem zurückzugebende Exitcode. Verwenden Sie 0 (null), um anzugeben, dass der Prozess erfolgreich abgeschlossen wurde.</param>
        <summary>Beendet den Prozess und gibt einen Exitcode an das Betriebssystem zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie `exitCode` für den-Parameter eine Zahl ungleich 0 (null), um einen Fehler anzugeben. In Ihrer Anwendung können Sie eigene Fehlercodes in einer Enumeration definieren und den entsprechenden Fehlercode auf der Grundlage des Szenarios zurückgeben. Geben Sie z. b. den Wert 1 zurück, um anzugeben, dass die erforderliche Datei nicht vorhanden ist, und den Wert 2, um anzugeben, dass die Datei das falsche Format hat. Eine Liste der Exitcodes, die vom Windows-Betriebssystem verwendet werden, finden Sie unter [Systemfehler Codes](https://msdn.microsoft.com/library/ms681381.aspx) in der Windows-Dokumentation.  
  
 Das Aufrufen <xref:System.Environment.Exit%2A> der-Methode unterscheidet sich von der `return` Verwendung der-Anweisung ihrer Programmiersprache auf folgende Weise:  
  
-   <xref:System.Environment.Exit%2A>beendet eine Anwendung immer. Die Verwendung `return` der-Anweisung kann eine Anwendung nur dann beenden, wenn Sie im Einstiegspunkt der Anwendung verwendet wird, `Main` z. b. in der-Methode.  
  
-   <xref:System.Environment.Exit%2A>beendet eine Anwendung sofort, auch wenn andere Threads ausgeführt werden. Wenn die `return` -Anweisung im Einstiegspunkt der Anwendung aufgerufen wird, wird eine Anwendung erst beendet, nachdem alle Vordergrundthreads beendet wurden.  
  
-   <xref:System.Environment.Exit%2A>erfordert, dass der Aufrufer über Berechtigungen zum Aufruf von nicht verwaltetem Code verfügt. Die `return` -Anweisung ist nicht.  
  
-   Wenn <xref:System.Environment.Exit%2A> von einem `try` -oder `catch` -Block aufgerufen wird, wird der `finally` Code in einem beliebigen-Block nicht ausgeführt. Wenn die `return` -Anweisung verwendet wird, wird der Code `finally` im-Block ausgeführt.  
  
-   Wenn <xref:System.Environment.Exit%2A> aufgerufen wird, wenn Code in einem [eingeschränkten Ausführungs Bereich](~/docs/framework/performance/constrained-execution-regions.md) (CER) ausgeführt wird, wird die Ausführung durch den CER nicht vollständig beendet. Wenn die `return` -Anweisung verwendet wird, schließt der CER die Ausführung ab.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über ausreichende Sicherheitsberechtigungen zum Ausführen dieser Funktion.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">, wenn nicht verwalteter Code aufgerufen werden soll. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public static int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ExitCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int with get, set" Usage="System.Environment.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Exitcode des Prozesses ab oder legt diesen fest.</summary>
        <value>Eine 32-Bit-Ganzzahl mit Vorzeichen, die den Exitcode enthält. Der Standardwert ist 0 (null), was angibt, dass der Prozess erfolgreich abgeschlossen wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die `Main` Methode zurück `void`gibt, können Sie diese Eigenschaft verwenden, um den Exitcode festzulegen, der an die aufrufende Umgebung zurückgegeben wird. Wenn `Main` nicht zurück `void`gibt, wird diese Eigenschaft ignoriert. Der Anfangswert dieser Eigenschaft ist 0 (null).  
  
> [!WARNING]
>  Die <xref:System.Environment.ExitCode%2A> Eigenschaft ist eine ganze Zahl mit Vorzeichen und einer Länge von 32 Bit. Um zu verhindern, dass die-Eigenschaft einen negativen Exitcode zurückgibt, sollten Sie keine Werte größer oder gleich 0x80000000 verwenden.  
  
 Verwenden Sie eine Zahl ungleich 0 (null), um einen Fehler anzugeben. In Ihrer Anwendung können Sie eigene Fehlercodes in einer Enumeration definieren und den entsprechenden Fehlercode auf der Grundlage des Szenarios zurückgeben. Geben Sie z. b. den Wert 1 zurück, um anzugeben, dass die erforderliche Datei nicht vorhanden ist, und den Wert 2, um anzugeben, dass die Datei das falsche Format hat. Eine Liste der Exitcodes, die vom Windows-Betriebssystem verwendet werden, finden Sie unter [Systemfehler Codes](https://msdn.microsoft.com/library/ms681381\(v=vs.85\)) in der Windows-Dokumentation.  
  
   
  
## Examples  
 Im folgenden finden Sie eine einfache App namens Double. exe, die einen ganzzahligen Wert verdoppelt, der als Befehlszeilenargument an ihn übermittelt wird. Der-Wert weist der <xref:System.Environment.ExitCode%2A> -Eigenschaft Fehlercodes zu, um Fehlerbedingungen anzugeben. Beachten Sie, dass Sie einen Verweis auf die Assembly "System. Numerics. dll" hinzufügen müssen, damit das Beispiel erfolgreich kompiliert werden konnte.  
  
 [!code-csharp[System.Environment.ExitCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double.cs#1)]
 [!code-vb[System.Environment.ExitCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double.vb#1)]  
  
 Das Beispiel kann dann aus einer Batchdatei wie der folgenden aufgerufen werden, die die Fehlercodes mithilfe des `ERRORLEVEL` -Befehls zugänglich macht.  
  
```  
  
echo off  
Double.exe %1  
If errorlevel 1639 goto NoArg   
if errorlevel 534 goto Overflow  
if errorlevel 160 goto BadArg  
if errorlevel 0 echo Completed Successfully   
goto :EOF  
  
:NoArg  
echo Missing argument  
goto :EOF  
  
: Overflow  
echo Arithmetic overflow  
goto :EOF  
  
:BadArg  
echo Invalid argument  
goto :EOF  
  
```  
  
 Das folgende Beispiel zeigt eine Beispielausgabe, die durch den Aufruf der Batchdatei erzeugt wird.  
  
```Output  
  
>getdouble 123>echo offResult: 246Completed Successfully>getdouble 5912323109093>echo offArithmetic overflow>getdouble>echo offMissing argument>getdouble "a string">echo offInvalid argument  
  
```  
  
 Beachten Sie, dass der Code für "Double. exe" in der Funktion mit dem folgenden Beispiel identisch ist, mit dem unter `Main` schied, dass der frühere einen Einstiegspunkt mit dem Namen definiert, der `Main` keinen Rückgabewert aufweist. in diesem Beispiel wird ein Einstiegspunkt mit dem Namen definiert, der  
  
 [!code-csharp[System.Environment.ExitCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double1.cs#2)]
 [!code-vb[System.Environment.ExitCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpandEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static string ExpandEnvironmentVariables (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ExpandEnvironmentVariables(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.ExpandEnvironmentVariables(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExpandEnvironmentVariables (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ExpandEnvironmentVariables(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member ExpandEnvironmentVariables : string -&gt; string" Usage="System.Environment.ExpandEnvironmentVariables name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Eine Zeichenfolge, die die Namen von 0 (null) oder mehr Umgebungsvariablen enthält. Jede Umgebungsvariable wird mit dem Prozentzeichen (%) angegeben.</param>
        <summary>Ersetzt den Namen aller Umgebungsvariablen, die in die angegebene Zeichenfolge eingebettet sind, durch die Zeichenfolgenentsprechung für den Wert der Variablen und gibt anschließend das Ergebnis als Zeichenfolge zurück.</summary>
        <returns>Eine Zeichenfolge, bei der alle Umgebungsvariablen durch ihren Wert ersetzt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit COM-Interop werden die Umgebungsvariablen aus dem Betriebssystem abgerufen. Wenn die Umgebungsvariablen aufgrund eines COM-Fehlers nicht abgerufen werden können, wird das HRESULT, das die Ursache des Fehlers erläutert, dazu verwendet, eine von mehreren möglichen Ausnahmen zu generieren. Das heißt, die Ausnahme hängt von HRESULT ab. Weitere Informationen zur Verarbeitung von HRESULT finden Sie im Abschnitt "Hinweise" der <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A?displayProperty=nameWithType> -Methode.  
  
 Der Austausch tritt nur bei Umgebungsvariablen auf, die festgelegt werden. Nehmen wir `name` beispielsweise an, dass "MYD =% myendv%" lautet. Wenn die Umgebungsvariable myEnv auf 42 festgelegt ist, gibt diese Methode "MyENV = 42" zurück. Wenn MyENV nicht festgelegt ist, erfolgt keine Änderung. Diese Methode gibt "MyENV =% MyENV%" zurück.  
  
 Die Größe des Rückgabewerts ist auf 32 KB beschränkt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie das Systemlaufwerk und die System Stamm Variablen abgerufen werden.  
  
 [!code-cpp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CPP/expandenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CS/expandenvironmentvariables.cs#1)]
 [!code-vb[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/VB/expandenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">die Möglichkeit, auf die Umgebungsvariablen in <paramref name="name" />zuzugreifen. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="FailFast">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Beendet einen Prozess sofort, nachdem eine Meldung in das Windows-Anwendungsereignisprotokoll geschrieben wurde, und schließt dann die Meldung und optionale Ausnahmeinformationen in Fehlerberichte an Microsoft ein.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FailFast (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FailFast(System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member FailFast : string -&gt; unit" Usage="System.Environment.FailFast message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Diagnostics.CodeAnalysis.DoesNotReturn</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="message">Eine Meldung, die erklärt, warum der Prozess beendet wurde, oder <see langword="null" />, wenn keine Erklärung gegeben wird.</param>
        <summary>Beendet einen Prozess sofort, nachdem eine Meldung in das Windows-Anwendungsereignisprotokoll geschrieben wurde, und schließt dann die Meldung in Fehlerberichte an Microsoft ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Methode wird ein Prozess beendet, ohne `try` dass aktive / `finally` Blöcke oder Finalizer ausgeführt werden.
  
 Die `Environment.FailFast` -Methode schreibt `message` die Zeichenfolge in das Windows-Anwendungs Ereignisprotokoll, erstellt einen Dump der Anwendung und beendet dann den aktuellen Prozess. Die `message` Zeichenfolge ist auch bei der Fehlerberichterstattung an Microsoft enthalten.  
  
 Verwenden Sie `Environment.FailFast` die- `try` <xref:System.Environment.Exit%2A> Methodeanstelle`finally` der-Methode, um die Anwendung zu beenden, wenn der Status der Anwendung über die Reparatur hinaus beschädigt ist, und führen Sie die Blöcke und Finalizer der Anwendung aus. / Programmressourcen werden beschädigt.  
  
 Informationen werden an Microsoft über Windows-Fehlerberichterstattung gemeldet. Weitere Informationen finden [Sie unter Windows-Fehlerberichterstattung: ](https://msdn.microsoft.com/library/windows/hardware/dn641144.aspx)Einstieg.  

Wenn Sie `Environment.FailFast` die-Methode aufrufen, um die Ausführung einer Anwendung zu beenden, die im Visual <xref:System.ExecutionEngineException> Studio-Debugger ausgeführt wird, wird eine ausgelöst, und der [fatalExecutionEngineError-MDA (Assistent für verwaltetes Debugging)](https://github.com/dotnet/docs/blob/master/docs/framework/debug-trace-profile/fatalexecutionengineerror-mda.md)
  
## Examples  
 Im folgenden Beispiel wird ein Protokolleintrag in das Windows-Anwendungs Ereignisprotokoll geschrieben, und der aktuelle Prozess wird beendet.  
  
 [!code-csharp[environment.FailFast#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.FailFast/cs/ff.cs#1)]
 [!code-vb[environment.FailFast#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.FailFast/vb/ff.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message, Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message, class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String,System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FailFast(System::String ^ message, Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FailFast : string * Exception -&gt; unit" Usage="System.Environment.FailFast (message, exception)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Diagnostics.CodeAnalysis.DoesNotReturn</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="exception" Type="System.Exception" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="message">Eine Meldung, die erklärt, warum der Prozess beendet wurde, oder <see langword="null" />, wenn keine Erklärung gegeben wird.</param>
        <param name="exception">Eine Ausnahme, die den Fehler darstellt, der die Beendigung verursacht hat. Dies ist in der Regel die Ausnahme in einem <see langword="catch" />-Block.</param>
        <summary>Beendet einen Prozess sofort, nachdem eine Meldung in das Windows-Anwendungsereignisprotokoll geschrieben wurde, und schließt dann die Meldung und Ausnahmeinformationen in Fehlerberichte an Microsoft ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode beendet den Prozess, ohne dass aktive `try` / `finally` Blöcke oder Finalizer ausgeführt werden.  
  
 Die `Environment.FailFast` -Methode schreibt `message` die Zeichenfolge in das Windows-Anwendungs Ereignisprotokoll, erstellt einen Dump der Anwendung und beendet dann den aktuellen Prozess.  
  
 Informationen werden an Microsoft über Windows-Fehlerberichterstattung gemeldet. Weitere Informationen finden [Sie unter Windows-Fehlerberichterstattung: ](https://msdn.microsoft.com/library/windows/hardware/dn641144.aspx)Einstieg. Bei der Fehlerberichterstattung an `message` Microsoft `exception` sind die Informationen und enthalten, die Details zum Klassifizieren des Fehlers enthalten. Obwohl `exception` nicht behandelt wird, da der Prozess beendet wird, werden die Kontextinformationen, die die Ausnahme ausgelöst haben, weiterhin abgerufen.  
  
 Wenn `exception` ist `null`oder <xref:System.Environment.FailFast%28System.String%29> Wenn `exception` nicht ausgelöst wird, funktioniert diese Methode genauso wie die-Methoden Überladung.  
  
 Verwenden Sie `Environment.FailFast` die- `try` <xref:System.Environment.Exit%2A> Methodeanstelle`finally` der-Methode, um die Anwendung zu beenden, wenn der Status der Anwendung über die Reparatur hinaus beschädigt ist, und führen Sie die Blöcke und Finalizer der Anwendung aus. / Programmressourcen werden beschädigt.  

Wenn Sie `Environment.FailFast` die-Methode aufrufen, um die Ausführung einer Anwendung zu beenden, die im Visual <xref:System.ExecutionEngineException> Studio-Debugger ausgeführt wird, wird eine ausgelöst, und der [fatalExecutionEngineError-MDA (Assistent für verwaltetes Debugging)](https://github.com/dotnet/docs/blob/master/docs/framework/debug-trace-profile/fatalexecutionengineerror-mda.md)
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCommandLineArgs">
      <MemberSignature Language="C#" Value="public static string[] GetCommandLineArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetCommandLineArgs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetCommandLineArgs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCommandLineArgs () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetCommandLineArgs();" />
      <MemberSignature Language="F#" Value="static member GetCommandLineArgs : unit -&gt; string[]" Usage="System.Environment.GetCommandLineArgs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein Zeichenfolgenarray mit den Befehlszeilenargumenten für den aktuellen Prozess zurück.</summary>
        <returns>Ein Array von Zeichenfolgen, in dem jedes Element ein Befehlszeilenargument enthält. Das erste Element ist der Name der ausführbaren Datei. Falls nachfolgende Elemente vorhanden sind, enthalten sie die restlichen Befehlszeilenargumente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das erste Element im Array enthält den Dateinamen des ausführenden Programms. Wenn der Dateiname nicht verfügbar ist, ist das erste Element gleich <xref:System.String.Empty?displayProperty=nameWithType>. Die restlichen Elemente enthalten alle zusätzlichen Token, die in der Befehlszeile eingegeben werden.  
  
 Der Programm Dateiname kann Pfadinformationen enthalten, ist jedoch nicht erforderlich.  
  
 Befehlszeilenargumente sind durch Leerzeichen begrenzt. Sie können in doppelten Anführungszeichen (") Leerzeichen innerhalb eines Arguments einschließen. Das einfache Anführungszeichen (') bietet jedoch diese Funktionalität nicht.  
  
 Wenn ein doppeltes Anführungszeichen auf zwei oder eine gerade Anzahl umgekehrter Schrägstriche folgt, wird jedes umgekehrte Schrägstrich paar durch einen umgekehrten Schrägstrich ersetzt, und das doppelte Anführungszeichen wird entfernt. Wenn ein doppeltes Anführungszeichen auf eine ungerade Anzahl umgekehrter Schrägstriche folgt, einschließlich nur eines, wird jedes vorangehende paar durch einen umgekehrten Schrägstrich ersetzt, und der verbleibende umgekehrte Schrägstrich wird entfernt. in diesem Fall wird das doppelte Anführungszeichen jedoch nicht entfernt.  
  
 `MyApp` In der folgenden Tabelle wird gezeigt, wie Befehlszeilenargumente begrenzt werden können  
  
|Eingabe in der Befehlszeile|Resultierende Befehlszeilenargumente|  
|-------------------------------|--------------------------------------|  
|`MyApp alpha beta`|`MyApp, alpha, beta`|  
|`MyApp "alpha with spaces" "beta with spaces"`|`MyApp, alpha with spaces, beta with spaces`|  
|`MyApp 'alpha with spaces' beta`|`MyApp, 'alpha, with, spaces', beta`|  
|`MyApp \\\alpha \\\\"beta`|`MyApp, \\\alpha, \\beta`|  
|`MyApp \\\\\"alpha \"beta`|`MyApp, \\"alpha, "beta`|  
  
 Verwenden Sie die <xref:System.Environment.CommandLine%2A> -Eigenschaft, um die Befehlszeile als einzelne Zeichenfolge zu erhalten.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Befehlszeilenargumente der Anwendung angezeigt.  
  
 [!code-cpp[Environment.GetCommandLineArgs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CPP/getcommandlineargs.cpp#1)]
 [!code-csharp[Environment.GetCommandLineArgs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CS/getcommandlineargs.cs#1)]
 [!code-vb[Environment.GetCommandLineArgs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetCommandLineArgs/VB/getcommandlineargs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Das System unterstützt keine Befehlszeilenargumente.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für den Lesezugriff auf die PATH-Umgebungsvariable. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.CommandLine" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnvironmentVariable">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den Wert einer Umgebungsvariable ab.</summary>
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariable (variable As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEnvironmentVariable(System::String ^ variable);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariable : string -&gt; string" Usage="System.Environment.GetEnvironmentVariable variable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="variable">Der Name der Umgebungsvariablen.</param>
        <summary>Ruft den Wert einer Umgebungsvariablen vom aktuellen Prozess ab.</summary>
        <returns>Der Wert der von <paramref name="variable" /> angegebenen Umgebungsvariablen oder <see langword="null" />, wenn die Umgebungsvariable nicht gefunden wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Die <xref:System.Environment.GetEnvironmentVariable%28System.String%29> -Methode ruft eine Umgebungsvariable nur aus dem Umgebungsblock des aktuellen Prozesses ab. Dies entspricht dem Aufrufen der <xref:System.Environment.GetEnvironmentVariable%28System.String%2CSystem.EnvironmentVariableTarget%29> -Methode `target` mit dem Wert <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>. 

Um alle Umgebungsvariablen zusammen mit ihren Werten abzurufen, rufen Sie <xref:System.Environment.GetEnvironmentVariables%2A> die-Methode auf.  
  
Bei Umgebungsvariablen Namen wird die Groß-/Kleinschreibung unter Linux und macOS beachtet  
 
### <a name="on-windows-systems"></a>Auf Windows-Systemen

 Auf Windows-Systemen umfasst der Umgebungsblock des aktuellen Prozesses Folgendes:
 
- Alle Umgebungsvariablen, die für den übergeordneten Prozess bereitgestellt werden, der ihn erstellt hat. Beispielsweise erbt eine .NET-Anwendung, die über ein Konsolenfenster gestartet wird, alle Umgebungsvariablen des Konsolenfensters. 

  Wenn kein übergeordneter Prozess vorhanden ist, werden stattdessen die Umgebungsvariablen pro Computer und pro Benutzer verwendet. Beispielsweise verfügt ein neues Konsolenfenster über alle Umgebungsvariablen pro Computer und pro Benutzer, die zum Zeitpunkt der Start Definition definiert wurden.

- Alle Variablen, die dem Prozess Block während der Ausführung des Prozesses hinzugefügt werden, <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> indem entweder die <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> -Methode oder `target` die- <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>Methode mit dem Wert aufgerufen wird. Diese Umgebungsvariablen bleiben bestehen, bis die .NET-Anwendung beendet wird.  
  
Wenn Umgebungsvariablen erstellt werden, nachdem der Prozess gestartet wurde, können Sie mit dieser Methode nur die Variablen abrufen, die durch Aufrufen <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> der-Methode oder der <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> -Methode mit `target` dem Wert.<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>erstellt wurden.  

### <a name="on-macos-and-linux-systems"></a>Auf macOS-und Linux-Systemen

Unter macOS und Linux umfasst der Umgebungsblock des aktuellen Prozesses die folgenden Umgebungsvariablen:

- Alle Umgebungsvariablen, die für den übergeordneten Prozess bereitgestellt werden, der ihn erstellt hat. Bei .NET-Anwendungen, die über eine Shell gestartet werden, sind alle in der Shell definierten Umgebungsvariablen enthalten.

- Alle Variablen, die dem Prozess Block während der Ausführung des Prozesses hinzugefügt werden, <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> indem entweder die <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> -Methode oder `target` die- <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>Methode mit dem Wert aufgerufen wird. Diese Umgebungsvariablen bleiben bestehen, bis die .NET-Anwendung beendet wird.  

.Net Core unter macOS und Linux unterstützt keine Umgebungsvariablen pro Computer oder pro Benutzer.   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Environment.GetEnvironmentVariable%2A> -Methode verwendet, `windir` um die-Umgebungsvariable abzurufen, die den Pfad des Windows-Verzeichnisses enthält.  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 Im folgenden Beispiel wird versucht, den Wert einer Umgebungsvariablen mit dem `Test1` Namen aus dem Process Environment-Block abzurufen. Wenn die Variable nicht vorhanden ist, erstellt das Beispiel Ihre und ruft ihren Wert ab. Im Beispiel wird der Wert der-Variablen angezeigt. Wenn im Beispiel die-Variable erstellt wurde, wird auch <xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29> die-Methode mit jedem Member <xref:System.EnvironmentVariableTarget> der-Enumeration aufgerufen, um festzulegen, dass die Variable nur aus dem aktuellen Prozess Umgebungsblock abgerufen werden kann. Wenn im Beispiel die-Variable erstellt wurde, wird Sie gelöscht.  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="variable" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer hat nicht die erforderliche Berechtigung zum Ausführen dieses Vorgangs.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">, um den Wert von <paramref name="variable" />lesen zu können. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable, EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariable (variable As String, target As EnvironmentVariableTarget) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEnvironmentVariable(System::String ^ variable, EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariable : string * EnvironmentVariableTarget -&gt; string" Usage="System.Environment.GetEnvironmentVariable (variable, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="variable">Der Name einer Umgebungsvariablen.</param>
        <param name="target">Einer der <see cref="T:System.EnvironmentVariableTarget" />-Werte. Nur <see cref="F:System.EnvironmentVariableTarget.Process" /> wird in .NET Core bei der Ausführung auf Unix-basierten Systemen unterstützt.</param>
        <summary>Ruft den Wert einer Umgebungsvariablen vom aktuellen Prozess oder aus dem Registrierungsschlüssel des Windows-Betriebssystems für den aktuellen Benutzer oder den lokalen Computer ab.</summary>
        <returns>Der Wert der von den Parametern <paramref name="variable" /> und <paramref name="target" /> angegebenen Umgebungsvariablen oder <see langword="null" />, wenn die Umgebungsvariable nicht gefunden wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks 

Um alle Umgebungsvariablen zusammen mit ihren Werten abzurufen, rufen Sie <xref:System.Environment.GetEnvironmentVariables%2A> die-Methode auf.  
  
Bei Umgebungsvariablen Namen wird die Groß-/Kleinschreibung unter Linux und macOS beachtet 

### <a name="on-windows-systems"></a>Auf Windows-Systemen

Unter Windows gibt der `target` -Parameter an, ob die Umgebungsvariable aus dem aktuellen Prozess oder aus dem Registrierungsschlüssel des Windows-Betriebssystems für den aktuellen Benutzer oder den lokalen Computer abgerufen wird. Alle Umgebungsvariablen pro Benutzer und pro Computer werden automatisch in den Umgebungsblock des aktuellen Prozesses kopiert, ebenso wie alle anderen Umgebungsvariablen, die für den übergeordneten Prozess verfügbar sind, der den .NET-Prozess erstellt hat. Umgebungsvariablen werden jedoch nur dem Umgebungsblock des aktuellen Prozesses hinzugefügt, indem entweder <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> die-Methode oder die <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> - <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> Methode mit `target` dem Wert Persistenz nur für die Dauer des Prozesses aufgerufen wird.  
  
### <a name="on-macos-and-linux-systems"></a>Auf macOS-und Linux-Systemen

Unter macOS und Linux `GetEnvironmentVariable(String, EnvironmentVariableTarget)` `target` unterstützt die-Methode <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> nur den Wert. Aufrufe mit dem `target` <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> Wert oder <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> werden nicht unterstützt und geben `null`zurück. 

Die Umgebungsvariablen pro Prozess lauten:

- Die vom übergeordneten Prozess geerbten, in der Regel die Shell `dotnet.exe` , die zum Aufrufen oder zum Starten der .NET-Anwendung verwendet wird.

- Diese werden durch Aufrufen <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> der-Methode oder der <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> - <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>Methode mit `target` dem-Wert definiert. Diese Umgebungsvariablen bleiben nur bestehen, `dotnet` bis der Prozess oder die .NET-Anwendung beendet wird.   
  
## Examples

Das folgende Beispiel erstellt die Umgebungsvariablen für die <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>, <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>, und <xref:System.EnvironmentVariableTarget.Machine> ausgerichtet ist, überprüft, ob die Registrierung des Betriebssystems, die Benutzer und Computer-Umgebungsvariablen enthält, und löscht dann die Umgebungsvariablen. Da .net auf UNIX-basierten Systemen nicht pro Benutzer-und Computer spezifische Umgebungsvariablen unterstützt, werden nur <xref:System.Environment.SetEnvironmentVariable(System.String,System.String)> und <xref:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)> mit dem Wert <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> erfolgreich eine Umgebungsvariable im Process Environment-Block gespeichert.

[!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs)]
[!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="variable" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> ist kein gültiger <see cref="T:System.EnvironmentVariableTarget" /> -Wert.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer hat nicht die erforderliche Berechtigung zum Ausführen dieses Vorgangs.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">um den Wert <paramref name="variable" /> von zu lesen, wenn <paramref name="target" /> (Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" />) ist <see cref="F:System.EnvironmentVariableTarget.Process" /> , 
oder 
für den Vollzugriff auf Umgebungsvariablen <paramref name="target" /> , <see cref="F:System.EnvironmentVariableTarget.User" /> Wenn <see cref="F:System.EnvironmentVariableTarget.Machine" /> oder ist (zugeordnete <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />Enumeration:).</permission>
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnvironmentVariables">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft die Namen und Werte aller Umgebungsvariablen ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariables () As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IDictionary ^ GetEnvironmentVariables();" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariables : unit -&gt; System.Collections.IDictionary" Usage="System.Environment.GetEnvironmentVariables " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft alle Namen und Werte der Umgebungsvariablen vom aktuellen Prozess ab.</summary>
        <returns>Ein Wörterbuch, das die Namen und Werte aller Umgebungsvariablen enthält, andernfalls ein leeres Wörterbuch, wenn keine Umgebungsvariablen gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Namen und Werte für die Umgebungsvariablen werden als Schlüssel-Wert-Paare in der zurück <xref:System.Collections.IDictionary>gegebenen gespeichert.  
  
### <a name="on-windows-systems"></a>Auf Windows-Systemen

Auf Windows-Systemen gibt `GetEnvironmentVariables` die-Methode die folgenden Umgebungsvariablen zurück:
  
- Alle Umgebungsvariablen pro Computer, die zum Zeitpunkt der Erstellung des Prozesses definiert sind, zusammen mit ihren Werten.  
  
- Alle Umgebungsvariablen pro Benutzer, die zum Zeitpunkt der Erstellung des Prozesses definiert sind, zusammen mit ihren Werten.  

- Alle Variablen, die vom übergeordneten Prozess geerbt wurden, von dem aus die .NET-Anwendung gestartet oder dem Prozess Block hinzugefügt wurde, während der Prozess ausgeführt wird. Umgebungsvariablen werden hinzugefügt, während der Prozess ausgeführt wird, indem <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> entweder die- <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> Methode oder die `target` - <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>Methode mit dem Wert aufgerufen wird.  

### <a name="on-macos-and-linux-systems"></a>Auf macOS-und Linux-Systemen

Unter MacOS und Linux Ruft die `GetEnvironmentVariables` -Methode den Namen und den Wert aller Umgebungsvariablen ab, die vom übergeordneten Prozess geerbt werden, der `dotnet` den Prozess gestartet hat oder die `dotnet` im Bereich des Prozesses selbst definiert werden. Nachdem der `dotnet` Prozess beendet wurde, sind diese letzteren Umgebungsvariablen nicht mehr vorhanden. 

.Net Core, das auf UNIX-basierten Systemen ausgeführt wird, unterstützt keine Umgebungsvariablen pro Computer oder pro Benutzer.   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Environment.GetEnvironmentVariables%2A> Methode.  
  
 [!code-cpp[Environment.GetEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CPP/getenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.GetEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CS/getenvironmentvariables.cs#1)]
 [!code-vb[Environment.GetEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetEnvironmentVariables/VB/getenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer hat nicht die erforderliche Berechtigung zum Ausführen dieses Vorgangs.</exception>
        <exception cref="T:System.OutOfMemoryException">Im Puffer ist nicht genügend Arbeitsspeicher.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">die Möglichkeit, die Namen und Werte von Umgebungsvariablen zu lesen. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables (EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables(valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariables (target As EnvironmentVariableTarget) As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IDictionary ^ GetEnvironmentVariables(EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariables : EnvironmentVariableTarget -&gt; System.Collections.IDictionary" Usage="System.Environment.GetEnvironmentVariables target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="target">Einer der <see cref="T:System.EnvironmentVariableTarget" />-Werte. Nur <see cxref="F:System.EnvironmentVariableTarget.Process" /> wird in .NET Core bei der Ausführung auf Unix-basierten Systemen unterstützt.</param>
        <summary>Ruft die Namen und Werte aller Umgebungsvariablen vom aktuellen Prozess oder aus dem Registrierungsschlüssel des Windows-Betriebssystems für den aktuellen Benutzer oder den lokalen Computer ab.</summary>
        <returns>Ein Wörterbuch, das die Namen und Werte aller Umgebungsvariablen aus der durch den <paramref name="target" />-Parameter angegebenen Quelle enthält, andernfalls ein leeres Wörterbuch, wenn keine Umgebungsvariablen gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Die Namen und Werte der Umgebungsvariablen werden als Schlüssel-Wert-Paare im zurückgegebenen <xref:System.Collections.IDictionary> -Objekt gespeichert.  

### <a name="on-windows-systems"></a>Auf Windows-Systemen

Auf Windows-Systemen gibt `target` der-Parameter an, ob die Quelle der aktuelle Prozess, der Registrierungsschlüssel für den aktuellen Benutzer oder der Registrierungsschlüssel für den lokalen Computer ist.  

### <a name="on-macos-and-linux-systems"></a>Auf macOS-und Linux-Systemen

Unter macOS und Linux wird nur `target` der <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> Wert unterstützt. Prozessspezifische Umgebungsvariablen werden von dem übergeordneten Prozess (in der Regel die Shell) geerbt, der `dotnet` zum Starten des Prozesses verwendet wird, oder werden `dotnet` innerhalb des Bereichs des Prozesses selbst definiert. Sobald der dotnet-Prozess beendet ist, sind diese letzten Umgebungsvariablen nicht mehr vorhanden.  

Pro-Computer-und benutzerspezifische Umgebungsvariablen werden nicht unterstützt. Der `target` Wert<xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> oder<xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> gibt ein leeres Array zurück.
  
## Examples

Das folgende Beispiel erstellt die Umgebungsvariablen für die <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>, <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>, und <xref:System.EnvironmentVariableTarget.Machine> ausgerichtet ist, überprüft, ob die Registrierung des Betriebssystems, die Benutzer und Computer-Umgebungsvariablen enthält, und löscht dann die Umgebungsvariablen. Da .net auf UNIX-basierten Systemen nicht pro Benutzer-und Computer spezifische Umgebungsvariablen unterstützt, werden nur <xref:System.Environment.SetEnvironmentVariable(System.String,System.String)> und <xref:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)> mit dem Wert <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> erfolgreich eine Umgebungsvariable im Process Environment-Block gespeichert.

[!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs)]
[!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer hat für den angegebenen Wert von <paramref name="target" /> nicht die erforderliche Berechtigung zum Ausführen dieses Vorgangs.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> enthält einen unzulässigen Wert.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">damit die Namen und Werte von Umgebungsvariablen gelesen werden können, wenn <paramref name="target" /> ( <see cref="F:System.EnvironmentVariableTarget.Process" /> zugeordnete Enumeration: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" />) ist, 
oder 
für den Vollzugriff auf Umgebungsvariablen <paramref name="target" /> , <see cref="F:System.EnvironmentVariableTarget.User" /> Wenn <see cref="F:System.EnvironmentVariableTarget.Machine" /> oder ist (zugeordnete <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />Enumeration:).</permission>
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFolderPath">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den Pfad des durch die angegebene Enumeration bezeichneten besonderen Systemordners ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFolderPath (folder As Environment.SpecialFolder) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFolderPath(Environment::SpecialFolder folder);" />
      <MemberSignature Language="F#" Value="static member GetFolderPath : Environment.SpecialFolder -&gt; string" Usage="System.Environment.GetFolderPath folder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="folder">Einer der Enumerationswerte, die eine besonderen Systemordner bezeichnen.</param>
        <summary>Ruft den Pfad des durch die angegebene Enumeration bezeichneten besonderen Systemordners ab.</summary>
        <returns>Der Pfad zum angegebenen besonderen Systemordner, sofern dieser auf dem Computer physisch vorhanden ist, andernfalls eine leere Zeichenfolge ("").  
  
 Ein Ordner ist physisch nicht vorhanden, wenn er nicht vom Betriebssystem erstellt wurde, wenn der vorhandene Ordner gelöscht wurde oder wenn der Ordner ein virtuelles Verzeichnis ist, z. B. Arbeitsplatz, das keinem physischen Pfad entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft den Pfad zu einem speziellen Systemordner ab, z. b. Programmdateien, Programme, System oder Start, mit dem auf allgemeine Informationen zugegriffen werden kann. Besondere Ordner werden standardmäßig vom System oder explizit durch den Benutzer festgelegt, wenn eine Version von Windows installiert wird.  
  
 Der `folder` -Parameter legt den speziellen Ordner fest, der abgerufen werden soll, und muss einer der <xref:System.Environment.SpecialFolder> Werte in der-Enumeration sein. jeder andere Wert löst eine Ausnahme aus.  
  
 Weitere Informationen zu speziellen Ordnern finden Sie im Thema [CSIDL](https://go.microsoft.com/fwlink/?LinkId=116664) values.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Environment.GetFolderPath%2A> -Methode verwendet wird, um den Pfad zurückzugeben `folder` und anzuzeigen, der dem-Parameter zugeordnet ist.  
  
 [!code-cpp[Environment.GetFolderPath#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetFolderPath/CPP/getfolderpath.cpp#1)]
 [!code-csharp[Environment.GetFolderPath#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetFolderPath/CS/getfolderpath.cs#1)]
 [!code-vb[Environment.GetFolderPath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetFolderPath/VB/getfolderpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="folder" /> ist kein Member von <see cref="T:System.Environment.SpecialFolder" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die aktuelle Plattform wird nicht unterstützt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Informationen im Pfad selbst. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder, Environment.SpecialFolderOption option);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder, valuetype System.Environment/SpecialFolderOption option) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder,System.Environment.SpecialFolderOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFolderPath (folder As Environment.SpecialFolder, option As Environment.SpecialFolderOption) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFolderPath(Environment::SpecialFolder folder, Environment::SpecialFolderOption option);" />
      <MemberSignature Language="F#" Value="static member GetFolderPath : Environment.SpecialFolder * Environment.SpecialFolderOption -&gt; string" Usage="System.Environment.GetFolderPath (folder, option)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="option" Type="System.Environment+SpecialFolderOption" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="folder">Einer der Enumerationswerte, die einen besonderen Systemordner bezeichnen.</param>
        <param name="option">Einer der Enumerationswerte, die Optionen zum Zugreifen auf einen besonderen Ordner angeben.</param>
        <summary>Ruft den Pfad zum besonderen Systemordner ab, der von der angegebenen Enumeration bezeichnet wird, und verwendet eine angegebene Option zum Zugreifen auf besondere Ordner.</summary>
        <returns>Der Pfad zum angegebenen besonderen Systemordner, sofern dieser auf dem Computer physisch vorhanden ist, andernfalls eine leere Zeichenfolge ("").  
  
 Ein Ordner ist physisch nicht vorhanden, wenn er nicht vom Betriebssystem erstellt wurde, wenn der vorhandene Ordner gelöscht wurde oder wenn der Ordner ein virtuelles Verzeichnis ist, z. B. Arbeitsplatz, das keinem physischen Pfad entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft den Pfad zu einem speziellen Systemordner ab, z. b. Programmdateien, Programme, System oder Start, mit dem auf allgemeine Informationen zugegriffen werden kann. Besondere Ordner werden standardmäßig vom System oder explizit durch den Benutzer festgelegt, wenn eine Version von Windows installiert wird.  
  
 Der `folder` -Parameter legt den speziellen Ordner fest, der abgerufen werden soll, und muss einer der <xref:System.Environment.SpecialFolder> Werte in der-Enumeration sein. jeder andere Wert löst eine Ausnahme aus.  
  
 Weitere Informationen zu speziellen Ordnern finden Sie im Thema [CSIDL](https://go.microsoft.com/fwlink/?LinkId=116664) values.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="folder" /> ist kein Member von <see cref="T:System.Environment.SpecialFolder" />.
- oder -

<paramref name="options" /> ist kein Member von <see cref="T:System.Environment.SpecialFolderOption" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Die aktuelle Plattform wird nicht unterstützt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Informationen im Pfad selbst. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetLogicalDrives">
      <MemberSignature Language="C#" Value="public static string[] GetLogicalDrives ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetLogicalDrives() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetLogicalDrives" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLogicalDrives () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetLogicalDrives();" />
      <MemberSignature Language="F#" Value="static member GetLogicalDrives : unit -&gt; string[]" Usage="System.Environment.GetLogicalDrives " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein Zeichenfolgenarray mit den Namen der logischen Laufwerke des aktuellen Computers zurück.</summary>
        <returns>Ein Array von Zeichenfolgen, in dem jedes Element den Namen eines logischen Laufwerks enthält. Wenn z.B. die Festplatte das erste logische Laufwerk eines Computers ist, lautet das erste zurückgegebene Element "C:\\".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die logischen Laufwerke des aktuellen Computers mithilfe der <xref:System.Environment.GetLogicalDrives%2A> -Methode angezeigt werden.  
  
 [!code-cpp[Environment.GetLogicalDrives#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetLogicalDrives/CPP/getlogicaldrives.cpp#1)]
 [!code-csharp[Environment.GetLogicalDrives#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetLogicalDrives/CS/getlogicaldrives.cs#1)]
 [!code-vb[Environment.GetLogicalDrives#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetLogicalDrives/VB/getlogicaldrives.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für vollständigen Zugriff auf die durch diese Berechtigung geschützte Ressource. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownStarted">
      <MemberSignature Language="C#" Value="public static bool HasShutdownStarted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool HasShutdownStarted" />
      <MemberSignature Language="DocId" Value="P:System.Environment.HasShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property HasShutdownStarted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool HasShutdownStarted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasShutdownStarted : bool" Usage="System.Environment.HasShutdownStarted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die derzeitige Anwendungsdomäne entladen wird oder die Common Language Runtime (CLR) heruntergefahren wird.</summary>
        <value><see langword="true" />, wenn die aktuelle Anwendungsdomäne entladen oder die CLR heruntergefahren wird. <see langword="false" />andernfalls.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 **Nur .NET Framework**: Wenn die CLR eine Anwendungsdomäne entlädt, führt Sie die Finalizer für alle Objekte aus, die über eine Finalizer-Methode in dieser Anwendungsdomäne verfügen. Wenn die CLR heruntergefahren wird, startet Sie den Finalizerthread für alle Objekte, die über eine Finalizer-Methode verfügen. Die <xref:System.Environment.HasShutdownStarted%2A> -Eigenschaft `true` gibt nur dann zurück, wenn der Finalizerthread gestartet wurde. Wenn die-Eigenschaft `true`zurückgegeben wird, können Sie bestimmen, ob eine Anwendungsdomäne entladen wird oder die CLR selbst durch Aufrufen der <xref:System.AppDomain.IsFinalizingForUnload%2A?displayProperty=nameWithType> -Methode heruntergefahren wird. Diese Methode gibt `true` zurück, wenn Finalizer aufgerufen werden, da die Anwendungsdomäne `false` entladen wird oder wenn die CLR heruntergefahren wird.  
  
 Die <xref:System.Environment.HasShutdownStarted%2A> -Eigenschaft `false` gibt zurück, wenn der Finalizerthread nicht gestartet wurde.  
  
 Mithilfe dieser Eigenschaft können Sie feststellen, ob im Finalisierungscode auf statische Variablen zugegriffen werden soll. Wenn entweder eine Anwendungsdomäne oder die CLR heruntergefahren wird, können Sie nicht zuverlässig auf ein Objekt zugreifen, das über eine Abschluss-Methode verfügt und auf die von einem statischen Feld verwiesen wird. Dies liegt daran, dass diese Objekte möglicherweise bereits fertiggestellt wurden.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsFinalizingForUnload" />
      </Docs>
    </Member>
    <Member MemberName="Is64BitOperatingSystem">
      <MemberSignature Language="C#" Value="public static bool Is64BitOperatingSystem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitOperatingSystem" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitOperatingSystem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Is64BitOperatingSystem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Is64BitOperatingSystem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Is64BitOperatingSystem : bool" Usage="System.Environment.Is64BitOperatingSystem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bestimmt, ob das aktuelle Betriebssystem ein 64-Bit-Betriebssystem ist.</summary>
        <value><see langword="true" /> , wenn das aktuelle Betriebssystem ein 64-Bit-Betriebssystem ist, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Is64BitProcess">
      <MemberSignature Language="C#" Value="public static bool Is64BitProcess { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitProcess" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Is64BitProcess As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Is64BitProcess { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Is64BitProcess : bool" Usage="System.Environment.Is64BitProcess" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bestimmt, ob der aktuelle Prozess ein 64-Bit-Prozess ist.</summary>
        <value><see langword="true" /> , wenn der aktuelle Prozess ein 64-Bit-Prozess ist, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public static string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Environment.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den NetBIOS-Namen dieses lokalen Computers ab.</summary>
        <value>Eine Zeichenfolge mit dem Namen dieses Computers.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Name dieses Computers wird beim Systemstart festgelegt, wenn der Name aus der Registrierung gelesen wird. Wenn es sich bei diesem Computer um einen Knoten in einem Cluster handelt, wird der Name des Knotens zurückgegeben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Name des Computers angezeigt, auf dem das Codebeispiel ausgeführt wird. (Aus Sicherheitsgründen wird der Computername aus der Beispielausgabe weggelassen.)  
  
 [!code-cpp[environment.machinename#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.MachineName/CPP/machinename.cpp#1)]
 [!code-csharp[environment.machinename#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.MachineName/CS/machinename.cs#1)]
 [!code-vb[environment.machinename#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.MachineName/VB/machinename.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Name dieses Computers kann nicht abgerufen werden.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für den Lesezugriff auf die Computername-Umgebungsvariable. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="NewLine">
      <MemberSignature Language="C#" Value="public static string NewLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string NewLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.NewLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property NewLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ NewLine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NewLine : string" Usage="System.Environment.NewLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die für diese Umgebung definierte Zeichenfolge für einen Zeilenumbruch ab.</summary>
        <value>Eine Zeichenfolge für Nicht-Unix-Plattformen, die "\r\n" enthält, oder eine Zeichenfolge für Unix-Plattformen, die "\n" enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der-Eigenschafts <xref:System.Environment.NewLine%2A> Wert von ist eine Konstante, die speziell für die aktuelle Plattform und Implementierung der .NET Framework angepasst ist. Weitere Informationen zu den Escapezeichen im Eigenschafts [Wert finden Sie](~/docs/standard/base-types/character-escapes-in-regular-expressions.md)unter Escapezeichen.  
  
 Die von <xref:System.Environment.NewLine%2A> bereitgestellte Funktionalität ist häufig die Bedeutung von Zeilenvorschub, Zeilenvorschub, Zeilenumbruch, Wagen Rücklauf, CRLF und Zeilenende.  
  
 <xref:System.Environment.NewLine%2A>kann in Kombination mit sprachspezifischer NeuUnterstützung verwendet werden, wie z. b. den Escapezeichen ' \r ' und ' \n ' C# inC++Microsoft und `vbCrLf` C/oder in Microsoft Visual Basic.  
  
 <xref:System.Environment.NewLine%2A>wird automatisch an Text angehängt, der von <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> den <xref:System.Text.StringBuilder.AppendLine%2A?displayProperty=nameWithType> Methoden und verarbeitet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel werden drei Zeilen angezeigt, die durch Zeilenumbrüche getrennt sind.  
  
 [!code-cpp[environment.newline#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.NewLine/CPP/newline.cpp#1)]
 [!code-csharp[environment.newline#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.NewLine/CS/newline.cs#1)]
 [!code-vb[environment.newline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.NewLine/VB/newline.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OSVersion">
      <MemberSignature Language="C#" Value="public static OperatingSystem OSVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.OperatingSystem OSVersion" />
      <MemberSignature Language="DocId" Value="P:System.Environment.OSVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSVersion As OperatingSystem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property OperatingSystem ^ OSVersion { OperatingSystem ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OSVersion : OperatingSystem" Usage="System.Environment.OSVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.OperatingSystem</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.OperatingSystem" />-Objekt ab, das den Bezeichner und die Versionsnummer der aktuellen Plattform enthält.</summary>
        <value>Ein Objekt, das den Bezeichner und die Versionsnummer der Plattform enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

Die `Environment.OSVersion` -Eigenschaft bietet keine zuverlässige Möglichkeit, um genau das Betriebssystem und seine Version zu identifizieren. Daher wird empfohlen, diese Methode nicht zu verwenden. Stattdessen 

- Verwenden Sie die <xref:System.Runtime.InteropServices.RuntimeInformation.IsOSPlatform%2A?displayProperty=nameWithType> -Methode, um die Betriebssystem Plattform zu identifizieren. 

- Vermeiden Sie das Schreiben von Code, der von einer gemeldeten Betriebssystemversion abhängt. Überprüfen Sie stattdessen die Verfügbarkeit der Features, die Ihre Anwendung benötigt.

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Diese Eigenschaft war nicht in der Lage, die Systemversion abzurufen.  
  
- oder - 
Der abgerufene Plattformbezeichner ist kein Mitglied von <see cref="T:System.PlatformID" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessorCount">
      <MemberSignature Language="C#" Value="public static int ProcessorCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ProcessorCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ProcessorCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProcessorCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ProcessorCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorCount : int" Usage="System.Environment.ProcessorCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl von Prozessoren im aktuellen Computer ab.</summary>
        <value>Die 32-Bit-Ganzzahl mit Vorzeichen, die die Anzahl von Prozessoren im aktuellen Computer angibt. Es ist kein Standardwert vorhanden. Wenn der aktuelle Computer mehrere Prozessorgruppen enthält, gibt diese Eigenschaft die Anzahl logischer Prozessoren zurück, die für die Common Language Runtime (CLR) verfügbar sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zu Prozessor Gruppen und logischen Prozessoren finden Sie unter [Prozessor Gruppen](https://msdn.microsoft.com/library/windows/desktop/dd405503.aspx).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Environment.ProcessorCount%2A> -Eigenschaft veranschaulicht.  
  
 [!code-cpp[environment.processorcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.processorcount/CPP/pc.cpp#1)]
 [!code-csharp[environment.processorcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.processorcount/CS/pc.cs#1)]
 [!code-vb[environment.processorcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.processorcount/VB/pc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetEnvironmentVariable">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt, ändert oder löscht eine Umgebungsvariable.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetEnvironmentVariable (variable As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEnvironmentVariable(System::String ^ variable, System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member SetEnvironmentVariable : string * string -&gt; unit" Usage="System.Environment.SetEnvironmentVariable (variable, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="variable">Der Name einer Umgebungsvariablen.</param>
        <param name="value">Ein Wert, der <paramref name="variable" /> zugewiesen werden soll.</param>
        <summary>Erstellt, ändert oder löscht eine im aktuellen Prozess gespeicherte Umgebungsvariable.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen dieser Methode entspricht dem Aufrufen der <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> -Überladung mit dem <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> Wert für `target` das-Argument.  
  
 Wenn die `value` Argument ist nicht leer (siehe die Erläuterung der Löschen einer Umgebungsvariablen, die weiter unten in diesem Abschnitt für die Definition von ein leerer Wert) und die Umgebungsvariable mit dem Namen, indem die `variable` Parameter nicht vorhanden ist, die Umgebungsvariable wird erstellt und dem Inhalt von zugewiesen `value`. Wenn er vorhanden ist, wird sein Wert geändert. Da die Umgebungsvariable nur im Umgebungsblock des aktuellen Prozesses definiert ist, wird Sie nicht beibehalten, wenn der Prozess beendet wurde.  
  
 Wenn `variable` ein nicht anfängliches hexadezimales NULL Zeichen enthält, werden die Zeichen vor dem NULL-Zeichen als Umgebungsvariablen Name betrachtet, und alle nachfolgenden Zeichen werden ignoriert.  
  
 Wenn `value` ein nicht anfängliches hexadezimales NULL Zeichen enthält, werden die Zeichen vor dem NULL-Zeichen der Umgebungsvariablen zugewiesen, und alle nachfolgenden Zeichen werden ignoriert.  
  
 Wenn `value` leer ist und die durch `variable` benannte Umgebungsvariable vorhanden ist, wird die Umgebungsvariable gelöscht. Wenn `variable` nicht vorhanden ist, tritt kein Fehler auf, obwohl der Vorgang nicht ausgeführt werden kann. `value`gilt unter folgenden Bedingungen als leer:  
  
-   Dies ist `null`.  
  
-   Dies ist <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Sie besteht aus einem einzelnen Zeichen, dessen Wert U + 0000 ist.  
  
## Examples

Im folgenden Beispiel wird versucht, den Wert einer Umgebungsvariablen mit dem `Test1` Namen aus dem Process Environment-Block abzurufen. Wenn die Variable nicht vorhanden ist, wird im Beispiel die Variable erstellt und ihr Wert abgerufen. Im Beispiel wird der Wert der-Variablen angezeigt. Bei .net-Implementierungen, die auf Windows-Systemen ausgeführt werden <xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29> , wird auch die-Methode <xref:System.EnvironmentVariableTarget> mit jedem Member der-Enumeration aufgerufen, um festzulegen, dass die Variable nur aus dem aktuellen Prozess Umgebungsblock abgerufen werden kann. (.Net-Implementierungen auf UNIX-basierten Systemen unterstützen nur Variablen im Process Environment-Block.) Wenn im Beispiel die-Variable erstellt wurde, wird Sie gelöscht.  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="variable" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="variable" /> enthält eine leere Zeichenfolge („“), ein anfängliches Hexadezimalzeichen 0 (0x00) oder ein Gleichheitszeichen ("=").  
  
- oder - 
Die Länge von <paramref name="variable" /> oder <paramref name="value" /> ist größer gleich 32.767 Zeichen.  
  
- oder - 
Während der Ausführung dieses Vorgangs ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer hat nicht die erforderliche Berechtigung zum Ausführen dieses Vorgangs.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für vollständigen Zugriff auf Umgebungsvariablen. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
      </Docs>
    </Member>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value, EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetEnvironmentVariable (variable As String, value As String, target As EnvironmentVariableTarget)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEnvironmentVariable(System::String ^ variable, System::String ^ value, EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member SetEnvironmentVariable : string * string * EnvironmentVariableTarget -&gt; unit" Usage="System.Environment.SetEnvironmentVariable (variable, value, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="variable">Der Name einer Umgebungsvariablen.</param>
        <param name="value">Ein Wert, der <paramref name="variable" /> zugewiesen werden soll.</param>
        <param name="target">Einer der Enumerationswerte, der den Standort der Umgebungsvariablen angibt.</param>
        <summary>Erstellt, ändert oder löscht eine Umgebungsvariable, die im aktuellen Prozess oder im Registrierungsschlüssel des für den aktuellen Benutzer oder den lokalen Computer reservierten Windows-Betriebssystems gespeichert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Mit <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> der-Methode können Sie eine Umgebungsvariable definieren, die für den aktuellen Prozess ( <xref:System.EnvironmentVariableTarget.Process> den Wert) verfügbar ist. Umgebungsvariablen, die für den aktuellen Prozess Umgebungsblock eindeutig sind, werden nur bis zum Ende des Prozesses beibehalten.

Außerdem können Sie auf Windows-Systemen mit der <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> -Methode eine Umgebungsvariable definieren, die für alle Prozesse verfügbar ist, die auf einem Computer (dem <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> Wert) ausgeführt werden, sowie für alle Prozesse, die von <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> einem Benutzer ausgeführt werden (der Wert). Pro-Computer-und benutzerspezifische Umgebungsvariablen werden in den Umgebungsblock des aktuellen Prozesses kopiert.  
 
In .net Core auf macOS-und Linux-Systemen werden Aufrufe <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> der-Methode mit dem <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> Wert <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> oder ignoriert. 
  
 Wenn die `value` Argument ist nicht leer (siehe die Erläuterung der Löschen einer Umgebungsvariablen, die weiter unten in diesem Abschnitt für die Definition von ein leerer Wert) und die Umgebungsvariable mit dem Namen, indem die `variable` Argument ist nicht vorhanden, die Umgebungsvariable wird erstellt und dem Inhalt von zugewiesen `value`.  Wenn er vorhanden ist, wird sein Wert geändert.  
  
 Wenn `variable` ein nicht anfängliches hexadezimales NULL Zeichen enthält, werden die Zeichen vor dem NULL-Zeichen als Umgebungsvariablen Name betrachtet, und alle nachfolgenden Zeichen werden ignoriert.  
  
 Wenn `value` ein nicht anfängliches hexadezimales NULL Zeichen enthält, werden die Zeichen vor dem NULL-Zeichen der Umgebungsvariablen zugewiesen, und alle nachfolgenden Zeichen werden ignoriert.  
  
 Wenn `value` leer ist und die durch `variable` benannte Umgebungsvariable vorhanden ist, wird die Umgebungsvariable gelöscht. `value`gilt unter folgenden Bedingungen als leer:  
  
-   Dies ist `null`.  
  
-   Dies ist <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Sie besteht aus einem einzelnen Zeichen, dessen Wert U + 0000 ist.  
  
 Wenn `variable` nicht vorhanden ist, tritt kein Fehler auf, obwohl der Vorgang nicht ausgeführt werden kann. Seien Sie vorsichtig `target` <xref:System.EnvironmentVariableTarget.Machine>, wenn den Wert hat, denn Sie können versehentlich eine Umgebungsvariable löschen, die sich auf den gesamten lokalen Computer auswirkt, nicht nur auf den aktuellen Prozess oder den aktuellen Benutzer.  

### <a name="environmentvariabletargetmachine-and-environmentvariabletargetuser-on-windows-systems"></a>Umgebungs variabletarget. Machine und Umgebungs variabletarget. User auf Windows-Systemen

Wenn `target`den Wert hat,wirddieUmgebungsvariableimHKEY_CURRENT_USER\Environment-SchlüsselderRegistrierungdeslokalenComputersgespeichert.<xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> Sie wird auch in Instanzen des Datei-Explorers kopiert, die als aktueller Benutzer ausgeführt werden. Die Umgebungsvariable wird dann von allen neuen Prozessen geerbt, die vom Benutzer im Datei-Explorer gestartet werden.  
  
 Wenn `target` gleich ist <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>, wird die Umgebungsvariable im HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Session Manager\Environment Key der Registrierung des lokalen Computers gespeichert. Sie wird auch in alle Instanzen des Datei-Explorers kopiert. Die Umgebungsvariable wird dann von allen neuen Prozessen geerbt, die aus dem Datei-Explorer gestartet werden.  
  
 Wenn `target`den Wert oder<xref:System.EnvironmentVariableTarget.Machine>hat, werden andere Anwendungen über den Set-Vorgang durch `WM_SETTINGCHANGE` eine Windows-Meldung benachrichtigt. <xref:System.EnvironmentVariableTarget.User>  
  
 Wenn `target` den <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> Wert oder<xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>hat, wird empfohlen, dass `value` die Länge von weniger als 2048 Zeichen beträgt.  
  
## Examples

Das folgende Beispiel erstellt die Umgebungsvariablen für die <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>, <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>, und <xref:System.EnvironmentVariableTarget.Machine> ausgerichtet ist, überprüft, ob die Registrierung des Betriebssystems, die Benutzer und Computer-Umgebungsvariablen enthält, und löscht dann die Umgebungsvariablen. Da .net auf UNIX-basierten Systemen nicht pro Benutzer-und Computer spezifische Umgebungsvariablen unterstützt, werden nur <xref:System.Environment.SetEnvironmentVariable(System.String,System.String)> und <xref:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)> mit dem Wert <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> erfolgreich eine Umgebungsvariable im Process Environment-Block gespeichert.
  
[!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs)]
[!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="variable" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="variable" /> enthält eine leere Zeichenfolge („“), ein anfängliches Hexadezimalzeichen 0 (0x00) oder ein Gleichheitszeichen ("=").  
  
- oder - 
Die Länge von <paramref name="variable" /> ist größer gleich 32.767 Zeichen.  
  
- oder - 
 <paramref name="target" /> ist kein Member der <see cref="T:System.EnvironmentVariableTarget" /> -Enumeration.  
  
- oder - 
 <paramref name="target" /> ist gleich <see cref="F:System.EnvironmentVariableTarget.Machine" /> oder gleich <see cref="F:System.EnvironmentVariableTarget.User" />, und die Länge von <paramref name="variable" /> ist größer gleich 255.  
  
- oder - 
 <paramref name="target" /> ist gleich <see cref="F:System.EnvironmentVariableTarget.Process" /> , und die Länge von <paramref name="value" /> ist größer gleich 32,767.  
  
- oder - 
Während der Ausführung dieses Vorgangs ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer hat nicht die erforderliche Berechtigung zum Ausführen dieses Vorgangs.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für vollständigen Zugriff auf Umgebungsvariablen. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public static string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Environment.StackTrace" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StackTrace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StackTrace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StackTrace : string" Usage="System.Environment.StackTrace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die aktuellen Stapelüberwachungsinformationen ab.</summary>
        <value>Eine Zeichenfolge, die Stapelüberwachungsinformationen enthält. Dieser Wert kann <see cref="F:System.String.Empty" /> sein.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Environment.StackTrace%2A> -Eigenschaft listet Methodenaufrufe in umgekehrter chronologischer Reihenfolge auf, d. h., der letzte Methodenaufruf wird zuerst beschrieben, und eine Zeile mit Stapel Überwachungsinformationen wird für jeden Methodenaufruf im Stapel aufgelistet. Die <xref:System.Environment.StackTrace%2A> -Eigenschaft meldet jedoch möglicherweise aufgrund von Code Transformationen, die während der Optimierung auftreten, nicht so viele Methodenaufrufe wie erwartet.  
  
> [!NOTE]
>  Verwenden Sie für eine hierarchische Ansicht der Stapel Überwachungsinformationen durch die- <xref:System.Diagnostics.StackTrace> Klasse die-Klasse.  
  
 Die <xref:System.Environment.StackTrace%2A> -Eigenschaft formatiert die Stapel Überwachungsinformationen für die einzelnen Methodenaufrufe wie folgt:  
  
 "unter `FullClassName`.`MethodName` (`MethodParams`) in `FileName` : Zeile `LineNumber` "  
  
 Dem Literalzeichen "at" sind drei Leerzeichen vorangestellt, und die gesamte Teil Zeichenfolge, die mit "in" beginnt, wird weggelassen, wenn keine Debugsymbole verfügbar sind. Die Platzhalter `FullClassName`, `MethodName` `MethodParams` ,`FileName`,, und`LineNumber`, werden durch tatsächliche Werte ersetzt und wie folgt definiert:  
  
 FullClassName  
 Der vollständige Name der Klasse, einschließlich des Namespace.  
  
 `MethodName`  
 Der Name der Methode.  
  
 `MethodParams`  
 Die Liste der Parametertyp-/namens-Paare. Jedes Paar ist durch ein Komma (",") getrennt. Diese Informationen werden weggelassen, `MethodName` wenn keine Parameter annimmt.  
  
 `FileName`  
 Der Name der Quelldatei, in der `MethodName` die Methode deklariert wird. Diese Informationen werden weggelassen, wenn keine Debugsymbole verfügbar sind.  
  
 `LineNumber`  
 Die Nummer der Zeile in `FileName` , die den Quellcode `MethodName` für die Anweisung enthält, die sich in der-aufrufsstapel befindet. Diese Informationen werden weggelassen, wenn keine Debugsymbole verfügbar sind.  
  
 Die <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> Zeichenfolge beendet jede Zeile der Stapel Überwachung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Environment.StackTrace%2A> -Eigenschaft veranschaulicht.  
  
 [!code-cpp[environment.stacktrace#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.StackTrace/CPP/stacktrace.cpp#1)]
 [!code-csharp[environment.stacktrace#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.StackTrace/CS/stacktrace.cs#1)]
 [!code-vb[environment.stacktrace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.StackTrace/VB/stacktrace.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für vollständigen Zugriff auf die durch die Berechtigung geschützte Ressource. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SystemDirectory">
      <MemberSignature Language="C#" Value="public static string SystemDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string SystemDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SystemDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SystemDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SystemDirectory : string" Usage="System.Environment.SystemDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den voll gekennzeichneten Pfad des Systemverzeichnisses ab.</summary>
        <value>Eine Zeichenfolge mit einem Verzeichnispfad.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Beispiel für den zurückgegebenen Wert ist die Zeichenfolge "c:\WINNT\System32".  
  
   
  
## Examples  
 Im folgenden Beispiel wird das System Verzeichnis des Computers angezeigt, auf dem das Codebeispiel ausgeführt wird. (Aus Sicherheitsgründen wird das System Verzeichnis in der Beispielausgabe weggelassen.)  
  
 [!code-cpp[environment.systemdirectory#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.SystemDirectory/CPP/systemdirectory.cpp#1)]
 [!code-csharp[environment.systemdirectory#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.SystemDirectory/CS/systemdirectory.cs#1)]
 [!code-vb[environment.systemdirectory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.SystemDirectory/VB/systemdirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Informationen im Pfad selbst. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SystemPageSize">
      <MemberSignature Language="C#" Value="public static int SystemPageSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 SystemPageSize" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemPageSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SystemPageSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int SystemPageSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SystemPageSize : int" Usage="System.Environment.SystemPageSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Bytes in der Speicherseite des Betriebssystems ab.</summary>
        <value>Die Anzahl der Bytes in einer Arbeitsspeicherauslagerung des Betriebssystems.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Informationen können hilfreich sein, um zu bestimmen, ob <xref:System.IO.MemoryMappedFiles.MemoryMappedFileOptions.DelayAllocatePages?displayProperty=nameWithType> die-Option bei der Arbeit mit Speicher Abbild Dateien verwendet werden soll.  
  
 In Windows ist dieser Wert der `dwPageSize` -Member in der `SYSTEM_INFO` -Struktur.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für den Zugriff auf System-und Benutzer Umgebungsvariablen. Zugeordnete Ausnahme: 
 <see cref="P:System.Security.SecurityException.PermissionState" /></permission>
      </Docs>
    </Member>
    <Member MemberName="TickCount">
      <MemberSignature Language="C#" Value="public static int TickCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 TickCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.TickCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TickCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int TickCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.TickCount : int" Usage="System.Environment.TickCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Millisekunden ab, die seit dem Systemstart verstrichen sind.</summary>
        <value>Eine 32-Bit-Ganzzahl mit Vorzeichen, die die seit dem letzten Start des Computers vergangene Zeit in Millisekunden enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Eigenschaft wird vom System-Timer abgeleitet und als 32-Bit-Ganzzahl mit Vorzeichen gespeichert. Beachten Sie, dass die Auflösung <xref:System.Environment.TickCount%2A> der-Eigenschaft auf die Auflösung des Systemzeit Gebers beschränkt ist, da Sie vom Systemzeit Geber abgeleitet ist. Dies liegt in der Regel im Bereich von 10 bis 16 Millisekunden.  
  
> [!IMPORTANT]
>  <xref:System.Environment.TickCount%2A> Da der Wert des Eigenschafts Werts eine 32-Bit-Ganzzahl mit Vorzeichen ist und das System fort <xref:System.Environment.TickCount%2A> laufend ausgeführt wird, wird für ungefähr 24,9 Tage von NULL auf <xref:System.Int32.MaxValue?displayProperty=nameWithType> erhöht und <xref:System.Int32.MinValue?displayProperty=nameWithType>springt zu, was eine negative Zahl ist. erhöhen Sie dann während der nächsten 24,9 Tage wieder den Wert 0 (null). Sie können dieses Problem umgehen, indem Sie die Windows [GetTickCount](https://msdn.microsoft.com/library/windows/desktop/ms724408.aspx) -Funktion aufrufen, die nach ungefähr 49,7 Tagen auf Null zurückgesetzt wird, oder indem Sie die [GetTickCount64](https://msdn.microsoft.com/library/windows/desktop/ms724411.aspx) -Funktion aufrufen.  
  
 <xref:System.Environment.TickCount%2A>unterscheidet sich von <xref:System.DateTime.Ticks%2A?displayProperty=nameWithType> der-Eigenschaft. Hierbei handelt es sich um die Anzahl von 100-Nanosekunden-Intervallen, die seit 1/1/0001, 12 Uhr vergangen sind.  
  
 Verwenden Sie <xref:System.DateTime.Now%2A?displayProperty=nameWithType> die-Eigenschaft, um das aktuelle lokale Datum und die aktuelle Uhrzeit auf diesem Computer abzurufen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie Sie den positiven Bereich von Werten abrufen, <xref:System.Environment.TickCount%2A> die von der-Eigenschaft zurückgegeben werden. Die <xref:System.Environment.TickCount%2A> Eigenschaften Zyklen zwischen <xref:System.Int32.MinValue?displayProperty=nameWithType>, eine negative Zahl und <xref:System.Int32.MaxValue?displayProperty=nameWithType> einmal alle 49,8 Tage. Dieses Codebeispiel entfernt das Vorzeichen-Bit, um eine nicht negative Zahl zu erzielen, die <xref:System.Int32.MaxValue> alle 24,9 Tage zwischen null und einmal liegt.  
  
 [!code-cpp[environment.tickcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.TickCount/CPP/tickcount.cpp#1)]
 [!code-csharp[environment.tickcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.TickCount/CS/tickcount.cs#1)]
 [!code-vb[environment.tickcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.TickCount/VB/tickcount.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TickCount64">
      <MemberSignature Language="C#" Value="public static long TickCount64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TickCount64" />
      <MemberSignature Language="DocId" Value="P:System.Environment.TickCount64" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TickCount64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long TickCount64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.TickCount64 : int64" Usage="System.Environment.TickCount64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Millisekunden ab, die seit dem Systemstart verstrichen sind.</summary>
        <value>Die seit dem Systemstart verstrichenen Millisekunden.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserDomainName">
      <MemberSignature Language="C#" Value="public static string UserDomainName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserDomainName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserDomainName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserDomainName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserDomainName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserDomainName : string" Usage="System.Environment.UserDomainName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Netzwerkdomänennamen ab, der dem aktuellen Benutzer zugeordnet ist.</summary>
        <value>Der Netzwerkdomänenname, der dem aktuellen Benutzer zugeordnet ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Anmelde Informationen des Domänen Kontos für einen Benutzer werden als Domänen Name des Benutzers,\\das Zeichen "" und der Benutzername formatiert. Verwenden Sie <xref:System.Environment.UserDomainName%2A> die-Eigenschaft, um den Domänen Namen des Benutzers ohne den Benutzernamen <xref:System.Environment.UserName%2A> abzurufen, und die-Eigenschaft zum Abrufen des Benutzernamens ohne den Domänen Namen.  Wenn der Domänen Name und der Benutzername eines Benutzers beispielsweise "corporatenetwork\john" <xref:System.Environment.UserDomainName%2A> lauten, gibt die Eigenschaft "corporatenetwork" zurück.  
  
 Die <xref:System.Environment.UserDomainName%2A> -Eigenschaft versucht zunächst, die Domänen Namen Komponente des Windows-Konto namens für den aktuellen Benutzer zu erhalten. Wenn dieser Versuch fehlschlägt, versucht diese Eigenschaft, den Domänen Namen zu erhalten, der dem von der <xref:System.Environment.UserName%2A> -Eigenschaft bereitgestellten Benutzernamen zugeordnet ist. Wenn dieser Versuch fehlschlägt, weil der Host Computer keiner Domäne hinzugefügt wurde, wird der Name des Host Computers zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Das Betriebssystem unterstützt nicht das Abrufen des Netzwerkdomänennamens.</exception>
        <exception cref="T:System.InvalidOperationException">Der Netzwerkdomänenname kann nicht abgerufen werden.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für den Lesezugriff auf die User Domain-Umgebungsvariable. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.UserName" />
      </Docs>
    </Member>
    <Member MemberName="UserInteractive">
      <MemberSignature Language="C#" Value="public static bool UserInteractive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UserInteractive" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserInteractive" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserInteractive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UserInteractive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UserInteractive : bool" Usage="System.Environment.UserInteractive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Prozess im interaktiven Modus ausgeführt wird.</summary>
        <value><see langword="true" />, wenn der aktuelle Prozess im interaktiven Modus ausgeführt wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Environment.UserInteractive%2A> -Eigenschaft `false` meldet einen Windows-Prozess oder einen-Dienst wie IIS, der ohne Benutzeroberfläche ausgeführt wird. Wenn diese Eigenschaft ist `false`, werden keine modalen Dialoge oder Meldungs Felder angezeigt, da keine grafische Benutzeroberfläche vorhanden ist, mit der der Benutzer interagieren kann.  
  
   
  
## Examples  
 Im folgenden Beispiel wird angezeigt, ob der aktuelle Prozess im interaktiven Modus ausgeführt wird.  
  
 [!code-cpp[Environment.UserInteractive#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserInteractive/CPP/userinteractive.cpp#1)]
 [!code-csharp[Environment.UserInteractive#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserInteractive/CS/userinteractive.cs#1)]
 [!code-vb[Environment.UserInteractive#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserInteractive/VB/userinteractive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UserName">
      <MemberSignature Language="C#" Value="public static string UserName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserName : string" Usage="System.Environment.UserName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Benutzernamen der Person ab, die derzeit beim Betriebssystem angemeldet ist.</summary>
        <value>Der Benutzername der Person, die beim Betriebssystem angemeldet ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die <xref:System.Environment.UserName%2A> -Eigenschaft verwenden, um den Benutzer für den aktuellen Thread, das System und die Anwendung zu Sicherheits-oder Zugriffs Zwecken zu identifizieren. Sie kann auch verwendet werden, um eine bestimmte Anwendung für jeden Benutzer anzupassen.  
 
 Unter Windows umschließt die <xref:System.Environment.UserName%2A> -Eigenschaft einen Aufrufen der Windows-Funktion " [GetUsername](https://msdn.microsoft.com/library/windows/desktop/ms724432.aspx) ". Die Anmelde Informationen des Domänen Kontos für einen Benutzer werden als Domänen Name des Benutzers,\\das Zeichen "" und der Benutzername formatiert. Verwenden Sie <xref:System.Environment.UserDomainName%2A> die-Eigenschaft, um den Domänen Namen des <xref:System.Environment.UserName%2A> Benutzers und die-Eigenschaft zum Abrufen des Benutzernamens abzurufen.  
 
 Auf UNIX-Platt <xref:System.Environment.UserName%2A> Formen umschließt die-Eigenschaft `getpwuid_r` einen Rückruf für die-Funktion.
 
 Wenn eine ASP.NET-Anwendung in einer Entwicklungsumgebung ausgeführt wird <xref:System.Environment.UserName%2A> , gibt die-Eigenschaft den Namen des aktuellen Benutzers zurück. In einer veröffentlichten ASP.NET-Anwendung gibt diese Eigenschaft den Namen des Anwendungs Pool Kontos (z. b. Standard-AppPool) zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Benutzername der Person angezeigt, die den aktuellen Thread gestartet hat.  
  
 [!code-cpp[Environment.UserName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserName/CPP/username.cpp#1)]
 [!code-csharp[Environment.UserName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserName/CS/username.cs#1)]
 [!code-vb[Environment.UserName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserName/VB/username.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für den Lesezugriff auf die Benutzername-Umgebungsvariable. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.UserDomainName" />
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public static Version Version { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Version Version" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Version" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Version As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Version ^ Version { Version ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Version : Version" Usage="System.Environment.Version" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Version" />-Objekt ab, das die Nummern für Haupt- und Nebenversion, Build und Revision der Common Language Runtime beschreibt.</summary>
        <value>Ein Objekt, das die Version der Common Language Runtime anzeigt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei den .NET Framework-Versionen 4, 4.5, 4.5.1 und 4.5.2 gibt die <xref:System.Environment.Version%2A?displayProperty=nameWithType>Eigenschaft ein <xref:System.Version>-Objekt zurück, dessen Zeichenfolgedarstellung die Form `4.0.30319.xxxxx`besitzt. Für den .NET Framework 4,6 und höhere Versionen hat er das `4.0.30319.42000`Format.  
  
> [!WARNING]
>  Für und höher wird die Verwendung der <xref:System.Environment.Version%2A> -Eigenschaft zum Erkennen der Laufzeitversion nicht empfohlen. stattdessen können Sie die Version der Common Language Runtime bestimmen, indem Sie die Registrierung Abfragen. [!INCLUDE[net_v45](~/includes/net-v45-md.md)] Weitere Informationen finden Sie unter [Vorgehensweise: Determine Which .NET Framework Versions Are Installed](~/docs/framework/migration-guide/how-to-determine-which-versions-are-installed.md) (Bestimmen der installierten .NET Framework-Versionen).  
  
 Weitere Informationen zur Version der Common Language Runtime, die mit jeder Version der .NET Framework installiert wird, finden Sie unter [Versionen und Abhängigkeiten](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Version der Common Language Runtime angezeigt. (Die-Version wird aus Sicherheitsgründen aus der Beispielausgabe weggelassen.)  
  
 [!code-cpp[Environment.Version#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.Version/CPP/version.cpp#1)]
 [!code-csharp[Environment.Version#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.Version/CS/version.cs#1)]
 [!code-vb[Environment.Version#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.Version/VB/version.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public static long WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Environment.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property WorkingSet As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long WorkingSet { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int64" Usage="System.Environment.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe des physischen Speichers ab, der dem Prozesskontext zugeordnet ist.</summary>
        <value>Eine 64-Bit-Ganzzahl mit Vorzeichen, die die Größe des dem Prozesskontext zugeordneten physischen Speichers in Bytes angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird die Größe des Workingsets des Computers angezeigt, auf dem das Codebeispiel ausgeführt wird.  
  
 [!code-cpp[Environment.WorkingSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.WorkingSet/CPP/workingset.cpp#1)]
 [!code-csharp[Environment.WorkingSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.WorkingSet/CS/workingset.cs#1)]
 [!code-vb[Environment.WorkingSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.WorkingSet/VB/workingset.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für vollständigen Zugriff auf die durch diese Berechtigung geschützte Ressource. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>
