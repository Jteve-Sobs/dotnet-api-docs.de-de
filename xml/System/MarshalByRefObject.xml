<Type Name="MarshalByRefObject" FullName="System.MarshalByRefObject">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="581d775aac81241d975e88cf7c586e38dbe64827" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36430072" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class MarshalByRefObject" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit MarshalByRefObject extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.MarshalByRefObject" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MarshalByRefObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class MarshalByRefObject abstract" />
  <TypeSignature Language="F#" Value="type MarshalByRefObject = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Ermöglicht den Zugriff auf Objekte über Anwendungsdomänen hinweg in Anwendungen, die Remoting unterstützen.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Anwendungsdomäne ist eine Partition in einem Betriebssystemprozess, auf dem eine oder mehrere Anwendungen befinden. Objekte in der gleichen Anwendungsdomäne direkt miteinander kommunizieren. Objekte in unterschiedlichen Anwendungsdomänen kommunizieren durch das Transportieren von Kopien von Objekten über Anwendungsdomänen hinweg oder mit einem Proxy für den Austausch von Nachrichten.  
  
 <xref:System.MarshalByRefObject> die Basisklasse für Objekte, die über Anwendungsdomänengrenzen hinweg zu kommunizieren, indem Nachrichten ausgetauscht werden, die einen Proxy verwenden. Objekte, die nicht von erben <xref:System.MarshalByRefObject> implizit als Wert gemarshallt werden. Wenn eine Remoteanwendung eine Marshallen von Wertobjekt verwiesen wird, wird eine Kopie des Objekts über Anwendungsdomänengrenzen hinweg übergeben.  
  
 <xref:System.MarshalByRefObject> Objekte direkt innerhalb der Grenzen der lokalen Anwendungsdomäne zugegriffen. Zum ersten Mal eine Anwendung in einer Anwendungsdomäne greift ein <xref:System.MarshalByRefObject>, ein Proxy an die Anwendung übergeben wird. Nachfolgende Aufrufe auf dem Proxy werden zurück an das Objekt im lokalen Anwendungsdomäne gespeicherten gemarshallt.  
  
 Typen müssen von erben <xref:System.MarshalByRefObject> Wenn der Typ über Anwendungsdomänengrenzen hinweg verwendet wird, und der Zustand des Objekts muss nicht kopiert werden, da die Member des Objekts nicht außerhalb der Anwendungsdomäne verwendet werden, in dem sie erstellt wurden.  
  
 Beim Ableiten eines Objekts aus <xref:System.MarshalByRefObject> für die Verwendung über Anwendungsdomänengrenzen hinweg, Sie sollte nicht außer Kraft setzen eines seiner Member noch sollten Sie seine Methoden direkt aufrufen. Die Common Language Runtime erkennt, dass Klassen abgeleitete <xref:System.MarshalByRefObject> über app-Domänengrenzen hinweg gemarshallt werden sollen.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele. Im ersten Codebeispiel wird veranschaulicht, wie eine Instanz einer Klasse in einer anderen Anwendungsdomäne zu erstellen. Das zweite Codebeispiel zeigt eine einfache Klasse, die für das Remoting verwendet werden kann.  
  
 **Beispiel 1**  
  
 Das folgende Codebeispiel zeigt die einfachste Möglichkeit zum Ausführen von Code in einer anderen Anwendungsdomäne. Im Beispiel definiert eine Klasse namens `Worker` erbt <xref:System.MarshalByRefObject>, mit einer Methode, die den Namen der Anwendungsdomäne anzeigt, in der er ausgeführt wird. Das Beispiel erstellt Instanzen von `Worker` in der Standardanwendungsdomäne und in eine neue Anwendungsdomäne.  
  
> [!NOTE]
>  Die Assembly mit `Worker` muss in beide Anwendungsdomänen geladen werden, aber andere Assemblys, die nur in der neuen Anwendungsdomäne vorhanden wäre geladen werden konnte.  
  
 [!code-cpp[CreateInstanceAndUnwrap2#1](~/samples/snippets/cpp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cpp/source.cpp#1)]
 [!code-csharp[CreateInstanceAndUnwrap2#1](~/samples/snippets/csharp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cs/source.cs#1)]
 [!code-vb[CreateInstanceAndUnwrap2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CreateInstanceAndUnwrap2/VB/source.vb#1)]  
  
 **Beispiel 2**  
  
 Das folgende Beispiel veranschaulicht eine Klasse abgeleitet <xref:System.MarshalByRefObject> also verwendete weiter unten in Remoting.  
  
 [!code-cpp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/cpp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CPP/source.cpp#1)]
 [!code-csharp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/csharp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CS/source.cs#1)]
 [!code-vb[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MarshalByRefObject ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MarshalByRefObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MarshalByRefObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.MarshalByRefObject" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObjRef">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.Remoting.ObjRef CreateObjRef (Type requestedType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjRef CreateObjRef(class System.Type requestedType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MarshalByRefObject.CreateObjRef(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateObjRef (requestedType As Type) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjRef ^ CreateObjRef(Type ^ requestedType);" />
      <MemberSignature Language="F#" Value="abstract member CreateObjRef : Type -&gt; System.Runtime.Remoting.ObjRef&#xA;override this.CreateObjRef : Type -&gt; System.Runtime.Remoting.ObjRef" Usage="marshalByRefObject.CreateObjRef requestedType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestedType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="requestedType">Der <see cref="T:System.Type" /> des Objekts, auf das der neue <see cref="T:System.Runtime.Remoting.ObjRef" /> verweist.</param>
        <summary>Erstellt ein Objekt mit allen relevanten Informationen, die zum Generieren eines Proxys für die Kommunikation mit einem Remoteobjekt erforderlich sind.</summary>
        <returns>Zum Generieren eines Proxys erforderliche Informationen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.MarshalByRefObject.CreateObjRef%2A> Methode wird von Methoden zur knotenerstellung Remoteobjekt aufgerufen, wie z. B. <xref:System.AppDomain.CreateInstance%2A?displayProperty=nameWithType> und <xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=nameWithType>. In den meisten Fällen ist gibt es nicht erforderlich, diese Methode überschreiben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException">Diese Instanz ist kein gültiges Remoteobjekt.</exception>
        <exception cref="T:System.Security.SecurityException">Der direkte Aufrufer verfügt nicht über die Berechtigung für die Infrastruktur.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetLifetimeService">
      <MemberSignature Language="C#" Value="public object GetLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MarshalByRefObject.GetLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetLifetimeService();" />
      <MemberSignature Language="F#" Value="abstract member GetLifetimeService : unit -&gt; obj&#xA;override this.GetLifetimeService : unit -&gt; obj" Usage="marshalByRefObject.GetLifetimeService " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft das aktuelle Lebensdauerdienstobjekt ab, das die Lebensdauerrichtlinien für diese Instanz steuert.</summary>
        <returns>Ein Objekt vom Typ <see cref="T:System.Runtime.Remoting.Lifetime.ILease" />, das zur Steuerung der Lebensdauerrichtlinien für diese Instanz verwendet wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen über Lebensdauerdienste finden Sie unter der <xref:System.Runtime.Remoting.Lifetime.LifetimeServices> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der direkte Aufrufer verfügt nicht über die Berechtigung für die Infrastruktur.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="InitializeLifetimeService">
      <MemberSignature Language="C#" Value="public virtual object InitializeLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InitializeLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MarshalByRefObject.InitializeLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function InitializeLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InitializeLifetimeService();" />
      <MemberSignature Language="F#" Value="abstract member InitializeLifetimeService : unit -&gt; obj&#xA;override this.InitializeLifetimeService : unit -&gt; obj" Usage="marshalByRefObject.InitializeLifetimeService " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft ein Lebensdauerdienstobjekt zur Steuerung der Lebensdauerrichtlinie für diese Instanz ab.</summary>
        <returns>Ein Objekt vom Typ <see cref="T:System.Runtime.Remoting.Lifetime.ILease" />, das zur Steuerung der Lebensdauerrichtlinien für diese Instanz verwendet wird. Dies ist das aktuelle Lebensdauerdienstobjekt für diese Instanz, sofern vorhanden, bzw. ein neues Lebensdauerdienstobjekt, das mit dem Wert der <see cref="P:System.Runtime.Remoting.Lifetime.LifetimeServices.LeaseManagerPollTime" />-Eigenschaft initialisiert wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen über Lebensdauerdienste finden Sie unter der <xref:System.Runtime.Remoting.Lifetime.LifetimeServices> Klasse.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Erstellen einer Leases.  
  
 [!code-cpp[Classic MarshalByRefObject.InitializeLifetimeService Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MarshalByRefObject.InitializeLifetimeService Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MarshalByRefObject.InitializeLifetimeService Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MarshalByRefObject.InitializeLifetimeService Example/CS/source.cs#1)]
 [!code-vb[Classic MarshalByRefObject.InitializeLifetimeService Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MarshalByRefObject.InitializeLifetimeService Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der direkte Aufrufer verfügt nicht über die Berechtigung für die Infrastruktur.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="MemberwiseClone">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine flache Kopie des aktuellen Objekts.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected MarshalByRefObject MemberwiseClone (bool cloneIdentity);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.MarshalByRefObject MemberwiseClone(bool cloneIdentity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MarshalByRefObject.MemberwiseClone(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone (cloneIdentity As Boolean) As MarshalByRefObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MarshalByRefObject ^ MemberwiseClone(bool cloneIdentity);" />
      <MemberSignature Language="F#" Value="override this.MemberwiseClone : bool -&gt; MarshalByRefObject" Usage="marshalByRefObject.MemberwiseClone cloneIdentity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.MarshalByRefObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cloneIdentity" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="cloneIdentity">
          <see langword="false" /> zum Löschen der Identität des aktuellen <see cref="T:System.MarshalByRefObject" />-Objekts. Dies führt dazu, dass dem Objekt eine neue Identität zugewiesen wird, wenn es über eine Remotegrenze gemarshallt wird. Der Wert <see langword="false" /> ist in der Regel geeignet. <see langword="true" />, wenn die Identität des aktuellen <see cref="T:System.MarshalByRefObject" /> in dessen Klon kopiert werden soll. Das führt dazu, dass Remoteclient-Aufrufe an das Remoteserverobjekt weitergeleitet werden.</param>
        <summary>Erstellt eine flache Kopie des aktuellen <see cref="T:System.MarshalByRefObject" />-Objekts.</summary>
        <returns>Eine flache Kopie des aktuellen <see cref="T:System.MarshalByRefObject" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.MarshalByRefObject.MemberwiseClone%28System.Boolean%29> Methode erstellt eine flache Kopie durch Erstellen eines neuen <xref:System.MarshalByRefObject> -Objekt, und kopieren Sie die nicht statischen Felder des aktuellen <xref:System.MarshalByRefObject> -Objekt, das neue Objekt. Wenn ein Feld ein Werttyp ist, erfolgt eine Bit für Bit-Kopie des Felds. Wenn ein Feld ein Verweistyp ist, wird der Verweis kopiert, aber das referenzierte Objekt ist nicht; das ursprüngliche Objekt und dessen Klon sich daher auf das gleiche Objekt beziehen.  
  
 Betrachten Sie beispielsweise eine <xref:System.MarshalByRefObject> x, Objekte A und B, verweist, das Objekt verweist wiederum auf Objekt C. Eine flache Kopie von X erstellt neue Objekt X2, das auch Objekte A und b verweist Im Gegensatz dazu eine tiefe Kopie von X erstellt ein neues Objekt X2, die verweist auf die neuen Objekte A2 und B2, die Kopien von A und b B2 verweist wiederum auf das neue Objekt C2, der eine Kopie C. Verwenden einer Klasse implementiert die <xref:System.ICloneable> Schnittstelle, um eine tief oder flach c ausführen Kopieren eines Objekts.  
  
 Die Identität des ein <xref:System.MarshalByRefObject> Objekt ist als der Remoteserver-Objekt, das das Ziel eines Aufrufs der Remoting-Client ist definiert. Wird standardmäßig die memberspezifische Kopie einer <xref:System.MarshalByRefObject> Objekt hat die gleiche Identität wie das ursprüngliche Objekt, die in der Regel nicht das richtige Verhalten nach Klonen dieses serverseitige Objekte, die über eine Remotegrenze mit dem clientseitigen gemarshallt werden. Geben Sie `false`, also normalerweise sinnvoll, die Identität des Klons zu löschen und eine neue Identität zugewiesen werden, wenn der Klon über eine Remotegrenze gemarshallt wird oder `true` , dazu führen, dass den Klon die Identität des ursprünglichen beibehaltenwerdensollen.<xref:System.MarshalByRefObject> Objekt. Die <xref:System.MarshalByRefObject.MemberwiseClone%28System.Boolean%29> Methode von Entwicklern zum Implementieren von remote-Server-Objekte verwendet werden soll.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>