<Type Name="Random" FullName="System.Random">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7a2c42b4da1c7b0ee11963dcad14520dc83134e6" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52238570" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Random" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Random extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Random" />
  <TypeSignature Language="VB.NET" Value="Public Class Random" />
  <TypeSignature Language="C++ CLI" Value="public ref class Random" />
  <TypeSignature Language="F#" Value="type Random = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt einen Generator für Pseudozufallszahlen dar, d. h. ein Gerät, das eine Zahlenfolge erzeugt, die bestimmte statistische Anforderungen hinsichtlich ihrer Zufälligkeit erfüllt.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pseudozufallszahlen werden von einer begrenzten Menge von Zahlen mit gleicher Wahrscheinlichkeit ausgewählt. Die gewählten Zahlen sind nicht vollständig wahlfreien, da ein mathematischer Algorithmus verwendet wird, um sie auszuwählen, aber sie für praktische Zwecke ausreichend zufälligen sind. Die aktuelle Implementierung von der <xref:System.Random> Klasse basiert darauf, dass eine geänderte Version des Donald E. Knuths Subtraktive Algorithmus mit Zufallszahlengenerator. Weitere Informationen finden Sie unter d E. Knuth. *The Art of Computer Programming "," Volume 2: Seminumerical Algorithms*. Addison-Wesley, lesen, MA, 3. Auflage, 1997.  
  
 Verwenden Sie eine kryptografisch sichere Zufallszahl, z. B. ein generieren, die für Sie erstellen ein zufälliges Kennwort, geeignet ist die <xref:System.Security.Cryptography.RNGCryptoServiceProvider> Klasse oder leiten eine Klasse von <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>.  
  
 In diesem Thema:  
  
 [Instanziieren den Zufallszahlengenerator](#Instantiate)   
 [Vermeiden Sie mehrere Instanziierungen von](#Multiple)   
 [Der System.Random-Klasse und Threadsicherheit](#ThreadSafety)   
 [Generieren von anderen Typen von Zufallszahlen](#Functionality)   
 [Ersetzen einen eigenen Algorithmus](#Overriding)   
 [Wie verwenden Sie "System.Random", um...](#Operations)   
 [Rufen Sie die gleiche Sequenz von zufälligen Werten](#Same)  
 [Eindeutige Sequenzen von zufälligen Werten abrufen](#Unique)  
 [Abrufen von ganzen Zahlen in einem angegebenen Bereich](#Range)  
 [Abrufen von ganzen Zahlen mit einer angegebenen Anzahl von Ziffern](#Digits)  
 [Gleitkommawerte in einem angegebenen Bereich abrufen](#Floats)  
 [Generieren von zufälligen boolesche Werte](#Boolean)  
 [Generieren von zufälligen 64-Bit-Ganzzahlen](#Long)  
 [Abrufen der Bytes in einem angegebenen Bereich](#Bytes)  
 [Ein Element nach dem Zufallsprinzip aus einem Array oder einer Auflistung abrufen](#Array)  
 [Ein eindeutiges Element aus einem Array oder einer Auflistung abrufen](#UniqueArray)  
  
<a name="Instantiate"></a>   
## <a name="instantiating-the-random-number-generator"></a>Instanziieren den Zufallszahlengenerator  
 Instanziieren Sie den Zufallszahlen-Generator durch Angeben eines Ausgangswert-Werts (ein Startwert für den Algorithmus von Pseudozufallszahlen Generation) zu einem <xref:System.Random.%23ctor%2A> Klassenkonstruktor.  Sie können den Ausgangswert entweder explizit oder implizit bereitstellen:  
  
-   Die <xref:System.Random.%23ctor%28System.Int32%29> Konstruktor verwendet einen expliziten Seed-Wert, den Sie angeben.  
  
-   Die <xref:System.Random.%23ctor> Konstruktor verwendet die Systemuhr, um einen Ausgangswert angeben. Dies ist die gängigste Methode instanziieren Sie den Zufallszahlengenerator an.  
  
 Wenn der gleiche Ausgangswert, für einzelne verwendet wird <xref:System.Random> Objekten, die sie die gleiche Reihe von Zufallszahlen generiert. Dies kann nützlich für das Erstellen einer Testsammlung aus, die zufällige Werte verarbeitet oder für die Wiedergabe von Spielen, die ihre Daten von Zufallszahlen abgeleitet sein. Beachten Sie jedoch, dass <xref:System.Random> Objekte in Prozesse, die unter unterschiedlichen Versionen von .NET Framework ausgeführt werden. möglicherweise verschiedene Folge von Zufallszahlen zurück, selbst wenn sie mit dem identischen Startwerten instanziiert werden.  
  
 Um verschiedene Sequenzen von Zufallszahlen zu generieren, können Sie vornehmen den Ausgangswert zeitabhängige, und erzeugt eine andere Datenreihe mit jeder neuen Instanz von <xref:System.Random>. Die parametrisierte <xref:System.Random.%23ctor%28System.Int32%29> Konstruktor dauert ein <xref:System.Int32> -Wert auf Grundlage der Anzahl der Ticks in der aktuellen Zeit, während die parameterlose <xref:System.Random.%23ctor> Konstruktor verwendet die Systemuhr zum Generieren des Startwerts. Aber da die Uhr endliche Auflösung verfügt, mithilfe des Konstruktors unterschiedlichen <xref:System.Random> Objekte unmittelbar nacheinander erstellt random Number-Generatoren, die identische Sequenzen von Zufallszahlen zu generieren. Im folgende Beispiel wird veranschaulicht, wie zwei <xref:System.Random> Objekte, die unmittelbar nacheinander instanziiert werden, generieren eine identische Folge von Zufallszahlen. In den meisten Windows-Systemen <xref:System.Random> innerhalb von 15 Millisekunden voneinander erstellten Objekte haben wahrscheinlich identische Ausgangswerte.  
  
 [!code-cpp[System.Random#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)]
 [!code-csharp[System.Random#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)]
 [!code-vb[System.Random#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)]  
  
 Um dieses Problem zu vermeiden, erstellen Sie eine einzelne <xref:System.Random> Objekt anstelle mehrerer Objekte.  
  
<a name="Multiple"></a>   
## <a name="avoiding-multiple-instantiations"></a>Vermeiden Sie mehrere Instanziierungen von  
 Initialisieren von zwei random Number-Generatoren in einer engen Schleife oder in rascher Folge erstellt zwei random Number-Generatoren, die identische Sequenzen von Zufallszahlen erzeugen können. In den meisten Fällen Dies ist nicht der Entwickler den Zweck und kann zu Leistungseinbußen zu vermeiden, führen, da instanziieren und Initialisieren eines Zufallszahlen-Generators ein relativ teurer Vorgang ist.  
  
 Sowohl zum Verbessern der Leistung und verhindern, dass versehentlich erstellt separate random Number-Generatoren, die identische numerische Sequenzen zu generieren, es wird empfohlen, dass Sie eine erstellen <xref:System.Random> Objekt, das viele zufällige Zahlen im Laufe der Zeit, statt zu generieren. neue <xref:System.Random> Objekte, die eine Zufallszahl zu generieren.  
  
 Allerdings die <xref:System.Random> Klasse nicht threadsicher. Wenn Sie aufrufen <xref:System.Random> Methoden von mehreren Threads, befolgen Sie die Richtlinien, die im nächsten Abschnitt erläutert.  
  
<a name="ThreadSafety"></a>   
## <a name="the-systemrandom-class-and-thread-safety"></a>Der System.Random-Klasse und Threadsicherheit  
 Anstelle von instanziieren Person <xref:System.Random> Objekte, es wird empfohlen, erstellen Sie eine einzelne <xref:System.Random> Instanz, um alle von der Anwendung benötigten Zufallszahlen zu generieren. Allerdings <xref:System.Random> Objekte sind nicht threadsicher. Wenn Ihre app aufruft <xref:System.Random> Methoden von mehreren Threads, Sie müssen ein Synchronisierungsobjekt verwenden, um sicherzustellen, dass nur ein Thread den Zufallszahlengenerator gleichzeitig zugreifen kann. Wenn Sie nicht sicherstellen, dass die <xref:System.Random> Objekt Zugriff auf eine threadsichere Möglichkeit, Aufrufe von Methoden, die Zufallszahlen zurückzugeben, gibt 0 zurück.  
  
 Im folgenden Beispiel wird der C#- [lock-Anweisung](~/docs/csharp/language-reference/keywords/lock-statement.md) und die Visual Basic [SyncLock-Anweisung](~/docs/visual-basic/language-reference/statements/synclock-statement.md) um sicherzustellen, dass ein einzelnes Zufallszahlen-Generators von 11 Threads auf threadsichere Weise zugegriffen wird. Jeder Thread 2 Millionen Zufallszahlen generiert, zählt die Anzahl von Zufallszahlen generiert, deren Summe berechnet und aktualisiert dann die Gesamtwerte für alle Threads aus, wenn sie mit der Ausführung beendet ist.  
  
 [!code-cpp[System.Random#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)]
 [!code-csharp[System.Random#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)]
 [!code-vb[System.Random#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)]  
  
 Im Beispiel wird Threadsicherheit sichergestellt, es gibt folgende Möglichkeiten:  
  
-   Die <xref:System.ThreadStaticAttribute> Attribut wird verwendet, um die Thread-lokalen Variablen zu definieren, die die Gesamtzahl der Zufallszahlen generiert und die Summe für jeden Thread nachverfolgen.  
  
-   Eine Sperre (die `lock` -Anweisung in c# und die `SyncLock` -Anweisung in Visual Basic) schützt den Zugriff auf die Variablen für die Gesamtanzahl und die Summe aller zufälligen Zahlen, die auf alle Threads generiert.  
  
-   Ein Semaphor (die <xref:System.Threading.CountdownEvent> Objekt) wird verwendet, um sicherzustellen, dass der Hauptthread blockiert, bis alle anderen Threads vollständig ausgeführt.  
  
-   Im Beispiel wird überprüft, ob für der Zufallszahlengenerator durch bestimmen beschädigt wurde, ob zwei aufeinander folgende Aufrufe von Zufallszahlen generieren, Methoden 0 zurückgegeben. Wenn eine Beschädigung erkannt wird, wird im Beispiel wird die <xref:System.Threading.CancellationTokenSource> -Objekt signalisiert, dass es sich bei allen Threads abgebrochen werden soll.  
  
-   Vor dem Generieren von jeder Zufallszahl jeder Thread überprüft den Status der <xref:System.Threading.CancellationToken> Objekt. Wenn der Abbruch angefordert wird, wird im Beispiel wird die <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> Methode, um den Thread abzubrechen.  
  
 Im folgende Beispiel wird mit dem ersten identisch, außer dass mithilfe einer <xref:System.Threading.Tasks.Task> -Objekt und ein Lambda-Ausdruck anstelle von <xref:System.Threading.Thread> Objekte.  
  
 [!code-csharp[System.Random#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)]
 [!code-vb[System.Random#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)]  
  
 Es unterscheidet sich von dem ersten Beispiel gibt folgenden Möglichkeiten:  
  
-   Die Variablen zum Nachverfolgen der Anzahl von Zufallszahlen generiert und die Summe in jeder Aufgabe gelten lokal in der Aufgabe, daher keine Notwendigkeit besteht, verwenden Sie die <xref:System.ThreadStaticAttribute> Attribut.  
  
-   Die statische <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> Methode wird verwendet, um sicherzustellen, dass der Hauptthread nicht abgeschlossen, bevor alle Aufgaben beendet wurden. Besteht keine Notwendigkeit für die <xref:System.Threading.CountdownEvent> Objekt.  
  
-   Die Ausnahme, die aus den Aufgabenabbruch wird angezeigt, der <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> Methode. Im vorherigen Beispiel wird sie von jedem Thread behandelt.  
  
<a name="Functionality"></a>   
## <a name="generating-different-types-of-random-numbers"></a>Generieren von anderen Typen von Zufallszahlen  
 Der Zufallszahlengenerator bietet Methoden, mit denen Sie die folgenden Arten von Zufallszahlen zu generieren:  
  
-   Eine Reihe von <xref:System.Byte> Werte. Sie bestimmen die Anzahl der Bytewerte durch Übergeben eines Arrays initialisiert, um die Anzahl der Elemente, die Sie möchten, dass die Methode zurückgibt, die <xref:System.Random.NextBytes%2A> Methode. Im folgende Beispiel werden 20 Byte an Daten generiert.  
  
     [!code-cpp[System.Random#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)]
     [!code-csharp[System.Random#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)]
     [!code-vb[System.Random#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)]  
  
-   Eine einzelne ganze Zahl. Sie können auswählen, ob Sie einen Integer zwischen 0 und einen maximalen Wert (<xref:System.Int32.MaxValue?displayProperty=nameWithType> – 1) durch Aufrufen der <xref:System.Random.Next> -Methode, eine ganze Zahl zwischen 0 und einen bestimmten Wert durch Aufrufen der <xref:System.Random.Next%28System.Int32%29> Methode oder eine ganze Zahl in einen Bereich von Werten durch Aufrufen der <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>Methode. In parametrisierten Überladungen ist der angegebene Wert für die maximale exklusive; die aktuelle maximale Anzahl generiert, ist eine kleiner als der angegebene Wert.  
  
     Im folgenden Beispiel wird die <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> Methode, um 10 zufällige Zahlen zwischen-10 und 10 zu generieren. Beachten Sie, dass das zweite Argument für die Methode gibt an, die exklusive obere Grenze des Bereichs von zufälligen Werten, die von der Methode zurückgegeben. Das heißt, die größte ganze Zahl, die die Methode zurückgeben kann eine ist kleiner als dieser Wert.  
  
     [!code-cpp[System.Random#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)]
     [!code-csharp[System.Random#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)]
     [!code-vb[System.Random#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)]  
  
-   Ein einzelner Gleitkommawert Wert von 0,0 kleiner als 1,0 durch Aufrufen der <xref:System.Random.NextDouble%2A> Methode. Die exklusive obere Grenze der Zufallszahl, die von der Methode zurückgegebenen ist 1, damit die tatsächliche Obergrenze 0.99999999999999978 ist. Im folgende Beispiel wird 10 zufällige Gleitkommazahlen generiert.  
  
     [!code-cpp[System.Random#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)]
     [!code-csharp[System.Random#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)]
     [!code-vb[System.Random#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)]  
  
> [!IMPORTANT]
>  Die <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> Methode können Sie den Bereich der zurückgegebenen Zufallszahl an. Allerdings die `maxValue` Parameter gibt an, der obere Bereich Anzahl zurückgegeben wird, wird eine exklusive, keiner inklusiven Wert. Dies bedeutet, dass den Methodenaufruf `Next(0, 100)` gibt einen Wert zwischen 0 und 99 und nicht zwischen 0 und 100 zurück.  
  
 Können Sie auch die <xref:System.Random> -Klasse für Aufgaben wie das Generieren von [Zufallswerte t: System.Boolean](#Boolean), Generieren von [zufällige Gleitkommazahl Werte mit einer Reihe außer 0 bis 1](#Floats), Generieren von [zufälligen 64-Bit-Ganzzahlen](#Long), und [nach dem Zufallsprinzip ein eindeutiges Element aus einem Array oder einer Auflistung abrufen](#UniqueArray). Diese und andere häufige Aufgaben finden Sie in der [wie verwenden Sie "System.Random", um...](#Operations) Abschnitt.  
  
<a name="Overriding"></a>   
## <a name="substituting-your-own-algorithm"></a>Ersetzen einen eigenen Algorithmus  
 Sie können Ihre eigenen Zufallszahlengenerator implementieren, durch Erben von der <xref:System.Random> -Klasse und Ihre random Number-generierungsalgorithmus angeben. Um einen eigenen Algorithmus angeben, müssen Sie überschreiben die <xref:System.Random.Sample%2A> Methode, die die random Number-generierungsalgorithmus implementiert. Sie sollten auch überschreiben, die <xref:System.Random.Next>, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>, und <xref:System.Random.NextBytes%2A> Methoden, um sicherzustellen, dass sie die überschriebene Aufrufen <xref:System.Random.Sample%2A> Methode. Sie müssen keine außer Kraft setzen der <xref:System.Random.Next%28System.Int32%29> und <xref:System.Random.NextDouble%2A> Methoden.  
  
 Ein Beispiel für die abgeleitet der <xref:System.Random> Klasse und ändert dessen Standardwert Zufallszahlengenerator, finden Sie unter den <xref:System.Random.Sample%2A> Referenzseite.  
  
<a name="Operations"></a>   
## <a name="how-do-you-use-systemrandom-to"></a>Wie verwenden Sie "System.Random", um...  
 In den folgenden Abschnitten erörtern und stellen entsprechenden Beispielcode für einige der Möglichkeiten, die Zufallszahlen in Ihrer app verwenden möchten.  
  
<a name="Same"></a>   
### <a name="retrieve-the-same-sequence-of-random-values"></a>Rufen Sie die gleiche Sequenz von zufälligen Werten  
 Manchmal möchten Sie die gleiche Sequenz von Zufallszahlen zu generieren, in Testszenarien und Spiele zu spielen. Mit derselben Sequenz von Zufallszahlen testen, können Sie Regressionen erkennen und Fehlerbehebungen zu bestätigen. Verwenden die gleiche Sequenz von Zufallszahl bei Spielen, können Sie vorherigen Spiele wiedergeben.  
  
 Sie können die gleiche Sequenz von Zufallszahlen generieren, indem Sie den gleichen Ausgangswert zum Bereitstellen der <xref:System.Random.%23ctor%28System.Int32%29> Konstruktor. Der Ausgangswert enthält einen Startwert für das Pseudo-random Number-generierungsalgorithmus. Im folgenden Beispiel wird 100100 als einen beliebigen Startwert zum Instanziieren der <xref:System.Random> zeigt 20 zufällige Gleitkommazahlen-Punktwerte-Objekt, und die Seed-Wert beibehalten. Anschließend wird den Startwert, instanziiert einen neuen Zufallszahlen-Generator, und zeigt die gleichen 20 zufällige Gleitkommazahlen-Punktwerte.  Beachten Sie, dass im Beispiel verschiedene Sequenzen der Zufallszahlen erzeugen kann, wenn unterschiedliche Versionen von .NET Framework ausgeführt.  
  
 [!code-cpp[System.Random#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp#12)]
 [!code-csharp[System.Random#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs#12)]
 [!code-vb[System.Random#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb#12)]  
  
<a name="Unique"></a>   
### <a name="retrieve-unique-sequences-of-random-numbers"></a>Abrufen von eindeutige Sequenzen von Zufallszahlen  
 Bereitstellen von Werten der anderen Startwert auf Instanzen von der <xref:System.Random> Klasse bewirkt, dass jede Zufallszahlengenerator, um eine andere Sequenz von Werten zu erzeugen. Sie können einem Ausgangswert angeben, entweder explizit durch Aufrufen der <xref:System.Random.%23ctor%28System.Int32%29> Konstruktor oder implizit durch Aufrufen der <xref:System.Random.%23ctor> Konstruktor. Die meisten Entwickler rufen Sie den parameterlosen Konstruktor, der die Systemuhr verwendet. Im folgenden Beispiel wird dieser Ansatz zum Instanziieren zweier <xref:System.Random> Instanzen. Jede Instanz wird eine Reihe von 10 zufällige ganze Zahlen angezeigt.  
  
 [!code-cpp[System.Random#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp#13)]
 [!code-csharp[System.Random#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs#13)]
 [!code-vb[System.Random#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb#13)]  
  
 Jedoch aufgrund der begrenzten Auflösung erkennt die Systemuhr Zeitunterschiede nicht, die weniger als etwa 15 Millisekunden. Aus diesem Grund Wenn Ihr Code Ruft die <xref:System.Random.%23ctor> -Überladung verwenden, um zwei instanziieren <xref:System.Random> Objekte nacheinander Sie versehentlich geleistet werden die Objekte mit dem Startwerten identisch. Um dies im vorherigen Beispiel zu sehen, kommentieren Sie die <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> -Methodenaufruf, und kompilieren und führen Sie das Beispiel erneut aus.  
  
 Um dies zu verhindern, wird empfohlen, Sie ein einzelnes instanziieren <xref:System.Random> -Objekt statt mehrere. Da jedoch <xref:System.Random> ist nicht threadsicher ist, müssen Sie einige Synchronisierung-Gerät verwenden, wenn Sie Zugriff auf eine <xref:System.Random> -Instanz; Weitere Informationen von mehreren Threads verwenden, finden Sie unter [der Random-Klasse und Threadsicherheit](#ThreadSafety) weiter oben in diesem In diesem Thema. Alternativ können Sie können einen verzögerungsmechanismus, z. B. die <xref:System.Threading.Thread.Sleep%2A> Methode, die im vorherigen Beispiel verwendet, um sicherzustellen, dass die Instanziierungen, mehr als 15 Millisekunden voneinander entfernt auftreten.  
  
<a name="Range"></a>   
### <a name="retrieve-integers-in-a-specified-range"></a>Abrufen von ganzen Zahlen in einem angegebenen Bereich  
 Sie können die ganzen Zahlen in einem angegebenen Bereich abrufen, durch den Aufruf der <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> -Methode, die können Sie angeben, sowohl für die untere als auch für die obere Grenze der Zahlen den Zufallszahlengenerator zurückgegeben werden sollen. Die Obergrenze ist eine exklusive, keiner inklusiven Wert. Es ist, also nicht in den Bereich der Werte, die von der Methode zurückgegebenen enthalten. Im folgenden Beispiel wird diese Methode zum Generieren von zufälliger Zahlen zwischen-10 und 10. Beachten Sie, dass es 11 gibt, der eins größer ist als der Wert den gewünschten Wert von der `maxValue` Argument im Aufruf Methode.  
  
 [!code-cpp[System.Random#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)]
 [!code-csharp[System.Random#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)]
 [!code-vb[System.Random#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)]  
  
<a name="Digits"></a>   
### <a name="retrieve-integers-with-a-specified-number-of-digits"></a>Abrufen von ganzen Zahlen mit einer angegebenen Anzahl von Ziffern  
 Rufen Sie die <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> Methode zum Abrufen von Zahlen mit einer angegebenen Anzahl von Ziffern. Beispielsweise zum Abrufen von Zahlen mit vier Ziffern (d. h. Zahlen, die zwischen 1000 und 9999 liegen), rufen Sie die <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> -Methode mit einer `minValue` Wert 1000 und ein `maxValue` Wert 10.000, wie im folgenden Beispiel gezeigt.  
  
 [!code-cpp[System.Random#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)]
 [!code-csharp[System.Random#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)]
 [!code-vb[System.Random#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)]  
  
<a name="Floats"></a>   
### <a name="retrieve-floating-point-values-in-a-specified-range"></a>Gleitkommawerte in einem angegebenen Bereich abrufen  
 Die <xref:System.Random.NextDouble%2A> Methodenrückgabe zufällige Gleitkommazahlen-Punktwerte diesen Bereich von 0 auf weniger als 1. Sie sollten jedoch häufig zum Generieren von zufälliger Werten in einigen anderen Bereich zu können.  
  
 Wenn das Intervall zwischen den minimalen und maximalen Werten für den gewünschten 1 ist, können Sie den Unterschied zwischen den gewünschten ab Abstand und 0 hinzufügen, um die Anzahl von zurückgegebenen der <xref:System.Random.NextDouble%2A> Methode. Im folgende Beispiel wird um 10 Zufallszahlen zwischen-1 und 0.  
  
 [!code-cpp[System.Random#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)]
 [!code-csharp[System.Random#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)]
 [!code-vb[System.Random#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)]  
  
 Um zufällige Gleitkommazahlen generiert wird, dessen untere Grenze 0 aber Obergrenze ist größer als 1 (oder, bei negativen Zahlen, dessen untere Grenze ist kleiner als-1 und obere Grenze ist 0), Multiplizieren Sie die Zufallszahl an, mit der Grenze ungleich NULL. Im folgende Beispiel wird diese Option, um 20 Millionen zufällige Gleitkommazahlen generiert dieses Bereichs von 0 bis <xref:System.Int64.MaxValue?displayProperty=nameWithType>. In zeigt außerdem die Verteilung der zufälligen Werte von der Methode generiert.  
  
 [!code-cpp[System.Random#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)]
 [!code-csharp[System.Random#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)]
 [!code-vb[System.Random#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)]  
  
 Um zufällige Gleitkommazahlen zwischen zwei beliebigen Werten zu generieren, wie die <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> Methode für ganze Zahlen ist, verwenden Sie die folgende Formel:  
  
```csharp  
Random.NextDouble() * (maxValue – minValue) + minValue  
```  
  
 Das folgende Beispiel generiert von 1 Mio. Zufallszahlen, die den Bereich aus 10.0 auf 11.0 und zeigt die Verteilung.  
  
 [!code-cpp[System.Random#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)]
 [!code-csharp[System.Random#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)]
 [!code-vb[System.Random#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)]  
  
<a name="Boolean"></a>   
### <a name="generate-random-boolean-values"></a>Generieren von zufälligen boolesche Werte  
 Die <xref:System.Random> Klasse nicht die Methoden zur Erstellung bereitstellen <xref:System.Boolean> Werte. Allerdings können Sie Ihre eigenen Klasse oder Methode dafür definieren. Das folgende Beispiel definiert eine Klasse, `BooleanGenerator`, mit einer einzelnen Methode, `NextBoolean`. Die `BooleanGenerator` -Klasse speichert ein <xref:System.Random> -Objekt als eine private Variable. Die `NextBoolean` Methodenaufrufe der <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> Methode und übergibt das Ergebnis an die <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType> Methode. Beachten Sie, dass 2 als Argument an die obere Grenze der Zufallszahl verwendet wird. Da dies ein ausgeschlossener Wert ist, gibt der Aufruf der Methode zurück, 0 oder 1.  
  
 [!code-cpp[System.Random#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp#8)]
 [!code-csharp[System.Random#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs#8)]
 [!code-vb[System.Random#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb#8)]  
  
 Statt eine separate Klasse für das Generieren von zufälligen <xref:System.Boolean> Werte im Beispiel können einfach eine einzelne Methode definiert haben. In diesem Fall jedoch die <xref:System.Random> Objekt sollte als eine Variable auf Klassenebene, um zu vermeiden, Instanziierung eines neuen definiert wurden <xref:System.Random> -Instanz in jedem Methodenaufruf. In Visual Basic die Random-Instanz definiert werden kann, als eine [statische](~/docs/visual-basic/language-reference/modifiers/static.md) -Variable in der `NextBoolean` Methode.  Im folgende Beispiel stellt eine Implementierung bereit.  
  
 [!code-cpp[System.Random#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)]
 [!code-csharp[System.Random#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)]
 [!code-vb[System.Random#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)]  
  
<a name="Long"></a>   
### <a name="generate-random-64-bit-integers"></a>Generieren von zufälligen 64-Bit-Ganzzahlen  
 Die Überladungen der <xref:System.Random.Next%2A> Methodenrückgabewert 32-Bit-Ganzzahlen. In einigen Fällen möchten jedoch möglicherweise arbeiten mit der 64-Bit-Ganzzahlen. Sie können dies wie folgt tun:  
  
1.  Rufen Sie die <xref:System.Random.NextDouble%2A> Datenpunkt Methode zum Abrufen der Gleitkommazahl mit doppelter Genauigkeit.  
  
2.  Multiplizieren Sie diesen Wert durch <xref:System.Int64.MaxValue?displayProperty=nameWithType>.  
  
 Im folgende Beispiel verwendet dieses Verfahren zum Generieren von 20 Millionen zufälliger ganzer lange Zahlen und stuft sie in 10 gleich große Gruppen. Er wertet dann die Verteilung der zufälligen Zahlen durch zählen der Anzahl in jeder Gruppe von 0 bis <xref:System.Int64.MaxValue?displayProperty=nameWithType>. Wie die Ausgabe des Beispiels zeigt, werden die Zahlen über den Bereich einer langen ganzen Zahl mehr oder weniger gleichmäßig verteilt.  
  
 [!code-cpp[System.Random#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)]
 [!code-csharp[System.Random#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)]
 [!code-vb[System.Random#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)]  
  
 Alternatives Verfahren, dass Bitmanipulation verwendet keine echten Zufallszahlen generiert. Diese Methode ruft <xref:System.Random.Next> zum Generieren von zwei ganzen Zahlen, links verschiebt eine von 32 Bits und OR werden zusammen. Diese Technik bietet zwei Einschränkungen:  
  
1.  Da Bit 31 das signierte Bit ist, ist der Wert in 31 Bit, das sich ergebende langen ganzen Zahl immer 0.  Dies kann behoben werden, durch Generieren einer zufälligen 0 oder 1, es links-Verschiebung, 31 Bits und oder-Verknüpfung mit der ursprünglichen zufällige lange ganze Zahl.  
  
2.  Doch Spaß beiseite, da die Wahrscheinlichkeit, die den Rückgabewert von <xref:System.Random.Next> 0, wird ggf. einige zufällig gewählte Zahlen im Bereich von 0 x 0 – 0x00000000FFFFFFFF.  
  
<a name="Bytes"></a>   
### <a name="retrieve-bytes-in-a-specified-range"></a>Abrufen der Bytes in einem angegebenen Bereich  
 Die Überladungen von der <xref:System.Random.Next%2A> Methode ermöglichen Ihnen die Angabe des Bereichs von Zufallszahlen, aber die <xref:System.Random.NextBytes%2A> Methode nicht. Das folgende Beispiel implementiert eine `NextBytes` -Methode, die Sie den Bereich der zurückgegebenen Bytes angeben kann. Definiert eine `Random2` abgeleitete Klasse <xref:System.Random> und überlädt die `NextBytes` Methode.  
  
 [!code-cpp[System.Random#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp#9)]
 [!code-csharp[System.Random#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs#9)]
 [!code-vb[System.Random#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb#9)]  
  
 Die `NextBytes(Byte[], Byte, Byte)` Methode umschließt einen Aufruf der <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> Methode und gibt den minimalen Wert und eine, die größer als der maximale Wert (in diesem Fall 0 und 101), dass wir in das Bytearray zurückgegeben werden sollen. Da wir Sie sicher sind, dass die ganzzahligen Werte von zurückgegeben. die <xref:System.Random.Next%2A> Methode werden innerhalb des Bereichs von der <xref:System.Byte> -Datentyp, wir können sicher umgewandelt werden (in c#) oder konvertieren Sie sie (in Visual Basic) von ganzen Zahlen, in Byte.  
  
<a name="Array"></a>   
### <a name="retrieve-an-element-from-an-array-or-collection-at-random"></a>Ein Element nach dem Zufallsprinzip aus einem Array oder einer Auflistung abrufen  
 Zufallszahlen dienen häufig als Indizes, um Werte aus Arrays oder Auflistungen abzurufen. Um einen zufälligen Indexwert abzurufen, können Sie Aufrufen der <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> -Methode, und verwenden Sie die untere Grenze des Arrays als Wert für die `minValue` Argument und eins größer ist als die obere Grenze des Arrays als Wert für die `maxValue` Argument. Für ein nullbasiertes Array, dies entspricht der <xref:System.Array.Length%2A> Eigenschaft oder eins größer ist als der Rückgabewert von der <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> Methode. Im folgende Beispiel ruft den Namen einer Stadt in den Vereinigten Staaten nach dem Zufallsprinzip aus einem Array aus Städten ab.  
  
 [!code-cpp[System.Random#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)]
 [!code-csharp[System.Random#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)]
 [!code-vb[System.Random#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)]  
  
<a name="UniqueArray"></a>   
### <a name="retrieve-a-unique-element-from-an-array-or-collection"></a>Ein eindeutiges Element aus einem Array oder einer Auflistung abrufen  
 Eine Zufallszahlen-Generators kann doppelte Werte immer zurück. Der Bereich der Werte kleiner wird, oder die Anzahl der Werte, die generiert wird, größer, steigt die Wahrscheinlichkeit von Duplikaten. Wenn zufällige Werte eindeutig sein müssen, werden weitere Zahlen generiert, um Duplikate zu kompensieren zunehmend eine schlechte Leistung.  
  
 Es gibt eine Reihe von Techniken zum Behandeln dieses Szenarios. Eine gängige Lösung ist ein Array oder -Auflistung, die die Werte enthält, abgerufen werden sollen, und ein paralleles Array, das zufällige Gleitkommazahlen enthält zu erstellen. Das zweite Array wird mit Zufallszahlen gefüllt, die zum Zeitpunkt der erste Array erstellt, und die <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> Methode wird verwendet, um das erste Array zu sortieren, indem Sie mithilfe der Werte in den parallelen Arrays.  
  
 Z. B. Wenn Sie ein Spiel Solitaire entwickeln, möchten Sie sicherstellen, dass jede Karte nur einmal verwendet wird. Anstatt Zufallszahlen zum Abrufen einer Karte und nachverfolgt, ob die Karte bereits behandelt wurde, können Sie ein paralleles Array von Zufallszahlen erstellen, die verwendet werden können, um den Stapel zu sortieren. Nach der Kartenstapel sortiert ist, kann Ihre app einen Zeiger, um anzugeben, den Index der nächsten Karte des Kartenstapels beibehalten.  
  
 Dieser Ansatz wird anhand des folgenden Beispiels veranschaulicht. Definiert eine `Card` Klasse die darstellt, die eine Spielkarte und einen `Dealer` -Klasse, die einen Satz mischenden Karten behandelt. Die `Dealer` Klassenkonstruktor füllt zwei Arrays: eine `deck` Array, das über einen Klassenbereich und, das alle Karten des Kartenstapels; und einem lokalen darstellt `order` Array, das die gleiche von Elementen wie Anzahl die `deck` array und aufgefüllt mit nach dem Zufallsprinzip generiert <xref:System.Double> Werte.  Die <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> Methode wird aufgerufen, um das Sortieren der `deck` Array basierend auf den Werten in der `order` Array.  
  
 [!code-cpp[System.Random#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp#11)]
 [!code-csharp[System.Random#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs#11)]
 [!code-vb[System.Random#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb#11)]  
  
   
  
## Examples  
 Das folgende Beispiel erstellt einen einzelnen Zufallszahlen-Generator und ruft seine <xref:System.Random.NextBytes%2A>, <xref:System.Random.Next%2A>, und <xref:System.Random.NextDouble%2A> Methoden zum Generieren von Sequenzen von Zufallszahlen in verschiedenen Bereichen.  
  
 [!code-cpp[System.Random#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random2.cpp#2)]
 [!code-csharp[System.Random#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random2.cs#2)]
 [!code-vb[System.Random#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random2.vb#2)]  
  
 Im folgenden Beispiel wird eine zufällige ganze Zahl, die sie als Index verwendet. um einen Zeichenfolgenwert aus einem Array abzurufen.  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>In .NET Framework 1.0 und 1.1, eine minimale Implementierung einer Klasse abgeleitet <see cref="T:System.Random" /> erforderlich sind, überschreiben die <see cref="M:System.Random.Sample" /> Methode, um einen neuen oder geänderten Algorithmus zum Generieren von Zufallszahlen zu definieren. Die abgeleitete Klasse kann anschließend die basisklassenimplementierung von kommen die <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32)" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, <see cref="M:System.Random.NextBytes(System.Byte[])" />, und <see cref="M:System.Random.NextDouble" /> Methoden zum Aufrufen der Implementierung der abgeleiteten Klasse die <see cref="M:System.Random.Sample" /> Methode.  
  
In .NET Framework 2.0 und höher wird das Verhalten der <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, und <see cref="M:System.Random.NextBytes(System.Byte[])" /> Methoden wurden geändert, sodass diese Methoden nicht unbedingt Implementierung der abgeleiteten Klasse Aufrufen der <see cref="M:System.Random.Sample" /> Methode. Daher von abgeleiteten Klassen <see cref="T:System.Random" /> , die als Ziel .NET Framework 2.0 und höher sollten auch diese drei Methoden überschreiben.</para>
    </block>
    <block subset="none" type="usage">
      <para>Die Implementierung der vom Zufallszahlen-Generator in der <see cref="T:System.Random" /> Klasse ist nicht zwingend von Hauptversionen von .NET Framework unverändert. Daher sollte nicht Sie davon ausgehen, dass der gleiche Ausgangswert in der gleichen pseudozufällige Sequenz in verschiedenen Versionen von .NET Framework führt.</para>
    </block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Random" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Random" />-Klasse unter Verwendung eines zeitabhängigen Standardstartwerts.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardstartwert wird von der Systemuhr abgeleitet und verfügt über begrenzte Auflösung. Als Ergebnis verschiedene <xref:System.Random> Objekte, die unmittelbar nacheinander durch einen Aufruf des Standardkonstruktors erstellt werden müssen identische Ausgangswert Standardwerte, und daher erzeugen identische Sätze von Zufallszahlen. Dieses Problem kann vermieden werden, mithilfe einer einzelnes <xref:System.Random> Objekt, das alle Zufallszahlen zu generieren. Sie können auch umgehen, indem der Seed-Wert, der von der Systemuhr zurückgegebenen ändern und anschließend explizit dieser neuen Ausgangswerts, um die <xref:System.Random.%23ctor%28System.Int32%29> Konstruktor. Weitere Informationen finden Sie unter den <xref:System.Random.%23ctor%28System.Int32%29> Konstruktor.  
  
 Rufen Sie diesen Konstruktor, ggf. Ihre Zufallszahlengenerator, um eine zufällige Sequenz von Zahlen zu generieren. Rufen Sie eine feste Abfolge von Zufallszahlen generieren, die für verschiedene random Number-Generatoren werden die <xref:System.Random.%23ctor%28System.Int32%29> Konstruktor mit einem festen Ausgangswert. Dies <xref:System.Random> Überladung des Konstruktors wird häufig verwendet werden, beim Testen von apps, die Zufallszahlen zu verwenden.  
  
 Nachdem Sie den Zufallszahlengenerator instanziiert haben, rufen Sie einzelne <xref:System.Random> Methoden, wie z. B. <xref:System.Random.Next> oder <xref:System.Random.NextDouble>, um Zufallszahlen zu generieren.  
  
   
  
## Examples  
 Im folgenden Beispiel wird den Standardkonstruktor drei instanziieren <xref:System.Random> Objekte und eine Sequenz von fünf zufällige ganze Zahlen enthält, für die einzelnen. Da die ersten beiden <xref:System.Random> Objekte werden unmittelbar nacheinander erstellt, sie mit identischen Startwerten basierend auf der Systemzeit instanziiert sind und deshalb erzeugen sie eine identische Folge von Zufallszahlen. Andererseits, der Standardkonstruktor des dritten <xref:System.Random> -Objekts aufgerufen wird, nach einer Verzögerung von zwei Sekunden durch Aufrufen der <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> Methode. Da dies einen anderer Startwert für die dritte erzeugt <xref:System.Random> Objekt, es wird eine andere Sequenz von Zufallszahlen generiert.  
  
 [!code-csharp[System.Random.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor1.cs#2)]
 [!code-vb[System.Random.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random (int Seed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 Seed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Seed As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random(int Seed);" />
      <MemberSignature Language="F#" Value="new Random : int -&gt; Random" Usage="new System.Random Seed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Seed" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Seed">Eine Zahl, mit der ein Startwert für Folgen von Pseudozufallszahlen berechnet wird. Wenn eine negative Zahl angegeben wird, wird der absolute Wert der Zahl verwendet.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Random" />-Klasse unter Verwendung des angegebenen Startwerts.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bereitstellen einer identischen Startwerts in andere <xref:System.Random> Objekte bewirkt, dass jede Instanz identische Sequenzen von Zufallszahlen erzeugen. Dies erfolgt häufig beim Testen von apps, die von random Number-Generatoren abhängen.  
  
 Wenn Ihre Anwendung verschiedene Folgen von Zufallszahlen erfordert, rufen Sie diesen Konstruktor wiederholt mit verschiedenen Ausgangswerte. Eine Möglichkeit, einen eindeutigen Ausgangswert zu erstellen ist, zeitabhängige zu erleichtern. Die Systemuhr, z. B. den Ausgangswert abgeleitet werden, als die <xref:System.Random.%23ctor> Überladung ist. Die Systemuhr möglicherweise jedoch nicht genügend Auflösung verschiedene Aufrufen dieses Konstruktors mit einem anderen Ausgangswert angeben. Dies führt in random Number-Generatoren, die identische Sequenzen von Pseudozufallszahlen, generieren, wie die ersten beiden veranschaulicht <xref:System.Random> Objekte im folgenden Beispiel. Um dies zu verhindern, wenden Sie einen Algorithmus zum unterscheiden des Seed-Wertes in jeder Aufruf oder ein Aufruf der <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> Methode, um sicherzustellen, dass Sie jeder Konstruktor mit einem anderen Ausgangswert angeben.  
  
 [!code-csharp[System.Random.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)]
 [!code-vb[System.Random.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)]  
  
 Eine weitere Möglichkeit ist eine einzelne Instanziierung <xref:System.Random> Objekt, das Sie verwenden, um die Zufallszahlen in Ihrer Anwendung zu generieren. Dies ergibt eine etwas bessere Leistung, da Instanziieren eines Zufallszahlen-Generators recht teuer ist.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt <xref:System.Random> Objekte mit dem Konstruktor der Klasse, die einen Ausgangswert Parameter und generiert eine Sequenz von Zufallszahlen und Double-Werten. Im Beispiel wird veranschaulicht, dass die gleiche Sequenz generiert, wird bei der <xref:System.Random> Objekt mit dem Parameter-Konstruktor und einem Startwert erneut erstellt wird.  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Next">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine Zufallsganzzahl zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next();" />
      <MemberSignature Language="F#" Value="abstract member Next : unit -&gt; int&#xA;override this.Next : unit -&gt; int" Usage="random.Next " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine nicht negative Zufallsganzzahl zurück.</summary>
        <returns>Eine ganze 32-Bit-Zahl mit Vorzeichen, die größer oder gleich 0 (null) und kleiner als <see cref="F:System.Int32.MaxValue" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%2A?displayProperty=nameWithType> generiert eine zufällige Zahl, deren Wert liegt, zwischen 0 und kleiner als <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Verwenden Sie zum Generieren einer Zufallszahl, dessen Wert im Bereich, von 0 auf eine andere positive Zahl der <xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType> -methodenüberladung. Verwenden Sie zum Generieren einer Zufallszahl innerhalb eines anderen Bereichs der <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> -methodenüberladung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die wiederholte Aufrufe an die <xref:System.Random.Next%2A> Methode, um eine bestimmte Anzahl von vom Benutzer angeforderte Zufallszahlen zu generieren. Die <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> Methode wird verwendet, um Kundeninformationen zu erhalten.  
  
 [!code-cpp[System.Random.Next#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next3.cpp#5)]
 [!code-csharp[System.Random.Next#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next3.cs#5)]
 [!code-vb[System.Random.Next#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next3.vb#5)]  
  
 Im folgende Beispiel wird eine Klasse von abgeleitet <xref:System.Random> generiert eine Sequenz von Zufallszahlen, deren Verteilung unterscheidet sich, bei der gleichmäßigen Verteilung von generiert die <xref:System.Random.Sample%2A> Methode der Basisklasse. Es überschreibt die <xref:System.Random.Sample%2A> Methode, um die Verteilung von Zufallszahlen und Außerkraftsetzungen bereitzustellen der <xref:System.Random.Next%2A?displayProperty=nameWithType> zu Folge von Zufallszahlen zu verwendende Methode.  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ab .NET Framework, Version 2.0, bei der Ableitung einer Klasse von <see cref="T:System.Random" /> und überschreiben die <see cref="M:System.Random.Sample" /> -Methode, die von der Implementierung der abgeleiteten Klasse der bereitgestellte Verteilung der <see cref="M:System.Random.Sample" /> Methode wird nicht verwendet, in der Basisklasse aufrufen Implementierung der <see cref="M:System.Random.Next" /> Methode. Stattdessen die gleichmäßigen Verteilung zurückgegeben, der von den Basis- <see cref="T:System.Random" /> Klasse wird verwendet. Dieses Verhalten verbessert die gesamtleistung der <see cref="T:System.Random" /> Klasse. So ändern Sie dieses Verhalten zum Aufrufen der <see cref="M:System.Random.Sample" /> -Methode in der abgeleiteten Klasse, müssen Sie auch überschreiben die <see cref="M:System.Random.Next" /> Methode.</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int -&gt; int&#xA;override this.Next : int -&gt; int" Usage="random.Next maxValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxValue">Die exklusive obere Grenze der Zufallszahl, die generiert werden soll. <paramref name="maxValue" /> muss größer oder gleich 0 sein.</param>
        <summary>Gibt eine nicht negative Zufallsganzzahl zurück, die kleiner als das angegebene Maximum ist.</summary>
        <returns>Eine ganze 32-Bit-Zahl mit Vorzeichen, die größer oder gleich 0 (null) und kleiner als <paramref name="maxValue" /> ist, d.h., der Bereich der Rückgabewerte umfasst in der Regel 0 (null), aber nicht <paramref name="maxValue" />. Wenn jedoch <paramref name="maxValue" /> 0 (null) entspricht, wird <paramref name="maxValue" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Random.Next%28System.Int32%29> Überladung gibt zufälligen ganze Zahlen, Bereich von 0 bis `maxValue` – 1. Aber wenn `maxValue` gleich 0 ist, gibt die Methode 0 zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die zufällige ganze Zahlen mit verschiedenen Überladungen von der <xref:System.Random.Next%2A> Methode.  
  
 [!code-cpp[System.Random.Next#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next.cpp#1)]
 [!code-csharp[System.Random.Next#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next.cs#1)]
 [!code-vb[System.Random.Next#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next.vb#1)]  
  
 Im folgenden Beispiel wird eine zufällige ganze Zahl, die sie als Index verwendet. um einen Zeichenfolgenwert aus einem Array abzurufen. Da der höchste Index des Arrays eine kleiner als die Länge wird der Wert des ist der <xref:System.Array.Length%2A?displayProperty=nameWithType> -Eigenschaft angegeben ist, als eine der `maxValue` Parameter.  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxValue" /> ist kleiner als 0.</exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int minValue, int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 minValue, int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (minValue As Integer, maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int minValue, int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int * int -&gt; int&#xA;override this.Next : int * int -&gt; int" Usage="random.Next (minValue, maxValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minValue" Type="System.Int32" />
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minValue">Die inklusive untere Grenze der zurückgegebenen Zufallszahl.</param>
        <param name="maxValue">Die exklusive obere Grenze der zurückgegebenen Zufallszahl. <paramref name="maxValue" /> muss größer oder gleich <paramref name="minValue" /> sein.</param>
        <summary>Gibt eine Zufallsganzzahl zurück, die in einem angegebenen Bereich liegt.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die größer oder gleich <paramref name="minValue" /> und kleiner als <paramref name="maxValue" /> ist, d. h., der Bereich der Rückgabewerte umfasst <paramref name="minValue" />, aber nicht <paramref name="maxValue" />. Wenn <paramref name="minValue" /> gleich <paramref name="maxValue" /> ist, wird <paramref name="minValue" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> Überladung gibt eine zufälligen ganze Zahlen zwischen `minValue` zu `maxValue` – 1. Aber wenn `maxValue` gleich `minValue`, gibt die Methode zurück `minValue`.  
  
 Im Gegensatz zu den anderen Überladungen der der <xref:System.Random.Next%2A> -Methode, die nur positive Werte zurückgeben möchten, kann diese Methode eine negative Zufallsganzzahl zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> Methode, um zufällige ganze Zahlen mit drei verschiedenen Wertebereichen zu generieren. Beachten Sie, dass der vom System bereitgestellten Ausgangswert übergeben wird, um die genaue Ausgabe aus dem Beispiel abhängig der <xref:System.Random> Klassenkonstruktor.  
  
 [!code-cpp[System.Random.Next#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next2.cpp#2)]
 [!code-csharp[System.Random.Next#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/Next2.cs#2)]
 [!code-vb[System.Random.Next#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next2.vb#2)]  
  
 Im folgenden Beispiel wird eine zufällige ganze Zahl, die sie als Index verwendet. um einen Zeichenfolgenwert aus einem Array abzurufen. Da der höchste Index des Arrays eine kleiner als die Länge wird der Wert des ist der <xref:System.Array.Length%2A?displayProperty=nameWithType> -Eigenschaft angegeben ist, als eine der `maxValue` Parameter.  
  
 [!code-cpp[System.Random.Next#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next4.cpp#4)]
 [!code-csharp[System.Random.Next#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next4.cs#4)]
 [!code-vb[System.Random.Next#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="minValue" /> ist größer als <paramref name="maxValue" />.</exception>
        <block subset="none" type="overrides">
          <para>Ab .NET Framework, Version 2.0, bei der Ableitung einer Klasse von <see cref="T:System.Random" /> und überschreiben die <see cref="M:System.Random.Sample" /> -Methode, die von der Implementierung der abgeleiteten Klasse der bereitgestellte Verteilung der <see cref="M:System.Random.Sample" /> Methode wird nicht verwendet, in der Basisklasse aufrufen Implementierung der <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> Methode zu überladen, wenn der Unterschied zwischen der <paramref name="minValue" /> und <paramref name="maxValue" /> Parameter ist größer als <see cref="F:System.Int32.MaxValue" />. Stattdessen die gleichmäßigen Verteilung zurückgegeben, der von den Basis- <see cref="T:System.Random" /> Klasse wird verwendet. Dieses Verhalten verbessert die gesamtleistung der <see cref="T:System.Random" /> Klasse. So ändern Sie dieses Verhalten zum Aufrufen der <see cref="M:System.Random.Sample" /> -Methode in der abgeleiteten Klasse, müssen Sie auch überschreiben die <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> -methodenüberladung.</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : byte[] -&gt; unit&#xA;override this.NextBytes : byte[] -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Bytearray, das für Zufallszahlen vorgesehen ist.</param>
        <summary>Füllt die Elemente eines angegebenen Bytearrays mit Zufallszahlen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jedes Element des Arrays von Bytes in eine zufällige Zahl größer als oder gleich 0 (null) festgelegt ist und kleiner als oder gleich <xref:System.Byte.MaxValue>.  
  
 Z. B. um eine kryptografisch sichere Zufallszahl, die für das Erstellen eines zufälligen Kennworts generieren, verwenden Sie eine Methode wie z. B. <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Random.NextBytes%2A> Methode, um ein Array von Bytes mit zufälligen Bytes-Werte zu füllen.  
  
 [!code-cpp[Classic Random.NextBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Random.NextBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CS/source.cs#1)]
 [!code-vb[Classic Random.NextBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <block subset="none" type="overrides">
          <para>Ab .NET Framework, Version 2.0, bei der Ableitung einer Klasse von <see cref="T:System.Random" /> und überschreiben die <see cref="M:System.Random.Sample" /> -Methode, die von der Implementierung der abgeleiteten Klasse der bereitgestellte Verteilung der <see cref="M:System.Random.Sample" /> Methode wird nicht verwendet, in der Basisklasse aufrufen Implementierung der <see cref="M:System.Random.NextBytes(System.Byte[])" /> Methode. Stattdessen die gleichmäßigen Verteilung zurückgegeben, der von den Basis- <see cref="T:System.Random" /> Klasse wird verwendet. Dieses Verhalten verbessert die gesamtleistung der <see cref="T:System.Random" /> Klasse. So ändern Sie dieses Verhalten zum Aufrufen der <see cref="M:System.Random.Sample" /> -Methode in der abgeleiteten Klasse, müssen Sie auch überschreiben die <see cref="M:System.Random.NextBytes(System.Byte[])" /> Methode.</para>
        </block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Span(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : Span&lt;byte&gt; -&gt; unit&#xA;override this.NextBytes : Span&lt;byte&gt; -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NextDouble">
      <MemberSignature Language="C#" Value="public virtual double NextDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 NextDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function NextDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double NextDouble();" />
      <MemberSignature Language="F#" Value="abstract member NextDouble : unit -&gt; double&#xA;override this.NextDouble : unit -&gt; double" Usage="random.NextDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine zufällige Gleitkommazahl zurück, die größer oder gleich 0,0 und kleiner als 1,0 ist.</summary>
        <returns>Eine Gleitkommazahl mit doppelter Genauigkeit, die größer oder gleich 0,0 und kleiner als 1,0 ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die tatsächliche obere Grenze der Zufallszahl, die von dieser Methode zurückgegebene ist 0.99999999999999978.  
  
 Um zufällige Gleitkommazahlen-Punktwerte innerhalb eines Bereichs als 0,0 und 1,0 abzurufen, finden Sie im Abschnitt "Abgerufen werden Gleitkommazahlen-Punktwerte in einem angegebenen Bereich", der die <xref:System.Random> Thema-Klasse.  
  
 Diese Methode ist die öffentliche Version der geschützten Methode <xref:System.Random.Sample%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Random.NextDouble%2A> Methode, um Sequenzen von Double zu generieren.  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 Im folgenden Beispiel wird die <xref:System.Random.NextDouble%2A> Methode zum Generieren von 100 zufälligen Zahlen und zeigt deren Häufigkeit-Verteilung.  
  
 [!code-csharp[System.Random.NextDouble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.random.nextdouble/cs/nextdouble1.cs#2)]
 [!code-vb[System.Random.NextDouble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.random.nextdouble/vb/nextdouble1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sample">
      <MemberSignature Language="C#" Value="protected virtual double Sample ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance float64 Sample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Sample" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Sample () As Double" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual double Sample();" />
      <MemberSignature Language="F#" Value="abstract member Sample : unit -&gt; double&#xA;override this.Sample : unit -&gt; double" Usage="random.Sample " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine zufällige Gleitkommazahl zwischen 0,0 und 1,0 zurück.</summary>
        <returns>Eine Gleitkommazahl mit doppelter Genauigkeit, die größer oder gleich 0,0 und kleiner als 1,0 ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um eine andere zufällige Verteilung oder anderen random Number Generatorprinzip zu erzeugen, leiten Sie eine Klasse von der <xref:System.Random> Klasse, und überschreiben die <xref:System.Random.Sample%2A> Methode.  
  
> [!IMPORTANT]
>  Die <xref:System.Random.Sample%2A> Methode `protected`, was bedeutet, dass er nur innerhalb ist die <xref:System.Random> -Klasse und ihrer abgeleiteten Klassen. Generiert eine Zufallszahl zwischen 0 und 1 ein <xref:System.Random> Instanz ist, rufen Sie die <xref:System.Random.NextDouble%2A> Methode.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Klasse von abgeleitet <xref:System.Random> und überschreibt die <xref:System.Random.Sample%2A> Methode, um eine Verteilung von Zufallszahlen zu generieren. Diese Verteilung unterscheidet sich von der gleichmäßigen Verteilung von generiert die <xref:System.Random.Sample%2A> Methode der Basisklasse.  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ab .NET Framework, Version 2.0, bei der Ableitung einer Klasse von <see cref="T:System.Random" /> und überschreiben die <see cref="M:System.Random.Sample" /> -Methode, die von der Implementierung der abgeleiteten Klasse der bereitgestellte Verteilung der <see cref="M:System.Random.Sample" /> Methode wird nicht verwendet, in der Basisklasse aufrufen die Implementierung der folgenden Methoden: 
–   Die <see cref="M:System.Random.NextBytes(System.Byte[])" />-Methode.  
  
–   Die <see cref="M:System.Random.Next" />-Methode.  
  
– Die <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> -Methode, wenn (<paramref name="maxValue" /> - <paramref name="minValue" />) ist größer als <see cref="F:System.Int32.MaxValue" />.  
  
Stattdessen die Basis die gleichmäßigen Verteilung gebotenen <see cref="T:System.Random" /> Klasse wird verwendet. Dieses Verhalten verbessert die gesamtleistung der <see cref="T:System.Random" /> Klasse. So ändern Sie das Verhalten, dass die Implementierung von Aufrufen der <see cref="M:System.Random.Sample" /> Methode in der abgeleiteten Klasse, müssen Sie auch das Verhalten dieser drei Member überschreiben. Dies wird im Beispiel veranschaulicht.</para>
        </block>
        <altmember cref="M:System.Random.NextDouble" />
      </Docs>
    </Member>
  </Members>
</Type>