<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Random.xml" source-language="en-US" target-language="de-DE">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5601795a307b1570fa0290d626c624db4c949b72e.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">601795a307b1570fa0290d626c624db4c949b72e</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Random">
          <source>Represents a pseudo-random number generator, which is a device that produces a sequence of numbers that meet certain statistical requirements for randomness.</source>
          <target state="translated">Stellt einen Generator für Pseudozufallszahlen dar, d. h. ein Gerät, das eine Zahlenfolge erzeugt, die bestimmte statistische Anforderungen hinsichtlich ihrer Zufälligkeit erfüllt.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Pseudo-random numbers are chosen with equal probability from a finite set of numbers.</source>
          <target state="translated">Pseudozufallszahlen werden aus einer endlichen Menge von Zahlen mit gleicher Wahrscheinlichkeit ausgewählt.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The chosen numbers are not completely random because a mathematical algorithm is used to select them, but they are sufficiently random for practical purposes.</source>
          <target state="translated">Die ausgewählten Zahlen sind nicht vollständig zufälligen, da ein mathematisches Algorithmus verwendet wird, um sie auszuwählen, aber sie ausreichend zufällige aus praktischen Gründen sind.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The current implementation of the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class is based on a modified version of Donald E. Knuth's subtractive random number generator algorithm.</source>
          <target state="translated">Die aktuelle Implementierung von der <ph id="ph1">&lt;xref:System.Random&gt;</ph> Klasse basiert auf eine geänderte Version des Donald E. Knuths Subtraktive Algorithmus mit Zufallszahlengenerator.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>For more information, see D. E.</source>
          <target state="translated">Weitere Informationen finden Sie unter D. E.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Knuth.</source>
          <target state="translated">Knuth.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">*</bpt>The Art of Computer Programming, Volume 2: Seminumerical Algorithms<ept id="p1">*</ept>.</source>
          <target state="translated"><bpt id="p1">*</bpt>Die Art des Computers Programmierung, Volume 2: Seminumerical Algorithmen<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Addison-Wesley, Reading, MA, third edition, 1997.</source>
          <target state="translated">Addison-Wesley, lesen, MA, dritte Edition, 1997.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To generate a cryptographically secure random number, such as one that's suitable for creating a random password, use the <ph id="ph1">&lt;xref:System.Security.Cryptography.RNGCryptoServiceProvider&gt;</ph> class or derive a class from <ph id="ph2">&lt;xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Verwenden Sie eine kryptografisch sichere Zufallszahl, z. B. einen generieren, für das Erstellen eines zufälligen Kennworts entspricht, der <ph id="ph1">&lt;xref:System.Security.Cryptography.RNGCryptoServiceProvider&gt;</ph> Klasse oder eine Klasse von <ph id="ph2">&lt;xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In this topic:</source>
          <target state="translated">In diesem Thema:</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Instantiating the random number generator<ept id="p1">](#Instantiate)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Instanziieren den Zufallszahlen-generator<ept id="p1">](#Instantiate)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Avoiding multiple instantiations<ept id="p1">](#Multiple)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Mehrere Instanziierungen vermeiden<ept id="p1">](#Multiple)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>The System.Random class and thread safety<ept id="p1">](#ThreadSafety)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Der System.Random-Klasse und Thread-Sicherheit<ept id="p1">](#ThreadSafety)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Generating different types of random numbers<ept id="p1">](#Functionality)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Verschiedene Typen von Zufallszahlen generieren<ept id="p1">](#Functionality)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Substituting your own algorithm<ept id="p1">](#Overriding)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Ersetzen einen eigenen Algorithmus<ept id="p1">](#Overriding)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>How do you use System.Random to…<ept id="p1">](#Operations)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Wie werden System.Random, verwendet...<ept id="p1">](#Operations)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve the same sequence of random values<ept id="p1">](#Same)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Die gleiche Sequenz von Zufallswerten abrufen<ept id="p1">](#Same)</ept></target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve unique sequences of random values<ept id="p1">](#Unique)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Eindeutige Sequenzen von Zufallswerten abrufen<ept id="p1">](#Unique)</ept></target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve integers in a specified range<ept id="p1">](#Range)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Abrufen von ganzen Zahlen in einem angegebenen Bereich<ept id="p1">](#Range)</ept></target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve integers with a specified number of digits<ept id="p1">](#Digits)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Abrufen von ganzen Zahlen mit einer angegebenen Anzahl von Ziffern<ept id="p1">](#Digits)</ept></target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve floating-point values in a specified range<ept id="p1">](#Floats)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Abrufen von Gleitkommawerten in einem angegebenen Bereich<ept id="p1">](#Floats)</ept></target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Generate random Boolean values<ept id="p1">](#Boolean)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Generieren von zufälligen boolesche Werte<ept id="p1">](#Boolean)</ept></target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Generate random 64-bit integers<ept id="p1">](#Long)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Generieren von zufälligen 64-Bit-Ganzzahlen<ept id="p1">](#Long)</ept></target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve bytes in a specified range<ept id="p1">](#Bytes)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Abrufen von Bytes in einem angegebenen Bereich<ept id="p1">](#Bytes)</ept></target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve an element from an array or collection at random<ept id="p1">](#Array)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Nach dem Zufallsprinzip ein Element aus einem Array oder einer Auflistung abrufen<ept id="p1">](#Array)</ept></target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve a unique element from an array or collection<ept id="p1">](#UniqueArray)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Ein eindeutiges Element aus einem Array oder einer Auflistung abrufen<ept id="p1">](#UniqueArray)</ept></target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Instantiating the random number generator</source>
          <target state="translated">Instanziieren den Zufallszahlen-generator</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You instantiate the random number generator by providing a seed value (a starting value for the pseudo-random number generation algorithm) to a <ph id="ph1">&lt;xref:System.Random.%23ctor%2A&gt;</ph> class constructor.</source>
          <target state="translated">Zufallszahlen-Generator wird durch Angeben eines Ausgangswert-Werts (ein Startwert für die Generierung Algorithmus Pseudozufallszahlen) instanziieren, um eine <ph id="ph1">&lt;xref:System.Random.%23ctor%2A&gt;</ph> Klassenkonstruktor.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can supply the seed value either explicitly or implicitly:</source>
          <target state="translated">Sie können den Ausgangswert entweder explizit oder implizit angeben:</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor uses an explicit seed value that you supply.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> -Konstruktor verwendet einen explizite Seed-Wert, den Sie angeben.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">&lt;xref:System.Random.%23ctor&gt;</ph> constructor uses the system clock to provide a seed value.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Random.%23ctor&gt;</ph> Konstruktor verwendet die Systemuhr einen Ausgangswert angeben.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>This is the most common way of instantiating the random number generator.</source>
          <target state="translated">Dies ist üblicherweise wird bei der Instanziierung des Zufallszahlengenerator.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If the same seed is used for separate <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects, they will generate the same series of random numbers.</source>
          <target state="translated">Wenn der gleiche Ausgangswert, für Separate verwendet wird <ph id="ph1">&lt;xref:System.Random&gt;</ph> Objekte aufweist, werden sie der gleichen Reihe von Zufallszahlen generiert.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>This can be useful for creating a test suite that processes random values, or for replaying games that derive their data from random numbers.</source>
          <target state="translated">Dies kann zum Erstellen einer Testsammlung aus, die Zufallswerte verarbeitet oder für die Wiedergabe Spiele, die ihre Daten von Zufallszahlen abgeleitet werden, nützlich sein.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, note that <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects in processes running under different versions of the .NET Framework may return different series of random numbers even if they're instantiated with identical seed values.</source>
          <target state="translated">Beachten Sie jedoch, dass <ph id="ph1">&lt;xref:System.Random&gt;</ph> Objekte in der Prozesse, die unter verschiedenen Versionen von .NET Framework ausgeführt werden. möglicherweise verschiedene Reihen mit Zufallszahlen zurück, selbst wenn sie mit identischen Startwerten instanziiert werden.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To produce different sequences of random numbers, you can make the seed value time-dependent, thereby producing a different series with each new instance of <ph id="ph1">&lt;xref:System.Random&gt;</ph>.</source>
          <target state="translated">Um verschiedene Sequenzen von Zufallszahlen zu erzeugen, möglich den Ausgangswert zeitabhängige, dadurch erzeugt eine andere Serie mit jeder neuen Instanz des <ph id="ph1">&lt;xref:System.Random&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The parameterized <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor can take an <ph id="ph2">&lt;xref:System.Int32&gt;</ph> value based on the number of ticks in the current time, whereas the parameterless <ph id="ph3">&lt;xref:System.Random.%23ctor&gt;</ph> constructor uses the system clock to generate its seed value.</source>
          <target state="translated">Die parametrisierte <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> Konstruktor akzeptiert ein <ph id="ph2">&lt;xref:System.Int32&gt;</ph> Wert basierend auf der Anzahl der Ticks in die aktuelle Uhrzeit, während die parameterlose <ph id="ph3">&lt;xref:System.Random.%23ctor&gt;</ph> Konstruktor verwendet die Systemuhr zum Generieren des Startwerts.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, because the clock has finite resolution, using the parameterless constructor to create different <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects in close succession creates random number generators that produce identical sequences of random numbers.</source>
          <target state="translated">Jedoch, da die Uhr endliche Auflösung hat, mithilfe des Konstruktors verschiedenen <ph id="ph1">&lt;xref:System.Random&gt;</ph> Objekte schließen nacheinander erstellt random Number-Generatoren, die identische Sequenzen von Zufallszahlen erzeugen.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example illustrates how two <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects that are instantiated in close succession generate an identical series of random numbers.</source>
          <target state="translated">Im folgende Beispiel wird veranschaulicht, wie zwei <ph id="ph1">&lt;xref:System.Random&gt;</ph> Objekte, die in Zufallszahlengeneratoren instanziiert eine identische Folge von zufälligen Zahlen zu generieren.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>On most Windows systems, <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects created within 15 milliseconds of one another are likely to have identical seed values.</source>
          <target state="translated">In den meisten Windows-Systemen <ph id="ph1">&lt;xref:System.Random&gt;</ph> innerhalb von 15 Millisekunden voneinander erstellten Objekte werden wahrscheinlich identische Ausgangswerte haben.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To avoid this problem, create a single <ph id="ph1">&lt;xref:System.Random&gt;</ph> object instead of multiple objects.</source>
          <target state="translated">Um dieses Problem zu vermeiden, erstellen Sie eine einzelne <ph id="ph1">&lt;xref:System.Random&gt;</ph> Objekt anstelle mehrerer Objekte.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Avoiding multiple instantiations</source>
          <target state="translated">Mehrere Instanziierungen vermeiden</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Initializing two random number generators in a tight loop or in rapid succession creates two random number generators that can produce identical sequences of random numbers.</source>
          <target state="translated">Initialisieren von zwei random Number-Generatoren in einer dichten Schleife oder in schneller Folge erstellt zwei random Number-Generatoren, die identische Sequenzen von Zufallszahlen generieren können.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In most cases, this is not the developer's intent and can lead to performance issues, because instantiating and initializing a random number generator is a relatively expensive process.</source>
          <target state="translated">In den meisten Fällen ist kein des Entwicklers Absicht es kann zu Leistungsproblemen können führen, da instanziieren und Initialisieren eines Zufallszahlen-Generators relativ kostenintensiv ist.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Both to improve performance and to avoid inadvertently creating separate random number generators that generate identical numeric sequences, we recommend that you create one <ph id="ph1">&lt;xref:System.Random&gt;</ph> object to generate many random numbers over time, instead of creating new <ph id="ph2">&lt;xref:System.Random&gt;</ph> objects to generate one random number.</source>
          <target state="translated">Sowohl zum Verbessern der Leistung und um zu vermeiden, versehentlich erstellen separate random Number-Generatoren, die identische numerische Sequenzen zu generieren, es wird empfohlen, Sie eine erstellen <ph id="ph1">&lt;xref:System.Random&gt;</ph> Objekt viele Zufallszahlen im Laufe der Zeit anstatt zu erstellen neue <ph id="ph2">&lt;xref:System.Random&gt;</ph> -Objekten, die eine Zufallszahl zu generieren.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class isn't thread safe.</source>
          <target state="translated">Allerdings die <ph id="ph1">&lt;xref:System.Random&gt;</ph> Klasse nicht threadsicher ist.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If you call <ph id="ph1">&lt;xref:System.Random&gt;</ph> methods from multiple threads, follow the guidelines discussed in the next section.</source>
          <target state="translated">Beim Aufrufen <ph id="ph1">&lt;xref:System.Random&gt;</ph> Methoden aus mehreren Threads verwenden, befolgen Sie die Richtlinien, die im nächsten Abschnitt erläutert.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The System.Random class and thread safety</source>
          <target state="translated">Der System.Random-Klasse und Thread-Sicherheit</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Instead of instantiating individual <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects, we recommend that you create a single <ph id="ph2">&lt;xref:System.Random&gt;</ph> instance to generate all the random numbers needed by your app.</source>
          <target state="translated">Statt einzelne Instanziierung <ph id="ph1">&lt;xref:System.Random&gt;</ph> Objekte, es wird empfohlen, dass Sie beim Erstellen einer einzelnen <ph id="ph2">&lt;xref:System.Random&gt;</ph> Instanz alle von der Anwendung benötigten Zufallszahlen generiert.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects are not thread safe.</source>
          <target state="translated">Allerdings <ph id="ph1">&lt;xref:System.Random&gt;</ph> Objekte sind nicht threadsicher.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If your app calls <ph id="ph1">&lt;xref:System.Random&gt;</ph> methods from multiple threads, you must use a synchronization object to ensure that only one thread can access the random number generator at a time.</source>
          <target state="translated">Wenn Ihre app aufruft <ph id="ph1">&lt;xref:System.Random&gt;</ph> Methoden aus mehreren Threads, müssen Sie ein Synchronisierungsobjekt verwenden, um sicherzustellen, dass nur ein Thread den Zufallszahlen-Generator zu einem Zeitpunkt zugreifen kann.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If you don't ensure that the <ph id="ph1">&lt;xref:System.Random&gt;</ph> object is accessed in a thread-safe way, calls to methods that return random numbers return 0.</source>
          <target state="translated">Wenn Sie nicht sicherstellen, dass die <ph id="ph1">&lt;xref:System.Random&gt;</ph> Objekt auf threadsichere Weise zugegriffen wird, Aufrufe von Methoden, die Zufallszahlen zurückgeben geben 0 zurück.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example uses the C# <bpt id="p1">[</bpt>lock Statement<ept id="p1">](~/docs/csharp/language-reference/keywords/lock-statement.md)</ept> and the Visual Basic <bpt id="p2">[</bpt>SyncLock statement<ept id="p2">](~/docs/visual-basic/language-reference/statements/synclock-statement.md)</ept> to ensure that a single random number generator is accessed by 11 threads in a thread-safe manner.</source>
          <target state="translated">Im folgenden Beispiel wird der C#- <bpt id="p1">[</bpt>lock-Anweisung<ept id="p1">](~/docs/csharp/language-reference/keywords/lock-statement.md)</ept> und Visual Basic <bpt id="p2">[</bpt>SyncLock-Anweisung<ept id="p2">](~/docs/visual-basic/language-reference/statements/synclock-statement.md)</ept> , stellen Sie sicher, dass eine einzelne Zufallszahlen-Generators auf threadsichere Weise von 11 Threads zugegriffen wird.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Each thread generates 2 million random numbers, counts the number of random numbers generated and calculates their sum, and then updates the totals for all threads when it finishes executing.</source>
          <target state="translated">Jeder Thread 2 Millionen Zufallszahlen generiert, zählt die Anzahl der Zufallszahlen generiert und deren Summe berechnet und aktualisiert dann die Gesamtwerte für alle Threads aus, wenn sie die Ausführung abschließt.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The example ensures thread-safety in the following ways:</source>
          <target state="translated">Im Beispiel wird sichergestellt, dass Threadsicherheit auf folgende Weise:</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute is used to define thread-local variables that track the total number of random numbers generated and their sum for each thread.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> Attribut wird verwendet, um die Thread-lokalen Variablen definieren, die die Gesamtanzahl der Zufallszahlen generiert und deren Summe für jeden Thread zu verfolgen.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>A lock (the <ph id="ph1">`lock`</ph> statement in C# and the <ph id="ph2">`SyncLock`</ph> statement in Visual Basic) protects access to the variables for the total count and sum of all random numbers generated on all threads.</source>
          <target state="translated">Eine Sperre (die <ph id="ph1">`lock`</ph> -Anweisung in c# und die <ph id="ph2">`SyncLock`</ph> -Anweisung in Visual Basic) schützt den Zugriff auf die Variablen für den insgesamt und die Summe aller Zufallszahlen generiert für alle Threads.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>A semaphore (the <ph id="ph1">&lt;xref:System.Threading.CountdownEvent&gt;</ph> object) is used to ensure that the main thread blocks until all other threads complete execution.</source>
          <target state="translated">Ein Semaphor (die <ph id="ph1">&lt;xref:System.Threading.CountdownEvent&gt;</ph> Objekt) wird verwendet, um sicherzustellen, dass der Hauptthread wird blockiert, bis alle anderen Threads die Ausführung abschließt.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The example checks whether the random number generator has become corrupted by determining whether two consecutive calls to random number generation methods return 0.</source>
          <target state="translated">Im Beispiel wird überprüft, ob die Zufallszahlen-Generators durch bestimmen beschädigt wurde, ob zwei aufeinander folgende Aufrufe von Zufallszahlen generieren, Methoden geben 0 zurück.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If corruption is detected, the example uses the <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph> object to signal that all threads should be canceled.</source>
          <target state="translated">Wenn eine Beschädigung festgestellt wird, wird im Beispiel wird die <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph> -Objekt signalisiert, dass alle Threads abgebrochen werden soll.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Before generating each random number, each thread checks the state of the <ph id="ph1">&lt;xref:System.Threading.CancellationToken&gt;</ph> object.</source>
          <target state="translated">Vor dem Generieren von jeder Zufallszahl jeder Thread überprüft den Status der <ph id="ph1">&lt;xref:System.Threading.CancellationToken&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If cancellation is requested, the example calls the <ph id="ph1">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> method to cancel the thread.</source>
          <target state="translated">Wenn der Abbruch angefordert wird, wird im Beispiel wird die <ph id="ph1">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> Methode, um den Thread abzubrechen.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example is identical to the first, except that it uses a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and a lambda expression instead of <ph id="ph2">&lt;xref:System.Threading.Thread&gt;</ph> objects.</source>
          <target state="translated">Das folgende Beispiel ist mit dem ersten identisch, außer dass mithilfe einer <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> -Objekt und einen Lambda-Ausdruck anstelle von <ph id="ph2">&lt;xref:System.Threading.Thread&gt;</ph> Objekte.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>It differs from the first example in the following ways:</source>
          <target state="translated">Es unterscheidet sich von der ersten Beispiel auf folgende Weise:</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The variables to keep track of the number of random numbers generated and their sum in each task are local to the task, so there is no need to use the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute.</source>
          <target state="translated">Die Variablen zum Nachverfolgen der Anzahl der Zufallszahlen generiert und deren Summe in jeder Aufgabe befinden sich lokal auf die Aufgabe, daher keine Notwendigkeit zum Verwenden besteht der <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> Attribut.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The static <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> method is used to ensure that the main thread doesn't complete before all tasks have finished.</source>
          <target state="translated">Die statische <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> Methode wird verwendet, um sicherzustellen, dass der Hauptthread nicht abgeschlossen, bevor alle Aufgaben beendet wurden.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>There is no need for the <ph id="ph1">&lt;xref:System.Threading.CountdownEvent&gt;</ph> object.</source>
          <target state="translated">Besteht keine Notwendigkeit für die <ph id="ph1">&lt;xref:System.Threading.CountdownEvent&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The exception that results from task cancellation is surfaced in the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Die Ausnahme, die durch den Aufgabenabbruch entsteht werden eingeblendet, der <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In the previous example, it is handled by each thread.</source>
          <target state="translated">Im vorherigen Beispiel wird sie von jedem Thread verarbeitet.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Generating different types of random numbers</source>
          <target state="translated">Verschiedene Typen von Zufallszahlen generieren</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The random number generator provides methods that let you generate the following kinds of random numbers:</source>
          <target state="translated">Der Zufallszahlengenerator bietet Methoden, mit die Sie die folgenden Arten von Zufallszahlen generieren können:</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>A series of <ph id="ph1">&lt;xref:System.Byte&gt;</ph> values.</source>
          <target state="translated">Eine Reihe von <ph id="ph1">&lt;xref:System.Byte&gt;</ph> Werte.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You determine the number of byte values by passing an array initialized to the number of elements you want the method to return to the <ph id="ph1">&lt;xref:System.Random.NextBytes%2A&gt;</ph> method.</source>
          <target state="translated">Sie bestimmen die Anzahl der Byte-Werten durch Übergeben eines Arrays initialisiert, um die Anzahl der Elemente, die Sie die Methode zum zurückgeben möchten der <ph id="ph1">&lt;xref:System.Random.NextBytes%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example generates 20 bytes.</source>
          <target state="translated">Im folgende Beispiel werden 20 Byte an Daten generiert.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>A single integer.</source>
          <target state="translated">Eine einzelne ganze Zahl.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can choose whether you want an integer from 0 to a maximum value (<ph id="ph1">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> – 1) by calling the <ph id="ph2">&lt;xref:System.Random.Next&gt;</ph> method, an integer between 0 and a specific value by calling the <ph id="ph3">&lt;xref:System.Random.Next%28System.Int32%29&gt;</ph> method, or an integer within a range of values by calling the <ph id="ph4">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method.</source>
          <target state="translated">Sie können auswählen, ob Sie eine Ganzzahl zwischen 0 und einen maximalen Wert (<ph id="ph1">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> – 1) durch Aufrufen der <ph id="ph2">&lt;xref:System.Random.Next&gt;</ph> -Methode, eine ganze Zahl zwischen 0 und einen bestimmten Wert durch Aufrufen der <ph id="ph3">&lt;xref:System.Random.Next%28System.Int32%29&gt;</ph> -Methode oder eine ganze Zahl innerhalb eines Bereichs von Werten durch Aufrufen der <ph id="ph4">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph>Methode.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In the parameterized overloads, the specified maximum value is exclusive; that is, the actual maximum number generated is one less than the specified value.</source>
          <target state="translated">In den parametrisierten Überladungen ist der angegebene maximale Wert; die tatsächliche Höchstanzahl generiert also eine kleiner als der angegebene Wert.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method to generate 10 random numbers between -10 and 10.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> Methode zum Generieren der 10 zufälliger Zahlen zwischen-10 und 10.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Note that the second argument to the method specifies the exclusive upper bound of the range of random values returned by the method.</source>
          <target state="translated">Beachten Sie, dass das zweite Argument an die Methode gibt an, die exklusive obere Grenze des Bereichs von zufälligen Werten, die von der Methode zurückgegeben.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In other words, the largest integer that the method can return is one less than this value.</source>
          <target state="translated">Das heißt, die größte ganze Zahl, die die Methode zurückgeben kann, ist kleiner als dieser Wert.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>A single floating-point value from 0.0 to less than 1.0 by calling the <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method.</source>
          <target state="translated">Eine einzelne Gleitkommawert zwischen 0,0 und kleiner als 1,0 durch Aufrufen der <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The exclusive upper bound of the random number returned by the method is 1, so its actual upper bound is 0.99999999999999978.</source>
          <target state="translated">Die exklusive obere Grenze der von der Methode zurückgegebenen Zufallszahl ist 1, damit die tatsächliche Obergrenze 0.99999999999999978 ist.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example generates 10 random floating-point numbers.</source>
          <target state="translated">Im folgende Beispiel wird 10 zufällige Gleitkommazahlen generiert.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method allows you to specify the range of the returned random number.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> Methode können Sie den Bereich der zurückgegebenen Zufallszahl an.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, the <ph id="ph1">`maxValue`</ph> parameter, which specifies the upper range returned number, is an exclusive, not an inclusive, value.</source>
          <target state="translated">Allerdings die <ph id="ph1">`maxValue`</ph> -Parameter, der angibt, der obere Bereich zurückgegebene Zahl, wird eine exklusive, keine inklusive Wert.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>This means that the method call <ph id="ph1">`Next(0, 100)`</ph> returns a value between 0 and 99, and not between 0 and 100.</source>
          <target state="translated">Dies bedeutet, dass den Methodenaufruf <ph id="ph1">`Next(0, 100)`</ph> gibt einen Wert zwischen 0 und 99, und nicht zwischen 0 und 100.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can also use the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class for such tasks as generating <bpt id="p1">[</bpt>random T:System.Boolean values<ept id="p1">](#Boolean)</ept>, generating <bpt id="p2">[</bpt>random floating point values with a range other than 0 to 1<ept id="p2">](#Floats)</ept>, generating <bpt id="p3">[</bpt>random 64-bit integers<ept id="p3">](#Long)</ept>, and <bpt id="p4">[</bpt>randomly retrieving a unique element from an array or collection<ept id="p4">](#UniqueArray)</ept>.</source>
          <target state="translated">Können Sie auch die <ph id="ph1">&lt;xref:System.Random&gt;</ph> Klasse für Aufgaben wie das Generieren von <bpt id="p1">[</bpt>Zufallswerte: System.Boolean<ept id="p1">](#Boolean)</ept>, Generieren von <bpt id="p2">[</bpt>zufällige Gleitkommazahlen Werte mit einem Bereich von 0 bis 1 außer<ept id="p2">](#Floats)</ept>, Generieren von <bpt id="p3">[</bpt>zufälligen 64-Bit-Ganzzahlen<ept id="p3">](#Long)</ept>, und <bpt id="p4">[</bpt>nach dem Zufallsprinzip ein eindeutiges Element aus einem Array oder einer Auflistung abrufen<ept id="p4">](#UniqueArray)</ept>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>For these and other common tasks, see the <bpt id="p1">[</bpt>How do you use System.Random to…<ept id="p1">](#Operations)</ept></source>
          <target state="translated">Diese und andere häufige Aufgaben finden Sie in der <bpt id="p1">[</bpt>wie verwenden Sie System.Random zu...<ept id="p1">](#Operations)</ept></target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>section.</source>
          <target state="translated">Abschnitt.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Substituting your own algorithm</source>
          <target state="translated">Ersetzen einen eigenen Algorithmus</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can implement your own random number generator by inheriting from the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class and supplying your random number generation algorithm.</source>
          <target state="translated">Sie können eigene Zufallszahlengenerator implementieren, durch Erben von der <ph id="ph1">&lt;xref:System.Random&gt;</ph> Klasse und Ihre Generierung Algorithmus Zufallszahlen bereitstellt.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To supply your own algorithm, you must override the <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph> method, which implements the random number generation algorithm.</source>
          <target state="translated">Um einen eigenen Algorithmus angeben, müssen Sie überschreiben die <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph> -Methode, die der zufällige Zahlen generieren-Algorithmus implementiert.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You should also override the <ph id="ph1">&lt;xref:System.Random.Next&gt;</ph>, <ph id="ph2">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph>, and <ph id="ph3">&lt;xref:System.Random.NextBytes%2A&gt;</ph> methods to ensure that they call your overridden <ph id="ph4">&lt;xref:System.Random.Sample%2A&gt;</ph> method.</source>
          <target state="translated">Sie sollten auch überschreiben die <ph id="ph1">&lt;xref:System.Random.Next&gt;</ph>, <ph id="ph2">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph>, und <ph id="ph3">&lt;xref:System.Random.NextBytes%2A&gt;</ph> Methoden, um sicherzustellen, dass sie die überschriebene Aufrufen <ph id="ph4">&lt;xref:System.Random.Sample%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You don't have to override the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Random.NextDouble%2A&gt;</ph> methods.</source>
          <target state="translated">Sie überschreiben, müssen die <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%29&gt;</ph> und <ph id="ph2">&lt;xref:System.Random.NextDouble%2A&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>For an example that derives from the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class and modifies its default pseudo-random number generator, see the <ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph> reference page.</source>
          <target state="translated">Ein Beispiel, das von abgeleitet ist die <ph id="ph1">&lt;xref:System.Random&gt;</ph> Klasse und ändert dessen Standardwert Pseudozufallszahlen, finden Sie unter der <ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph> Referenzseite.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>How do you use System.Random to…</source>
          <target state="translated">Wie werden System.Random, verwendet...</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following sections discuss and provide sample code for some of the ways you might want to use random numbers in your app.</source>
          <target state="translated">In den folgenden Abschnitten besprechen und stellen entsprechenden Beispielcode für einige der Methoden, die Zufallszahlen in Ihrer app verwenden werden sollen.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve the same sequence of random values</source>
          <target state="translated">Die gleiche Sequenz von Zufallswerten abrufen</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Sometimes you want to generate the same sequence of random numbers in software test scenarios and in game playing.</source>
          <target state="translated">In einigen Fällen Sie dieselbe Sequenz von Zufallszahlen in Software Testszenarios und Spiel Wiedergabe generieren möchten.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Testing with the same sequence of random numbers allows you to detect regressions and confirm bug fixes.</source>
          <target state="translated">Mit derselben Sequenz von Zufallszahlen testen, können Sie erkennen von Regressionen und Fehlerbehebungen zu bestätigen.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Using the same sequence of random number in games allows you to replay previous games.</source>
          <target state="translated">Die gleiche Sequenz von Zufallszahl können Spiele Sie vorherige Spiele wiedergeben.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can generate the same sequence of random numbers by providing the same seed value to the <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor.</source>
          <target state="translated">Sie können die gleiche Sequenz von Zufallszahlen generieren, indem Sie den gleichen Ausgangswert zum Bereitstellen der <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> Konstruktor.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The seed value provides a starting value for the pseudo-random number generation algorithm.</source>
          <target state="translated">Der Ausgangswert stellt einen Startwert für die Generierung Algorithmus Pseudozufallszahlen bereit.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example uses 100100 as an arbitrary seed value to instantiate the <ph id="ph1">&lt;xref:System.Random&gt;</ph> object, displays 20 random floating-point values, and persists the seed value.</source>
          <target state="translated">Im folgenden Beispiel wird 100100 als eine beliebige Ausgangswert zum Instanziieren der <ph id="ph1">&lt;xref:System.Random&gt;</ph> Objekt 20 zufällige Gleitkommazahlen-Punktwerte angezeigt und bleibt weiterhin den Ausgangswert.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>It then restores the seed value, instantiates a new random number generator, and displays the same 20 random floating-point values.</source>
          <target state="translated">Anschließend wird der Ausgangswert wiederhergestellt, instanziiert einen neuen Zufallszahlengenerator, und zeigt die gleichen 20 zufällige Gleitkommazahlen Werte.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Note that the example may produce different sequences of random numbers if run on different versions of the .NET Framework.</source>
          <target state="translated">Beachten Sie, dass im Beispiel verschiedene Sequenzen von Zufallszahlen erzeugen kann, wenn in verschiedenen Versionen von .NET Framework ausgeführt werden.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve unique sequences of random numbers</source>
          <target state="translated">Abrufen von eindeutigen Sequenzen von Zufallszahlen</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Providing different seed values to instances of the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class causes each random number generator to produce a different sequence of values.</source>
          <target state="translated">Bietet verschiedene Ausgangswerte auf Instanzen von der <ph id="ph1">&lt;xref:System.Random&gt;</ph> Klasse bewirkt, dass jede Zufallszahlen-Generator um eine andere Sequenz von Werten zu erzeugen.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can provide a seed value either explicitly by calling the <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor, or implicitly by calling the <ph id="ph2">&lt;xref:System.Random.%23ctor&gt;</ph> constructor.</source>
          <target state="translated">Sie können einem Ausgangswert angeben, entweder explizit durch Aufrufen der <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> -Konstruktor oder implizit durch Aufrufen der <ph id="ph2">&lt;xref:System.Random.%23ctor&gt;</ph> Konstruktor.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Most developers call the parameterless constructor, which uses the system clock.</source>
          <target state="translated">Die meisten Entwickler Aufrufen des Konstruktors, der Systemuhr verwendet.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example uses this approach to instantiate two <ph id="ph1">&lt;xref:System.Random&gt;</ph> instances.</source>
          <target state="translated">Im folgenden Beispiel wird dieser Ansatz zum Instanziieren zweier <ph id="ph1">&lt;xref:System.Random&gt;</ph> Instanzen.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Each instance displays a series of 10 random integers.</source>
          <target state="translated">Jede Instanz zeigt eine Reihe von 10 zufällige ganze Zahlen.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, because of its finite resolution, the system clock doesn't detect time differences that are less than approximately 15 milliseconds.</source>
          <target state="translated">Jedoch aufgrund seiner endliche Auflösung erkennt die Systemuhr Zeitunterschiede nicht, die weniger als etwa 15 Millisekunden.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Therefore, if your code calls the <ph id="ph1">&lt;xref:System.Random.%23ctor&gt;</ph> overload to instantiate two <ph id="ph2">&lt;xref:System.Random&gt;</ph> objects in succession, you might inadvertently be providing the objects with identical seed values.</source>
          <target state="translated">Daher Ihren Code aufruft der <ph id="ph1">&lt;xref:System.Random.%23ctor&gt;</ph> Überladung zum Instanziieren zweier <ph id="ph2">&lt;xref:System.Random&gt;</ph> Objekte nacheinander, Sie versehentlich geleistet werden die Objekte mit identischen Ausgangswerte.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To see this in the previous example, comment out the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method call, and compile and run the example again.</source>
          <target state="translated">Um dies im vorherigen Beispiel zu sehen, kommentieren Sie Sie aus der <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> -Methodenaufruf, und kompilieren und führen Sie das Beispiel erneut aus.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To prevent this from happening, we recommend that you instantiate a single <ph id="ph1">&lt;xref:System.Random&gt;</ph> object rather than multiple ones.</source>
          <target state="translated">Um dies zu vermeiden, wird empfohlen, dass Sie ein einzelnes instanziieren <ph id="ph1">&lt;xref:System.Random&gt;</ph> -Objekt statt mehrere Sitzungen.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, since <ph id="ph1">&lt;xref:System.Random&gt;</ph> isn't thread safe, you must use some synchronization device if you access a <ph id="ph2">&lt;xref:System.Random&gt;</ph> instance from multiple threads; for more information, see <bpt id="p1">[</bpt>The Random class and thread safety<ept id="p1">](#ThreadSafety)</ept> earlier in this topic.</source>
          <target state="translated">Da jedoch <ph id="ph1">&lt;xref:System.Random&gt;</ph> ist nicht threadsicher ist, müssen Sie einige Synchronisierung-Gerät verwenden, wenn der Zugriff auf eine <ph id="ph2">&lt;xref:System.Random&gt;</ph> -Instanz aus mehreren Threads; Weitere Informationen verwenden, finden Sie unter <bpt id="p1">[</bpt>der zufälligen Klasse und Threadsicherheit<ept id="p1">](#ThreadSafety)</ept> weiter oben in dieser Thema.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Alternately, you can use a delay mechanism, such as the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> method used in the previous example, to ensure that the instantiations occur more than 15 millisecond apart.</source>
          <target state="translated">Alternativ können Sie einen verzögerungsmechanismus, wie z. B. die <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> Methode, die im vorherigen Beispiel verwendet werden, um sicherzustellen, dass die Instanziierungen mehr als 15 Millisekunden voneinander auftreten.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve integers in a specified range</source>
          <target state="translated">Abrufen von ganzen Zahlen in einem angegebenen Bereich</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can retrieve integers in a specified range by calling the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method, which lets you specify both the lower and the upper bound of the numbers you'd like the random number generator to return.</source>
          <target state="translated">Abrufen von ganzen Zahlen in einem angegebenen Bereich durch Aufrufen der <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> -Methode, die ermöglicht die Angabe der niedrigere Wert und die Obergrenze für die Zahlen den Zufallszahlengenerator zurückgeben möchten.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The upper bound is an exclusive, not an inclusive, value.</source>
          <target state="translated">Die Obergrenze ist eine exklusive, keine inklusive Wert.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>That is, it isn't included in the range of values returned by the method.</source>
          <target state="translated">Es ist nicht, also in den Bereich der Werte, die von der Methode zurückgegebenen enthalten.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example uses this method to generate random integers between -10 and 10.</source>
          <target state="translated">Im folgenden Beispiel wird diese Methode zum Generieren von Zufallszahlen zwischen-10 und 10 ein.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Note that it specifies 11, which is one greater than the desired value, as the value of the <ph id="ph1">`maxValue`</ph> argument in the method call.</source>
          <target state="translated">Beachten Sie, dass es 11, gibt der eins größer als den gewünschten Wert, als der Wert von der <ph id="ph1">`maxValue`</ph> Argument im Aufruf Methode.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve integers with a specified number of digits</source>
          <target state="translated">Abrufen von ganzen Zahlen mit einer angegebenen Anzahl von Ziffern</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can call the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method to retrieve numbers with a specified number of digits.</source>
          <target state="translated">Sie erreichen die <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> Methode, um Zahlen mit einer angegebenen Anzahl von Ziffern abzurufen.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>For example, to retrieve numbers with four digits (that is, numbers that range from 1000 to 9999), you call the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method with a <ph id="ph2">`minValue`</ph> value of 1000 and a <ph id="ph3">`maxValue`</ph> value of 10000, as the following example shows.</source>
          <target state="translated">Beispielsweise zum Abrufen von Zahlen mit vier Ziffern (d. h., Zahlen, die im Bereich von 1000 bis 9999), rufen Sie die <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> Methode mit einem <ph id="ph2">`minValue`</ph> Wert 1000 und ein <ph id="ph3">`maxValue`</ph> Wert von 10.000, wie im folgenden Beispiel gezeigt.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve floating-point values in a specified range</source>
          <target state="translated">Abrufen von Gleitkommawerten in einem angegebenen Bereich</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method returns random floating-point values that range from 0 to less than 1.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> Methode gibt zufällige Gleitkommazahlen-Punktwerte dieses Bereichs liegt zwischen 0 und kleiner als 1.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, you'll often want to generate random values in some other range.</source>
          <target state="translated">Sie sollten jedoch häufig zum Generieren von zufälliger Werten in einem anderen Bereich zu können.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If the interval between the minimum and maximum desired values is 1, you can add the difference between the desired starting interval and 0 to the number returned by the <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method.</source>
          <target state="translated">Wenn das Intervall zwischen den minimalen und maximalen Werten für den gewünschten 1 ist, können Sie den Unterschied zwischen der gewünschten beginnend Intervall und 0 hinzufügen, auf die zurückgegebene Anzahl der <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example does this to generate 10 random numbers between -1 and 0.</source>
          <target state="translated">Im folgende Beispiel wird diese Option, um 10 Zufallszahlen zwischen-1 und 0.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To generate random floating-point numbers whose lower bound is 0 but upper bound is greater than 1 (or, in the case of negative numbers, whose lower bound is less than -1 and upper bound is 0), multiply the random number by the non-zero bound.</source>
          <target state="translated">Um zufällige Gleitkommazahlen generiert wird, dessen untere Grenze 0 jedoch Obergrenze ist größer als 1 (oder bei negativen Zahlen, dessen untere Grenze ist kleiner als-1 und obere Grenze ist 0), Multiplizieren Sie Zufallszahl mit der Grenze ungleich NULL.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example does this to generate 20 million random floating-point numbers that range from 0 to <ph id="ph1">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Im folgende Beispiel wird diese Option, um 20 Millionen zufällige Gleitkommazahlen generiert dieses Bereichs von 0 bis <ph id="ph1">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In also displays the distribution of the random values generated by the method.</source>
          <target state="translated">In zeigt auch die Verteilung von Zufallswerten, die von der Methode generiert.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To generate random floating-point numbers between two arbitrary values, like the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method does for integers, use the following formula:</source>
          <target state="translated">Um zufällige Gleitkommazahlen zwischen zwei beliebigen Werten zu generieren, wie die <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> Methode für ganze Zahlen enthält, verwenden Sie die folgende Formel:</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example generates 1 million random numbers that range from 10.0 to 11.0, and displays their distribution.</source>
          <target state="translated">Im folgenden Beispiel generiert 1 Million Zufallszahlen, die im Bereich von 10.0 11.0 und zeigt die Verteilung.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Generate random Boolean values</source>
          <target state="translated">Generieren von zufälligen boolesche Werte</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">&lt;xref:System.Random&gt;</ph> class doesn't provide methods that generate <ph id="ph2">&lt;xref:System.Boolean&gt;</ph> values.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Random&gt;</ph> Klasse stellt Methoden zur Erstellung keinen <ph id="ph2">&lt;xref:System.Boolean&gt;</ph> Werte.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, you can define your own class or method to do that.</source>
          <target state="translated">Allerdings können Sie eine eigene Klasse oder Methode dafür definieren.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example defines a class, <ph id="ph1">`BooleanGenerator`</ph>, with a single method, <ph id="ph2">`NextBoolean`</ph>.</source>
          <target state="translated">Das folgende Beispiel definiert eine Klasse <ph id="ph1">`BooleanGenerator`</ph>, mit einer einzelnen Methode <ph id="ph2">`NextBoolean`</ph>.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">`BooleanGenerator`</ph> class stores a <ph id="ph2">&lt;xref:System.Random&gt;</ph> object as a private variable.</source>
          <target state="translated">Die <ph id="ph1">`BooleanGenerator`</ph> -Klasse speichert ein <ph id="ph2">&lt;xref:System.Random&gt;</ph> Objekt als eine private Variable.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">`NextBoolean`</ph> method calls the <ph id="ph2">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method and passes the result to the <ph id="ph3">&lt;xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Die <ph id="ph1">`NextBoolean`</ph> Methodenaufrufe der <ph id="ph2">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> Methode und übergibt das Ergebnis, das die <ph id="ph3">&lt;xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Note that 2 is used as the argument to specify the upper bound of the random number.</source>
          <target state="translated">Beachten Sie, dass 2 als Argument an die obere Grenze der zufälligen Zahl verwendet wird.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Since this is an exclusive value, the method call returns either 0 or 1.</source>
          <target state="translated">Da dies ein ausgeschlossener Wert ist, gibt der Aufruf der Methode zurück, entweder 0 oder 1.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Instead of creating a separate class to generate random <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> values, the example could simply have defined a single method.</source>
          <target state="translated">Statt eine separate Klasse generieren zufälliger <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> Werte, die im Beispiel können einfach eine einzelne Methode definiert haben.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In that case, however, the <ph id="ph1">&lt;xref:System.Random&gt;</ph> object should have been defined as a class-level variable to avoid instantiating a new <ph id="ph2">&lt;xref:System.Random&gt;</ph> instance in each method call.</source>
          <target state="translated">In diesem Fall wird jedoch die <ph id="ph1">&lt;xref:System.Random&gt;</ph> Objekt sollte als einer Variablen auf Klassenebene, um zu vermeiden, instanziieren ein neues definiert wurden <ph id="ph2">&lt;xref:System.Random&gt;</ph> Instanz in jedem Methodenaufruf.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In Visual Basic, the Random instance can be defined as a <bpt id="p1">[</bpt>Static<ept id="p1">](~/docs/visual-basic/language-reference/modifiers/static.md)</ept> variable in the <ph id="ph1">`NextBoolean`</ph> method.</source>
          <target state="translated">In Visual Basic Random-Instanz definiert werden kann, als ein <bpt id="p1">[</bpt>statische<ept id="p1">](~/docs/visual-basic/language-reference/modifiers/static.md)</ept> -Variable in der <ph id="ph1">`NextBoolean`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example provides an implementation.</source>
          <target state="translated">Im folgende Beispiel stellt eine Implementierung bereit.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Generate random 64-bit integers</source>
          <target state="translated">Generieren von zufälligen 64-Bit-Ganzzahlen</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> method return 32-bit integers.</source>
          <target state="translated">Die Überladungen der <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> Methodenrückgabewert 32-Bit-Ganzzahlen.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, in some cases, you might want to work with 64-bit integers.</source>
          <target state="translated">In einigen Fällen möchten jedoch möglicherweise mit 64-Bit-Ganzzahlen arbeiten.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can do this as follows:</source>
          <target state="translated">Sie können dies wie folgt tun:</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Call the <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method to retrieve a double-precision floating point value.</source>
          <target state="translated">Rufen Sie die <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> Methode zum Abrufen der Gleitkommazahl mit doppelter Genauigkeit Datenpunktwert.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Multiply that value by <ph id="ph1">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Multiplizieren Sie den Wert von <ph id="ph1">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example uses this technique to generate 20 million random long integers and categorizes them in 10 equal groups.</source>
          <target state="translated">Im folgenden Beispiel verwendet dieses Verfahren zu lange 20 Millionen Zufallszahlen generieren und diese in 10 gleich große Gruppen kategorisiert.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>It then evaluates the distribution of the random numbers by counting the number in each group from 0 to <ph id="ph1">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Wertet dann die Verteilung der zufälligen Zahlen durch zählen der Anzahl in jeder Gruppe von 0 bis <ph id="ph1">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>As the output from the example shows, the numbers are distributed more or less equally through the range of a long integer.</source>
          <target state="translated">Wie die Ausgabe des Beispiels zeigt, werden die Zahlen über den Bereich einer langen ganzen Zahl mehr oder weniger gleichmäßig verteilt.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>An alternative technique that uses bit manipulation does not generate truly random numbers.</source>
          <target state="translated">Ein alternatives Verfahren, dass Bitmanipulation verwendet keine echten Zufallszahlen generiert.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>This technique calls <ph id="ph1">&lt;xref:System.Random.Next&gt;</ph> to generate two integers, left-shifts one by 32 bits, and ORs them together.</source>
          <target state="translated">Diese Methode ruft <ph id="ph1">&lt;xref:System.Random.Next&gt;</ph> zum Generieren von zwei ganzen Zahlen nach links verschiebt eine von 32 Bits und oder-Operatoren werden zusammen.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>This technique has two limitations:</source>
          <target state="translated">Dieses Verfahren hat zwei Nachteile:</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Because bit 31 is the sign bit, the value in bit 31 of the resulting long integer is always 0.</source>
          <target state="translated">Da Bit 31 das signierte Bit ist, lautet der Wert in Bit 31 des resultierenden long integer-Wert immer 0.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>This can be addressed by generating a random 0 or 1, left-shifting it 31 bits, and ORing it with the original random long integer.</source>
          <target state="translated">Dies kann durch Generieren einer zufälligen 0 oder 1, es links-Verschiebung Bits 31 und OR adressiert werden mit der ursprünglichen zufällige lange ganze Zahl.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>More seriously, because the probability that the value returned by <ph id="ph1">&lt;xref:System.Random.Next&gt;</ph> will be 0, there will be few if any random numbers in the range 0x0-0x00000000FFFFFFFF.</source>
          <target state="translated">Mehr erheblich, da die Wahrscheinlichkeit, die der Wert von zurückgegeben <ph id="ph1">&lt;xref:System.Random.Next&gt;</ph> wird "0" sein, es werden ggf. einige Zufallszahlen im Bereich 0 x 0 – 0x00000000FFFFFFFF.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve bytes in a specified range</source>
          <target state="translated">Abrufen von Bytes in einem angegebenen Bereich</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> method allow you to specify the range of random numbers, but the <ph id="ph2">&lt;xref:System.Random.NextBytes%2A&gt;</ph> method does not.</source>
          <target state="translated">Überladungen der der <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> Methode ermöglichen Ihnen das Festlegen des Bereichs von zufälligen Zahlen, aber die <ph id="ph2">&lt;xref:System.Random.NextBytes%2A&gt;</ph> Methode nicht.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example implements a <ph id="ph1">`NextBytes`</ph> method that lets you specify the range of the returned bytes.</source>
          <target state="translated">Das folgende Beispiel implementiert eine <ph id="ph1">`NextBytes`</ph> Methode, die Sie den Bereich der zurückgegebenen Bytes angeben kann.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>It defines a <ph id="ph1">`Random2`</ph> class that derives from <ph id="ph2">&lt;xref:System.Random&gt;</ph> and overloads its <ph id="ph3">`NextBytes`</ph> method.</source>
          <target state="translated">Definiert eine <ph id="ph1">`Random2`</ph> von abgeleitete Klasse <ph id="ph2">&lt;xref:System.Random&gt;</ph> und überlädt die <ph id="ph3">`NextBytes`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">`NextBytes(Byte[], Byte, Byte)`</ph> method wraps a call to the <ph id="ph2">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method and specifies the minimum value and one greater than the maximum value (in this case, 0 and 101) that we want returned in the byte array.</source>
          <target state="translated">Die <ph id="ph1">`NextBytes(Byte[], Byte, Byte)`</ph> Methode bindet einen Aufruf der <ph id="ph2">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> Methode und gibt den minimalen und Wert größer als der maximale Wert (in diesem Fall 0 und 101), dass wir in der Byte-Array zurückgegeben werden sollen.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Because we are sure that the integer values returned by the <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> method are within the range of the <ph id="ph2">&lt;xref:System.Byte&gt;</ph> data type, we can safely cast them (in C#) or convert them (in Visual Basic) from integers to bytes.</source>
          <target state="translated">Da wir sicher sind, dass die ganzzahligen Werte zurückgegebene der <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> Methode sind innerhalb des Bereichs von der <ph id="ph2">&lt;xref:System.Byte&gt;</ph> -Datentyp, wir können sicher umgewandelt werden (in c#) oder konvertieren Sie sie (in Visual Basic) von ganzen Zahlen in Byte.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve an element from an array or collection at random</source>
          <target state="translated">Nach dem Zufallsprinzip ein Element aus einem Array oder einer Auflistung abrufen</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Random numbers often serve as indexes to retrieve values from arrays or collections.</source>
          <target state="translated">Zufallszahlen dienen häufig als Indizes, um Werte aus Arrays oder Auflistungen abzurufen.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To retrieve a random index value, you can call the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method, and use the lower bound of the array as the value of its <ph id="ph2">`minValue`</ph> argument and one greater than the upper bound of the array as the value of its <ph id="ph3">`maxValue`</ph> argument.</source>
          <target state="translated">Um einen zufälligen Indexwert abzurufen, rufen Sie die <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> -Methode, und verwenden Sie die untere Grenze des Arrays als Wert für die <ph id="ph2">`minValue`</ph> Argument und der eins größer als die obere Grenze des Arrays als Wert des seine <ph id="ph3">`maxValue`</ph> Argument.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>For a zero-based array, this is equivalent to its <ph id="ph1">&lt;xref:System.Array.Length%2A&gt;</ph> property, or one greater than the value returned by the <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Für ein nullbasiertes Array entspricht dies dem seine <ph id="ph1">&lt;xref:System.Array.Length%2A&gt;</ph> Eigenschaft oder eins größer als der Rückgabewert von der <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example randomly retrieves the name of a city in the United States from an array of cities.</source>
          <target state="translated">Das folgende Beispiel ruft den Namen eines Orts in den USA nach dem Zufallsprinzip aus einem Array aus Städten ab.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve a unique element from an array or collection</source>
          <target state="translated">Ein eindeutiges Element aus einem Array oder einer Auflistung abrufen</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>A random number generator can always return duplicate values.</source>
          <target state="translated">Eine Zufallszahlen-Generators kann immer doppelte Werte zurückgeben.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>As the range of numbers becomes smaller or the number of values generated becomes larger, the probability of duplicates grows.</source>
          <target state="translated">Der Bereich von Zahlen wird kleiner, oder die Anzahl der generierten Werte größer wird, wächst die Wahrscheinlichkeit von Duplikaten.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If random values must be unique, more numbers are generated to compensate for duplicates, resulting in increasingly poor performance.</source>
          <target state="translated">Wenn Zufallswerte eindeutig sein müssen, werden weitere Zahlen generiert, um Duplikate zu kompensieren zunehmend eine schlechte Leistung.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>There are a number of techniques to handle this scenario.</source>
          <target state="translated">Es gibt eine Reihe von Techniken, dieses Szenario zu behandeln.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>One common solution is to create an array or collection that contains the values to be retrieved, and a parallel array that contains random floating-point numbers.</source>
          <target state="translated">Eine allgemeine Lösung besteht darin, erstellen Sie ein Array oder Auflistung mit den Werten abgerufen werden sollen und ein paralleles Array, das zufällige Gleitkommazahlen enthält.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The second array is populated with random numbers at the time the first array is created, and the <ph id="ph1">&lt;xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType&gt;</ph> method is used to sort the first array by using the values in the parallel array.</source>
          <target state="translated">Das zweite Array wird mit Zufallszahlen aufgefüllt, die zum Zeitpunkt der erste Array erstellt wird, und die <ph id="ph1">&lt;xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType&gt;</ph> Methode wird verwendet, um das erste Array zu sortieren, indem Sie mithilfe der Werte in den parallelen Arrays.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>For example, if you're developing a Solitaire game, you want to ensure that each card is used only once.</source>
          <target state="translated">Z. B. Wenn Sie ein Solitärspiel entwickeln, möchten Sie sicherstellen, dass jede Karte nur einmal verwendet wird.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Instead of generating random numbers to retrieve a card and tracking whether that card has already been dealt, you can create a parallel array of random numbers that can be used to sort the deck.</source>
          <target state="translated">Anstatt das Generieren von Zufallszahlen zum Abrufen einer Karte und nachverfolgen, ob diese Karte bereits behandelt wurde, können Sie ein paralleles Array von Zufallszahlen erstellen, die zum Sortieren der Deckblatt verwendet werden kann.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Once the deck is sorted, your app can maintain a pointer to indicate the index of the next card on the deck.</source>
          <target state="translated">Sobald die Deckblatt sortiert ist, kann Ihre app einen Zeiger, um den Index des nächsten Karte auf der Deckblatt anzugeben verwalten.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example illustrates this approach.</source>
          <target state="translated">Dieser Ansatz wird anhand des folgenden Beispiels veranschaulicht.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>It defines a <ph id="ph1">`Card`</ph> class that represents a playing card and a <ph id="ph2">`Dealer`</ph> class that deals a deck of shuffled cards.</source>
          <target state="translated">Definiert eine <ph id="ph1">`Card`</ph> -Klasse, stellt ein Playing Karte und <ph id="ph2">`Dealer`</ph> -Klasse, die eine falsch platzierte Kartenstapel behandelt.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">`Dealer`</ph> class constructor populates two arrays: a <ph id="ph2">`deck`</ph> array that has class scope and that represents all the cards in the deck; and a local <ph id="ph3">`order`</ph> array that has the same number of elements as the <ph id="ph4">`deck`</ph> array and is populated with randomly generated <ph id="ph5">&lt;xref:System.Double&gt;</ph> values.</source>
          <target state="translated">Die <ph id="ph1">`Dealer`</ph> Klassenkonstruktor füllt zwei Arrays: eine <ph id="ph2">`deck`</ph> Array, das über einen Klassenbereich und, die alle Karten Deckblatt; und einem lokalen darstellt <ph id="ph3">`order`</ph> Array, das die gleiche von Elementen als Anzahl die <ph id="ph4">`deck`</ph> array erstellt und gefüllt ist mit nach dem Zufallsprinzip generiert <ph id="ph5">&lt;xref:System.Double&gt;</ph> Werte.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType&gt;</ph> method is then called to sort the <ph id="ph2">`deck`</ph> array based on the values in the <ph id="ph3">`order`</ph> array.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType&gt;</ph> Methode wird aufgerufen, um das Sortieren der <ph id="ph2">`deck`</ph> Array basierend auf den Werten in der <ph id="ph3">`order`</ph> Array.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example creates a single random number generator and calls its <ph id="ph1">&lt;xref:System.Random.NextBytes%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Random.Next%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Random.NextDouble%2A&gt;</ph> methods to generate sequences of random numbers within different ranges.</source>
          <target state="translated">Das folgende Beispiel erstellt eine einzelne Zufallszahlen-Generators und ruft seine <ph id="ph1">&lt;xref:System.Random.NextBytes%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Random.Next%2A&gt;</ph>, und <ph id="ph3">&lt;xref:System.Random.NextDouble%2A&gt;</ph> Methoden zum Generieren von Sequenzen von Zufallszahlen in verschiedenen Bereichen.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example generates a random integer that it uses as an index to retrieve a string value from an array.</source>
          <target state="translated">Das folgende Beispiel generiert eine zufällige ganze Zahl, die als Index verwendet einen Zeichenfolgenwert aus einem Array abgerufen.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In the .NET Framework 1.0 and 1.1, a minimum implementation of a class derived from <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> required overriding the <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method to define a new or modified algorithm for generating random numbers.</source>
          <target state="translated">In .NET Framework 1.0 und 1.1, eine minimale Implementierung einer Klasse abgeleitet <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> erforderlich sind, überschreiben die <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> Methode, um einen neuen oder geänderten Algorithmus zum Generieren von Zufallszahlen zu definieren.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The derived class could then rely on the base class implementation of the <ph id="ph1">&lt;see cref="M:System.Random.Next" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Random.Next(System.Int32)" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph>, <ph id="ph4">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph>, and <ph id="ph5">&lt;see cref="M:System.Random.NextDouble" /&gt;</ph> methods to call the derived class implementation of the <ph id="ph6">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method.</source>
          <target state="translated">Die abgeleitete Klasse konnten klicken Sie dann auf die Implementierung der Basisklasse der Verlassen der <ph id="ph1">&lt;see cref="M:System.Random.Next" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Random.Next(System.Int32)" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph>, <ph id="ph4">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph>, und <ph id="ph5">&lt;see cref="M:System.Random.NextDouble" /&gt;</ph> Methoden zur Implementierung der abgeleiteten Klasse Aufrufen der <ph id="ph6">&lt;see cref="M:System.Random.Sample" /&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In the .NET Framework 2.0 and later, the behavior of the <ph id="ph1">&lt;see cref="M:System.Random.Next" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph>, and <ph id="ph3">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph> methods have changed so that these methods do not necessarily call the derived class implementation of the <ph id="ph4">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method.</source>
          <target state="translated">In .NET Framework 2.0 und höher, das Verhalten der <ph id="ph1">&lt;see cref="M:System.Random.Next" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph>, und <ph id="ph3">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph> Methoden wurden geändert, sodass diese Methoden nicht unbedingt Implementierung der abgeleiteten Klasse Aufrufen der <ph id="ph4">&lt;see cref="M:System.Random.Sample" /&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>As a result, classes derived from <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> that target the .NET Framework 2.0 and later should also override these three methods.</source>
          <target state="translated">Folglich von abgeleiteten Klassen <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> , die als Ziel .NET Framework 2.0 und höher sollten auch diese drei Methoden überschreiben.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The implementation of the random number generator in the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class isn't guaranteed to remain the same across major versions of the .NET Framework.</source>
          <target state="translated">Die Implementierung des Zufallszahlen-Generator in der <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> Klasse ist nicht unbedingt Hauptversionen von .NET Framework unverändert.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>As a result, you shouldn't assume that the same seed will result in the same pseudo-random sequence in different versions of the .NET Framework.</source>
          <target state="translated">Daher sollte nicht Sie davon ausgehen, dass der gleiche Ausgangswert in derselben Reihenfolge an pseudozufälligen Schlüsselbytes in verschiedenen Versionen von .NET Framework führt.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="T:System.Random">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph>-Klasse.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Random.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class, using a time-dependent default seed value.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph>-Klasse unter Verwendung eines zeitabhängigen Standardstartwerts.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>The default seed value is derived from the system clock and has finite resolution.</source>
          <target state="translated">Der Standardstartwert wird aus der Systemuhr abgeleitet und verfügt über begrenzte Auflösung.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>As a result, different <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects that are created in close succession by a call to the default constructor will have identical default seed values and, therefore, will produce identical sets of random numbers.</source>
          <target state="translated">Als Ergebnis unterschiedliche <ph id="ph1">&lt;xref:System.Random&gt;</ph> durch einen Aufruf des Standardkonstruktors in Zufallszahlengeneratoren erstellten Objekte müssen identische Ausgangswert Standardwerte, und daher entsteht identische Sätze von Zufallszahlen.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>This problem can be avoided by using a single <ph id="ph1">&lt;xref:System.Random&gt;</ph> object to generate all random numbers.</source>
          <target state="translated">Dieses Problem kann vermieden werden, mithilfe einer einzelnes <ph id="ph1">&lt;xref:System.Random&gt;</ph> Objekt, das alle Zufallszahlen generiert.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>You can also work around it by modifying the seed value returned by the system clock and then explicitly providing this new seed value to the <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor.</source>
          <target state="translated">Sie können auch umgehen, es durch Ändern der Startwert der Systemuhr zurückgegebenes und klicken Sie dann auf diese neuen Ausgangswerts explizite Angabe der <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> Konstruktor.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor.</source>
          <target state="translated">Weitere Informationen finden Sie unter der <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> Konstruktor.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>Call this constructor if you want your random number generator to generate a random sequence of numbers.</source>
          <target state="translated">Rufen Sie diesen Konstruktor, gegebenenfalls Ihre Zufallszahlen-Generators eine zufällige Sequenz von Zahlen zu generieren.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>To generate a fixed  sequence of random numbers that will be the same for different random number generators, call the <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor with a fixed seed value .</source>
          <target state="translated">Um einer festen Reihenfolge von Zufallszahlen generieren, die für verschiedene Zufallszahlengeneratoren identisch sind, rufen Sie die <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> Konstruktor mit einem festen Ausgangswert.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>This <ph id="ph1">&lt;xref:System.Random&gt;</ph> constructor overload is frequently used when testing apps that use random numbers.</source>
          <target state="translated">Dies <ph id="ph1">&lt;xref:System.Random&gt;</ph> Konstruktorüberladung wird häufig verwendet, beim Testen von apps, die Zufallszahlen verwenden.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>Once you've instantiated the random number generator, you call individual <ph id="ph1">&lt;xref:System.Random&gt;</ph> methods, such as <ph id="ph2">&lt;xref:System.Random.Next&gt;</ph> or <ph id="ph3">&lt;xref:System.Random.NextDouble&gt;</ph>, to generate random numbers.</source>
          <target state="translated">Nachdem Sie den Zufallszahlen-Generator instanziiert haben, rufen Sie einzelne <ph id="ph1">&lt;xref:System.Random&gt;</ph> Methoden, wie z. B. <ph id="ph2">&lt;xref:System.Random.Next&gt;</ph> oder <ph id="ph3">&lt;xref:System.Random.NextDouble&gt;</ph>, um zufällige Zahlen zu generieren.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>The following example uses the default constructor to instantiate three <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects and displays a sequence of five random integers for each.</source>
          <target state="translated">Im folgenden Beispiel wird den Standardkonstruktor drei instanziieren <ph id="ph1">&lt;xref:System.Random&gt;</ph> Objekte und eine Sequenz von fünf zufällige ganze Zahlen enthält, für die einzelnen.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>Because the first two <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects are created in close succession, they are instantiated using identical seed values based on the system clock and, therefore, they produce an identical sequence of random numbers.</source>
          <target state="translated">Da die ersten beiden <ph id="ph1">&lt;xref:System.Random&gt;</ph> Objekte schließen nacheinander erstellt werden, sie mit identischen Startwerten basierend auf der Systemzeit instanziiert werden und daher eine identische Folge von zufälligen Zahlen hervorrufen.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>On the other hand, the default constructor of the third <ph id="ph1">&lt;xref:System.Random&gt;</ph> object is called after a two-second delay caused by calling the <ph id="ph2">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Auf der anderen Seite der Standardkonstruktor des dritten <ph id="ph1">&lt;xref:System.Random&gt;</ph> Objekt wird aufgerufen, nachdem eine Verzögerung von zwei Sekunden durch einen Aufruf verursacht die <ph id="ph2">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>Because this produces a different seed value for the third <ph id="ph1">&lt;xref:System.Random&gt;</ph> object, it produces a different sequence of random numbers.</source>
          <target state="translated">Da dies einen anderer Startwert für die dritte erzeugt <ph id="ph1">&lt;xref:System.Random&gt;</ph> -Objekt, es wird eine andere Sequenz von Zufallszahlen generiert.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Random.#ctor(System.Int32)">
          <source>A number used to calculate a starting value for the pseudo-random number sequence.</source>
          <target state="translated">Eine Zahl, mit der ein Startwert für Folgen von Pseudozufallszahlen berechnet wird.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Random.#ctor(System.Int32)">
          <source>If a negative number is specified, the absolute value of the number is used.</source>
          <target state="translated">Wenn eine negative Zahl angegeben wird, wird der absolute Wert der Zahl verwendet.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Random.#ctor(System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class, using the specified seed value.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph>-Klasse unter Verwendung des angegebenen Startwerts.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>Providing an identical seed value to different <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects causes each instance to produce identical sequences of random numbers.</source>
          <target state="translated">Bereitstellen eines identischen Startwerts zu anderen <ph id="ph1">&lt;xref:System.Random&gt;</ph> Objekte bewirkt, dass jede Instanz identische Sequenzen von Zufallszahlen erzeugen.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>This is often done when testing apps that rely on random number generators.</source>
          <target state="translated">Dies erfolgt häufig beim Testen von apps, die auf Zufallszahlen-Generatoren abhängig sind.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>If your application requires different random number sequences, invoke this constructor repeatedly with different seed values.</source>
          <target state="translated">Wenn Ihre Anwendung verschiedene Folgen von Zufallszahlen erfordert, rufen Sie diesen Konstruktor wiederholt mit verschiedenen Ausgangswerte.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>One way to produce a unique seed value is to make it time-dependent.</source>
          <target state="translated">Eine Möglichkeit zur Erzeugung eines Werts eindeutige Ausgangswert ist zum erleichtern der zeitabhängige.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>For example, derive the seed value from the system clock, as the <ph id="ph1">&lt;xref:System.Random.%23ctor&gt;</ph> overload does.</source>
          <target state="translated">Die Systemuhr, z. B. den Ausgangswert abgeleitet werden, als die <ph id="ph1">&lt;xref:System.Random.%23ctor&gt;</ph> Überladung ist.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>However, the system clock might not have sufficient resolution to provide different invocations of this constructor with a different seed value.</source>
          <target state="translated">Die Systemuhr möglicherweise jedoch nicht ausreichend Auflösung verschiedene Aufrufen dieses Konstruktors mit einem anderen Ausgangswert angeben.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>This results in random number generators that generate identical sequences of pseudo-random numbers, as illustrated by the first two <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects in the following example.</source>
          <target state="translated">Dies führt in random Number-Generatoren, die identische Sequenzen von pseudozufälligen Zahlen zu generieren, wie die ersten beiden veranschaulicht <ph id="ph1">&lt;xref:System.Random&gt;</ph> Objekte im folgenden Beispiel.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>To prevent this, apply an algorithm to differentiate the seed value in each invocation, or call the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method to ensure that you provide each constructor with a different seed value.</source>
          <target state="translated">Um dies zu verhindern, wenden Sie einen Algorithmus zum unterscheiden des Seed-Werts in jeder Aufruf oder ein Aufruf der <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> Methode, um sicherzustellen, dass Sie jeder Konstruktor mit einem anderen Ausgangswert angeben.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>Another option is to instantiate a single <ph id="ph1">&lt;xref:System.Random&gt;</ph> object that you use to generate all the random numbers in your application.</source>
          <target state="translated">Eine weitere Möglichkeit besteht, instanziieren Sie ein einzelnes <ph id="ph1">&lt;xref:System.Random&gt;</ph> Objekt, das Sie verwenden, um die Zufallszahlen in Ihrer Anwendung zu generieren.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>This yields slightly better performance, since instantiating a random number generator is fairly expensive.</source>
          <target state="translated">Dies ergibt eine etwas bessere Leistung, da Instanziieren eines Zufallszahlen-Generators relativ teuer ist.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>The following example creates <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects with the class constructor that takes a seed parameter and generates a sequence of random integers and doubles.</source>
          <target state="translated">Das folgende Beispiel erstellt <ph id="ph1">&lt;xref:System.Random&gt;</ph> Objekte mit dem Konstruktor der Klasse, die nimmt einen ausgangswertparameter und generiert eine Sequenz von Zufallszahlen und Double-Werte.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>The example illustrates that the same sequence is generated when the <ph id="ph1">&lt;xref:System.Random&gt;</ph> object is created again with the constructor and seed parameter.</source>
          <target state="translated">Im Beispiel wird veranschaulicht, dass die gleiche Sequenz generiert, wird bei der <ph id="ph1">&lt;xref:System.Random&gt;</ph> Objekt erneut mit dem Konstruktor und einem Startwert Parameter erstellt.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="T:System.Random">
          <source>Returns a random integer.</source>
          <target state="translated">Gibt eine Zufallsganzzahl zurück.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Random.Next">
          <source>Returns a non-negative random integer.</source>
          <target state="translated">Gibt eine nicht negative Zufallsganzzahl zurück.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Random.Next">
          <source>A 32-bit signed integer that is greater than or equal to 0 and less than <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Eine ganze 32-Bit-Zahl mit Vorzeichen, die größer oder gleich 0 (null) und kleiner als <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> ist.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source><ph id="ph1">&lt;xref:System.Random.Next%2A?displayProperty=nameWithType&gt;</ph> generates a random number whose value ranges from 0 to less than <ph id="ph2">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Random.Next%2A?displayProperty=nameWithType&gt;</ph> generiert eine zufällige Zahl, deren Wert liegt, zwischen 0 und kleiner als <ph id="ph2">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>To generate a random number whose value ranges from 0 to some other positive number, use the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">Verwenden Sie zum Generieren einer zufälligen Zahl, deren Wert im Bereich, von 0 zu einer anderen positive Zahl der <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType&gt;</ph> -methodenüberladung.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>To generate a random number within a different range, use the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">Verwenden Sie zum Generieren einer Zufallszahl in einen anderen Bereich der <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> -methodenüberladung.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>The following example makes repeated calls to the <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> method to generate a specific number of random numbers requested by the user.</source>
          <target state="translated">Im folgenden Beispiel wird die wiederholte Aufrufe an die <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> Methode zum Generieren einer bestimmten Anzahl von zufälligen Zahlen, die vom Benutzer angefordert wird.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>The <ph id="ph1">&lt;xref:System.Console.ReadLine%2A?displayProperty=nameWithType&gt;</ph> method is used to get customer input.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Console.ReadLine%2A?displayProperty=nameWithType&gt;</ph> Methode wird verwendet, um Kundeninformationen zu erhalten.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>The following example derives a class from <ph id="ph1">&lt;xref:System.Random&gt;</ph> to generate a sequence of random numbers whose distribution differs from the uniform distribution generated by the <ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph> method of the base class.</source>
          <target state="translated">Im folgende Beispiel wird eine Klasse von abgeleitet <ph id="ph1">&lt;xref:System.Random&gt;</ph> zum Generieren von zufälligen Zahlenfolge, deren Verteilung unterscheidet sich, von der einheitlichen Verteilung von generiert die <ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph> Methode der Basisklasse.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>It overrides the <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph> method to provide the distribution of random numbers, and overrides the <ph id="ph2">&lt;xref:System.Random.Next%2A?displayProperty=nameWithType&gt;</ph> method to use series of random numbers.</source>
          <target state="translated">Es überschreibt die <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph> Methode, um die Verteilung von Zufallszahlen und überschreibt bereitzustellen die <ph id="ph2">&lt;xref:System.Random.Next%2A?displayProperty=nameWithType&gt;</ph> Methode, um eine Reihe von Zufallszahlen verwenden.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>Starting with the .NET Framework version 2.0, if you derive a class from <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> and override the <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method, the distribution provided by the derived class implementation of the <ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method is not used in calls to the base class implementation of the <ph id="ph4">&lt;see cref="M:System.Random.Next" /&gt;</ph> method.</source>
          <target state="translated">Ab .NET Framework, Version 2.0, wenn Sie beim Ableiten einer Klasse von <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> und überschreiben die <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> -Methode, die durch die Implementierung der abgeleiteten Klasse zur Verfügung gestellte Verteilung der <ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph> Methode wird nicht verwendet, in der Basisklasse aufrufen Implementierung der <ph id="ph4">&lt;see cref="M:System.Random.Next" /&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>Instead, the uniform distribution returned by the base <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class is used.</source>
          <target state="translated">Die gleichverteilung stattdessen zurückgegeben, der vom Basistyp <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> Klasse dient.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>This behavior improves the overall performance of the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class.</source>
          <target state="translated">Dieses Verhalten verbessert die gesamtleistung der <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>To modify this behavior to call the <ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method in the derived class, you must also override the <ph id="ph2">&lt;see cref="M:System.Random.Next" /&gt;</ph> method.</source>
          <target state="translated">So ändern Sie dieses Verhalten so rufen Sie die <ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph> Methode in der abgeleiteten Klasse, müssen Sie auch überschreiben die <ph id="ph2">&lt;see cref="M:System.Random.Next" /&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32)">
          <source>The exclusive upper bound of the random number to be generated.</source>
          <target state="translated">Die exklusive obere Grenze der Zufallszahl, die generiert werden soll.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32)">
          <source><bpt id="p1">&lt;c&gt;</bpt>maxValue<ept id="p1">&lt;/c&gt;</ept> must be greater than or equal to 0.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>maxValue<ept id="p1">&lt;/c&gt;</ept> muss größer oder gleich 0 (null) sein.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32)">
          <source>Returns a non-negative random integer that is less than the specified maximum.</source>
          <target state="translated">Gibt eine nicht negative Zufallsganzzahl zurück, die kleiner als das angegebene Maximum ist.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32)">
          <source>A 32-bit signed integer that is greater than or equal to 0, and less than <ph id="ph1">&lt;paramref name="maxValue" /&gt;</ph>; that is, the range of return values ordinarily includes 0 but not <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>.</source>
          <target state="translated">Eine ganze 32-Bit-Zahl mit Vorzeichen, die größer oder gleich 0 (null) und kleiner als <ph id="ph1">&lt;paramref name="maxValue" /&gt;</ph> ist, d.h., der Bereich der Rückgabewerte umfasst in der Regel 0 (null), aber nicht <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32)">
          <source>However, if <ph id="ph1">&lt;paramref name="maxValue" /&gt;</ph> equals 0, <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph> is returned.</source>
          <target state="translated">Wenn jedoch <ph id="ph1">&lt;paramref name="maxValue" /&gt;</ph> 0 (null) entspricht, wird <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph> zurückgegeben.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%29&gt;</ph> overload returns random integers that range from 0 to <ph id="ph2">`maxValue`</ph> – 1.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%29&gt;</ph> Überladung gibt zufälligen ganze Zahlen dieses Bereichs von 0 bis <ph id="ph2">`maxValue`</ph> – 1.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32)">
          <source>However, if <ph id="ph1">`maxValue`</ph> is 0, the method returns 0.</source>
          <target state="translated">Jedoch wenn <ph id="ph1">`maxValue`</ph> gleich 0 ist, die Methode gibt 0 zurück.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32)">
          <source>The following example generates random integers with various overloads of the <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> method.</source>
          <target state="translated">Im folgenden Beispiel wird die zufällige ganze Zahlen mit verschiedenen Überladungen der <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32)">
          <source>The following example generates a random integer that it uses as an index to retrieve a string value from an array.</source>
          <target state="translated">Das folgende Beispiel generiert eine zufällige ganze Zahl, die als Index verwendet einen Zeichenfolgenwert aus einem Array abgerufen.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32)">
          <source>Because the highest index of the array is one less than its length, the value of the <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph> property is supplied as a the <ph id="ph2">`maxValue`</ph> parameter.</source>
          <target state="translated">Da der höchste Index des Arrays 1 kleiner als die Länge ist, den Wert des ist der <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph> -Eigenschaft angegeben ist, als eine der <ph id="ph2">`maxValue`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="maxValue" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maxValue" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>The inclusive lower bound of the random number returned.</source>
          <target state="translated">Die inklusive untere Grenze der zurückgegebenen Zufallszahl.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>The exclusive upper bound of the random number returned.</source>
          <target state="translated">Die exklusive obere Grenze der zurückgegebenen Zufallszahl.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source><bpt id="p1">&lt;c&gt;</bpt>maxValue<ept id="p1">&lt;/c&gt;</ept> must be greater than or equal to <bpt id="p2">&lt;c&gt;</bpt>minValue<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>maxValue<ept id="p1">&lt;/c&gt;</ept> muss größer oder gleich <bpt id="p2">&lt;c&gt;</bpt>minValue<ept id="p2">&lt;/c&gt;</ept> sein.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>Returns a random integer that is within a specified range.</source>
          <target state="translated">Gibt eine Zufallsganzzahl zurück, die in einem angegebenen Bereich liegt.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>A 32-bit signed integer greater than or equal to <ph id="ph1">&lt;paramref name="minValue" /&gt;</ph> and less than <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>; that is, the range of return values includes <ph id="ph3">&lt;paramref name="minValue" /&gt;</ph> but not <ph id="ph4">&lt;paramref name="maxValue" /&gt;</ph>.</source>
          <target state="translated">Eine 32-Bit-Ganzzahl mit Vorzeichen, die größer oder gleich <ph id="ph1">&lt;paramref name="minValue" /&gt;</ph> und kleiner als <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph> ist, d. h., der Bereich der Rückgabewerte umfasst <ph id="ph3">&lt;paramref name="minValue" /&gt;</ph>, aber nicht <ph id="ph4">&lt;paramref name="maxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>If <ph id="ph1">&lt;paramref name="minValue" /&gt;</ph> equals <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>, <ph id="ph3">&lt;paramref name="minValue" /&gt;</ph> is returned.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="minValue" /&gt;</ph> gleich <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph> ist, wird <ph id="ph3">&lt;paramref name="minValue" /&gt;</ph> zurückgegeben.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> overload returns random integers that range from <ph id="ph2">`minValue`</ph> to <ph id="ph3">`maxValue`</ph> – 1.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> Überladung gibt eine zufälligen ganze Zahlen zwischen <ph id="ph2">`minValue`</ph> auf <ph id="ph3">`maxValue`</ph> – 1.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>However, if <ph id="ph1">`maxValue`</ph> equals <ph id="ph2">`minValue`</ph>, the method returns <ph id="ph3">`minValue`</ph>.</source>
          <target state="translated">Jedoch wenn <ph id="ph1">`maxValue`</ph> gleich <ph id="ph2">`minValue`</ph>, gibt die Methode <ph id="ph3">`minValue`</ph>.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>Unlike the other overloads of the <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> method, which return only non-negative values, this method can return a negative random integer.</source>
          <target state="translated">Im Gegensatz zu anderen Überladungen auf der die <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> -Methode, die nur positive Werte zurückzugeben, kann diese Methode eine negative Zufallsganzzahl zurück.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method to generate random integers with three distinct ranges.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> Methode zum Generieren von Zufallszahlen mit drei verschiedenen Wertebereichen.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>Note that the exact output from the example depends on the system-supplied seed value passed to the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class constructor.</source>
          <target state="translated">Beachten Sie, dass der vom System bereitgestellten Ausgangswert übergeben, um die genaue Ausgabe des Beispiels hängt die <ph id="ph1">&lt;xref:System.Random&gt;</ph> Klassenkonstruktor.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>The following example generates a random integer that it uses as an index to retrieve a string value from an array.</source>
          <target state="translated">Das folgende Beispiel generiert eine zufällige ganze Zahl, die als Index verwendet einen Zeichenfolgenwert aus einem Array abgerufen.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>Because the highest index of the array is one less than its length, the value of the <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph> property is supplied as a the <ph id="ph2">`maxValue`</ph> parameter.</source>
          <target state="translated">Da der höchste Index des Arrays 1 kleiner als die Länge ist, den Wert des ist der <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph> -Eigenschaft angegeben ist, als eine der <ph id="ph2">`maxValue`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="minValue" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="minValue" /&gt;</ph> ist größer als <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>Starting with the .NET Framework version 2.0, if you derive a class from <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> and override the <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method, the distribution provided by the derived class implementation of the <ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method is not used in calls to the base class implementation of the <ph id="ph4">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph> method overload if the difference between the <ph id="ph5">&lt;paramref name="minValue" /&gt;</ph> and <ph id="ph6">&lt;paramref name="maxValue" /&gt;</ph> parameters is greater than <ph id="ph7">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Ab .NET Framework, Version 2.0, wenn Sie beim Ableiten einer Klasse von <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> und überschreiben die <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> -Methode, die durch die Implementierung der abgeleiteten Klasse zur Verfügung gestellte Verteilung der <ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph> Methode wird nicht verwendet, in der Basisklasse aufrufen Implementierung von der <ph id="ph4">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph> Methode zu überladen, wenn der Unterschied zwischen der <ph id="ph5">&lt;paramref name="minValue" /&gt;</ph> und <ph id="ph6">&lt;paramref name="maxValue" /&gt;</ph> Parameter ist größer als <ph id="ph7">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>Instead, the uniform distribution returned by the base <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class is used.</source>
          <target state="translated">Die gleichverteilung stattdessen zurückgegeben, der vom Basistyp <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> Klasse dient.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>This behavior improves the overall performance of the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class.</source>
          <target state="translated">Dieses Verhalten verbessert die gesamtleistung der <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>To modify this behavior to call the <ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method in the derived class, you must also override the <ph id="ph2">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph> method overload.</source>
          <target state="translated">So ändern Sie dieses Verhalten so rufen Sie die <ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph> Methode in der abgeleiteten Klasse, müssen Sie auch überschreiben die <ph id="ph2">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph> -methodenüberladung.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>An array of bytes to contain random numbers.</source>
          <target state="translated">Ein Bytearray, das für Zufallszahlen vorgesehen ist.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>Fills the elements of a specified array of bytes with random numbers.</source>
          <target state="translated">Füllt die Elemente eines angegebenen Bytearrays mit Zufallszahlen.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>Each element of the array of bytes is set to a random number greater than or equal to 0, and less than or equal to <ph id="ph1">&lt;xref:System.Byte.MaxValue&gt;</ph>.</source>
          <target state="translated">Jedes Element des Arrays von Bytes in eine Zufallszahl größer oder gleich 0 (null) festgelegt ist und kleiner als oder gleich <ph id="ph1">&lt;xref:System.Byte.MaxValue&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>For example, to generate a cryptographically secured random number suitable for creating a random password, use a method such as <ph id="ph1">&lt;xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Beispielsweise um eine kryptografisch sicheren Zufallszahl, die für das Erstellen eines zufälligen Kennworts generieren möchten, verwenden Sie eine Methode wie z. B. <ph id="ph1">&lt;xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Random.NextBytes%2A&gt;</ph> method to fill an array of bytes with random byte values.</source>
          <target state="translated">Im folgenden Beispiel wird veranschaulicht, wie die <ph id="ph1">&lt;xref:System.Random.NextBytes%2A&gt;</ph> Methode, um ein Array von Bytes mit zufälliger Bytewerte zu füllen.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Random.NextBytes(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>Starting with the .NET Framework version 2.0, if you derive a class from <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> and override the <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method, the distribution provided by the derived class implementation of the <ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method is not used in calls to the base class implementation of the <ph id="ph4">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph> method.</source>
          <target state="translated">Ab .NET Framework, Version 2.0, wenn Sie beim Ableiten einer Klasse von <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> und überschreiben die <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> -Methode, die durch die Implementierung der abgeleiteten Klasse zur Verfügung gestellte Verteilung der <ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph> Methode wird nicht verwendet, in der Basisklasse aufrufen Implementierung der <ph id="ph4">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>Instead, the uniform distribution returned by the base <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class is used.</source>
          <target state="translated">Die gleichverteilung stattdessen zurückgegeben, der vom Basistyp <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> Klasse dient.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>This behavior improves the overall performance of the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class.</source>
          <target state="translated">Dieses Verhalten verbessert die gesamtleistung der <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>To modify this behavior to call the <ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method in the derived class, you must also override the <ph id="ph2">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph> method.</source>
          <target state="translated">So ändern Sie dieses Verhalten so rufen Sie die <ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph> Methode in der abgeleiteten Klasse, müssen Sie auch überschreiben die <ph id="ph2">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Random.NextDouble">
          <source>Returns a random floating-point number that is greater than or equal to 0.0, and less than 1.0.</source>
          <target state="translated">Gibt eine zufällige Gleitkommazahl zurück, die größer oder gleich 0,0 und kleiner als 1,0 ist.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Random.NextDouble">
          <source>A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.</source>
          <target state="translated">Eine Gleitkommazahl mit doppelter Genauigkeit, die größer oder gleich 0,0 und kleiner als 1,0 ist.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextDouble">
          <source>The actual upper bound of the random number returned by this method is 0.99999999999999978.</source>
          <target state="translated">Die tatsächliche Obergrenze für die von dieser Methode zurückgegebene Zufallszahl ist 0.99999999999999978.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextDouble">
          <source>To retrieve random floating-point values within a range other than 0.0 and 1.0, see the "Retrieve floating-point values in a specified range" section of the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class topic.</source>
          <target state="translated">Um zufällige Gleitkommazahlen-Punktwerte innerhalb eines Bereichs als 0,0 und 1,0 abzurufen, finden Sie im Abschnitt "Werte für Gleitkommazahlen in einem angegebenen Bereich abgerufen werden" von der <ph id="ph1">&lt;xref:System.Random&gt;</ph> klassenthema.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextDouble">
          <source>This method is the public version of the protected method, <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph>.</source>
          <target state="translated">Diese Methode ist die öffentliche Version der geschützten Methode <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextDouble">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method to generate sequences of random doubles.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> Methode zum Generieren von Sequenzen von Double.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextDouble">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method to generate 100 random numbers and displays their frequency distribution.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> Methode zum Generieren von 100 zufällige Zahlen und zeigt deren Häufigkeit-Verteilung.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Random.Sample">
          <source>Returns a random floating-point number between 0.0 and 1.0.</source>
          <target state="translated">Gibt eine zufällige Gleitkommazahl zwischen 0,0 und 1,0 zurück.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Random.Sample">
          <source>A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.</source>
          <target state="translated">Eine Gleitkommazahl mit doppelter Genauigkeit, die größer oder gleich 0,0 und kleiner als 1,0 ist.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>To produce a different random distribution or a different random number generator principle, derive a class from the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class and override the <ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph> method.</source>
          <target state="translated">Eine andere zufällige Verteilung oder ein unterschiedliche random Number Generatorprinzip erzeugt werden, leiten Sie eine Klasse von der <ph id="ph1">&lt;xref:System.Random&gt;</ph> Klasse, und überschreiben die <ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>The <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph> method is <ph id="ph2">`protected`</ph>, which means that it is accessible only within the <ph id="ph3">&lt;xref:System.Random&gt;</ph> class and its derived classes.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph> Methode ist <ph id="ph2">`protected`</ph>, was bedeutet, dass darauf zugreifen können, nur innerhalb der <ph id="ph3">&lt;xref:System.Random&gt;</ph> Klasse und abgeleitete Klassen.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>To generate a random number between 0 and 1 from a <ph id="ph1">&lt;xref:System.Random&gt;</ph> instance, call the <ph id="ph2">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method.</source>
          <target state="translated">Generiert eine Zufallszahl zwischen 0 und 1 aus einer <ph id="ph1">&lt;xref:System.Random&gt;</ph> Instanz ist, rufen Sie die <ph id="ph2">&lt;xref:System.Random.NextDouble%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>The following example derives a class from <ph id="ph1">&lt;xref:System.Random&gt;</ph> and overrides the <ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph> method to generate a distribution of random numbers.</source>
          <target state="translated">Im folgende Beispiel wird eine Klasse von abgeleitet <ph id="ph1">&lt;xref:System.Random&gt;</ph> und überschreibt die <ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph> Methode, um eine Verteilung von Zufallszahlen generieren.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>This distribution is different than the uniform distribution generated by the <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph> method of the base class.</source>
          <target state="translated">Diese Verteilung unterscheidet sich von der einheitlichen Verteilung von generiert die <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph> Methode der Basisklasse.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>Starting with the .NET Framework version 2.0, if you derive a class from <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> and override the <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method, the distribution provided by the derived class implementation of the <ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method is not used in calls to the base class implementation of the following methods:</source>
          <target state="translated">Ab .NET Framework, Version 2.0, wenn Sie beim Ableiten einer Klasse von <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> und überschreiben die <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> -Methode, die durch die Implementierung der abgeleiteten Klasse zur Verfügung gestellte Verteilung der <ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph> Methode wird nicht verwendet, in der Basisklasse aufrufen die Implementierung der folgenden Methoden:</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>The <ph id="ph1">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph> method.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph>-Methode.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>The <ph id="ph1">&lt;see cref="M:System.Random.Next" /&gt;</ph> method.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="M:System.Random.Next" /&gt;</ph>-Methode.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>The <ph id="ph1">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph> method, if (<ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph><ph id="ph3"> - </ph><ph id="ph4">&lt;paramref name="minValue" /&gt;</ph>) is greater than <ph id="ph5">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph> -Methode, wenn (<ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph><ph id="ph3"> - </ph><ph id="ph4">&lt;paramref name="minValue" /&gt;</ph>) ist größer als <ph id="ph5">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>Instead, the uniform distribution provided by the base <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class is used.</source>
          <target state="translated">Stattdessen die Basis der gleichverteilung gebotenen <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> Klasse dient.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>This behavior improves the overall performance of the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class.</source>
          <target state="translated">Dieses Verhalten verbessert die gesamtleistung der <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>To modify this behavior to call the implementation of the <ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method in the derived class, you must also override the behavior of these three members.</source>
          <target state="translated">So ändern Sie das Verhalten, dass die Implementierung von Aufrufen der <ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph> Methode in der abgeleiteten Klasse, müssen Sie auch das Verhalten dieser drei Member überschreiben.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>The example provides an illustration.</source>
          <target state="translated">Dies wird im Beispiel veranschaulicht.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>