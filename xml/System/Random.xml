<Type Name="Random" FullName="System.Random">
  <Metadata><Meta Name="ms.openlocfilehash" Value="916c65c91bc8149c39c4b831ff081c57573e821e" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86600888" /></Metadata><TypeSignature Language="C#" Value="public class Random" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Random extends System.Object" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Random" />
  <TypeSignature Language="VB.NET" Value="Public Class Random" />
  <TypeSignature Language="C++ CLI" Value="public ref class Random" />
  <TypeSignature Language="F#" Value="type Random = class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Random extends System.Object" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime.Extensions" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Runtime.Extensions" FromVersion="5.0.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Serializable]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Serializable&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt einen Generator für Pseudozufallszahlen dar, d. h. ein Algorithmus, der eine Zahlenfolge erzeugt, die bestimmte statistische Anforderungen hinsichtlich ihrer Zufälligkeit erfüllt.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pseudo Zufallszahlen werden mit gleicher Wahrscheinlichkeit aus einem begrenzten Satz von Zahlen ausgewählt. Die ausgewählten Zahlen sind nicht vollständig zufällig, da Sie mit einem mathematischen Algorithmus ausgewählt werden, Sie sind jedoch für praktische Zwecke ausreichend. Die aktuelle Implementierung der <xref:System.Random> -Klasse basiert auf einer geänderten Version des subtraktiven Zufallszahlen-Generator Algorithmus von Donald E. Knuth. Weitere Informationen finden Sie unter D. E. Knuth. *Die Art der Computer Programmierung, Volume 2: seminumerische Algorithmen*. Addison-Wesley, Reading, MA, dritte Edition, 1997.  
  
 Um eine kryptografisch sichere Zufallszahl zu generieren, z. b. eine, die zum Erstellen eines zufälligen Kennworts geeignet ist, verwenden Sie die- <xref:System.Security.Cryptography.RNGCryptoServiceProvider> Klasse, oder leiten Sie eine Klasse von ab <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType> .  
  
 Inhalte dieses Themas:  
  
 [Instanziieren des Zufallszahlen-Generators](#Instantiate)   
 [Vermeiden mehrerer Instanziierungen](#Multiple)   
 [Die System. Random-Klasse und die Thread Sicherheit](#ThreadSafety)   
 [Erstellen verschiedener Typen von Zufallszahlen](#Functionality)   
 [Ersetzen Ihres eigenen Algorithmus](#Overriding)   
 [Verwendung von System. Random für...](#Operations)   
 [Abrufen der gleichen Sequenz von Zufalls Werten](#Same)  
 [Abrufen eindeutiger Sequenzen von Zufalls Werten](#Unique)  
 [Abrufen von ganzen Zahlen in einem angegebenen Bereich](#Range)  
 [Ganze Zahlen mit einer angegebenen Anzahl von Ziffern abrufen](#Digits)  
 [Abrufen von Gleit Komma Werten in einem angegebenen Bereich](#Floats)  
 [Generieren von zufälligen booleschen Werten](#Boolean)  
 [Generieren zufälliger 64-Bit-Ganzzahlen](#Long)  
 [Abrufen von Bytes in einem angegebenen Bereich](#Bytes)  
 [Abrufen eines Elements aus einem Array oder einer Auflistung nach dem Zufallsprinzip](#Array)  
 [Abrufen eines eindeutigen Elements aus einem Array oder einer Auflistung](#UniqueArray)  
  
<a name="Instantiate"></a>   
## <a name="instantiating-the-random-number-generator"></a>Instanziieren des Zufallszahlen-Generators  
 Sie instanziieren den Zufallszahlengenerator, indem Sie einem Klassenkonstruktor einen Ausgangswert (einen Startwert für den Algorithmus für die Pseudozufallszahlen Generierung) bereitstellen <xref:System.Random.%23ctor%2A> .  Sie können den Seed-Wert entweder explizit oder implizit angeben:  
  
-   Der <xref:System.Random.%23ctor%28System.Int32%29> Konstruktor verwendet einen expliziten Ausgangswert, den Sie angeben.  
  
-   Der <xref:System.Random.%23ctor> Konstruktor verwendet den standardseed-Wert. Dies ist die gängigste Methode zum Instanziieren des Zufallszahlen-Generators.  
  
 In .NET Framework ist der Standardstartwert Zeit abhängig. In .net Core wird der Standardstartwert durch den Thread statischen, Pseudozufallszahlen-Generator erzeugt.
  
 Wenn derselbe Ausgangswert für separate Objekte verwendet wird <xref:System.Random> , generieren Sie dieselbe Reihe von Zufallszahlen. Dies kann nützlich sein, um eine Test Sammlung zu erstellen, die zufällige Werte verarbeitet, oder um Spiele wiedergeben, die Ihre Daten von Zufallszahlen ableiten. Beachten Sie jedoch, dass <xref:System.Random> Objekte in Prozessen, die unter verschiedenen Versionen der .NET Framework ausgeführt werden, möglicherweise andere Reihen von Zufallszahlen zurückgeben, selbst wenn Sie mit identischen Ausgangswerten instanziiert werden.  
  
 Um verschiedene Sequenzen von Zufallszahlen zu erzeugen, können Sie den Seed-Wert Zeit abhängig machen und damit eine andere Reihe mit jeder neuen Instanz von erstellen <xref:System.Random> . Der parametrisierte <xref:System.Random.%23ctor%28System.Int32%29> Konstruktor kann <xref:System.Int32> basierend auf der Anzahl der Ticks in der aktuellen Zeit einen-Wert annehmen, während der Parameter lose <xref:System.Random.%23ctor> Konstruktor die Systemuhr verwendet, um den Ausgangswert zu generieren. Wenn jedoch nur im .NET Framework, da die Uhr über eine begrenzte Auflösung verfügt, erstellt die Verwendung des Parameter losen Konstruktors zum Erstellen verschiedener <xref:System.Random> Objekte in der Close-Folge Zufallszahlengeneratoren, die identische Sequenzen von Zufallszahlen erzeugen. Im folgenden Beispiel wird veranschaulicht, wie zwei <xref:System.Random> Objekte, die in einer .NET Framework Anwendung in einer Anwendung instanziiert werden, eine identische Reihe von Zufallszahlen generieren. Bei den meisten Windows-Systemen <xref:System.Random> verfügen Objekte, die innerhalb von 15 Millisekunden voneinander erstellt werden, wahrscheinlich über identische Seed-Werte.  
  
 [!code-cpp[System.Random#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)]
 [!code-csharp-interactive[System.Random#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)]
 [!code-vb[System.Random#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)]  
  
Um dieses Problem zu vermeiden, erstellen Sie ein einzelnes- <xref:System.Random> Objekt anstelle mehrerer-Objekte. Beachten Sie, dass die- `Random` Klasse in .net Core diese Einschränkung nicht besitzt.
  
<a name="Multiple"></a>   
## <a name="avoiding-multiple-instantiations"></a>Vermeiden mehrerer Instanziierungen  
 In der .NET Framework werden durch die Initialisierung von zwei Zufallszahlengeneratoren in einer engen Schleife oder in schneller Folge zwei Zufallszahlengeneratoren erstellt, die identische Sequenzen von Zufallszahlen erzeugen können. In den meisten Fällen ist dies nicht die Absicht des Entwicklers und kann zu Leistungsproblemen führen, da die Instanziierung und Initialisierung eines Zufallszahlengenerators ein relativ kostspieliger Prozess ist.  
  
 Um die Leistung zu verbessern und nicht versehentlich separate Zufallszahlengeneratoren zu erstellen, die identische numerische Sequenzen generieren, empfiehlt es sich, ein Objekt zu erstellen, das <xref:System.Random> viele Zufallszahlen generiert, anstatt neue <xref:System.Random> Objekte zu erstellen, um eine Zufallszahl zu generieren.  
  
 Die- <xref:System.Random> Klasse ist jedoch nicht Thread sicher. Wenn Sie <xref:System.Random> Methoden aus mehreren Threads aufzurufen, befolgen Sie die Richtlinien, die im nächsten Abschnitt erläutert werden.  
  
<a name="ThreadSafety"></a>   
## <a name="the-systemrandom-class-and-thread-safety"></a>Die System. Random-Klasse und die Thread Sicherheit  
 Anstatt einzelne Objekte zu instanziieren <xref:System.Random> , empfiehlt es sich, eine einzelne <xref:System.Random> Instanz zu erstellen, um alle Zufallszahlen zu generieren, die von Ihrer APP benötigt werden. <xref:System.Random>Objekte sind jedoch nicht Thread sicher. Wenn Ihre APP <xref:System.Random> Methoden aus mehreren Threads aufruft, müssen Sie ein Synchronisierungs Objekt verwenden, um sicherzustellen, dass jeweils nur ein Thread auf den Zufallszahlengenerator zugreifen kann. Wenn Sie nicht sicherstellen, dass <xref:System.Random> auf das Objekt auf Thread sichere Weise zugegriffen wird, geben Aufrufe von Methoden, die Zufallszahlen zurückgeben, den Wert 0 zurück.  
  
 Im folgenden Beispiel wird die c#-Anweisung [Lock](/dotnet/csharp/language-reference/keywords/lock-statement) und die Visual Basic [SyncLock-Anweisung](/dotnet/visual-basic/language-reference/statements/synclock-statement) verwendet, um sicherzustellen, dass von 11 Threads Thread sicher auf einen einzelnen Zufallszahlen-Generator zugegriffen wird. Jeder Thread generiert 2 Millionen Zufallszahlen, zählt die Anzahl der generierten Zufallszahlen und berechnet seine Summe und aktualisiert dann die Summen für alle Threads, wenn die Ausführung abgeschlossen ist.  
  
 [!code-cpp[System.Random#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)]
 [!code-csharp[System.Random#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)]
 [!code-vb[System.Random#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)]  
  
 Im Beispiel wird die Thread Sicherheit auf folgende Weise sichergestellt:  
  
-   Das <xref:System.ThreadStaticAttribute> -Attribut wird verwendet, um Thread lokale Variablen zu definieren, mit denen die Gesamtzahl der generierten Zufallszahlen und deren Summe für jeden Thread nachverfolgt wird.  
  
-   Eine Sperre (die `lock` -Anweisung in c# und die- `SyncLock` Anweisung in Visual Basic) schützt den Zugriff auf die Variablen für die Gesamtanzahl und Summe aller Zufallszahlen, die für alle Threads generiert werden.  
  
-   Ein Semaphor (das- <xref:System.Threading.CountdownEvent> Objekt) wird verwendet, um sicherzustellen, dass der Haupt Thread blockiert wird, bis alle anderen Threads die Ausführung vollständig erfüllen.  
  
-   Im Beispiel wird überprüft, ob der Zufallszahlen-Generator beschädigt wurde, indem ermittelt wird, ob zwei aufeinander folgende Aufrufe der Zufallszahlen Generierungs Methode 0 zurückgeben. Wenn eine Beschädigung erkannt wird, wird im Beispiel das-Objekt verwendet, <xref:System.Threading.CancellationTokenSource> um zu signalisieren, dass alle Threads abgebrochen werden sollen.  
  
-   Vor dem Erstellen der Zufallszahl überprüft jeder Thread den Status des <xref:System.Threading.CancellationToken> Objekts. Wenn der Abbruch angefordert wird, wird im Beispiel die-Methode aufgerufen, <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> um den Thread abzubrechen.  
  
 Das folgende Beispiel ist mit dem ersten identisch, mit der Ausnahme, dass es ein <xref:System.Threading.Tasks.Task> -Objekt und einen Lambda-Ausdruck anstelle von- <xref:System.Threading.Thread> Objekten verwendet.  
  
 [!code-csharp[System.Random#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)]
 [!code-vb[System.Random#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)]  
  
 Dies unterscheidet sich vom ersten Beispiel wie folgt:  
  
-   Die Variablen, die die Anzahl der generierten Zufallszahlen und deren Summe in jeder Aufgabe nachverfolgen, sind für die Aufgabe lokal, sodass das-Attribut nicht verwendet werden muss <xref:System.ThreadStaticAttribute> .  
  
-   Die statische- <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> Methode wird verwendet, um sicherzustellen, dass der Haupt Thread nicht vollständig abgeschlossen ist, bevor alle Aufgaben abgeschlossen sind. Das-Objekt ist nicht erforderlich <xref:System.Threading.CountdownEvent> .  
  
-   Die Ausnahme, die sich aus dem Task Abbruch ergibt, wird in der- <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> Methode angezeigt. Im vorherigen Beispiel wird Sie von jedem Thread behandelt.  
  
<a name="Functionality"></a>   
## <a name="generating-different-types-of-random-numbers"></a>Erstellen verschiedener Typen von Zufallszahlen  
 Der Zufallszahlengenerator stellt Methoden bereit, mit denen Sie die folgenden Arten von Zufallszahlen generieren können:  
  
-   Eine Reihe von <xref:System.Byte> Werten. Sie bestimmen die Anzahl von Byte Werten, indem Sie ein Array, das an die Anzahl der Elemente initialisiert wird, die die Methode zurückgeben soll, an die <xref:System.Random.NextBytes%2A> Methode übergeben. Im folgenden Beispiel werden 20 Bytes generiert.  
  
     [!code-cpp[System.Random#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)]
     [!code-csharp-interactive[System.Random#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)]
     [!code-vb[System.Random#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)]  
  
-   Eine einzelne Ganzzahl. Sie können auswählen, ob eine ganze Zahl zwischen 0 und einem maximalen Wert ( <xref:System.Int32.MaxValue?displayProperty=nameWithType> -1) durch Aufrufen der- <xref:System.Random.Next> Methode, eine ganze Zahl zwischen 0 und einen bestimmten Wert durch Aufrufen der-Methode <xref:System.Random.Next%28System.Int32%29> oder eine ganze Zahl innerhalb eines Wertebereichs durch Aufrufen der-Methode angezeigt werden soll <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> . In den parametrisierten über Ladungen ist der angegebene Maximalwert exklusiv. Das heißt, die tatsächliche Höchstzahl, die generiert wird, ist ein kleiner als der angegebene Wert.  
  
     Im folgenden Beispiel wird die <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> -Methode aufgerufen, um 10 Zufallszahlen zwischen-10 und 10 zu generieren. Beachten Sie, dass das zweite Argument für die-Methode die exklusive obere Grenze des Bereichs von Zufalls Werten angibt, die von der-Methode zurückgegeben werden. Anders ausgedrückt: die größte Ganzzahl, die die Methode zurückgeben kann, ist ein kleiner als dieser Wert.  
  
     [!code-cpp[System.Random#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)]
     [!code-csharp-interactive[System.Random#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)]
     [!code-vb[System.Random#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)]  
  
-   Ein einzelner Gleit Komma Wert zwischen 0,0 und kleiner als 1,0 durch Aufrufen der- <xref:System.Random.NextDouble%2A> Methode. Die exklusive obere Grenze der Zufallszahl, die von der-Methode zurückgegeben wird, ist 1, sodass Ihre tatsächliche obere Grenze 0.99999999999999978 ist. Im folgenden Beispiel werden 10 zufällige Gleit Komma Zahlen generiert.  
  
     [!code-cpp[System.Random#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)]
     [!code-csharp-interactive[System.Random#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)]
     [!code-vb[System.Random#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)]  
  
> [!IMPORTANT]
>  Mit der- <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> Methode können Sie den Bereich der zurückgegebenen Zufallszahl angeben. Der- `maxValue` Parameter, der die zurückgegebene Zahl des oberen Bereichs angibt, ist jedoch ein exklusiver, kein inklusiver Wert. Dies bedeutet, dass der Methoden `Next(0, 100)` Aufrufwert einen Wert zwischen 0 und 99 zurückgibt, nicht zwischen 0 und 100.  
  
 Sie können die- <xref:System.Random> Klasse auch für Aufgaben wie das Erstellen [zufälliger t:System.boolescher Werte](#Boolean)verwenden, und Sie können [zufällige Gleit Komma Werte mit einem Bereich von 0 bis 1](#Floats)erstellen, [zufällige 64-Bit-](#Long)Ganzzahlen erzeugen und [nach dem Zufallsprinzip ein eindeutiges Element aus einem Array oder](#UniqueArray)einer Auflistung abrufen. Informationen zu diesen und anderen häufigen Aufgaben finden Sie unter Gewusst [wie: Verwenden von System. Random für..](#Operations) . -Abschnitt.  
  
<a name="Overriding"></a>   
## <a name="substituting-your-own-algorithm"></a>Ersetzen Ihres eigenen Algorithmus  
 Sie können Ihren eigenen Zufallszahlen-Generator implementieren, indem Sie von der <xref:System.Random> -Klasse erben und den Algorithmus für die Zufallszahlengenerierung bereitstellen. Um einen eigenen Algorithmus bereitzustellen, müssen Sie die-Methode überschreiben <xref:System.Random.Sample%2A> , die den Algorithmus für die Zufallszahlengenerierung implementiert. Außerdem sollten Sie die <xref:System.Random.Next> Methoden, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> und überschreiben, <xref:System.Random.NextBytes%2A> um sicherzustellen, dass Sie die überschriebene-Methode aufzurufen <xref:System.Random.Sample%2A> . Sie müssen die <xref:System.Random.Next%28System.Int32%29> -Methode und die-Methode nicht überschreiben <xref:System.Random.NextDouble%2A> .  
  
 Ein Beispiel, das von der <xref:System.Random> -Klasse abgeleitet wird und den standardmäßigen Pseudozufallszahlen-Generator ändert, finden Sie auf der- <xref:System.Random.Sample%2A> Referenzseite.  
  
<a name="Operations"></a>   
## <a name="how-do-you-use-systemrandom-to"></a>Verwendung von System. Random für...  
 In den folgenden Abschnitten wird der Beispielcode für einige Möglichkeiten erläutert und bereitgestellt, wie Sie in Ihrer APP Zufallszahlen verwenden können.  
  
<a name="Same"></a>   
### <a name="retrieve-the-same-sequence-of-random-values"></a>Abrufen der gleichen Sequenz von Zufalls Werten  
 Manchmal möchten Sie die gleiche Sequenz von Zufallszahlen in Softwaretest Szenarien und in Spiel spielen generieren. Durch Tests mit der gleichen Sequenz von Zufallszahlen können Sie Regressionen erkennen und Fehlerbehebungen bestätigen. Die Verwendung derselben Sequenz von Zufallszahlen in spielen ermöglicht Ihnen, vorherige Spiele wiederzugeben.  
  
 Sie können dieselbe Sequenz von Zufallszahlen generieren, indem Sie dem Konstruktor denselben Ausgangswert bereitstellen <xref:System.Random.%23ctor%28System.Int32%29> . Der Seed-Wert stellt einen Startwert für den Algorithmus zur Generierung von Pseudozufallszahlen dar. Im folgenden Beispiel wird 100100 als beliebiger Ausgangswert verwendet, um das-Objekt zu instanziieren <xref:System.Random> , 20 zufällige Gleit Komma Werte anzeigt und den Seed-Wert persistent zu verwenden. Anschließend wird der Seed-Wert wieder hergestellt, ein neuer Zufallszahlengenerator instanziiert und die gleichen 20 zufälligen Gleit Komma Werte angezeigt.  Beachten Sie, dass das Beispiel möglicherweise unterschiedliche Sequenzen von Zufallszahlen erzeugt, wenn Sie in verschiedenen Versionen der .NET Framework ausgeführt werden.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs" interactive="try-dotnet" id="Snippet12":::
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp" id="Snippet12":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb" id="Snippet12":::
  
<a name="Unique"></a>   
### <a name="retrieve-unique-sequences-of-random-numbers"></a>Abrufen von eindeutigen Sequenzen von Zufallszahlen  
 Die Angabe unterschiedlicher Ausgangswerte für Instanzen der- <xref:System.Random> Klasse bewirkt, dass jeder Zufallszahlengenerator eine andere Sequenz von Werten erzeugt. Sie können einen Ausgangswert entweder explizit durch Aufrufen des- <xref:System.Random.%23ctor%28System.Int32%29> Konstruktors oder implizit durch Aufrufen des- <xref:System.Random.%23ctor> Konstruktors bereitstellen. Die meisten Entwickler wenden den Parameter losen Konstruktor an, der die Systemuhr verwendet. Im folgenden Beispiel wird dieser Ansatz verwendet, um zwei-Instanzen zu instanziieren <xref:System.Random> . Jede Instanz zeigt eine Reihe von 10 zufälligen Ganzzahlen an.  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp" id="Snippet13":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs" interactive="try-dotnet" id="Snippet13":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb" id="Snippet13":::

 Aufgrund der begrenzten Auflösung erkennt die Systemuhr jedoch keine Zeitunterschiede, die weniger als ungefähr 15 Millisekunden betragen. Wenn Ihr Code die-Überladung <xref:System.Random.%23ctor> für den .NET Framework aufruft, um zwei Objekte nacheinander zu instanziieren <xref:System.Random> , können Sie die Objekte versehentlich mit identischen Ausgangswerten bereitstellen. (Für die- <xref:System.Random> Klasse in .net Core gilt diese Einschränkung nicht.) Um dies im vorherigen Beispiel zu sehen, kommentieren Sie den <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> Methodenaufrufe aus, und kompilieren Sie das Beispiel, und führen Sie es erneut aus.  
  
 Um dies zu verhindern, empfiehlt es sich, anstelle mehrerer Objekte ein einzelnes Objekt zu instanziieren <xref:System.Random> . Da jedoch <xref:System.Random> nicht Thread sicher ist, müssen Sie ein Synchronisierungs Gerät verwenden, wenn Sie auf eine- <xref:System.Random> Instanz aus mehreren Threads zugreifen. Weitere Informationen finden Sie [unter Random class and Thread Safety](#ThreadSafety) weiter oben in diesem Thema. Alternativ können Sie einen Verzögerungs Mechanismus verwenden, wie z. b. die-Methode, die <xref:System.Threading.Thread.Sleep%2A> im vorherigen Beispiel verwendet wurde, um sicherzustellen, dass die Instanziierungen mehr als 15 Millisekunden voneinander getrennt vorkommen.  
  
<a name="Range"></a>   
### <a name="retrieve-integers-in-a-specified-range"></a>Abrufen von ganzen Zahlen in einem angegebenen Bereich  
 Sie können ganze Zahlen in einem angegebenen Bereich abrufen, indem Sie die <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> -Methode aufrufen, mit der Sie sowohl die untere als auch die obere Grenze der Zahlen angeben können, die der Zufallszahlengenerator zurückgeben soll. Die obere Grenze ist ein exklusiver, kein inklusiver Wert. Das heißt, es ist nicht in den von der-Methode zurückgegebenen Wertebereich enthalten. Im folgenden Beispiel wird diese Methode verwendet, um zufällige ganze Zahlen zwischen-10 und 10 zu generieren. Beachten Sie, dass es 11 angibt, das einen größer als der gewünschte Wert ist, als Wert des `maxValue` Arguments im Methoden Aufruf.  
  
 [!code-cpp[System.Random#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)]
 [!code-csharp-interactive[System.Random#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)]
 [!code-vb[System.Random#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)]  
  
<a name="Digits"></a>   
### <a name="retrieve-integers-with-a-specified-number-of-digits"></a>Ganze Zahlen mit einer angegebenen Anzahl von Ziffern abrufen  
 Sie können die- <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> Methode aufrufen, um Zahlen mit einer bestimmten Anzahl von Ziffern abzurufen. Wenn Sie z. b. Zahlen mit vier Ziffern (d. h. Zahlen zwischen 1000 und 9999) abrufen möchten, rufen Sie die <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> -Methode mit dem `minValue` Wert 1000 und `maxValue` dem Wert 10000 auf, wie im folgenden Beispiel gezeigt.  
  
 [!code-cpp[System.Random#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)]
 [!code-csharp-interactive[System.Random#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)]
 [!code-vb[System.Random#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)]  
  
<a name="Floats"></a>   
### <a name="retrieve-floating-point-values-in-a-specified-range"></a>Abrufen von Gleit Komma Werten in einem angegebenen Bereich  
 Die- <xref:System.Random.NextDouble%2A> Methode gibt zufällige Gleit Komma Werte zurück, die zwischen 0 und kleiner als 1 liegen. Sie möchten jedoch häufig Zufallswerte in einem anderen Bereich generieren.  
  
 Wenn das Intervall zwischen dem minimalen und dem maximalen gewünschten Wert 1 beträgt, können Sie den Unterschied zwischen dem gewünschten Start Intervall und 0 der von der-Methode zurückgegebenen Zahl hinzufügen <xref:System.Random.NextDouble%2A> . Im folgenden Beispiel werden 10 Zufallszahlen zwischen-1 und 0 generiert.  
  
 [!code-cpp[System.Random#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)]
 [!code-csharp-interactive[System.Random#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)]
 [!code-vb[System.Random#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)]  
  
 Um zufällige Gleit Komma Zahlen zu generieren, deren untere Grenze 0 (null) ist, aber obere Grenze größer als 1 ist (oder im Fall von negativen Zahlen, deren untere Grenze kleiner als-1 und die obere Grenze 0 ist), Multiplizieren Sie die Zufallszahl mit der Grenze ungleich 0 (null). Im folgenden Beispiel werden 20 Millionen zufällige Gleit Komma Zahlen generiert, die zwischen 0 und liegen <xref:System.Int64.MaxValue?displayProperty=nameWithType> . In wird auch die Verteilung der von der-Methode generierten zufälligen Werte angezeigt.  
  
 [!code-cpp[System.Random#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)]
 [!code-csharp-interactive[System.Random#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)]
 [!code-vb[System.Random#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)]  
  
 Verwenden Sie die folgende Formel, um zufällige Gleit Komma Zahlen zwischen zwei beliebigen Werten zu generieren, z. b. die <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> -Methode für ganze Zahlen:  
  
```csharp  
Random.NextDouble() * (maxValue - minValue) + minValue  
```  
  
 Im folgenden Beispiel werden 1 Million Zufallszahlen generiert, die zwischen 10,0 und 11,0 liegen und deren Verteilung anzeigt.  
  
 [!code-cpp[System.Random#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)]
 [!code-csharp-interactive[System.Random#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)]
 [!code-vb[System.Random#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)]  
  
<a name="Boolean"></a>   
### <a name="generate-random-boolean-values"></a>Generieren von zufälligen booleschen Werten  
 Die- <xref:System.Random> Klasse stellt keine Methoden bereit, die <xref:System.Boolean> Werte generieren. Hierfür können Sie jedoch auch eine eigene Klasse oder Methode definieren. Im folgenden Beispiel wird eine-Klasse `BooleanGenerator` mit einer einzelnen Methode,, definiert `NextBoolean` . Die- `BooleanGenerator` Klasse speichert ein- <xref:System.Random> Objekt als private Variable. Die `NextBoolean` -Methode ruft die <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> -Methode auf und übergibt das Ergebnis an die- <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType> Methode. Beachten Sie, dass 2 als Argument verwendet wird, um die obere Grenze der Zufallszahl anzugeben. Da dies ein exklusiver Wert ist, gibt der Methodenaufrufe entweder 0 oder 1 zurück.  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp" id="Snippet8":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs" interactive="try-dotnet" id="Snippet8":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb" id="Snippet8":::
  
 Anstatt eine separate Klasse zum Generieren zufälliger Werte zu erstellen <xref:System.Boolean> , kann im Beispiel einfach eine einzige Methode definiert werden. In diesem Fall sollte das Objekt jedoch <xref:System.Random> als Variable auf Klassenebene definiert worden sein, um zu vermeiden, dass <xref:System.Random> in jedem Methoden aufrufeine neue Instanz instanziiert wird. In Visual Basic kann die zufällige Instanz als [statische](/dotnet/visual-basic/language-reference/modifiers/static) Variable in der-Methode definiert werden `NextBoolean` .  Im folgenden Beispiel wird eine-Implementierung bereitstellt.  
  
 [!code-cpp[System.Random#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)]
 [!code-csharp-interactive[System.Random#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)]
 [!code-vb[System.Random#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)]  
  
<a name="Long"></a>   
### <a name="generate-random-64-bit-integers"></a>Generieren zufälliger 64-Bit-Ganzzahlen  
 Die über Ladungen der <xref:System.Random.Next%2A> -Methode geben 32-Bit-Ganzzahlen zurück. In einigen Fällen möchten Sie jedoch vielleicht mit 64-Bit-Ganzzahlen arbeiten. Sie können dies wie folgt tun:  
  
1.  Rufen Sie die- <xref:System.Random.NextDouble%2A> Methode auf, um einen Gleit Komma Wert mit doppelter Genauigkeit abzurufen.  
  
2.  Multiplizieren Sie diesen Wert mit <xref:System.Int64.MaxValue?displayProperty=nameWithType> .  
  
 Im folgenden Beispiel wird dieses Verfahren verwendet, um zufällige ganze Zahlen mit 20 Millionen zu generieren und in 10 gleich großen Gruppen zu kategorisieren. Anschließend wird die Verteilung der Zufallszahlen ausgewertet, indem die Zahl in jeder Gruppe von 0 bis gezählt wird <xref:System.Int64.MaxValue?displayProperty=nameWithType> . Wie die Ausgabe des Beispiels zeigt, werden die Zahlen mehr oder weniger gleichmäßig über den Bereich einer langen ganzen Zahl verteilt.  
  
 [!code-cpp[System.Random#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)]
 [!code-csharp-interactive[System.Random#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)]
 [!code-vb[System.Random#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)]  
  
 Eine alternative Methode, die Bitmanipulation verwendet, generiert keine wirklich zufälligen Zahlen. Mit dieser Technik <xref:System.Random.Next> wird aufgerufen, um zwei Ganzzahlen zu generieren, um eine nach 32 Bits zu verschieben, und werden Sie in eine Weise verknüpft. Diese Methode hat zwei Einschränkungen:  
  
1.  Da Bit 31 das Signier Bit ist, ist der Wert in Bit 31 der resultierenden Long-Ganzzahl immer 0.  Dies kann behoben werden, indem ein zufälliger 0-oder 1-Bit-Wert generiert wird, bei dem der Wert für 31 Bits nach links verschoben und mit der ursprünglichen zufälligen Long-Ganzzahl  
  
2.  Da die Wahrscheinlichkeit, dass der Wert, der von zurückgegeben <xref:System.Random.Next> wird, 0 (null) ist, gibt es nur wenige, wenn eine Zufallszahl im Bereich von 0x0-0x00000000FFFFFFFF liegt.  
  
<a name="Bytes"></a>   
### <a name="retrieve-bytes-in-a-specified-range"></a>Abrufen von Bytes in einem angegebenen Bereich  
 Die über Ladungen der- <xref:System.Random.Next%2A> Methode ermöglichen es Ihnen, den Bereich von Zufallszahlen anzugeben, die- <xref:System.Random.NextBytes%2A> Methode jedoch nicht. Im folgenden Beispiel wird eine- `NextBytes` Methode implementiert, mit der Sie den Bereich der zurückgegebenen Bytes angeben können. Es definiert eine `Random2` Klasse, die von abgeleitet wird <xref:System.Random> und die-Methode über lädt `NextBytes` .  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp" id="Snippet9":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs" interactive="try-dotnet" id="Snippet9":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb" id="Snippet9":::

 Die-Methode umschließt `NextBytes(Byte[], Byte, Byte)` einen aufzurufenden <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> -Methode und gibt den minimal-und einen-Wert an, der größer ist als der maximale Wert (in diesem Fall 0 und 101), der im Bytearray zurückgegeben werden soll. Da wir sicher sind, dass die von der-Methode zurückgegebenen ganzzahligen Werte <xref:System.Random.Next%2A> innerhalb des Bereichs des <xref:System.Byte> Datentyps liegen, können wir Sie problemlos umwandeln (in c#) oder (in Visual Basic) von ganzen Zahlen in Bytes konvertieren.  
  
<a name="Array"></a>   
### <a name="retrieve-an-element-from-an-array-or-collection-at-random"></a>Abrufen eines Elements aus einem Array oder einer Auflistung nach dem Zufallsprinzip  
 Zufallszahlen dienen häufig als Indizes zum Abrufen von Werten aus Arrays oder Auflistungen. Wenn Sie einen zufälligen Indexwert abrufen möchten, können Sie die <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> -Methode aufrufen und die untere Grenze des Arrays als Wert Ihres `minValue` Arguments und einen größer als die obere Grenze des Arrays als Wert seines `maxValue` Arguments verwenden. Für ein NULL basiertes Array entspricht dies <xref:System.Array.Length%2A> der-Eigenschaft, oder eine, die größer als der von der-Methode zurückgegebene Wert ist <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> . Im folgenden Beispiel wird der Name einer Stadt im USA aus einem Array von Städten nach dem Zufallsprinzip abgerufen.  
  
 [!code-cpp[System.Random#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)]
 [!code-csharp-interactive[System.Random#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)]
 [!code-vb[System.Random#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)]  
  
<a name="UniqueArray"></a>   
### <a name="retrieve-a-unique-element-from-an-array-or-collection"></a>Abrufen eines eindeutigen Elements aus einem Array oder einer Auflistung  
 Ein Zufallszahlengenerator kann immer doppelte Werte zurückgeben. Wenn der Bereich der Zahlen kleiner wird oder die Anzahl der generierten Werte größer ist, wächst die Wahrscheinlichkeit von Duplikaten. Wenn zufällige Werte eindeutig sein müssen, werden mehr Zahlen generiert, um Duplikate zu kompensieren. Dies führt zu einer zunehmend schlechten Leistung.  
  
 Es gibt eine Reihe von Techniken zum Behandeln dieses Szenarios. Eine gängige Lösung besteht darin, ein Array oder eine Sammlung zu erstellen, das die abzurufenden Werte enthält, sowie ein paralleles Array, das zufällige Gleit Komma Zahlen enthält. Das zweite Array wird mit Zufallszahlen aufgefüllt, wenn das erste Array erstellt wird, und die- <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> Methode wird verwendet, um das erste Array mithilfe der Werte im parallelen Array zu sortieren.  
  
 Wenn Sie z. b. ein Solitaire-Spiel entwickeln, sollten Sie sicherstellen, dass jede Karte nur einmal verwendet wird. Anstatt Zufallszahlen zum Abrufen einer Karte und nachverfolgen, ob diese Karte bereits behandelt wurde, zu erzeugen, können Sie ein paralleles Array von Zufallszahlen erstellen, das zum Sortieren des Stapels verwendet werden kann. Sobald der Stapel sortiert ist, kann Ihre APP einen Zeiger behalten, um den Index der nächsten Karte auf dem Stapel anzugeben.  
  
 Dieser Ansatz wird anhand des folgenden Beispiels veranschaulicht. Dabei wird eine `Card` Klasse definiert, die eine Wiedergabe Karte und eine `Dealer` Klasse darstellt, die eine Karte mit gemischten Karten darstellt. Der `Dealer` Klassenkonstruktor füllt zwei Arrays auf: ein `deck` -Array mit einem Klassen Bereich, das alle Karten im Stapel darstellt, und ein lokales `order` Array, das über die gleiche Anzahl von Elementen wie das `deck` Array verfügt und mit zufällig generierten <xref:System.Double> Werten aufgefüllt wird.  <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType>Anschließend wird die-Methode aufgerufen, um das `deck` Array auf der Grundlage der Werte im Array zu sortieren `order` .  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp" id="Snippet11":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs" interactive="try-dotnet" id="Snippet11":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb" id="Snippet11":::
  
## Examples  

 Im folgenden Beispiel wird ein einzelner Zufallszahlengenerator erstellt und seine <xref:System.Random.NextBytes%2A> <xref:System.Random.Next%2A> -,-und-Methoden aufgerufen, <xref:System.Random.NextDouble%2A> um Sequenzen von Zufallszahlen in verschiedenen Bereichen zu generieren.  
  
 [!code-cpp[System.Random#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random2.cpp#2)]
 [!code-csharp-interactive[System.Random#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random2.cs#2)]
 [!code-vb[System.Random#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random2.vb#2)]  
  
 Im folgenden Beispiel wird eine zufällige ganze Zahl generiert, die als Index zum Abrufen eines Zeichen folgen Werts aus einem Array verwendet wird.  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp-interactive[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>In den .NET Framework 1,0 und 1,1 wurde durch eine minimale Implementierung einer von abgeleiteten Klasse <see cref="T:System.Random" /> die- <see cref="M:System.Random.Sample" /> Methode überschrieben, um einen neuen oder geänderten Algorithmus zum Erstellen von Zufallszahlen zu definieren. Die abgeleitete Klasse kann dann auf die Basisklassen Implementierung der <see cref="M:System.Random.Next" /> Methoden, <see cref="M:System.Random.Next(System.Int32)" /> , <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> , <see cref="M:System.Random.NextBytes(System.Byte[])" /> und zurückgreifen, <see cref="M:System.Random.NextDouble" /> um die Implementierung der abgeleiteten Klasse aufzurufen <see cref="M:System.Random.Sample" /> .  
  
In .NET Framework 2,0 und höher haben sich das Verhalten der <see cref="M:System.Random.Next" /> Methoden, <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> und <see cref="M:System.Random.NextBytes(System.Byte[])" /> geändert, sodass diese Methoden nicht notwendigerweise die Implementierung der abgeleiteten Klasse der-Methode aufzurufen <see cref="M:System.Random.Sample" /> . Daher sollten von abgeleitete Klassen <see cref="T:System.Random" /> , die auf .NET Framework 2,0 und höher ausgerichtet sind, auch diese drei Methoden überschreiben.</para></block>
    <block subset="none" type="usage"><para>Es ist nicht garantiert, dass die Implementierung des Zufallszahlengenerators in der-Klasse in den <see cref="T:System.Random" /> Hauptversionen der .NET Framework identisch bleibt. Daher sollten Sie nicht davon ausgehen, dass derselbe Ausgangswert in verschiedenen Versionen der .NET Framework dieselbe pseudo zufällige Sequenz ergibt.</para></block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Random" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der- <see cref="T:System.Random" /> Klasse unter Verwendung eines standardseed-Werts.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks
In .NET Framework wird der Standardstartwert von der Systemuhr abgeleitet, die über eine begrenzte Auflösung verfügt. Folglich weisen unterschiedliche <xref:System.Random> Objekte, die mit einem-Parameter für den Parameter losen Konstruktor in der Schluss Folge erstellt werden, identische standardseed-Werte auf und erstellen daher identische Sätze von Zufallszahlen. Sie können dieses Problem vermeiden, indem Sie ein einzelnes- <xref:System.Random> Objekt verwenden, um alle Zufallszahlen zu generieren. Sie können das Problem auch umgehen, indem Sie einen eigenen zufälligen Ausgangswert erstellen und an den <xref:System.Random.%23ctor%28System.Int32%29> Konstruktor übergeben. Weitere Informationen finden Sie unter dem- <xref:System.Random.%23ctor%28System.Int32%29> Konstruktor. 

In .net Core wird der Standardstartwert durch den Thread statischen, Pseudozufallszahlen-Generator erzeugt, sodass die zuvor beschriebene Einschränkung nicht zutrifft. Verschiedene <xref:System.Random> Objekte, die in einer Schluss Folge erstellt werden, liefern unterschiedliche Sätze von Zufallszahlen in .net Core.
  
 Rufen Sie diesen Konstruktor auf, wenn Sie möchten, dass der Zufallszahlengenerator eine zufällige Sequenz von Zahlen generiert. Um eine festgelegte Sequenz von Zufallszahlen zu generieren, die für unterschiedliche Zufallszahlengeneratoren identisch sein werden, rufen Sie den <xref:System.Random.%23ctor%28System.Int32%29> Konstruktor mit einem fixierten Ausgangswert auf. Diese <xref:System.Random> Konstruktorüberladung wird häufig beim Testen von apps verwendet, die Zufallszahlen verwenden.  
  
 Nachdem Sie den Zufallszahlengenerator instanziiert haben, rufen Sie einzelne <xref:System.Random> Methoden (z. b. <xref:System.Random.Next> oder) auf, <xref:System.Random.NextDouble> um Zufallszahlen zu generieren.  
  
   
  
## Examples

Im folgenden Beispiel wird der Parameter lose Konstruktor verwendet, um drei-Objekte zu instanziieren, und es wird <xref:System.Random> eine Sequenz von fünf zufälligen ganzen Zahlen für jede angezeigt. Wenn Sie auf .NET Framework ausgeführt wird, da die ersten beiden <xref:System.Random> Objekte in der Schlusssequenz erstellt werden, werden Sie mit identischen Ausgangswerten instanziiert, die auf der Systemuhr basieren, und deshalb wird eine identische Sequenz von Zufallszahlen erzeugt. Auf der anderen Seite wird der Parameter lose Konstruktor des dritten <xref:System.Random> Objekts nach einer Verzögerung von zwei Sekunden aufgerufen, die durch den Aufruf der- <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> Methode verursacht wurde. Da dadurch ein anderer Ausgangswert für das dritte <xref:System.Random> Objekt erzeugt wird, wird eine andere Sequenz von Zufallszahlen erzeugt.  
  
 [!code-csharp[System.Random.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor1.cs#2)]
 [!code-vb[System.Random.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random (int Seed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 Seed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Seed As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random(int Seed);" />
      <MemberSignature Language="F#" Value="new Random : int -&gt; Random" Usage="new System.Random Seed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Seed" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Seed">Eine Zahl, mit der ein Startwert für Folgen von Pseudozufallszahlen berechnet wird. Wenn eine negative Zahl angegeben wird, wird der absolute Wert der Zahl verwendet.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Random" />-Klasse unter Verwendung des angegebenen Startwerts.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Bereitstellen eines identischen Ausgangs Werts für verschiedene <xref:System.Random> Objekte bewirkt, dass jede Instanz identische Sequenzen von Zufallszahlen erzeugt. Dies erfolgt häufig beim Testen von apps, die auf Zufallszahlengeneratoren basieren.  
  
 Wenn Ihre Anwendung unterschiedliche Zufallszahlen Sequenzen erfordert, rufen Sie diesen Konstruktor wiederholt mit unterschiedlichen Seed-Werten auf. Eine Möglichkeit zum Erstellen eines eindeutigen Ausgangs Werts besteht darin, den Wert Zeit abhängig zu machen. Leiten Sie z. b. den Seed-Wert von der Systemuhr ab, wie die Überladung <xref:System.Random.%23ctor> Dies bewirkt. Die Systemuhr verfügt jedoch möglicherweise nicht über genügend Auflösung, um unterschiedliche Aufrufe dieses Konstruktors mit einem anderen Ausgangswert bereitzustellen. Auf der .NET Framework ergibt dies Zufallszahlengeneratoren, die identische Sequenzen von Pseudozufallszahlen generieren, wie von den ersten beiden <xref:System.Random> Objekten im folgenden Beispiel dargestellt. Um dies zu verhindern, wenden Sie einen Algorithmus an, um den Ausgangswert in jedem Aufruf zu unterscheiden, oder aufrufen Sie die- <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> Methode, um sicherzustellen, dass Sie jeden Konstruktor mit einem anderen Ausgangswert bereitstellen.  
  
 [!code-csharp[System.Random.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)]
 [!code-vb[System.Random.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)]  
  
 Eine andere Möglichkeit besteht darin, ein einzelnes- <xref:System.Random> Objekt zu instanziieren, das Sie zum Generieren aller Zufallszahlen in der Anwendung verwenden. Dies ergibt eine etwas bessere Leistung, da die Instanziierung eines Zufallszahlengenerators recht teuer ist.  
  
   
  
## Examples  
 Im folgenden Beispiel werden <xref:System.Random> -Objekte mit dem-Klassenkonstruktor erstellt, der einen Seed-Parameter annimmt und eine Sequenz von zufälligen Ganzzahlen und Double-Werten generiert. Das Beispiel veranschaulicht, dass dieselbe Sequenz generiert wird, wenn das <xref:System.Random> Objekt mit dem Konstruktor und dem Seed-Parameter erneut erstellt wird.  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Next">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine Zufallsganzzahl zurück.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next();" />
      <MemberSignature Language="F#" Value="abstract member Next : unit -&gt; int&#xA;override this.Next : unit -&gt; int" Usage="random.Next " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine nicht negative Zufallsganzzahl zurück.</summary>
        <returns>Eine ganze 32-Bit-Zahl mit Vorzeichen, die größer oder gleich 0 (null) und kleiner als <see cref="F:System.Int32.MaxValue" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%2A?displayProperty=nameWithType> generiert eine Zufallszahl, deren Wert zwischen 0 und kleiner als liegt <xref:System.Int32.MaxValue?displayProperty=nameWithType> . Verwenden Sie die-Methoden Überladung, um eine Zufallszahl zu generieren, deren Wert zwischen 0 und einer anderen positiven Zahl liegt <xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType> . Um eine Zufallszahl in einem anderen Bereich zu generieren, verwenden Sie die- <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> Methoden Überladung.  
  
   
  
## Examples  
 Im folgenden Beispiel werden wiederholte Aufrufe der- <xref:System.Random.Next%2A> Methode durchführen, um eine bestimmte Anzahl von Zufallszahlen zu generieren, die vom Benutzer angefordert werden. Die- <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> Methode wird zum erhalten von Kundeneingaben verwendet.  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next3.cpp" id="Snippet5":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next3.cs" interactive="try-dotnet-method" id="Snippet5":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next3.vb" id="Snippet5":::
  
 Im folgenden Beispiel wird eine-Klasse von abgeleitet <xref:System.Random> , um eine Sequenz von Zufallszahlen zu generieren, deren Verteilung von der von der- <xref:System.Random.Sample%2A> Methode der-Basisklasse generierten gleichmäßigen Verteilung abweicht. Er überschreibt die <xref:System.Random.Sample%2A> -Methode, um die Verteilung von Zufallszahlen bereitzustellen, und überschreibt die- <xref:System.Random.Next%2A?displayProperty=nameWithType> Methode, um eine Reihe von Zufallszahlen zu verwenden.  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb" id="Snippet1":::  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Beginnend mit der .NET Framework Version 2,0, wenn Sie eine Klasse von ableiten <see cref="T:System.Random" /> und die- <see cref="M:System.Random.Sample" /> Methode überschreiben, wird die Distribution, die von der Implementierung der abgeleiteten Klasse der-Methode bereitgestellt <see cref="M:System.Random.Sample" /> wird, nicht in Aufrufen der Basisklassen Implementierung der- <see cref="M:System.Random.Next" /> Methode verwendet. Stattdessen wird die von der Basisklasse zurückgegebene gleichmäßige Verteilung <see cref="T:System.Random" /> verwendet. Dieses Verhalten verbessert die Gesamtleistung der- <see cref="T:System.Random" /> Klasse. Wenn Sie dieses Verhalten ändern möchten, um die- <see cref="M:System.Random.Sample" /> Methode in der abgeleiteten Klasse aufzurufen, müssen Sie auch die-Methode überschreiben <see cref="M:System.Random.Next" /> .</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int -&gt; int&#xA;override this.Next : int -&gt; int" Usage="random.Next maxValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxValue">Die exklusive obere Grenze der Zufallszahl, die generiert werden soll. <paramref name="maxValue" /> muss größer oder gleich 0 sein.</param>
        <summary>Gibt eine nicht negative Zufallsganzzahl zurück, die kleiner als das angegebene Maximum ist.</summary>
        <returns>Eine ganze 32-Bit-Zahl mit Vorzeichen, die größer oder gleich 0 (null) und kleiner als <paramref name="maxValue" /> ist, d.h., der Bereich der Rückgabewerte umfasst in der Regel 0 (null), aber nicht <paramref name="maxValue" />. Wenn jedoch <paramref name="maxValue" /> 0 (null) entspricht, wird <paramref name="maxValue" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die-Überladung <xref:System.Random.Next%28System.Int32%29> gibt zufällige ganze Zahlen zurück, die zwischen 0 und `maxValue` -1 liegen. Wenn jedoch `maxValue` 0 ist, gibt die Methode 0 zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel werden ganzzahlige Ganzzahlen mit verschiedenen über Ladungen der- <xref:System.Random.Next%2A> Methode generiert.  

 [!code-cpp[System.Random.Next#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next.cpp#1)]
 [!code-csharp-interactive[System.Random.Next#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next.cs#1)]
 [!code-vb[System.Random.Next#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next.vb#1)]  
  
 Im folgenden Beispiel wird eine zufällige ganze Zahl generiert, die als Index zum Abrufen eines Zeichen folgen Werts aus einem Array verwendet wird. Da der höchste Index des Arrays ein kleiner als seine Länge ist, wird der Wert der <xref:System.Array.Length%2A?displayProperty=nameWithType> Eigenschaft als `maxValue` Parameter angegeben.  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp-interactive[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxValue" /> ist kleiner als 0.</exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int minValue, int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 minValue, int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (minValue As Integer, maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int minValue, int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int * int -&gt; int&#xA;override this.Next : int * int -&gt; int" Usage="random.Next (minValue, maxValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minValue" Type="System.Int32" />
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minValue">Die inklusive untere Grenze der zurückgegebenen Zufallszahl.</param>
        <param name="maxValue">Die exklusive obere Grenze der zurückgegebenen Zufallszahl. <paramref name="maxValue" /> muss größer oder gleich <paramref name="minValue" /> sein.</param>
        <summary>Gibt eine Zufallsganzzahl zurück, die in einem angegebenen Bereich liegt.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die größer oder gleich <paramref name="minValue" /> und kleiner als <paramref name="maxValue" /> ist, d. h., der Bereich der Rückgabewerte umfasst <paramref name="minValue" />, aber nicht <paramref name="maxValue" />. Wenn <paramref name="minValue" /> gleich <paramref name="maxValue" /> ist, wird <paramref name="minValue" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> -Überladung gibt zufällige ganze Zahlen zurück, die von `minValue` bis `maxValue` -1 reichen. Wenn jedoch `maxValue` `minValue` ist, gibt die Methode zurück `minValue` .  
  
 Anders als bei den anderen über Ladungen der- <xref:System.Random.Next%2A> Methode, die nur nicht negative Werte zurückgeben, kann diese Methode eine negative Zufalls Ganzzahl zurückgeben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die- <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> Methode verwendet, um zufällige ganze Zahlen mit drei unterschiedlichen Bereichen zu generieren. Beachten Sie, dass die genaue Ausgabe aus dem Beispiel vom vom System bereitgestellten Seed-Wert abhängig ist, der an den- <xref:System.Random> Klassenkonstruktor übergeben wird.  
  
 [!code-cpp[System.Random.Next#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next2.cpp#2)]
 [!code-csharp-interactive[System.Random.Next#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/Next2.cs#2)]
 [!code-vb[System.Random.Next#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next2.vb#2)]  
  
 Im folgenden Beispiel wird eine zufällige ganze Zahl generiert, die als Index zum Abrufen eines Zeichen folgen Werts aus einem Array verwendet wird. Da der höchste Index des Arrays ein kleiner als seine Länge ist, wird der Wert der <xref:System.Array.Length%2A?displayProperty=nameWithType> Eigenschaft als `maxValue` Parameter angegeben.  
  
 [!code-cpp[System.Random.Next#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next4.cpp#4)]
 [!code-csharp-interactive[System.Random.Next#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next4.cs#4)]
 [!code-vb[System.Random.Next#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="minValue" /> ist größer als <paramref name="maxValue" />.</exception>
        <block subset="none" type="overrides"><para>Beginnend mit der .NET Framework Version 2,0, wenn Sie eine Klasse von ableiten <see cref="T:System.Random" /> und die- <see cref="M:System.Random.Sample" /> Methode überschreiben, wird die Distribution, die von der abgeleiteten Klassen Implementierung der-Methode bereitgestellt wird, <see cref="M:System.Random.Sample" /> nicht in Aufrufen der Basisklassen Implementierung der <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> -Methoden Überladung verwendet, wenn der Unterschied zwischen dem <paramref name="minValue" /> -Parameter und dem- <paramref name="maxValue" /> Parameter größer als ist <see cref="F:System.Int32.MaxValue" /> . Stattdessen wird die von der Basisklasse zurückgegebene gleichmäßige Verteilung <see cref="T:System.Random" /> verwendet. Dieses Verhalten verbessert die Gesamtleistung der- <see cref="T:System.Random" /> Klasse. Um dieses Verhalten zum Aufrufen der- <see cref="M:System.Random.Sample" /> Methode in der abgeleiteten Klasse zu ändern, müssen Sie auch die- <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> Methoden Überladung überschreiben.</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : byte[] -&gt; unit&#xA;override this.NextBytes : byte[] -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Das Array, das mit zufälligen Zahlen aufgefüllt wird.</param>
        <summary>Füllt die Elemente eines angegebenen Bytearrays mit Zufallszahlen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jedes Element des Byte Arrays wird auf eine Zufallszahl größer oder gleich 0 und kleiner als oder gleich festgelegt <xref:System.Byte.MaxValue> .  
  
 Um z. b. eine kryptografisch gesicherte Zufallszahl zu generieren, die zum Erstellen eines zufälligen Kennworts geeignet ist, verwenden Sie eine Methode wie <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType> .  
  
   
  
## Examples

 Im folgenden Beispiel wird veranschaulicht, wie die-Methode verwendet wird <xref:System.Random.NextBytes%2A> , um ein Bytearray mit zufälligen Byte Werten zu füllen.  
 
 [!code-cpp[Classic Random.NextBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CPP/source.cpp#1)]
 [!code-csharp-interactive[Classic Random.NextBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CS/source.cs#1)]
 [!code-vb[Classic Random.NextBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <block subset="none" type="overrides"><para>Beginnend mit der .NET Framework Version 2,0, wenn Sie eine Klasse von ableiten <see cref="T:System.Random" /> und die- <see cref="M:System.Random.Sample" /> Methode überschreiben, wird die Distribution, die von der Implementierung der abgeleiteten Klasse der-Methode bereitgestellt <see cref="M:System.Random.Sample" /> wird, nicht in Aufrufen der Basisklassen Implementierung der- <see cref="M:System.Random.NextBytes(System.Byte[])" /> Methode verwendet. Stattdessen wird die von der Basisklasse zurückgegebene gleichmäßige Verteilung <see cref="T:System.Random" /> verwendet. Dieses Verhalten verbessert die Gesamtleistung der- <see cref="T:System.Random" /> Klasse. Wenn Sie dieses Verhalten ändern möchten, um die- <see cref="M:System.Random.Sample" /> Methode in der abgeleiteten Klasse aufzurufen, müssen Sie auch die-Methode überschreiben <see cref="M:System.Random.NextBytes(System.Byte[])" /> .</para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Span(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : Span&lt;byte&gt; -&gt; unit&#xA;override this.NextBytes : Span&lt;byte&gt; -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Das Array, das mit zufälligen Zahlen aufgefüllt wird.</param>
        <summary>Füllt die Elemente einer festgelegten Bytespanne mit zufälligen Zahlen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Jedes Element der Byte Spanne wird auf eine Zufallszahl, die größer oder gleich 0 und kleiner als oder gleich ist, festgelegt <xref:System.Byte.MaxValue> .

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NextDouble">
      <MemberSignature Language="C#" Value="public virtual double NextDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 NextDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function NextDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double NextDouble();" />
      <MemberSignature Language="F#" Value="abstract member NextDouble : unit -&gt; double&#xA;override this.NextDouble : unit -&gt; double" Usage="random.NextDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine zufällige Gleitkommazahl zurück, die größer oder gleich 0,0 und kleiner als 1,0 ist.</summary>
        <returns>Eine Gleitkommazahl mit doppelter Genauigkeit, die größer oder gleich 0,0 und kleiner als 1,0 ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die tatsächliche obere Grenze der Zufallszahl, die von dieser Methode zurückgegeben wird, ist 0.99999999999999978.  
  
 Informationen zum Abrufen von zufälligen Gleit Komma Werten in einem anderen Bereich als 0,0 und 1,0 finden Sie im Abschnitt "Abrufen von Gleit Komma Werten in einem angegebenen Bereich" im <xref:System.Random> Thema zur-Klasse.  
  
 Bei dieser Methode handelt es sich um die öffentliche Version der geschützten Methode <xref:System.Random.Sample%2A> .  
  
   
  
## Examples  

 Im folgenden Beispiel wird die- <xref:System.Random.NextDouble%2A> Methode verwendet, um Sequenzen zufälliger Double-Werte zu generieren.  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 Im folgenden Beispiel wird die <xref:System.Random.NextDouble%2A> -Methode aufgerufen, um 100 Zufallszahlen zu generieren und deren Häufigkeitsverteilung anzeigt.  
  
 [!code-csharp-interactive[System.Random.NextDouble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.random.nextdouble/cs/nextdouble1.cs#2)]
 [!code-vb[System.Random.NextDouble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.random.nextdouble/vb/nextdouble1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sample">
      <MemberSignature Language="C#" Value="protected virtual double Sample ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance float64 Sample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Sample" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Sample () As Double" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual double Sample();" />
      <MemberSignature Language="F#" Value="abstract member Sample : unit -&gt; double&#xA;override this.Sample : unit -&gt; double" Usage="random.Sample " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine zufällige Gleitkommazahl zwischen 0,0 und 1,0 zurück.</summary>
        <returns>Eine Gleitkommazahl mit doppelter Genauigkeit, die größer oder gleich 0,0 und kleiner als 1,0 ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Leiten Sie eine Klasse von der <xref:System.Random> -Klasse ab, und überschreiben Sie die-Methode, um eine andere Zufallsverteilung oder ein anderes Zufallszahlengenerator-Prinzip zu generieren <xref:System.Random.Sample%2A> .  
  
> [!IMPORTANT]
>  Die <xref:System.Random.Sample%2A> -Methode ist `protected` . Dies bedeutet, dass nur innerhalb der <xref:System.Random> -Klasse und der abgeleiteten Klassen darauf zugegriffen werden kann. Um eine Zufallszahl zwischen 0 und 1 aus einer- <xref:System.Random> Instanz zu generieren, rufen Sie die- <xref:System.Random.NextDouble%2A> Methode auf.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Klasse von abgeleitet <xref:System.Random> , und die-Methode wird überschrieben <xref:System.Random.Sample%2A> , um eine Verteilung von Zufallszahlen zu generieren. Diese Verteilung unterscheidet sich von der von der- <xref:System.Random.Sample%2A> Methode der Basisklasse generierten einheitlichen Verteilung.  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Beginnend mit der .NET Framework Version 2,0, wenn Sie eine Klasse von ableiten <see cref="T:System.Random" /> und die- <see cref="M:System.Random.Sample" /> Methode überschreiben, wird die Distribution, die von der Implementierung der abgeleiteten Klasse für die-Methode bereitgestellt <see cref="M:System.Random.Sample" /> wird, nicht in Aufrufen der Basisklassen Implementierung der folgenden Methoden verwendet: 
–   Die <see cref="M:System.Random.NextBytes(System.Byte[])" />-Methode.  
  
–   Die <see cref="M:System.Random.Next" />-Methode.  
  
-Die- <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> Methode, if ( <paramref name="maxValue" />  -  <paramref name="minValue" /> ), ist größer als <see cref="F:System.Int32.MaxValue" /> .  
  
Stattdessen wird die von der Basisklasse bereitgestellte einheitliche Verteilung <see cref="T:System.Random" /> verwendet. Dieses Verhalten verbessert die Gesamtleistung der- <see cref="T:System.Random" /> Klasse. Wenn Sie dieses Verhalten ändern möchten, um die Implementierung der- <see cref="M:System.Random.Sample" /> Methode in der abgeleiteten Klasse aufzurufen, müssen Sie auch das Verhalten dieser drei Member überschreiben. Dies wird im Beispiel veranschaulicht.</para></block>
        <altmember cref="M:System.Random.NextDouble" />
      </Docs>
    </Member>
  </Members>
</Type>
