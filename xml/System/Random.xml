<Type Name="Random" FullName="System.Random">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e57ee7a5127df07b7d489d04aa9ba75b27233161" /><Meta Name="ms.sourcegitcommit" Value="46b6829001d7a117b555e2b8cd81170b68efff08" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="03/18/2020" /><Meta Name="ms.locfileid" Value="79506455" /></Metadata><TypeSignature Language="C#" Value="public class Random" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Random extends System.Object" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Random" />
  <TypeSignature Language="VB.NET" Value="Public Class Random" />
  <TypeSignature Language="C++ CLI" Value="public ref class Random" />
  <TypeSignature Language="F#" Value="type Random = class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Random extends System.Object" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime.Extensions" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt einen Generator für Pseudozufallszahlen dar, d. h. ein Algorithmus, der eine Zahlenfolge erzeugt, die bestimmte statistische Anforderungen hinsichtlich ihrer Zufälligkeit erfüllt.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pseudo Zufallszahlen werden mit gleicher Wahrscheinlichkeit aus einem begrenzten Satz von Zahlen ausgewählt. Die ausgewählten Zahlen sind nicht vollständig zufällig, da Sie mit einem mathematischen Algorithmus ausgewählt werden, Sie sind jedoch für praktische Zwecke ausreichend. Die aktuelle Implementierung der <xref:System.Random>-Klasse basiert auf einer geänderten Version des subtraktiven Zufallszahlen-Generator Algorithmus von Donald E. Knuth. Weitere Informationen finden Sie unter D. E. Knuth. *Die Art der Computer Programmierung, Volume 2: seminumerische Algorithmen*. Addison-Wesley, Reading, MA, dritte Edition, 1997.  
  
 Um eine kryptografisch sichere Zufallszahl zu generieren, z. b. eine, die zum Erstellen eines zufälligen Kennworts geeignet ist, verwenden Sie die <xref:System.Security.Cryptography.RNGCryptoServiceProvider>-Klasse, oder leiten Sie eine Klasse von <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>ab.  
  
 Inhalte dieses Themas:  
  
 [Instanziieren des Zufallszahlen-Generators](#Instantiate)   
 [Vermeiden mehrerer Instanziierungen](#Multiple)   
 [Die System. Random-Klasse und die Thread Sicherheit](#ThreadSafety)   
 [Erstellen verschiedener Typen von Zufallszahlen](#Functionality)   
 Durch [ihren eigenen Algorithmus ersetzen](#Overriding)   
 [Verwendung von System. Random für..](#Operations) .   
 [Abrufen der gleichen Sequenz von Zufalls Werten](#Same)  
 [Abrufen eindeutiger Sequenzen von Zufalls Werten](#Unique)  
 [Abrufen von ganzen Zahlen in einem angegebenen Bereich](#Range)  
 [Ganze Zahlen mit einer angegebenen Anzahl von Ziffern abrufen](#Digits)  
 [Abrufen von Gleit Komma Werten in einem angegebenen Bereich](#Floats)  
 [Generieren von zufälligen booleschen Werten](#Boolean)  
 [Generieren zufälliger 64-Bit-Ganzzahlen](#Long)  
 [Abrufen von Bytes in einem angegebenen Bereich](#Bytes)  
 [Abrufen eines Elements aus einem Array oder einer Auflistung nach dem Zufallsprinzip](#Array)  
 [Abrufen eines eindeutigen Elements aus einem Array oder einer Auflistung](#UniqueArray)  
  
<a name="Instantiate"></a>   
## <a name="instantiating-the-random-number-generator"></a>Instanziieren des Zufallszahlen-Generators  
 Sie instanziieren den Zufallszahlengenerator, indem Sie einen Ausgangswert (einen Startwert für den Algorithmus für die Pseudozufallszahlen Generierung) einem <xref:System.Random.%23ctor%2A>-Klassenkonstruktor bereitstellen.  Sie können den Seed-Wert entweder explizit oder implizit angeben:  
  
-   Der <xref:System.Random.%23ctor%28System.Int32%29>-Konstruktor verwendet einen expliziten Ausgangswert, den Sie angeben.  
  
-   Der <xref:System.Random.%23ctor>-Konstruktor verwendet die Systemuhr, um einen Ausgangswert bereitzustellen. Dies ist die gängigste Methode zum Instanziieren des Zufallszahlen-Generators.  
  
 Wenn derselbe Ausgangswert für separate <xref:System.Random> Objekte verwendet wird, generieren Sie dieselbe Reihe von Zufallszahlen. Dies kann nützlich sein, um eine Test Sammlung zu erstellen, die zufällige Werte verarbeitet, oder um Spiele wiedergeben, die Ihre Daten von Zufallszahlen ableiten. Beachten Sie jedoch, dass <xref:System.Random> Objekte in Prozessen, die unter verschiedenen Versionen der .NET Framework ausgeführt werden, möglicherweise andere Serien von Zufallszahlen zurückgeben, selbst wenn Sie mit identischen Ausgangswerten instanziiert werden.  
  
 Um verschiedene Sequenzen von Zufallszahlen zu erzeugen, können Sie den Seed-Wert Zeit abhängig machen und so eine andere Reihe mit jeder neuen Instanz von <xref:System.Random>erzeugen. Der parametrisierte <xref:System.Random.%23ctor%28System.Int32%29> Konstruktor kann basierend auf der Anzahl der Ticks in der aktuellen Zeit einen <xref:System.Int32> Wert annehmen, während der Parameter lose <xref:System.Random.%23ctor> Konstruktor die Systemuhr verwendet, um den Ausgangswert zu generieren. Allerdings werden nur im .NET Framework, da die Uhr eine begrenzte Auflösung aufweist und der Parameter lose Konstruktor verwendet wird, um unterschiedliche <xref:System.Random> Objekte in der Schluss Folge zu erstellen, Zufallszahlengeneratoren erstellt, die identische Sequenzen von Zufallszahlen erzeugen. Im folgenden Beispiel wird veranschaulicht, wie zwei <xref:System.Random>-Objekte, die in einer .NET Framework-Anwendung in unmittelbarer Folge instanziiert werden, eine identische Reihe von Zufallszahlen generieren. Bei den meisten Windows-Systemen haben <xref:System.Random> Objekte, die innerhalb von 15 Millisekunden von einem anderen erstellt werden, wahrscheinlich identische Seed-Werte.  
  
 [!code-cpp[System.Random#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)]
 [!code-csharp-interactive[System.Random#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)]
 [!code-vb[System.Random#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)]  
  
Um dieses Problem zu vermeiden, erstellen Sie ein einzelnes <xref:System.Random> Objekt anstelle mehrerer Objekte. Beachten Sie, dass die `Random`-Klasse in .net Core diese Einschränkung nicht besitzt.
  
<a name="Multiple"></a>   
## <a name="avoiding-multiple-instantiations"></a>Vermeiden mehrerer Instanziierungen  
 In der .NET Framework werden durch die Initialisierung von zwei Zufallszahlengeneratoren in einer engen Schleife oder in schneller Folge zwei Zufallszahlengeneratoren erstellt, die identische Sequenzen von Zufallszahlen erzeugen können. In den meisten Fällen ist dies nicht die Absicht des Entwicklers und kann zu Leistungsproblemen führen, da die Instanziierung und Initialisierung eines Zufallszahlengenerators ein relativ kostspieliger Prozess ist.  
  
 Um die Leistung zu verbessern und nicht versehentlich separate Zufallszahlengeneratoren zu erstellen, die identische numerische Sequenzen generieren, empfiehlt es sich, ein <xref:System.Random> Objekt zu erstellen, das viele Zufallszahlen generiert, anstatt neue <xref:System.Random> Objekte zu erstellen, um eine Zufallszahl zu generieren.  
  
 Die <xref:System.Random>-Klasse ist jedoch nicht Thread sicher. Wenn Sie <xref:System.Random> Methoden aus mehreren Threads abrufen, befolgen Sie die im nächsten Abschnitt beschriebenen Richtlinien.  
  
<a name="ThreadSafety"></a>   
## <a name="the-systemrandom-class-and-thread-safety"></a>Die System. Random-Klasse und die Thread Sicherheit  
 Anstatt einzelne <xref:System.Random> Objekte zu instanziieren, empfiehlt es sich, eine einzelne <xref:System.Random> Instanz zu erstellen, um alle Zufallszahlen zu generieren, die von Ihrer APP benötigt werden. <xref:System.Random> Objekte sind jedoch nicht Thread sicher. Wenn Ihre APP <xref:System.Random> Methoden aus mehreren Threads aufruft, müssen Sie ein Synchronisierungs Objekt verwenden, um sicherzustellen, dass jeweils nur ein Thread auf den Zufallszahlengenerator zugreifen kann. Wenn Sie nicht sicherstellen, dass auf das <xref:System.Random> Objekt auf Thread sichere Weise zugegriffen wird, geben Aufrufe von-Methoden, die Zufallszahlen zurückgeben, den Wert 0 zurück.  
  
 Im folgenden Beispiel wird die C# [lock-Anweisung](~/docs/csharp/language-reference/keywords/lock-statement.md) und die Visual Basic [SyncLock-Anweisung](~/docs/visual-basic/language-reference/statements/synclock-statement.md) verwendet, um sicherzustellen, dass der Zugriff auf einen einzelnen Zufallszahlengenerator von 11 Threads Thread sicher erfolgt. Jeder Thread generiert 2 Millionen Zufallszahlen, zählt die Anzahl der generierten Zufallszahlen und berechnet seine Summe und aktualisiert dann die Summen für alle Threads, wenn die Ausführung abgeschlossen ist.  
  
 [!code-cpp[System.Random#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)]
 [!code-csharp[System.Random#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)]
 [!code-vb[System.Random#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)]  
  
 Im Beispiel wird die Thread Sicherheit auf folgende Weise sichergestellt:  
  
-   Das <xref:System.ThreadStaticAttribute>-Attribut wird verwendet, um Thread lokale Variablen zu definieren, mit denen die Gesamtzahl der generierten Zufallszahlen und deren Summe für jeden Thread nachverfolgt wird.  
  
-   Eine Sperre (die `lock`-Anweisung C# in und die `SyncLock`-Anweisung in Visual Basic) schützt den Zugriff auf die Variablen für die Gesamtanzahl und Summe aller Zufallszahlen, die für alle Threads generiert werden.  
  
-   Ein Semaphor (das <xref:System.Threading.CountdownEvent> Objekt) wird verwendet, um sicherzustellen, dass der Haupt Thread blockiert wird, bis alle anderen Threads die Ausführung vollständig erfüllen.  
  
-   Im Beispiel wird überprüft, ob der Zufallszahlen-Generator beschädigt wurde, indem ermittelt wird, ob zwei aufeinander folgende Aufrufe der Zufallszahlen Generierungs Methode 0 zurückgeben. Wenn eine Beschädigung erkannt wird, wird im Beispiel das <xref:System.Threading.CancellationTokenSource>-Objekt verwendet, um zu signalisieren, dass alle Threads abgebrochen werden sollen.  
  
-   Vor dem Erstellen der Zufallszahl überprüft jeder Thread den Status des <xref:System.Threading.CancellationToken> Objekts. Wenn der Abbruch angefordert wird, ruft das Beispiel die <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType>-Methode auf, um den Thread abzubrechen.  
  
 Das folgende Beispiel ist mit dem ersten identisch, mit der Ausnahme, dass es ein <xref:System.Threading.Tasks.Task> Objekt und einen Lambda-Ausdruck anstelle von <xref:System.Threading.Thread>-Objekten verwendet.  
  
 [!code-csharp[System.Random#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)]
 [!code-vb[System.Random#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)]  
  
 Dies unterscheidet sich vom ersten Beispiel wie folgt:  
  
-   Die Variablen, die die Anzahl der generierten Zufallszahlen und deren Summe in jeder Aufgabe nachverfolgen sollen, sind für die Aufgabe lokal, sodass es nicht erforderlich ist, das <xref:System.ThreadStaticAttribute>-Attribut zu verwenden.  
  
-   Die statische <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType>-Methode wird verwendet, um sicherzustellen, dass der Haupt Thread nicht vollständig abgeschlossen ist, bevor alle Aufgaben abgeschlossen sind. Das <xref:System.Threading.CountdownEvent>-Objekt ist nicht erforderlich.  
  
-   Die Ausnahme, die sich aus dem Task Abbruch ergibt, wird in der <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType>-Methode angezeigt. Im vorherigen Beispiel wird Sie von jedem Thread behandelt.  
  
<a name="Functionality"></a>   
## <a name="generating-different-types-of-random-numbers"></a>Erstellen verschiedener Typen von Zufallszahlen  
 Der Zufallszahlengenerator stellt Methoden bereit, mit denen Sie die folgenden Arten von Zufallszahlen generieren können:  
  
-   Eine Reihe von <xref:System.Byte> Werten. Sie bestimmen die Anzahl von Byte Werten, indem Sie ein Array, das an die Anzahl der Elemente initialisiert wird, die die Methode zurückgeben soll, an die <xref:System.Random.NextBytes%2A> Methode übergeben. Im folgenden Beispiel werden 20 Bytes generiert.  
  
     [!code-cpp[System.Random#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)]
     [!code-csharp-interactive[System.Random#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)]
     [!code-vb[System.Random#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)]  
  
-   Eine einzelne Ganzzahl. Sie können auswählen, ob eine ganze Zahl zwischen 0 und einem maximalen Wert (<xref:System.Int32.MaxValue?displayProperty=nameWithType>-1) werden soll, indem Sie die <xref:System.Random.Next>-Methode aufrufen, eine ganze Zahl zwischen 0 und einem bestimmten Wert, indem Sie die <xref:System.Random.Next%28System.Int32%29>-Methode aufrufen, oder eine ganze Zahl innerhalb eines Wertebereichs, indem Sie die <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>-Methode aufrufen. In den parametrisierten über Ladungen ist der angegebene Maximalwert exklusiv. Das heißt, die tatsächliche Höchstzahl, die generiert wird, ist ein kleiner als der angegebene Wert.  
  
     Im folgenden Beispiel wird die <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>-Methode aufgerufen, um 10 Zufallszahlen zwischen-10 und 10 zu generieren. Beachten Sie, dass das zweite Argument für die-Methode die exklusive obere Grenze des Bereichs von Zufalls Werten angibt, die von der-Methode zurückgegeben werden. Anders ausgedrückt: die größte Ganzzahl, die die Methode zurückgeben kann, ist ein kleiner als dieser Wert.  
  
     [!code-cpp[System.Random#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)]
     [!code-csharp-interactive[System.Random#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)]
     [!code-vb[System.Random#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)]  
  
-   Ein einzelner Gleit Komma Wert zwischen 0,0 und kleiner als 1,0 durch Aufrufen der <xref:System.Random.NextDouble%2A>-Methode. Die exklusive obere Grenze der Zufallszahl, die von der-Methode zurückgegeben wird, ist 1, sodass Ihre tatsächliche obere Grenze 0.99999999999999978 ist. Im folgenden Beispiel werden 10 zufällige Gleit Komma Zahlen generiert.  
  
     [!code-cpp[System.Random#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)]
     [!code-csharp-interactive[System.Random#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)]
     [!code-vb[System.Random#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)]  
  
> [!IMPORTANT]
>  Die <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>-Methode ermöglicht es Ihnen, den Bereich der zurückgegebenen Zufallszahl anzugeben. Der `maxValue`-Parameter, der die zurückgegebene Zahl des oberen Bereichs angibt, ist jedoch ein exklusiver, kein inklusiver Wert. Dies bedeutet, dass der Methoden Aufruf`Next(0, 100)` einen Wert zwischen 0 und 99 zurückgibt, nicht zwischen 0 und 100.  
  
 Sie können auch die <xref:System.Random>-Klasse für Aufgaben wie das Erstellen [zufälliger t:System.Boolean-Werte](#Boolean), das Erstellen [zufälliger Gleit Komma Werte mit einem Bereich von 0 bis 1](#Floats), das Erstellen [zufälliger 64-Bit-](#Long)Ganzzahlen und das [Zufalls Abrufen eines eindeutigen Elements aus einem Array oder](#UniqueArray)einer Auflistung verwenden. Informationen zu diesen und anderen häufigen Aufgaben finden Sie unter Gewusst [wie: Verwenden von System. Random für..](#Operations) . abgerufen haben.  
  
<a name="Overriding"></a>   
## <a name="substituting-your-own-algorithm"></a>Ersetzen Ihres eigenen Algorithmus  
 Sie können Ihren eigenen Zufallszahlen-Generator implementieren, indem Sie von der <xref:System.Random>-Klasse erben und den Algorithmus für die Zufallszahlengenerierung bereitstellen. Um einen eigenen Algorithmus bereitzustellen, müssen Sie die <xref:System.Random.Sample%2A>-Methode überschreiben, die den Algorithmus für die Zufallszahlengenerierung implementiert. Außerdem sollten Sie die Methoden <xref:System.Random.Next>, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>und <xref:System.Random.NextBytes%2A> überschreiben, um sicherzustellen, dass Sie die überschriebene <xref:System.Random.Sample%2A>-Methode aufzurufen. Sie müssen die Methoden <xref:System.Random.Next%28System.Int32%29> und <xref:System.Random.NextDouble%2A> nicht überschreiben.  
  
 Ein Beispiel, das von der <xref:System.Random>-Klasse abgeleitet wird und den standardmäßigen Pseudozufallszahlen-Generator ändert, finden Sie auf der <xref:System.Random.Sample%2A> Referenzseite.  
  
<a name="Operations"></a>   
## <a name="how-do-you-use-systemrandom-to"></a>Verwendung von System. Random für...  
 In den folgenden Abschnitten wird der Beispielcode für einige Möglichkeiten erläutert und bereitgestellt, wie Sie in Ihrer APP Zufallszahlen verwenden können.  
  
<a name="Same"></a>   
### <a name="retrieve-the-same-sequence-of-random-values"></a>Abrufen der gleichen Sequenz von Zufalls Werten  
 Manchmal möchten Sie die gleiche Sequenz von Zufallszahlen in Softwaretest Szenarien und in Spiel spielen generieren. Durch Tests mit der gleichen Sequenz von Zufallszahlen können Sie Regressionen erkennen und Fehlerbehebungen bestätigen. Die Verwendung derselben Sequenz von Zufallszahlen in spielen ermöglicht Ihnen, vorherige Spiele wiederzugeben.  
  
 Sie können dieselbe Sequenz von Zufallszahlen generieren, indem Sie dem <xref:System.Random.%23ctor%28System.Int32%29>-Konstruktor denselben Ausgangswert bereitstellen. Der Seed-Wert stellt einen Startwert für den Algorithmus zur Generierung von Pseudozufallszahlen dar. Im folgenden Beispiel wird 100100 als beliebiger Ausgangswert verwendet, um das <xref:System.Random>-Objekt zu instanziieren, 20 zufällige Gleit Komma Werte anzeigt und den Seed-Wert persistent zu verwenden. Anschließend wird der Seed-Wert wieder hergestellt, ein neuer Zufallszahlengenerator instanziiert und die gleichen 20 zufälligen Gleit Komma Werte angezeigt.  Beachten Sie, dass das Beispiel möglicherweise unterschiedliche Sequenzen von Zufallszahlen erzeugt, wenn Sie in verschiedenen Versionen der .NET Framework ausgeführt werden.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs" interactive="try-dotnet" id="Snippet12":::
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp" id="Snippet12":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb" id="Snippet12":::
  
<a name="Unique"></a>   
### <a name="retrieve-unique-sequences-of-random-numbers"></a>Abrufen von eindeutigen Sequenzen von Zufallszahlen  
 Die Angabe unterschiedlicher Ausgangswerte für Instanzen der <xref:System.Random> Klasse bewirkt, dass jeder Zufallszahlengenerator eine andere Sequenz von Werten erzeugt. Sie können einen Ausgangswert entweder explizit angeben, indem Sie den <xref:System.Random.%23ctor%28System.Int32%29>-Konstruktor aufrufen oder den <xref:System.Random.%23ctor>-Konstruktor implizit aufrufen. Die meisten Entwickler wenden den Parameter losen Konstruktor an, der die Systemuhr verwendet. Im folgenden Beispiel wird dieser Ansatz verwendet, um zwei <xref:System.Random> Instanzen zu instanziieren. Jede Instanz zeigt eine Reihe von 10 zufälligen Ganzzahlen an.  
  
 [!code-cpp[System.Random#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp#13)]
 [!code-csharp[System.Random#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs#13)]
 [!code-vb[System.Random#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb#13)]  
  
 Aufgrund der begrenzten Auflösung erkennt die Systemuhr jedoch keine Zeitunterschiede, die weniger als ungefähr 15 Millisekunden betragen. Wenn Ihr Code die <xref:System.Random.%23ctor> Überladung auf dem .NET Framework aufruft, um zwei <xref:System.Random> Objekte nacheinander zu instanziieren, können Sie daher versehentlich die Objekte mit identischen Ausgangswerten bereitstellen. (Für die <xref:System.Random>-Klasse in .net Core gibt es diese Einschränkung nicht.) Um dies im vorherigen Beispiel zu sehen, kommentieren Sie den <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>-Methodenaufrufe aus, und kompilieren Sie das Beispiel, und führen Sie es erneut aus.  
  
 Um dies zu verhindern, empfiehlt es sich, ein einzelnes <xref:System.Random> Objekt anstelle mehrerer Objekte zu instanziieren. Da <xref:System.Random> jedoch nicht Thread sicher ist, müssen Sie ein Synchronisierungs Gerät verwenden, wenn Sie von mehreren Threads aus auf eine <xref:System.Random> Instanz zugreifen. Weitere Informationen finden Sie [unter Random class and Thread Safety](#ThreadSafety) weiter oben in diesem Thema. Alternativ können Sie einen Verzögerungs Mechanismus verwenden, wie z. b. die <xref:System.Threading.Thread.Sleep%2A>-Methode, die im vorherigen Beispiel verwendet wurde, um sicherzustellen, dass die Instanziierungen mehr als 15 Millisekunden voneinander getrennt vorkommen.  
  
<a name="Range"></a>   
### <a name="retrieve-integers-in-a-specified-range"></a>Abrufen von ganzen Zahlen in einem angegebenen Bereich  
 Sie können ganze Zahlen in einem angegebenen Bereich abrufen, indem Sie die <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>-Methode aufrufen, mit der Sie sowohl die untere als auch die obere Grenze der Zahlen festlegen können, die der Zufallszahlengenerator zurückgeben soll. Die obere Grenze ist ein exklusiver, kein inklusiver Wert. Das heißt, es ist nicht in den von der-Methode zurückgegebenen Wertebereich enthalten. Im folgenden Beispiel wird diese Methode verwendet, um zufällige ganze Zahlen zwischen-10 und 10 zu generieren. Beachten Sie, dass es 11 angibt, das einen größer als der gewünschte Wert ist, als Wert des `maxValue` Arguments im Methoden Aufruf.  
  
 [!code-cpp[System.Random#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)]
 [!code-csharp-interactive[System.Random#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)]
 [!code-vb[System.Random#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)]  
  
<a name="Digits"></a>   
### <a name="retrieve-integers-with-a-specified-number-of-digits"></a>Ganze Zahlen mit einer angegebenen Anzahl von Ziffern abrufen  
 Sie können die <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>-Methode aufrufen, um Zahlen mit einer bestimmten Anzahl von Ziffern abzurufen. Wenn Sie z. b. Zahlen mit vier Ziffern (d. h. Zahlen zwischen 1000 und 9999) abrufen möchten, rufen Sie die <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>-Methode mit dem `minValue` Wert 1000 und dem `maxValue` Wert 10000 auf, wie im folgenden Beispiel gezeigt.  
  
 [!code-cpp[System.Random#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)]
 [!code-csharp-interactive[System.Random#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)]
 [!code-vb[System.Random#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)]  
  
<a name="Floats"></a>   
### <a name="retrieve-floating-point-values-in-a-specified-range"></a>Abrufen von Gleit Komma Werten in einem angegebenen Bereich  
 Die <xref:System.Random.NextDouble%2A>-Methode gibt zufällige Gleit Komma Werte zurück, die zwischen 0 und kleiner als 1 liegen. Sie möchten jedoch häufig Zufallswerte in einem anderen Bereich generieren.  
  
 Wenn das Intervall zwischen dem minimalen und dem maximalen gewünschten Wert 1 beträgt, können Sie den Unterschied zwischen dem gewünschten Start Intervall und 0 der von der <xref:System.Random.NextDouble%2A>-Methode zurückgegebenen Zahl hinzufügen. Im folgenden Beispiel werden 10 Zufallszahlen zwischen-1 und 0 generiert.  
  
 [!code-cpp[System.Random#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)]
 [!code-csharp-interactive[System.Random#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)]
 [!code-vb[System.Random#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)]  
  
 Um zufällige Gleit Komma Zahlen zu generieren, deren untere Grenze 0 (null) ist, aber obere Grenze größer als 1 ist (oder im Fall von negativen Zahlen, deren untere Grenze kleiner als-1 und die obere Grenze 0 ist), Multiplizieren Sie die Zufallszahl mit der Grenze ungleich 0 (null). Im folgenden Beispiel werden 20 Millionen zufällige Gleit Komma Zahlen generiert, die zwischen 0 und <xref:System.Int64.MaxValue?displayProperty=nameWithType>liegen. In wird auch die Verteilung der von der-Methode generierten zufälligen Werte angezeigt.  
  
 [!code-cpp[System.Random#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)]
 [!code-csharp-interactive[System.Random#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)]
 [!code-vb[System.Random#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)]  
  
 Verwenden Sie die folgende Formel, um zufällige Gleit Komma Zahlen zwischen zwei beliebigen Werten zu generieren, wie z. b. die <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>-Methode für ganze Zahlen.  
  
```csharp  
Random.NextDouble() * (maxValue - minValue) + minValue  
```  
  
 Im folgenden Beispiel werden 1 Million Zufallszahlen generiert, die zwischen 10,0 und 11,0 liegen und deren Verteilung anzeigt.  
  
 [!code-cpp[System.Random#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)]
 [!code-csharp-interactive[System.Random#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)]
 [!code-vb[System.Random#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)]  
  
<a name="Boolean"></a>   
### <a name="generate-random-boolean-values"></a>Generieren von zufälligen booleschen Werten  
 Die <xref:System.Random>-Klasse stellt keine Methoden bereit, die <xref:System.Boolean> Werte generieren. Hierfür können Sie jedoch auch eine eigene Klasse oder Methode definieren. Im folgenden Beispiel wird eine-Klasse, `BooleanGenerator`mit einer einzelnen Methode definiert, `NextBoolean`. Die `BooleanGenerator`-Klasse speichert ein <xref:System.Random>-Objekt als private Variable. Die `NextBoolean`-Methode ruft die <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType>-Methode auf und übergibt das Ergebnis an die <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType>-Methode. Beachten Sie, dass 2 als Argument verwendet wird, um die obere Grenze der Zufallszahl anzugeben. Da dies ein exklusiver Wert ist, gibt der Methodenaufrufe entweder 0 oder 1 zurück.  
  
 [!code-cpp[System.Random#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp#8)]
 [!code-csharp[System.Random#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs#8)]
 [!code-vb[System.Random#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb#8)]  
  
 Anstatt eine separate Klasse zum Generieren von zufälligen <xref:System.Boolean> Werten zu erstellen, könnte das Beispiel einfach nur eine einzige Methode definieren. In diesem Fall sollte das <xref:System.Random> Objekt jedoch als Variable auf Klassenebene definiert worden sein, um zu vermeiden, dass in jedem Methoden aufrufeine neue <xref:System.Random> Instanz instanziiert wird. In Visual Basic kann die zufällige Instanz als [statische](~/docs/visual-basic/language-reference/modifiers/static.md) Variable in der `NextBoolean`-Methode definiert werden.  Im folgenden Beispiel wird eine-Implementierung bereitstellt.  
  
 [!code-cpp[System.Random#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)]
 [!code-csharp-interactive[System.Random#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)]
 [!code-vb[System.Random#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)]  
  
<a name="Long"></a>   
### <a name="generate-random-64-bit-integers"></a>Generieren zufälliger 64-Bit-Ganzzahlen  
 Die über Ladungen der <xref:System.Random.Next%2A>-Methode geben 32-Bit-Ganzzahlen zurück. In einigen Fällen möchten Sie jedoch vielleicht mit 64-Bit-Ganzzahlen arbeiten. Sie können dies wie folgt tun:  
  
1.  Rufen Sie die <xref:System.Random.NextDouble%2A>-Methode auf, um einen Gleit Komma Wert mit doppelter Genauigkeit abzurufen.  
  
2.  Multiplizieren Sie diesen Wert <xref:System.Int64.MaxValue?displayProperty=nameWithType>.  
  
 Im folgenden Beispiel wird dieses Verfahren verwendet, um zufällige ganze Zahlen mit 20 Millionen zu generieren und in 10 gleich großen Gruppen zu kategorisieren. Anschließend wertet er die Verteilung der Zufallszahlen aus, indem er die Anzahl der einzelnen Gruppen von 0 bis <xref:System.Int64.MaxValue?displayProperty=nameWithType>zählt. Wie die Ausgabe des Beispiels zeigt, werden die Zahlen mehr oder weniger gleichmäßig über den Bereich einer langen ganzen Zahl verteilt.  
  
 [!code-cpp[System.Random#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)]
 [!code-csharp-interactive[System.Random#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)]
 [!code-vb[System.Random#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)]  
  
 Eine alternative Methode, die Bitmanipulation verwendet, generiert keine wirklich zufälligen Zahlen. Mit dieser Technik werden <xref:System.Random.Next> aufgerufen, um zwei Ganzzahlen zu generieren, um eine nach 32 Bits zu verschieben, und Sie werden miteinander verknüpft. Diese Methode hat zwei Einschränkungen:  
  
1.  Da Bit 31 das Signier Bit ist, ist der Wert in Bit 31 der resultierenden Long-Ganzzahl immer 0.  Dies kann behoben werden, indem ein zufälliger 0-oder 1-Bit-Wert generiert wird, bei dem der Wert für 31 Bits nach links verschoben und mit der ursprünglichen zufälligen Long-Ganzzahl  
  
2.  Da die Wahrscheinlichkeit, dass der Wert, der von <xref:System.Random.Next> zurückgegeben wird, 0 (null) ist, gibt es nur wenige, wenn eine Zufallszahl im Bereich von 0x0-0x00000000FFFFFFFF liegt.  
  
<a name="Bytes"></a>   
### <a name="retrieve-bytes-in-a-specified-range"></a>Abrufen von Bytes in einem angegebenen Bereich  
 Die über Ladungen der <xref:System.Random.Next%2A>-Methode ermöglichen es Ihnen, den Bereich von Zufallszahlen anzugeben, die <xref:System.Random.NextBytes%2A>-Methode jedoch nicht. Im folgenden Beispiel wird eine `NextBytes`-Methode implementiert, mit der Sie den Bereich der zurückgegebenen Bytes angeben können. Es definiert eine `Random2` Klasse, die von <xref:System.Random> abgeleitet ist und die `NextBytes`-Methode überlädt.  
  
 [!code-cpp[System.Random#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp#9)]
 [!code-csharp[System.Random#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs#9)]
 [!code-vb[System.Random#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb#9)]  
  
 Die `NextBytes(Byte[], Byte, Byte)`-Methode umschließt einen aufzurufenden <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> Methode und gibt den Minimalwert und einen größer als den maximalen Wert (in diesem Fall 0 und 101) an, der im Bytearray zurückgegeben werden soll. Da wir sicher sind, dass die von der <xref:System.Random.Next%2A>-Methode zurückgegebenen ganzzahligen Werte innerhalb des Bereichs des <xref:System.Byte> Datentyps liegen, können C#wir Sie problemlos umwandeln (in) oder von ganzen Zahlen in Bytes konvertieren (in Visual Basic).  
  
<a name="Array"></a>   
### <a name="retrieve-an-element-from-an-array-or-collection-at-random"></a>Abrufen eines Elements aus einem Array oder einer Auflistung nach dem Zufallsprinzip  
 Zufallszahlen dienen häufig als Indizes zum Abrufen von Werten aus Arrays oder Auflistungen. Wenn Sie einen zufälligen Indexwert abrufen möchten, können Sie die <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>-Methode aufrufen und die untere Grenze des Arrays als Wert seines `minValue` Arguments und einen größer als die obere Grenze des Arrays als Wert seines `maxValue` Arguments verwenden. Für ein NULL basiertes Array entspricht dies der <xref:System.Array.Length%2A>-Eigenschaft, oder eine größer als der Wert, der von der <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType>-Methode zurückgegeben wird. Im folgenden Beispiel wird der Name einer Stadt im USA aus einem Array von Städten nach dem Zufallsprinzip abgerufen.  
  
 [!code-cpp[System.Random#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)]
 [!code-csharp-interactive[System.Random#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)]
 [!code-vb[System.Random#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)]  
  
<a name="UniqueArray"></a>   
### <a name="retrieve-a-unique-element-from-an-array-or-collection"></a>Abrufen eines eindeutigen Elements aus einem Array oder einer Auflistung  
 Ein Zufallszahlengenerator kann immer doppelte Werte zurückgeben. Wenn der Bereich der Zahlen kleiner wird oder die Anzahl der generierten Werte größer ist, wächst die Wahrscheinlichkeit von Duplikaten. Wenn zufällige Werte eindeutig sein müssen, werden mehr Zahlen generiert, um Duplikate zu kompensieren. Dies führt zu einer zunehmend schlechten Leistung.  
  
 Es gibt eine Reihe von Techniken zum Behandeln dieses Szenarios. Eine gängige Lösung besteht darin, ein Array oder eine Sammlung zu erstellen, das die abzurufenden Werte enthält, sowie ein paralleles Array, das zufällige Gleit Komma Zahlen enthält. Das zweite Array wird mit Zufallszahlen aufgefüllt, wenn das erste Array erstellt wird, und die <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType>-Methode wird verwendet, um das erste Array mithilfe der Werte im parallelen Array zu sortieren.  
  
 Wenn Sie z. b. ein Solitaire-Spiel entwickeln, sollten Sie sicherstellen, dass jede Karte nur einmal verwendet wird. Anstatt Zufallszahlen zum Abrufen einer Karte und nachverfolgen, ob diese Karte bereits behandelt wurde, zu erzeugen, können Sie ein paralleles Array von Zufallszahlen erstellen, das zum Sortieren des Stapels verwendet werden kann. Sobald der Stapel sortiert ist, kann Ihre APP einen Zeiger behalten, um den Index der nächsten Karte auf dem Stapel anzugeben.  
  
 Dieser Ansatz wird anhand des folgenden Beispiels veranschaulicht. Es definiert eine `Card` Klasse, die eine Wiedergabe Karte und eine `Dealer` Klasse darstellt, die einen Stapel von gemischten Karten behandelt. Der `Dealer`-Klassenkonstruktor füllt zwei Arrays auf: ein `deck` Array mit Klassen Bereich, das alle Karten im Stapel darstellt. und ein lokales `order` Array, das über die gleiche Anzahl von Elementen wie das `deck` Array verfügt und mit zufällig generierten <xref:System.Double> Werten aufgefüllt wird.  Die <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType>-Methode wird dann aufgerufen, um das `deck` Array basierend auf den Werten im `order` Array zu sortieren.  
  
 [!code-cpp[System.Random#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp#11)]
 [!code-csharp[System.Random#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs#11)]
 [!code-vb[System.Random#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb#11)]  
  
   
  
## Examples  

 Im folgenden Beispiel wird ein einzelner Zufallszahlengenerator erstellt und seine Methoden <xref:System.Random.NextBytes%2A>, <xref:System.Random.Next%2A>und <xref:System.Random.NextDouble%2A> aufgerufen, um Sequenzen von Zufallszahlen in verschiedenen Bereichen zu generieren.  
  
 [!code-cpp[System.Random#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random2.cpp#2)]
 [!code-csharp-interactive[System.Random#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random2.cs#2)]
 [!code-vb[System.Random#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random2.vb#2)]  
  
 Im folgenden Beispiel wird eine zufällige ganze Zahl generiert, die als Index zum Abrufen eines Zeichen folgen Werts aus einem Array verwendet wird.  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp-interactive[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>In den .NET Framework 1,0 und 1,1 ist eine minimale Implementierung einer von <see cref="T:System.Random" /> abgeleiteten Klasse erforderlich, die die <see cref="M:System.Random.Sample" />-Methode überschreibt, um einen neuen oder geänderten Algorithmus zum Erstellen von Zufallszahlen zu definieren. Die abgeleitete Klasse kann dann auf die Basisklassen Implementierung der Methoden <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32)" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, <see cref="M:System.Random.NextBytes(System.Byte[])" />und <see cref="M:System.Random.NextDouble" /> zurückgreifen, um die Implementierung der abgeleiteten Klasse der <see cref="M:System.Random.Sample" />-Methode aufzurufen.  
  
In der .NET Framework 2,0 und höher wurde das Verhalten der Methoden <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />und <see cref="M:System.Random.NextBytes(System.Byte[])" /> geändert, sodass diese Methoden nicht notwendigerweise die Implementierung der abgeleiteten Klasse der <see cref="M:System.Random.Sample" />-Methode aufzurufen. Daher sollten von <see cref="T:System.Random" /> abgeleitete Klassen, die auf .NET Framework 2,0 und höher ausgerichtet sind, auch diese drei Methoden überschrieben werden.</para></block>
    <block subset="none" type="usage"><para>Es ist nicht garantiert, dass die Implementierung des Zufallszahlengenerators in der <see cref="T:System.Random" />-Klasse in den Hauptversionen des .NET Framework identisch bleibt. Daher sollten Sie nicht davon ausgehen, dass derselbe Ausgangswert in verschiedenen Versionen der .NET Framework dieselbe pseudo zufällige Sequenz ergibt.</para></block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der Klasse <see cref="T:System.Random" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Random" />-Klasse unter Verwendung eines zeitabhängigen Standardstartwerts.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

Der standardseed-Wert wird von der Systemuhr abgeleitet, die eine begrenzte Auflösung aufweist. Demzufolge verfügen unterschiedliche <xref:System.Random> Objekte, die durch einen-Parameter, der den Parameter losen Konstruktor mit einem-Parameter erstellt, mit identischen Standard Ausgangswerten und können daher identische Sätze von Zufallszahlen erstellen. .NET Framework Dieses Problem kann vermieden werden, indem ein einzelnes <xref:System.Random> Objekt verwendet wird, um alle Zufallszahlen zu generieren. Sie können das Problem auch umgehen, indem Sie einen eigenen zufälligen Ausgangswert erstellen und an den <xref:System.Random.%23ctor%28System.Int32%29>-Konstruktor übergeben. Weitere Informationen finden Sie im <xref:System.Random.%23ctor%28System.Int32%29>-Konstruktor. Beachten Sie, dass diese Einschränkung nicht auf .net Core anwendbar ist.  
  
 Rufen Sie diesen Konstruktor auf, wenn Sie möchten, dass der Zufallszahlengenerator eine zufällige Sequenz von Zahlen generiert. Um eine festgelegte Sequenz von Zufallszahlen zu generieren, die für unterschiedliche Zufallszahlengeneratoren identisch sein werden, rufen Sie den <xref:System.Random.%23ctor%28System.Int32%29>-Konstruktor mit einem fixierten Ausgangswert auf. Diese <xref:System.Random>-Konstruktorüberladung wird häufig beim Testen von apps verwendet, die Zufallszahlen verwenden.  
  
 Nachdem Sie den Zufallszahlengenerator instanziiert haben, rufen Sie einzelne <xref:System.Random> Methoden (z. b. <xref:System.Random.Next> oder <xref:System.Random.NextDouble>) auf, um Zufallszahlen zu generieren.  
  
   
  
## Examples

Im folgenden Beispiel wird der Parameter lose Konstruktor zum Instanziieren von drei <xref:System.Random> Objekten verwendet, und es wird eine Sequenz von fünf Zufallszahlen für jede angezeigt. Wenn Sie auf .NET Framework ausgeführt wird, da die ersten beiden <xref:System.Random> Objekte in der Schlusssequenz erstellt werden, werden Sie mit identischen Ausgangswerten instanziiert, die auf der Systemuhr basieren, und deshalb wird eine identische Sequenz von Zufallszahlen erzeugt. Auf der anderen Seite wird der Parameter lose Konstruktor des dritten <xref:System.Random> Objekts nach einer Verzögerung von zwei Sekunden aufgerufen, die durch den Aufruf der <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>-Methode verursacht wurde. Da dadurch ein anderer Ausgangswert für das dritte <xref:System.Random>-Objekt erzeugt wird, wird eine andere Sequenz von Zufallszahlen erzeugt.  
  
 [!code-csharp[System.Random.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor1.cs#2)]
 [!code-vb[System.Random.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random (int Seed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 Seed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Seed As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random(int Seed);" />
      <MemberSignature Language="F#" Value="new Random : int -&gt; Random" Usage="new System.Random Seed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Seed" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Seed">Eine Zahl, mit der ein Startwert für Folgen von Pseudozufallszahlen berechnet wird. Wenn eine negative Zahl angegeben wird, wird der absolute Wert der Zahl verwendet.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Random" />-Klasse unter Verwendung des angegebenen Startwerts.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Bereitstellen eines identischen Ausgangs Werts für verschiedene <xref:System.Random> Objekte bewirkt, dass jede Instanz identische Sequenzen von Zufallszahlen erzeugt. Dies erfolgt häufig beim Testen von apps, die auf Zufallszahlengeneratoren basieren.  
  
 Wenn Ihre Anwendung unterschiedliche Zufallszahlen Sequenzen erfordert, rufen Sie diesen Konstruktor wiederholt mit unterschiedlichen Seed-Werten auf. Eine Möglichkeit zum Erstellen eines eindeutigen Ausgangs Werts besteht darin, den Wert Zeit abhängig zu machen. Leiten Sie z. b. den Seed-Wert von der Systemuhr ab, wie die <xref:System.Random.%23ctor> Überladung. Die Systemuhr verfügt jedoch möglicherweise nicht über genügend Auflösung, um unterschiedliche Aufrufe dieses Konstruktors mit einem anderen Ausgangswert bereitzustellen. Auf der .NET Framework werden dadurch Zufallszahlengeneratoren generiert, die identische Sequenzen von Pseudozufallszahlen generieren, wie von den ersten beiden <xref:System.Random> Objekten im folgenden Beispiel dargestellt. Um dies zu verhindern, wenden Sie einen Algorithmus an, um den Ausgangswert in jedem Aufruf zu unterscheiden, oder aufrufen Sie die <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>-Methode, um sicherzustellen, dass Sie jeden Konstruktor mit einem anderen Ausgangswert bereitstellen.  
  
 [!code-csharp[System.Random.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)]
 [!code-vb[System.Random.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)]  
  
 Eine andere Möglichkeit besteht darin, ein einzelnes <xref:System.Random> Objekt zu instanziieren, mit dem Sie alle Zufallszahlen in der Anwendung generieren. Dies ergibt eine etwas bessere Leistung, da die Instanziierung eines Zufallszahlengenerators recht teuer ist.  
  
   
  
## Examples  
 Im folgenden Beispiel werden <xref:System.Random>-Objekte mit dem-Klassenkonstruktor erstellt, der einen Seed-Parameter annimmt und eine Sequenz von zufälligen Ganzzahlen und Double-Werten generiert. Das Beispiel veranschaulicht, dass dieselbe Sequenz generiert wird, wenn das <xref:System.Random>-Objekt mit dem Konstruktor und dem Seed-Parameter erneut erstellt wird.  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Next">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine Zufallsganzzahl zurück.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next();" />
      <MemberSignature Language="F#" Value="abstract member Next : unit -&gt; int&#xA;override this.Next : unit -&gt; int" Usage="random.Next " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine nicht negative Zufallsganzzahl zurück.</summary>
        <returns>Eine ganze 32-Bit-Zahl mit Vorzeichen, die größer oder gleich 0 (null) und kleiner als <see cref="F:System.Int32.MaxValue" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%2A?displayProperty=nameWithType> generiert eine Zufallszahl, deren Wert zwischen 0 und kleiner als <xref:System.Int32.MaxValue?displayProperty=nameWithType>liegt. Verwenden Sie die <xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType>-Methoden Überladung, um eine Zufallszahl zu generieren, deren Wert zwischen 0 und einer anderen positiven Zahl liegt. Um eine Zufallszahl in einem anderen Bereich zu generieren, verwenden Sie die <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType>-Methoden Überladung.  
  
   
  
## Examples  
 Im folgenden Beispiel werden wiederholte Aufrufe der <xref:System.Random.Next%2A>-Methode durchführen, um eine bestimmte Anzahl von Zufallszahlen zu generieren, die vom Benutzer angefordert werden. Die <xref:System.Console.ReadLine%2A?displayProperty=nameWithType>-Methode wird zum erhalten von Kundeneingaben verwendet.  
  
 [!code-cpp[System.Random.Next#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next3.cpp#5)]
 [!code-csharp[System.Random.Next#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next3.cs#5)]
 [!code-vb[System.Random.Next#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next3.vb#5)]  
  
 Im folgenden Beispiel wird eine Klasse von <xref:System.Random> abgeleitet, um eine Sequenz von Zufallszahlen zu generieren, deren Verteilung von der durch die <xref:System.Random.Sample%2A>-Methode der Basisklasse generierten Verteilung abweicht. Er überschreibt die <xref:System.Random.Sample%2A>-Methode, um die Verteilung von Zufallszahlen bereitzustellen, und überschreibt die <xref:System.Random.Next%2A?displayProperty=nameWithType>-Methode, um eine Reihe von Zufallszahlen zu verwenden.  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Beginnend mit der .NET Framework Version 2,0, wenn Sie eine Klasse von <see cref="T:System.Random" /> ableiten und die <see cref="M:System.Random.Sample" />-Methode überschreiben, wird die Distribution, die von der Implementierung der abgeleiteten Klasse der <see cref="M:System.Random.Sample" />-Methode bereitgestellt wird, nicht in Aufrufen der Basisklassen Implementierung der <see cref="M:System.Random.Next" />-Methode verwendet. Stattdessen wird die von der Basis <see cref="T:System.Random" />-Klasse zurückgegebene einheitliche Verteilung verwendet. Dieses Verhalten verbessert die Gesamtleistung der <see cref="T:System.Random" />-Klasse. Wenn Sie dieses Verhalten ändern möchten, um die <see cref="M:System.Random.Sample" />-Methode in der abgeleiteten Klasse aufzurufen, müssen Sie auch die <see cref="M:System.Random.Next" />-Methode überschreiben.</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int -&gt; int&#xA;override this.Next : int -&gt; int" Usage="random.Next maxValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxValue">Die exklusive obere Grenze der Zufallszahl, die generiert werden soll. <paramref name="maxValue" /> muss größer oder gleich 0 sein.</param>
        <summary>Gibt eine nicht negative Zufallsganzzahl zurück, die kleiner als das angegebene Maximum ist.</summary>
        <returns>Eine ganze 32-Bit-Zahl mit Vorzeichen, die größer oder gleich 0 (null) und kleiner als <paramref name="maxValue" /> ist, d.h., der Bereich der Rückgabewerte umfasst in der Regel 0 (null), aber nicht <paramref name="maxValue" />. Wenn jedoch <paramref name="maxValue" /> 0 (null) entspricht, wird <paramref name="maxValue" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Random.Next%28System.Int32%29> Überladung gibt ganzzahlige ganzzahlige Werte zurück, die zwischen 0 und `maxValue`-1 liegen. Wenn `maxValue` jedoch 0 ist, gibt die Methode 0 zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel werden ganzzahlige Ganzzahlen mit verschiedenen über Ladungen der <xref:System.Random.Next%2A>-Methode generiert.  

 [!code-cpp[System.Random.Next#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next.cpp#1)]
 [!code-csharp-interactive[System.Random.Next#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next.cs#1)]
 [!code-vb[System.Random.Next#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next.vb#1)]  
  
 Im folgenden Beispiel wird eine zufällige ganze Zahl generiert, die als Index zum Abrufen eines Zeichen folgen Werts aus einem Array verwendet wird. Da der höchste Index des Arrays kleiner als seine Länge ist, wird der Wert der <xref:System.Array.Length%2A?displayProperty=nameWithType>-Eigenschaft als `maxValue` Parameter bereitgestellt.  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp-interactive[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxValue" /> ist kleiner als 0.</exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int minValue, int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 minValue, int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (minValue As Integer, maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int minValue, int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int * int -&gt; int&#xA;override this.Next : int * int -&gt; int" Usage="random.Next (minValue, maxValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minValue" Type="System.Int32" />
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minValue">Die inklusive untere Grenze der zurückgegebenen Zufallszahl.</param>
        <param name="maxValue">Die exklusive obere Grenze der zurückgegebenen Zufallszahl. <paramref name="maxValue" /> muss größer oder gleich <paramref name="minValue" /> sein.</param>
        <summary>Gibt eine Zufallsganzzahl zurück, die in einem angegebenen Bereich liegt.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die größer oder gleich <paramref name="minValue" /> und kleiner als <paramref name="maxValue" /> ist, d. h., der Bereich der Rückgabewerte umfasst <paramref name="minValue" />, aber nicht <paramref name="maxValue" />. Wenn <paramref name="minValue" /> gleich <paramref name="maxValue" /> ist, wird <paramref name="minValue" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> Überladung gibt ganzzahlige ganzzahlige Werte zurück, die von `minValue` bis `maxValue`-1 reichen. Wenn `maxValue` jedoch `minValue`ist, gibt die Methode `minValue`zurück.  
  
 Im Gegensatz zu den anderen über Ladungen der <xref:System.Random.Next%2A>-Methode, die nur nicht negative Werte zurückgeben, kann diese Methode eine negative Zufalls Ganzzahl zurückgeben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType>-Methode verwendet, um zufällige ganze Zahlen mit drei unterschiedlichen Bereichen zu generieren. Beachten Sie, dass die genaue Ausgabe aus dem Beispiel vom vom System bereitgestellten Ausgangswert abhängig ist, der an den <xref:System.Random>-Klassenkonstruktor übergeben wird.  
  
 [!code-cpp[System.Random.Next#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next2.cpp#2)]
 [!code-csharp-interactive[System.Random.Next#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/Next2.cs#2)]
 [!code-vb[System.Random.Next#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next2.vb#2)]  
  
 Im folgenden Beispiel wird eine zufällige ganze Zahl generiert, die als Index zum Abrufen eines Zeichen folgen Werts aus einem Array verwendet wird. Da der höchste Index des Arrays kleiner als seine Länge ist, wird der Wert der <xref:System.Array.Length%2A?displayProperty=nameWithType>-Eigenschaft als `maxValue` Parameter bereitgestellt.  
  
 [!code-cpp[System.Random.Next#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next4.cpp#4)]
 [!code-csharp-interactive[System.Random.Next#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next4.cs#4)]
 [!code-vb[System.Random.Next#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="minValue" /> ist größer als <paramref name="maxValue" />.</exception>
        <block subset="none" type="overrides"><para>Beginnend mit der .NET Framework Version 2,0, wenn Sie eine Klasse von <see cref="T:System.Random" /> ableiten und die <see cref="M:System.Random.Sample" />-Methode überschreiben, wird die Distribution, die von der Implementierung der abgeleiteten Klasse der <see cref="M:System.Random.Sample" />-Methode bereitgestellt wird, nicht in Aufrufen der Basisklassen Implementierung der <see cref="M:System.Random.Next(System.Int32,System.Int32)" />-Methoden Überladung verwendet, wenn der Unterschied zwischen den <paramref name="minValue" />-und <paramref name="maxValue" />-Parametern größer als <see cref="F:System.Int32.MaxValue" />ist. Stattdessen wird die von der Basis <see cref="T:System.Random" />-Klasse zurückgegebene einheitliche Verteilung verwendet. Dieses Verhalten verbessert die Gesamtleistung der <see cref="T:System.Random" />-Klasse. Wenn Sie dieses Verhalten ändern möchten, um die <see cref="M:System.Random.Sample" />-Methode in der abgeleiteten Klasse aufzurufen, müssen Sie auch die <see cref="M:System.Random.Next(System.Int32,System.Int32)" />-Methoden Überladung überschreiben.</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : byte[] -&gt; unit&#xA;override this.NextBytes : byte[] -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Das Array, das mit zufälligen Zahlen aufgefüllt wird.</param>
        <summary>Füllt die Elemente eines angegebenen Bytearrays mit Zufallszahlen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jedes Element des Bytearrays wird auf eine Zufallszahl größer oder gleich 0 (null) und kleiner oder gleich <xref:System.Byte.MaxValue>festgelegt.  
  
 Um beispielsweise eine kryptografisch gesicherte Zufallszahl zu generieren, die zum Erstellen eines zufälligen Kennworts geeignet ist, verwenden Sie eine Methode wie z. b. <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>.  
  
   
  
## Examples

 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Random.NextBytes%2A>-Methode verwendet wird, um ein Bytearray mit zufälligen Byte Werten zu füllen.  
 
 [!code-cpp[Classic Random.NextBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CPP/source.cpp#1)]
 [!code-csharp-interactive[Classic Random.NextBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CS/source.cs#1)]
 [!code-vb[Classic Random.NextBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" /></exception>
        <block subset="none" type="overrides"><para>Beginnend mit der .NET Framework Version 2,0, wenn Sie eine Klasse von <see cref="T:System.Random" /> ableiten und die <see cref="M:System.Random.Sample" />-Methode überschreiben, wird die Distribution, die von der Implementierung der abgeleiteten Klasse der <see cref="M:System.Random.Sample" />-Methode bereitgestellt wird, nicht in Aufrufen der Basisklassen Implementierung der <see cref="M:System.Random.NextBytes(System.Byte[])" />-Methode verwendet. Stattdessen wird die von der Basis <see cref="T:System.Random" />-Klasse zurückgegebene einheitliche Verteilung verwendet. Dieses Verhalten verbessert die Gesamtleistung der <see cref="T:System.Random" />-Klasse. Wenn Sie dieses Verhalten ändern möchten, um die <see cref="M:System.Random.Sample" />-Methode in der abgeleiteten Klasse aufzurufen, müssen Sie auch die <see cref="M:System.Random.NextBytes(System.Byte[])" />-Methode überschreiben.</para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Span(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : Span&lt;byte&gt; -&gt; unit&#xA;override this.NextBytes : Span&lt;byte&gt; -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Das Array, das mit zufälligen Zahlen aufgefüllt wird.</param>
        <summary>Füllt die Elemente einer festgelegten Bytespanne mit zufälligen Zahlen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Jedes Element der Byte Spanne wird auf eine Zufallszahl festgelegt, die größer oder gleich 0 und kleiner als oder gleich <xref:System.Byte.MaxValue>ist.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NextDouble">
      <MemberSignature Language="C#" Value="public virtual double NextDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 NextDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function NextDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double NextDouble();" />
      <MemberSignature Language="F#" Value="abstract member NextDouble : unit -&gt; double&#xA;override this.NextDouble : unit -&gt; double" Usage="random.NextDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine zufällige Gleitkommazahl zurück, die größer oder gleich 0,0 und kleiner als 1,0 ist.</summary>
        <returns>Eine Gleitkommazahl mit doppelter Genauigkeit, die größer oder gleich 0,0 und kleiner als 1,0 ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die tatsächliche obere Grenze der Zufallszahl, die von dieser Methode zurückgegeben wird, ist 0.99999999999999978.  
  
 Informationen zum Abrufen von zufälligen Gleit Komma Werten in einem anderen Bereich als 0,0 und 1,0 finden Sie im Abschnitt "Abrufen von Gleit Komma Werten in einem angegebenen Bereich" des Themas <xref:System.Random>-Klasse.  
  
 Bei dieser Methode handelt es sich um die öffentliche Version der geschützten Methode, <xref:System.Random.Sample%2A>.  
  
   
  
## Examples  

 Im folgenden Beispiel wird die <xref:System.Random.NextDouble%2A>-Methode verwendet, um Sequenzen zufälliger Double-Werte zu generieren.  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 Im folgenden Beispiel wird die <xref:System.Random.NextDouble%2A>-Methode aufgerufen, um 100 Zufallszahlen zu generieren und deren Häufigkeitsverteilung anzeigt.  
  
 [!code-csharp-interactive[System.Random.NextDouble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.random.nextdouble/cs/nextdouble1.cs#2)]
 [!code-vb[System.Random.NextDouble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.random.nextdouble/vb/nextdouble1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sample">
      <MemberSignature Language="C#" Value="protected virtual double Sample ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance float64 Sample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Sample" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Sample () As Double" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual double Sample();" />
      <MemberSignature Language="F#" Value="abstract member Sample : unit -&gt; double&#xA;override this.Sample : unit -&gt; double" Usage="random.Sample " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine zufällige Gleitkommazahl zwischen 0,0 und 1,0 zurück.</summary>
        <returns>Eine Gleitkommazahl mit doppelter Genauigkeit, die größer oder gleich 0,0 und kleiner als 1,0 ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Leiten Sie eine Klasse von der <xref:System.Random>-Klasse ab, und überschreiben Sie die <xref:System.Random.Sample%2A>-Methode, um eine andere Zufallsverteilung oder ein anderes Zufallszahlengenerator-Prinzip zu generieren.  
  
> [!IMPORTANT]
>  Die <xref:System.Random.Sample%2A>-Methode ist `protected`. Dies bedeutet, dass auf Sie nur innerhalb der <xref:System.Random>-Klasse und ihrer abgeleiteten Klassen zugegriffen werden kann. Um eine Zufallszahl zwischen 0 und 1 aus einer <xref:System.Random> Instanz zu generieren, rufen Sie die <xref:System.Random.NextDouble%2A>-Methode auf.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Klasse von <xref:System.Random> abgeleitet und die <xref:System.Random.Sample%2A>-Methode überschrieben, um eine Verteilung von Zufallszahlen zu generieren. Diese Verteilung unterscheidet sich von der durch die <xref:System.Random.Sample%2A>-Methode der Basisklasse generierten einheitlichen Verteilung.  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Beginnend mit der .NET Framework Version 2,0, wenn Sie eine Klasse von <see cref="T:System.Random" /> ableiten und die <see cref="M:System.Random.Sample" />-Methode überschreiben, wird die Distribution, die von der Implementierung der abgeleiteten Klasse der <see cref="M:System.Random.Sample" />-Methode bereitgestellt wird, nicht in Aufrufen der Basisklassen Implementierung der folgenden Methoden verwendet: 
–   Die <see cref="M:System.Random.NextBytes(System.Byte[])" />-Methode.  
  
–   Die <see cref="M:System.Random.Next" />-Methode.  
  
-Die <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> Methode, wenn (<paramref name="maxValue" /> - <paramref name="minValue" />) größer als <see cref="F:System.Int32.MaxValue" />ist.  
  
Stattdessen wird die von der Basis <see cref="T:System.Random" /> Klasse bereitgestellte einheitliche Verteilung verwendet. Dieses Verhalten verbessert die Gesamtleistung der <see cref="T:System.Random" />-Klasse. Wenn Sie dieses Verhalten ändern möchten, um die Implementierung der <see cref="M:System.Random.Sample" />-Methode in der abgeleiteten Klasse aufzurufen, müssen Sie auch das Verhalten dieser drei Member überschreiben. Dies wird im Beispiel veranschaulicht.</para></block>
        <altmember cref="M:System.Random.NextDouble" />
      </Docs>
    </Member>
  </Members>
</Type>
