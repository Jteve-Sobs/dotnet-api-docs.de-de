<Type Name="Single" FullName="System.Single">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7c8859b91c5be6bf1a9b1a373885b0b5dc22edd0" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86686740" /></Metadata><TypeSignature Language="C#" Value="public struct Single : IComparable, IComparable&lt;float&gt;, IConvertible, IEquatable&lt;float&gt;, IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit float32 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float32&gt;, class System.IConvertible, class System.IEquatable`1&lt;float32&gt;, class System.IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Single" />
  <TypeSignature Language="VB.NET" Value="Public Structure Single&#xA;Implements IComparable, IComparable(Of Single), IConvertible, IEquatable(Of Single), IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public value class Single : IComparable, IComparable&lt;float&gt;, IConvertible, IEquatable&lt;float&gt;, IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type single = struct&#xA;    interface IConvertible&#xA;    interface IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="C#" Value="public struct Single : IComparable, IConvertible, IFormattable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit float32 extends System.ValueType implements class System.IComparable, class System.IConvertible, class System.IFormattable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="VB.NET" Value="Public Structure Single&#xA;Implements IComparable, IConvertible, IFormattable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="C++ CLI" Value="public value class Single : IComparable, IConvertible, IFormattable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="F#" Value="type single = struct&#xA;    interface IFormattable&#xA;    interface IConvertible" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit float32 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float32&gt;, class System.IConvertible, class System.IEquatable`1&lt;float32&gt;, class System.IFormattable" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C#" Value="public struct Single : IComparable, IComparable&lt;float&gt;, IEquatable&lt;float&gt;, IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit float32 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float32&gt;, class System.IEquatable`1&lt;float32&gt;, class System.IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="VB.NET" Value="Public Structure Single&#xA;Implements IComparable, IComparable(Of Single), IEquatable(Of Single), IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="C++ CLI" Value="public value class Single : IComparable, IComparable&lt;float&gt;, IEquatable&lt;float&gt;, IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="F#" Value="type single = struct&#xA;    interface IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.IComparable&lt;System.Single&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.IEquatable&lt;System.Single&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1">
      <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Serializable]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Serializable&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine Gleitkommazahl mit einfacher Genauigkeit dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Single> Werttyp stellt eine 32-Bit-Zahl mit einfacher Genauigkeit dar, deren Werte zwischen negativer 3.402823 E38 und positiv 3.402823 E38 liegen, sowie positive oder negative Null, <xref:System.Single.PositiveInfinity> , <xref:System.Single.NegativeInfinity> und keine Zahl ( <xref:System.Single.NaN> ). Er soll Werte darstellen, die sehr groß sind (z. b. Entfernungen zwischen Planeten oder Galaxien) oder extrem klein sind (z. b. die molekulare Masse eines Stoffs in Kilo Meter) und häufig unpräzise sind (z. b. die Entfernung von der Erde zu einem anderen Sonnensystem). Der- <xref:System.Single> Typ entspricht dem IEC 60559:1989 (IEEE 754)-Standard für binäre Gleit Komma Arithmetik.  
  
 Dieses Thema enthält folgende Abschnitte:  
  
-   [Darstellung und Genauigkeit von Gleit Komma Werten](#Precision)  
  
-   [Testen auf Gleichheit](#Equality)  
  
-   [Gleit Komma Werte und-Ausnahmen](#Exceptions)  
  
-   [Typkonvertierung und einzelne Struktur](#Conversion)  
  
-   [Gleit Komma Funktionen](#Functionality)  
  
 <xref:System.Single?displayProperty=nameWithType> stellt Methoden bereit, um Instanzen dieses Typs zu vergleichen, den Wert einer-Instanz in seine Zeichen folgen Darstellung zu konvertieren und die Zeichen folgen Darstellung einer Zahl in eine Instanz dieses Typs zu konvertieren. Informationen dazu, wie Format Spezifikations Codes die Zeichen folgen Darstellung von Werttypen steuern, finden Sie unter [Formatieren von Typen](/dotnet/standard/base-types/formatting-types), [Standard mäßigen Zahlenformat](/dotnet/standard/base-types/standard-numeric-format-strings)Zeichenfolgen und [benutzerdefinierte Zahlenformat](/dotnet/standard/base-types/custom-numeric-format-strings)Zeichen  
  
<a name="Precision"></a>   
## <a name="floating-point-representation-and-precision"></a>Darstellung und Genauigkeit von Gleit Komma Werten  
 Der- <xref:System.Single> Datentyp speichert Gleit Komma Werte mit einfacher Genauigkeit in einem 32-Bit-Binärformat, wie in der folgenden Tabelle dargestellt:  
  
|Teil|Bits|  
|----------|----------|  
|Signifikanor oder Mantisse|0-22|  
|Exponent|23-30|  
|Vorzeichen (0 = positiv, 1 = negativ)|31|  
  
 Ebenso wie dezimale Bruchteile nicht exakt einige Bruchwerte darstellen können (z. b. 1/3 oder <xref:System.Math.PI?displayProperty=nameWithType> ), können binäre Bruchteile einige Bruchzahlen nicht darstellen. Beispielsweise wird 2/10, der genau durch einen Dezimal Bruch dargestellt wird, durch. 0011111001001100 als binärer Bruchteil dargestellt, wobei das Muster "1100" in unendlich wiederholt wird. In diesem Fall stellt der Gleit Komma Wert eine ungenaue Darstellung der Zahl dar, die er darstellt. Das Ausführen zusätzlicher mathematischer Operationen für den ursprünglichen Gleit Komma Wert erhöht häufig den Mangel an Genauigkeit. Wenn Sie z. b. die Ergebnisse der Multiplikation von 3 bis 10 und das Hinzufügen von 3 bis 3 9 mal vergleichen, sehen Sie, dass Addition das weniger genaue Ergebnis erzeugt, da es acht weitere Vorgänge als Multiplikation umfasst. Beachten Sie, dass dieser Unterschied nur offensichtlich ist, wenn Sie die beiden <xref:System.Single> Werte mit der [standardmäßigen numerischen Format Zeichenfolge](/dotnet/standard/base-types/standard-numeric-format-strings)"R" anzeigen, die ggf. alle 9 Ziffern der Genauigkeit anzeigt, die vom-Typ unterstützt werden <xref:System.Single> .  
  
 [!code-csharp[System.Single.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/representation1.cs#3)]
 [!code-vb[System.Single.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/representation1.vb#3)]  
  
 Da einige Zahlen nicht exakt als binäre Binär Werte dargestellt werden können, können Gleit Komma zahlen nur in Bezug auf reelle Zahlen stehen.  
  
 Alle Gleit Komma Zahlen verfügen über eine begrenzte Anzahl signifikanter Ziffern, die außerdem bestimmen, wie genau ein Gleit Komma Wert einer reellen Zahl entspricht. Ein <xref:System.Single> Wert verfügt über bis zu 7 Dezimalstellen, obwohl intern maximal 9 Ziffern aufbewahrt werden. Dies bedeutet, dass einige Gleit Komma Vorgänge möglicherweise nicht die Genauigkeit zum Ändern eines Gleit Komma Werts haben. Im folgenden Beispiel wird ein großer Gleit Komma Wert mit einfacher Genauigkeit definiert, und anschließend wird das Produkt von <xref:System.Single.Epsilon?displayProperty=nameWithType> und einem vierwertigen Wert hinzugefügt. Das Produkt ist jedoch zu klein, um den ursprünglichen Gleit Komma Wert zu ändern. Die am wenigsten bedeutende Ziffer ist Tausendstel, wohingegen die signifikanteste Ziffer im Produkt 10<sup>-30</sup>beträgt.  
  
 [!code-csharp[System.Single.Structure#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/representation2.cs#4)]
 [!code-vb[System.Single.Structure#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/representation2.vb#4)]  
  
 Die begrenzte Genauigkeit einer Gleit Komma Zahl hat mehrere folgen:  
  
-   Zwei Gleitkommazahlen, die für eine bestimmte Genauigkeit identisch zu sein scheinen, können sich als unterschiedlich erweisen, wenn sich die zwei letzten Ziffern unterscheiden. Im folgenden Beispiel wird eine Reihe von Zahlen addiert, und ihr Gesamtwert wird mit dem erwarteten Gesamtwert verglichen. Obwohl die beiden Werte gleich sind, `Equals` gibt ein aufrufungsmethode an, dass Sie nicht gleich sind.  
  
     [!code-csharp[System.Single.Structure#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist3.cs#6)]
     [!code-vb[System.Single.Structure#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/precisionlist3.vb#6)]  
  
     Wenn Sie die Format Elemente in der <xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%29?displayProperty=nameWithType> Anweisung von `{0}` und in `{1}` ändern `{0:R}` und `{1:R}` alle wichtigen Ziffern der beiden <xref:System.Single> Werte anzeigen, ist klar, dass die beiden Werte aufgrund eines Genauigkeits Verlusts bei den Additions Vorgängen ungleich sind. In diesem Fall kann das Problem gelöst werden, indem Sie die- <xref:System.Math.Round%28System.Double%2CSystem.Int32%29?displayProperty=nameWithType> Methode aufrufen, um die <xref:System.Single> Werte auf die gewünschte Genauigkeit zu runden, bevor Sie den Vergleich durchführen.  
  
-   Eine mathematische oder Vergleichsoperation, die eine Gleit Komma Zahl verwendet, ergibt möglicherweise nicht dasselbe Ergebnis, wenn eine Dezimalzahl verwendet wird, da die binäre Gleit Komma Zahl möglicherweise nicht mit der Dezimalzahl übereinstimmt. Im vorherigen Beispiel wurde dies veranschaulicht, indem das Ergebnis der Multiplikation von 3 bis 10 und das Hinzufügen von "3 bis 3 9" angezeigt wird.  
  
     Wenn die Genauigkeit in numerischen Vorgängen mit Bruch Werten wichtig ist, verwenden Sie den- <xref:System.Decimal> Typ anstelle des- <xref:System.Single> Typs. Wenn die Genauigkeit in numerischen Vorgängen mit ganzzahligen Werten außerhalb des Bereichs der <xref:System.Int64> <xref:System.UInt64> Typen oder wichtig ist, verwenden Sie den- <xref:System.Numerics.BigInteger> Typ.  
  
-   Ein Wert ist möglicherweise kein Roundtrip, wenn eine Gleit Komma Zahl beteiligt ist. Ein Wert wird als Roundtrip bezeichnet, wenn ein Vorgang eine ursprüngliche Gleit Komma Zahl in ein anderes Format konvertiert, ein umgekehrter Vorgang das konvertierte Formular wieder in eine Gleit Komma Zahl umwandelt und die abschließende Gleit Komma Zahl gleich der ursprünglichen Gleit Komma Zahl ist. Der Roundtrip kann fehlschlagen, weil mindestens eine signifikante Ziffer verloren geht oder bei einer Konvertierung geändert wird. Im folgenden Beispiel werden drei Werte in Zeichen folgen <xref:System.Single> konvertiert und in einer Datei gespeichert. Wie die Ausgabe zeigt, sind die wiederhergestellten Werte nicht gleich den ursprünglichen Werten, obwohl die Werte als identisch erscheinen.  
  
     [!code-csharp[System.Single.Structure#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist4a.cs#17)]
     [!code-vb[System.Single.Structure#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/PrecisionList4a.vb#17)]  
  
     In diesem Fall können die Werte erfolgreich mit der [standardmäßigen numerischen Format Zeichenfolge](/dotnet/standard/base-types/standard-numeric-format-strings) "G9" abgerundet werden, um die vollständige Genauigkeit der <xref:System.Single> Werte beizubehalten, wie im folgenden Beispiel gezeigt.  
  
     [!code-csharp[System.Single.Structure#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/PrecisionList5a.cs#18)]
     [!code-vb[System.Single.Structure#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/PrecisionList5a.vb#18)]  
  
-   <xref:System.Single> Werte haben weniger Genauigkeit als <xref:System.Double> Werte. Ein <xref:System.Single> Wert, der in eine scheinbar Äquivalente konvertiert wird, ist <xref:System.Double> <xref:System.Double> aufgrund von Genauigkeits unterschieden oft nicht gleich dem Wert. Im folgenden Beispiel wird das Ergebnis von identischen Divisions Vorgängen einem <xref:System.Double> Wert und einem-Wert zugewiesen <xref:System.Single> . Nachdem der <xref:System.Single> Wert in einen umgewandelt <xref:System.Double> wurde, zeigt ein Vergleich der beiden Werte, dass Sie ungleich sind.  
  
     [!code-csharp[System.Double.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Double.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist1.vb#5)]  
  
     Um dieses Problem zu vermeiden, verwenden Sie entweder den- <xref:System.Double> Datentyp anstelle des- <xref:System.Single> Datentyps, oder verwenden Sie die- <xref:System.Math.Round%2A> Methode, sodass beide Werte dieselbe Genauigkeit aufweisen.  
  
<a name="Equality"></a>   
## <a name="testing-for-equality"></a>Testen auf Gleichheit  
 Um als gleich betrachtet zu werden, <xref:System.Single> müssen zwei Werte identische Werte darstellen. Aufgrund von Unterschieden in der Genauigkeit zwischen Werten oder aufgrund eines Genauigkeits Verlusts durch einen oder beide Werte werden Gleit Komma Werte, die als identisch erwartet werden, häufig aufgrund von Unterschieden in ihren am wenigsten signifikanten Ziffern als ungleich dargestellt. Dies führt dazu, dass Aufrufe der- <xref:System.Single.Equals%2A> Methode bestimmen, ob zwei Werte gleich sind, oder Aufrufe an die- <xref:System.Single.CompareTo%2A> Methode, um die Beziehung zwischen zwei Werten zu bestimmen <xref:System.Single> , was häufig zu unerwarteten Ergebnissen führt. Dies ist im folgenden Beispiel ersichtlich, in dem zwei scheinbar gleichwertige Werte sich als <xref:System.Single> ungleich erweisen, da der erste Wert 7 Ziffern der Genauigkeit aufweist, während der zweite Wert 9 ist.  
  
 [!code-csharp[System.Single.Structure#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison1.cs#9)]
 [!code-vb[System.Single.Structure#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison1.vb#9)]  
  
 Berechnete Werte, die auf unterschiedliche Codepfade folgen und auf unterschiedliche Weise bearbeitet werden, werden oft als ungleich feststellen. Im folgenden Beispiel <xref:System.Single> ist ein Wert quadratisch, und dann wird die Quadratwurzel berechnet, um den ursprünglichen Wert wiederherzustellen. Eine zweite <xref:System.Single> wird mit 3,51 und quadriert, bevor die Quadratwurzel des Ergebnisses durch 3,51 geteilt wird, um den ursprünglichen Wert wiederherzustellen. Obwohl die beiden Werte als identisch angezeigt werden, <xref:System.Single.Equals%28System.Single%29> weist ein aufrufungsmethode darauf hin, dass Sie nicht gleich sind. Wenn Sie die Standardformat Zeichenfolge "G9" verwenden, um eine Ergebnis Zeichenfolge zurückzugeben, die alle signifikanten Ziffern jedes <xref:System.Single> Werts anzeigt, wird angezeigt, dass der zweite Wert .0000000000001 kleiner als der erste Wert ist.  
  
 [!code-csharp[System.Single.Structure#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison2.cs#10)]
 [!code-vb[System.Single.Structure#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison2.vb#10)]  
  
 In Fällen, in denen sich der Genauigkeits Verlust wahrscheinlich auf das Ergebnis eines Vergleichs auswirkt, können Sie die folgenden Techniken verwenden, anstatt die-Methode oder die-Methode aufrufen zu müssen <xref:System.Single.Equals%2A> <xref:System.Single.CompareTo%2A> :  
  
-   Wenden Sie die- <xref:System.Math.Round%2A?displayProperty=nameWithType> Methode an, um sicherzustellen, dass beide Werte dieselbe Genauigkeit aufweisen. Im folgenden Beispiel wird ein vorheriges Beispiel dahingehend geändert, dass diese Vorgehensweise verwendet wird, damit zwei Dezimalzahlen gleichwertig sind.  
  
     [!code-csharp[System.Single.Structure#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison3.cs#11)]
     [!code-vb[System.Single.Structure#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison3.vb#11)]  
  
     Beachten Sie, dass das Problem der Genauigkeit weiterhin für die Rundung von Mittelpunkt Werten gilt. Weitere Informationen finden Sie unter der Methode <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29?displayProperty=nameWithType>.  
  
-   Testen Sie anstelle von Gleichheit die ungefähre Gleichheit. Diese Technik erfordert, dass Sie einen absoluten Betrag definieren, um den sich die beiden Werte unterscheiden können, aber dennoch gleich sind, oder dass Sie einen relativen Betrag definieren, um den der kleinere Wert vom größeren Wert abweichen kann.  
  
    > [!WARNING]
    >  <xref:System.Single.Epsilon?displayProperty=nameWithType> wird manchmal als absolutes Maß der Entfernung zwischen zwei <xref:System.Single> Werten beim Testen auf Gleichheit verwendet.  Misst jedoch <xref:System.Single.Epsilon?displayProperty=nameWithType> den kleinsten möglichen Wert, der einem hinzugefügt oder von diesem subtrahiert werden kann, <xref:System.Single> dessen Wert 0 (null) ist. Bei den meisten positiven und negativen <xref:System.Single> Werten ist der Wert von <xref:System.Single.Epsilon?displayProperty=nameWithType> zu klein, um erkannt zu werden. Mit Ausnahme von Werten, die 0 (null) sind, empfiehlt es sich daher nicht, die Verwendung in Tests auf Gleichheit zu übernehmen.  
  
     Im folgenden Beispiel wird der letztere Ansatz verwendet, um eine-Methode zu definieren `IsApproximatelyEqual` , die den relativen Unterschied zwischen zwei Werten testet. Außerdem wird das Ergebnis von Aufrufen der `IsApproximatelyEqual` -Methode und der-Methode als gegenübersteht <xref:System.Single.Equals%28System.Single%29> .  
  
     [!code-csharp[System.Single.Structure#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison4.cs#12)]
     [!code-vb[System.Single.Structure#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison4.vb#12)]  
  
<a name="Exceptions"></a>   
## <a name="floating-point-values-and-exceptions"></a>Gleit Komma Werte und-Ausnahmen  
 Vorgänge mit Gleit Komma Werten lösen keine Ausnahmen aus, im Gegensatz zu Operationen mit ganzzahligen Typen, die Ausnahmen in Fällen von unzulässigen Vorgängen auslösen, z. b. Division durch 0 (null) oder Überlauf.  Stattdessen ist das Ergebnis einer Gleit Komma Operation in diesen Fällen 0 (null), positiv unendlich, minus unendlich oder keine Zahl (NaN):  
  
-   Wenn das Ergebnis einer Gleit Komma Operation für das Zielformat zu klein ist, ist das Ergebnis 0 (null). Dies kann vorkommen, wenn zwei sehr kleine Gleit Komma Zahlen multipliziert werden, wie im folgenden Beispiel gezeigt.  
  
     [!code-csharp[System.Single.Structure#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/exceptional1.cs#1)]
     [!code-vb[System.Single.Structure#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/exceptional1.vb#1)]  
  
-   Wenn die Größe des Ergebnisses einer Gleit Komma Operation den Bereich des Ziel Formats überschreitet, ist das Ergebnis des Vorgangs <xref:System.Single.PositiveInfinity> oder <xref:System.Single.NegativeInfinity> , je nach dem Vorzeichen des Ergebnisses. Das Ergebnis eines Vorgangs, der <xref:System.Single.MaxValue?displayProperty=nameWithType> überläuft, <xref:System.Single.PositiveInfinity> und das Ergebnis eines Vorgangs, der <xref:System.Single.MinValue?displayProperty=nameWithType> überläuft, ist <xref:System.Single.NegativeInfinity> , wie im folgenden Beispiel gezeigt.  
  
     [!code-csharp[System.Single.Structure#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/exceptional2.cs#2)]
     [!code-vb[System.Single.Structure#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/exceptional2.vb#2)]  
  
     <xref:System.Single.PositiveInfinity> Dies ergibt auch Ergebnisse aus einer Division durch 0 (null) mit einer positiven Dividende und <xref:System.Single.NegativeInfinity> Ergebnisse aus einer Division durch 0 (null) mit einer negativen Dividende.  
  
-   Wenn ein Gleit Komma Vorgang ungültig ist, ist das Ergebnis des Vorgangs <xref:System.Single.NaN> . <xref:System.Single.NaN>Die Ergebnisse der folgenden Vorgänge sind z. b.:  
  
    -   Division durch 0 (null) mit einer Dividende von NULL. Beachten Sie, dass andere Fälle der Division durch Null zu <xref:System.Single.PositiveInfinity> oder führen <xref:System.Single.NegativeInfinity> .  
  
    -   Eine beliebige Gleit Komma Operation mit ungültiger Eingabe. Wenn Sie z. b. versuchen, die Quadratwurzel eines negativen Werts zu finden, wird zurückgegeben <xref:System.Single.NaN> .  
  
    -   Jeder Vorgang mit einem Argument, dessen Wert ist <xref:System.Single.NaN?displayProperty=nameWithType> .  
  
<a name="Conversion"></a>   
## <a name="type-conversions-and-the-single-structure"></a>Typkonvertierungen und die einzelne Struktur  
 Die- <xref:System.Single> Struktur definiert keine expliziten oder impliziten Konvertierungs Operatoren; stattdessen werden Konvertierungen vom Compiler implementiert.  
  
 In der folgenden Tabelle werden die möglichen Konvertierungen eines Werts der anderen primitiven numerischen Typen in einen- <xref:System.Single> Wert aufgelistet. Außerdem wird angegeben, ob die Konvertierung erweitert oder einschränkend erfolgt und ob das resultierende- <xref:System.Single> Wert eine geringere Genauigkeit als der ursprüngliche Wert aufweisen kann.  
  
|Konvertierung von|Erweiterung/Einschränkung|Möglicher Genauigkeits Verlust|  
|---------------------|-------------------------|--------------------------------|  
|<xref:System.Byte>|Widening|Nein|  
|<xref:System.Decimal>|Widening<br /><br /> Beachten Sie, dass c# einen Cast Operator erfordert.|Ja. <xref:System.Decimal> unterstützt 29 Dezimalziffern der Genauigkeit. <xref:System.Single> unterstützt 9.|  
|<xref:System.Double>|Schmaler Werte außerhalb des gültigen Bereichs werden in oder konvertiert <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> .|Ja. <xref:System.Double> unterstützt 17 Dezimalstellen der Genauigkeit. <xref:System.Single> unterstützt 9.|  
|<xref:System.Int16>|Widening|Nein|  
|<xref:System.Int32>|Widening|Ja. <xref:System.Int32> unterstützt 10 Dezimalziffern der Genauigkeit. <xref:System.Single> unterstützt 9.|  
|<xref:System.Int64>|Widening|Ja. <xref:System.Int64> unterstützt 19 Dezimalstellen der Genauigkeit. <xref:System.Single> unterstützt 9.|  
|<xref:System.SByte>|Widening|Nein|  
|<xref:System.UInt16>|Widening|Nein|  
|<xref:System.UInt32>|Widening|Ja. <xref:System.UInt32> unterstützt 10 Dezimalziffern der Genauigkeit. <xref:System.Single> unterstützt 9.|  
|<xref:System.UInt64>|Widening|Ja. <xref:System.Int64> unterstützt 20 Dezimalziffern der Genauigkeit. <xref:System.Single> unterstützt 9.|  
  
 Im folgenden Beispiel wird der minimale oder maximale Wert anderer primitiver numerischer Typen in einen- <xref:System.Single> Wert konvertiert.  
  
 [!code-csharp[System.Single.Structure#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/convert1.cs#20)]
 [!code-vb[System.Single.Structure#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/convert1.vb#20)]  
  
 Außerdem werden die Werte, und in <xref:System.Double> <xref:System.Double.NaN?displayProperty=nameWithType> <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> <xref:System.Single.NaN?displayProperty=nameWithType> , <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> bzw. konvertiert.  
  
 Beachten Sie, dass die Konvertierung des Werts einiger numerischer Typen in einen- <xref:System.Single> Wert zu einem Genauigkeits Verlust führen kann. Wie das Beispiel veranschaulicht, ist ein Genauigkeits Verlust möglich, wenn die Werte,,, <xref:System.Decimal> <xref:System.Double> <xref:System.Int32> <xref:System.Int64> , <xref:System.UInt32> und <xref:System.UInt64> in- <xref:System.Single> Werte umgerechnet werden.  
  
 Die Konvertierung eines- <xref:System.Single> Werts in einen-Wert <xref:System.Double> ist eine erweiternde Konvertierung. Die Konvertierung kann zu einem Genauigkeits Verlust führen, wenn der <xref:System.Double> Typ keine genaue Darstellung für den <xref:System.Single> Wert hat.  
  
 Die Konvertierung eines- <xref:System.Single> Werts in einen Wert eines beliebigen primitiven numerischen Datentyps, der keine <xref:System.Double> ist, ist eine einschränkende Konvertierung und erfordert einen Cast Operator (in c#) oder eine Konvertierungsmethode (in Visual Basic). Werte, die sich außerhalb des Bereichs des Ziel Datentyps befinden, der durch die-Eigenschaft und die-Eigenschaft des Zieltyps definiert wird `MinValue` `MaxValue` , Verhalten sich wie in der folgenden Tabelle gezeigt.  
  
|Zieltyp|Ergebnis|  
|-----------------|------------|  
|Beliebige ganzzahlige Typen|Eine <xref:System.OverflowException> Ausnahme, wenn die Konvertierung in einem überprüften Kontext erfolgt.<br /><br /> Wenn die Konvertierung in einem nicht überprüften Kontext (der Standard in c#) erfolgt, wird der Konvertierungs Vorgang erfolgreich ausgeführt, der Wert wird jedoch überlaufen.|  
|<xref:System.Decimal>|Eine <xref:System.OverflowException> Ausnahme,|  
  
 Außerdem lösen, <xref:System.Single.NaN?displayProperty=nameWithType> <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> und <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> einen <xref:System.OverflowException> für Konvertierungen in ganze Zahlen in einem überprüften Kontext aus, diese Werte überschreiten jedoch bei der Konvertierung in ganze Zahlen in einem nicht überprüften Kontext einen Überlauf. Für Konvertierungen in lösen <xref:System.Decimal> Sie immer eine aus <xref:System.OverflowException> . Konvertierung in <xref:System.Double>, sie konvertieren in <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, und <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>bzw.  
  
 Beachten Sie, dass ein Genauigkeits Verlust möglicherweise durch das wandeln eines <xref:System.Single> Werts in einen anderen numerischen Typ verursacht wird. Wenn nicht ganzzahlige <xref:System.Single> Werte konvertiert werden, wie die Ausgabe des Beispiels zeigt, geht die Bruchteile Komponente verloren, wenn der <xref:System.Single> Wert entweder gerundet (wie in Visual Basic) oder abgeschnitten (wie in c#) ist. Bei Konvertierungen in- <xref:System.Decimal> Werte <xref:System.Single> hat der Wert möglicherweise keine genaue Darstellung im Ziel Datentyp.  
  
 Im folgenden Beispiel wird eine Anzahl von <xref:System.Single> Werten in mehrere andere numerische Typen konvertiert. Die Konvertierungen erfolgen in einem überprüften Kontext in Visual Basic (Standardeinstellung) und in c# (aufgrund des [geprüften](/dotnet/csharp/language-reference/keywords/checked) Schlüssel Worts). Die Ausgabe aus dem Beispiel zeigt das Ergebnis für Konvertierungen in einem überprüften, nicht überprüften Kontext. Sie können Konvertierungen in einem nicht überprüften Kontext in Visual Basic ausführen, indem Sie mit dem `/removeintchecks+` Compilerschalter kompilieren und in c#, indem Sie die-Anweisung auskommentieren `checked` .  
  
 [!code-csharp[System.Single.Structure#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/convert2.cs#21)]
 [!code-vb[System.Single.Structure#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/convert2.vb#21)]  
  
 Weitere Informationen zur Konvertierung numerischer Typen finden Sie unter [Typkonvertierung in den .NET Framework](/dotnet/standard/base-types/type-conversion) -und [Typkonvertierungs Tabellen](/dotnet/standard/base-types/conversion-tables).  
  
<a name="Functionality"></a>   
## <a name="floating-point-functionality"></a>Gleit Komma Funktionen  
 Die <xref:System.Single> Struktur und verwandte Typen stellen Methoden bereit, um die folgenden Vorgangs Kategorien auszuführen:  
  
-   **Vergleich von-Werten**. Sie können die- <xref:System.Single.Equals%2A> Methode aufzurufen, um zu bestimmen, ob zwei <xref:System.Single> Werte gleich sind, oder die- <xref:System.Single.CompareTo%2A> Methode, um die Beziehung zwischen zwei Werten zu bestimmen.  
  
     Die <xref:System.Single> Struktur unterstützt auch einen kompletten Satz von Vergleichs Operatoren. Beispielsweise können Sie auf Gleichheit oder Ungleichheit testen oder feststellen, ob ein Wert größer oder gleich einem anderen Wert ist. Wenn einer der Operanden ein ist <xref:System.Double> , wird der <xref:System.Single> Wert <xref:System.Double> vor der Durchführung des Vergleichs in eine konvertiert. Wenn einer der Operanden ein ganzzahliger Typ ist, wird er <xref:System.Single> vor dem Durchführen des Vergleichs in eine konvertiert. Obwohl es sich um erweiternde Konvertierungen handelt, kann dies zu einem Genauigkeits Verlust führen.  
  
    > [!WARNING]
    >  Aufgrund von Unterschieden in der Genauigkeit können sich zwei Werte, die als <xref:System.Single> gleich erwartet werden, möglicherweise als ungleich erweisen, was sich auf das Ergebnis des Vergleichs auswirkt. Weitere Informationen zum Vergleichen von zwei Werten finden Sie im Abschnitt [Tests für Gleichheit](#Equality) <xref:System.Single> .  
  
     Sie können auch die <xref:System.Single.IsNaN%2A> Methoden, <xref:System.Single.IsInfinity%2A> , <xref:System.Single.IsPositiveInfinity%2A> und <xref:System.Single.IsNegativeInfinity%2A> zum Testen auf diese speziellen Werte aufzurufen.  
  
-   **Mathematische Vorgänge**. Gängige arithmetische Operationen wie Addition, Subtraktion, Multiplikation und Division werden von sprach Compilern und Common Intermediate Language-Anweisungen (CIL) anstelle von <xref:System.Single> Methoden implementiert. Wenn der andere Operand in einer mathematischen Operation eine ist <xref:System.Double> , <xref:System.Single> wird der <xref:System.Double> vor dem Ausführen des Vorgangs in eine konvertiert, und das Ergebnis des Vorgangs ist ebenfalls ein- <xref:System.Double> Wert. Wenn der andere Operand ein ganzzahliger Typ ist, wird er <xref:System.Single> vor dem Ausführen des Vorgangs in eine konvertiert, und das Ergebnis des Vorgangs ist ebenfalls ein- <xref:System.Single> Wert.  
  
     Sie können andere mathematische Vorgänge durchführen, indem Sie `static` ( `Shared` in Visual Basic)-Methoden in der- <xref:System.Math?displayProperty=nameWithType> Klasse aufrufen. Dazu zählen zusätzliche Methoden, die häufig für Arithmetik verwendet werden (z. b. <xref:System.Math.Abs%2A?displayProperty=nameWithType> , <xref:System.Math.Sign%2A?displayProperty=nameWithType> und <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> ), Geometrie (z. b. <xref:System.Math.Cos%2A?displayProperty=nameWithType> und <xref:System.Math.Sin%2A?displayProperty=nameWithType> ) und ein Kalkül (z <xref:System.Math.Log%2A?displayProperty=nameWithType> . b.).  In allen Fällen wird der <xref:System.Single> Wert in eine konvertiert <xref:System.Double> .  
  
     Sie können auch die einzelnen Bits in einem <xref:System.Single> Wert bearbeiten. Die- <xref:System.BitConverter.GetBytes%28System.Single%29?displayProperty=nameWithType> Methode gibt das Bitmuster in einem Bytearray zurück.  Wenn <xref:System.BitConverter.ToInt32%2A?displayProperty=nameWithType> Sie dieses Bytearray an die-Methode übergeben, können Sie auch das <xref:System.Single> Bitmuster des Werts in einer 32-Bit-Ganzzahl beibehalten.  
  
-   **Rundung**. Die Rundung wird häufig als Technik zum Verringern der Auswirkung von Unterschieden zwischen Werten verwendet, die durch Probleme mit der Gleit Komma Darstellung und-Genauigkeit verursacht werden. Sie können einen Wert Runden, <xref:System.Single> indem Sie die- <xref:System.Math.Round%2A?displayProperty=nameWithType> Methode aufrufen. Beachten Sie jedoch, dass der- <xref:System.Single> Wert in ein-Wert konvertiert wird <xref:System.Double> , bevor die-Methode aufgerufen wird, und die Konvertierung kann zu einem Genauigkeits Verlust führen.  
  
-   **Formatierung**. Sie können einen <xref:System.Single> Wert in seine Zeichen folgen Darstellung konvertieren, indem Sie die- <xref:System.Single.ToString%2A> Methode aufrufen oder die Funktion für die [kombinierte Formatierung](/dotnet/standard/base-types/composite-formatting) verwenden. Informationen dazu, wie Format Zeichenfolgen die Zeichen folgen Darstellung von Gleit Komma Werten steuern, finden Sie in den Themen [Standard Format](/dotnet/standard/base-types/standard-numeric-format-strings) Zeichenfolgen für Zahlen und [benutzerdefinierte Zahlenformat](/dotnet/standard/base-types/custom-numeric-format-strings) Zeichenfolgen.  
  
-   Zeichen folgen werden **verarbeitet.** Sie können die Zeichen folgen Darstellung eines Gleit Komma Werts in einen-Wert konvertieren, <xref:System.Single> indem Sie die- <xref:System.Single.Parse%2A> Methode oder die-Methode aufrufen <xref:System.Single.TryParse%2A> . Wenn der Analyse Vorgang fehlschlägt, löst die <xref:System.Single.Parse%2A> Methode eine Ausnahme aus, während die <xref:System.Single.TryParse%2A> Methode zurückgibt `false` .  
  
-   **Typkonvertierung**. Die- <xref:System.Single> Struktur stellt eine explizite Schnittstellen Implementierung für die- <xref:System.IConvertible> Schnittstelle bereit, die die Konvertierung zwischen zwei Datentypen vom Typ Standard .NET Framework unterstützt. Sprach Compiler unterstützen auch die implizite Konvertierung von Werten für alle anderen numerischen Standardtypen, mit Ausnahme der Konvertierung von <xref:System.Double> in- <xref:System.Single> Werte. Die Konvertierung eines Werts eines beliebigen standardmäßigen numerischen Typs außer einem <xref:System.Double> in einen <xref:System.Single> ist eine erweiternde Konvertierung und erfordert nicht die Verwendung eines Umwandlungs Operators oder einer Konvertierungsmethode.  
  
     Die Konvertierung von ganzzahligen 32-Bit-und 64-Bit-Werten kann jedoch einen Genauigkeits Verlust beinhalten. In der folgenden Tabelle werden die Unterschiede in der Genauigkeit für 32-Bit-, 64-Bit-und- <xref:System.Double> Typen aufgelistet:  
  
    |type|Maximale Genauigkeit (in Dezimalziffern)|Interne Genauigkeit (in Dezimalziffern)|  
    |----------|---------------------------------------------|----------------------------------------------|  
    |<xref:System.Double>|15|17|  
    |<xref:System.Int32> und <xref:System.UInt32>|10|10|  
    |<xref:System.Int64> und <xref:System.UInt64>|19|19|  
    |<xref:System.Single>|7|9|  
  
     Das Problem der Genauigkeit wirkt sich am häufigsten <xref:System.Single> auf Werte aus, die in-Werte konvertiert werden <xref:System.Double> . Im folgenden Beispiel sind zwei Werte, die von identischen Divisions Vorgängen erzeugt werden, ungleich, da einer der-Werte ein Gleit Komma Wert mit einfacher Genauigkeit ist, der in eine konvertiert wird <xref:System.Double> .  
  
     [!code-csharp[System.Single.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Single.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/precisionlist1.vb#5)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Alle Member dieses Typs sind Thread sicher. Member, die scheinbar den Instanzzustand ändern, geben tatsächlich eine neue Instanz zurück, die mit dem neuen Wert initialisiert wurde. Wie bei jedem anderen Typ muss das Lesen und Schreiben in eine freigegebene Variable, die eine Instanz dieses Typs enthält, durch eine Sperre geschützt werden, um die Thread Sicherheit zu gewährleisten.</threadsafe>
    <altmember cref="T:System.Decimal" />
    <altmember cref="T:System.Double" />
  </Docs>
  <Members>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Vergleicht diese Instanz mit einem angegebenen Objekt oder mit einer anderen <see cref="T:System.Single" />-Instanz und gibt eine ganze Zahl zurück, die angibt, ob der Wert dieser Instanz kleiner oder größer als der Wert des angegebenen Objekts bzw. der anderen <see cref="T:System.Single" />-Instanz ist oder mit diesem übereinstimmt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="single.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value">Ein Vergleichsobjekt oder <see langword="null" />.</param>
        <summary>Vergleicht diese Instanz mit einem angegebenen Objekt und gibt eine ganze Zahl zurück, die angibt, ob der Wert dieser Instanz kleiner oder größer als der Wert des angegebenen Objekts ist oder mit diesem übereinstimmt.</summary>
        <returns>Eine Zahl mit Vorzeichen, die das Verhältnis zwischen dem Wert dieser Instanz und <paramref name="value" /> angibt.  
  
 <list type="table"><listheader><term> Rückgabewert 
 </term><description> BESCHREIBUNG 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description> Diese Instanz ist kleiner als <paramref name="value" /> , oder diese Instanz ist keine Zahl ( <see cref="F:System.Single.NaN" /> ), und <paramref name="value" /> ist eine Zahl.  
  
 </description></item><item><term> Zero 
 </term><description> Diese Instanz ist gleich <paramref name="value" /> , oder diese Instanz und der Wert sind keine Zahl ( <see cref="F:System.Single.NaN" /> ), <see cref="F:System.Single.PositiveInfinity" /> oder <see cref="F:System.Single.NegativeInfinity" /> .  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description> Diese Instanz ist größer als <paramref name="value" /> , oder diese Instanz ist eine Zahl, und <paramref name="value" /> ist keine Zahl ( <see cref="F:System.Single.NaN" /> ), oder <paramref name="value" /> ist <see langword="null" /> .</description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der- `value` Parameter muss `null` oder eine Instanz von sein <xref:System.Single> . andernfalls wird eine Ausnahme ausgelöst. Jede Instanz von gilt <xref:System.Single> unabhängig von ihrem Wert als größer als `null` .  
  
 Werte müssen identisch sein, damit Sie als gleich betrachtet werden. Insbesondere wenn Gleit Komma Werte von mehreren mathematischen Operationen abhängen, ist es üblich, dass Sie Genauigkeit verlieren und ihre Werte nahezu identisch sind, mit Ausnahme der am wenigsten signifikanten Ziffern. Aus diesem Grund erscheint der Rückgabewert der <xref:System.Single.CompareTo%2A> Methode möglicherweise manchmal überraschend. Beispielsweise sollte die Multiplikation mit einem bestimmten Wert, gefolgt von der Division durch denselben Wert, den ursprünglichen Wert (im folgenden Beispiel) ergeben, aber der berechnete Wert ist größer als der ursprüngliche Wert. Wenn alle signifikanten Ziffern der beiden Werte mithilfe der [standardmäßigen numerischen Format Zeichenfolge](/dotnet/standard/base-types/standard-numeric-format-strings) "R" angezeigt werden, wird angegeben, dass der berechnete Wert vom ursprünglichen Wert in den geringsten Ziffern abweicht. Informationen zur Behandlung solcher Vergleiche finden Sie im Abschnitt "Hinweise" der- <xref:System.Single.Equals%28System.Single%29> Methode.  
  
 [!code-csharp[System.Single.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.compareto/cs/compareto3.cs#2)]
 [!code-vb[System.Single.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.compareto/vb/compareto3.vb#2)]  
  
 Diese Methode wird zur Unterstützung der- <xref:System.IComparable> Schnittstelle implementiert. Beachten Sie, dass <xref:System.Single.NaN> die-Schnittstelle, obwohl nicht als gleichwertig angesehen wird <xref:System.Single.NaN> (selbst), <xref:System.IComparable> erfordert, dass 0 (null) `A.CompareTo(A)` zurückgibt.  
  
## <a name="precision-in-comparisons"></a>Genauigkeit in vergleichen  
 Die Genauigkeit von Gleit Komma Zahlen jenseits der dokumentierten Genauigkeit ist spezifisch für die Implementierung und die Version der .NET Framework. Folglich kann sich ein Vergleich zweier bestimmter Zahlen zwischen den Versionen der .NET Framework ändern, da sich die Genauigkeit der internen Darstellung der Zahlen ändern kann.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die- <xref:System.Single.CompareTo%2A> Methode veranschaulicht.  
  
 [!code-cpp[System.Single#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#16)]
 [!code-csharp[System.Single#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#16)]
 [!code-vb[System.Single#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> ist keine <see cref="T:System.Single" />.</exception>
        <altmember cref="M:System.Single.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.CompareTo(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Single) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(float value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : single -&gt; int&#xA;override this.CompareTo : single -&gt; int" Usage="single.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Eine Gleitkommazahl mit einfacher Genauigkeit, mit der der Vergleich erfolgen soll.</param>
        <summary>Vergleicht diese Instanz mit einer angegebenen Gleitkommazahl mit einfacher Genauigkeit und gibt eine ganze Zahl zurück, die angibt, ob der Wert dieser Instanz kleiner oder größer als der Wert der angegebenen Gleitkommazahl mit einfacher Genauigkeit ist oder mit dieser übereinstimmt.</summary>
        <returns>Eine Zahl mit Vorzeichen, die das Verhältnis zwischen dem Wert dieser Instanz und <paramref name="value" /> angibt.  
  
 <list type="table"><listheader><term> Rückgabewert 
 </term><description> BESCHREIBUNG 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description> Diese Instanz ist kleiner als <paramref name="value" /> , oder diese Instanz ist keine Zahl ( <see cref="F:System.Single.NaN" /> ), und <paramref name="value" /> ist eine Zahl.  
  
 </description></item><item><term> Zero 
 </term><description> Diese Instanz ist gleich <paramref name="value" /> , oder sowohl diese Instanz als auch <paramref name="value" /> sind keine Zahl ( <see cref="F:System.Single.NaN" /> ), <see cref="F:System.Single.PositiveInfinity" /> oder <see cref="F:System.Single.NegativeInfinity" /> .  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description> Diese Instanz ist größer als <paramref name="value" /> , oder diese Instanz ist eine Zahl, und <paramref name="value" /> ist keine Zahl ( <see cref="F:System.Single.NaN" /> ).  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Werte müssen identisch sein, damit Sie als gleich betrachtet werden. Es kommt häufig vor, dass Gleit Komma Werte Genauigkeit verlieren und nahezu identisch sind, mit Ausnahme der am wenigsten signifikanten Ziffern, insbesondere dann, wenn die Werte von mehreren mathematischen Operationen abhängen. Aus diesem Grund mag der Rückgabewert der <xref:System.Single.CompareTo%2A> Methode zu Zeiten überraschend erscheinen. Beispielsweise sollte durch Multiplikation durch einen beliebigen Wert, gefolgt von der Division durch denselben Wert, der ursprüngliche Wert erzeugt werden. Im folgenden Beispiel erweist sich der berechnete Wert jedoch als größer als der ursprüngliche Wert. Wenn alle signifikanten Ziffern der beiden Werte mithilfe der [standardmäßigen numerischen Format Zeichenfolge](/dotnet/standard/base-types/standard-numeric-format-strings) "R" angezeigt werden, wird angegeben, dass der berechnete Wert vom ursprünglichen Wert in den geringsten Ziffern abweicht. Informationen zur Behandlung solcher Vergleiche finden Sie im Abschnitt "Hinweise" der- <xref:System.Single.Equals%28System.Single%29> Methode.  
  
 [!code-csharp[System.Single.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.compareto/cs/compareto2.cs#1)]
 [!code-vb[System.Single.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.compareto/vb/compareto2.vb#1)]  
  
 Diese Methode implementiert die <xref:System.IComparable%601?displayProperty=nameWithType> -Schnittstelle und führt eine etwas bessere Leistung als die- <xref:System.Single.CompareTo%2A?displayProperty=nameWithType> Methode aus, da der-Parameter nicht in ein-Objekt konvertiert werden muss `value` .  
  
 Beachten Sie, dass ein Objekt, dessen Wert <xref:System.Single.NaN> nicht gleich einem anderen Objekt ist, dessen Wert ist <xref:System.Single.NaN> (selbst), erfordert, <xref:System.IComparable%601> dass die-Schnittstelle `A.CompareTo(A)` NULL zurückgibt.  
  
## <a name="widening-conversions"></a>Erweiterungskonvertierungen  
 Abhängig von ihrer Programmiersprache kann es möglich sein, eine Methode zu codieren, <xref:System.Single.CompareTo%2A> bei der der Parametertyp weniger Bits (ist schmaler) als der Instanztyp aufweist. Dies ist möglich, weil einige Programmiersprachen eine implizite erweiternde Konvertierung durchführen, die den Parameter als Typ mit so vielen Bits wie die Instanz darstellt.  
  
 Angenommen, der Instanztyp ist, <xref:System.Single> und der Parametertyp ist <xref:System.Int32> . Der Microsoft c#-Compiler generiert Anweisungen, um den Wert des-Parameters als <xref:System.Single> -Objekt darzustellen, und generiert dann eine-Methode, die <xref:System.Single.CompareTo%28System.Single%29?displayProperty=nameWithType> die Werte der-Instanz und die erweiterte Darstellung des-Parameters vergleicht.  
  
 Überprüfen Sie die Dokumentation der Programmiersprache, um zu bestimmen, ob der Compiler implizite erweiternde Konvertierungen numerischer Typen durchführt. Weitere Informationen finden Sie im Thema [Typkonvertierungs Tabellen](/dotnet/standard/base-types/conversion-tables) .  
  
## <a name="precision-in-comparisons"></a>Genauigkeit in vergleichen  
 Die Genauigkeit von Gleit Komma Zahlen jenseits der dokumentierten Genauigkeit ist spezifisch für die Implementierung und die Version der .NET Framework. Folglich kann sich ein Vergleich zweier bestimmter Zahlen zwischen den Versionen der .NET Framework ändern, da sich die Genauigkeit der internen Darstellung der Zahlen ändern kann.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden generische und nicht generische Versionen der- <xref:System.Single.CompareTo%2A> Methode für verschiedene Wert-und Verweis Typen veranschaulicht.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Epsilon">
      <MemberSignature Language="C#" Value="public const float Epsilon = 1.401298E-45;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 Epsilon = float32(1.401298E-45)" />
      <MemberSignature Language="DocId" Value="F:System.Single.Epsilon" />
      <MemberSignature Language="VB.NET" Value="Public Const Epsilon As Single  = 1.401298E-45" />
      <MemberSignature Language="C++ CLI" Value="public: float Epsilon = 1.401298E-45;" />
      <MemberSignature Language="F#" Value="val mutable Epsilon : single" Usage="System.single.Epsilon" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>1.401298E-45</MemberValue>
      <Docs>
        <summary>Stellt den kleinsten positiven <see cref="T:System.Single" />-Wert dar, der größer als 0 (null) ist. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert der- <xref:System.Single.Epsilon> Eigenschaft gibt den kleinsten positiven <xref:System.Single> Wert an, der bei numerischen Vorgängen oder Vergleichen von Bedeutung ist, wenn der Wert der- <xref:System.Single> Instanz 0 (null) ist. Der folgende Code zeigt z. b., dass NULL und <xref:System.Single.Epsilon> als ungleich Werte angesehen werden, wohingegen NULL und die Hälfte des Werts von <xref:System.Single.Epsilon> als gleich betrachtet werden.  
  
 [!code-csharp[System.Single.Epsilon#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/epsilon.cs#5)]
 [!code-vb[System.Single.Epsilon#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/epsilon.vb#5)]  
  
 Genauer gesehen besteht das Gleit Komma Format mit einfacher Genauigkeit aus einem Vorzeichen, einer 23-Bit-Mantisse oder einem signifikanten und einem 8-Bit-Exponenten. Wie das folgende Beispiel zeigt, hat null einen Exponenten von-126 und eine Mantisse von 0. <xref:System.Single.Epsilon> hat einen Exponenten von-126 und eine Mantisse von 1. Dies bedeutet, dass <xref:System.Single.Epsilon?displayProperty=nameWithType> der kleinste positive <xref:System.Single> Wert ist, der größer als 0 (null) ist und den kleinsten möglichen Wert und das kleinste mögliche Inkrement für einen darstellt, <xref:System.Single> dessen Exponent-126 ist.  
  
 [!code-csharp[System.Single.Epsilon#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/epsilon1.cs#6)]
 [!code-vb[System.Single.Epsilon#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/epsilon1.vb#6)]  
  
 Die- <xref:System.Single.Epsilon> Eigenschaft ist jedoch kein allgemeines Maß der Genauigkeit des- <xref:System.Single> Typs. Sie gilt nur für- <xref:System.Single> Instanzen, die den Wert 0 (null) aufweisen.  
  
> [!NOTE]
>  Der Wert der- <xref:System.Single.Epsilon> Eigenschaft entspricht nicht dem Computer Epsilon, der die obere Grenze des relativen Fehlers aufgrund der Rundung in der Gleit Komma Arithmetik darstellt.  
  
 Der Wert dieser Konstante ist 1.4 e-45.  
  
 Zwei scheinbar äquivalente Gleit Komma Zahlen können aufgrund von Unterschieden in den geringsten Ziffern nicht gleich sein. Beispielsweise vergleicht der c#-Ausdruck, `(float)1/3 == (float)0.33333` , nicht gleich, da der Divisions Vorgang auf der linken Seite eine maximale Genauigkeit aufweist, während die Konstante auf der rechten Seite nur für die angegebenen Ziffern präzise ist. Wenn Sie einen benutzerdefinierten Algorithmus erstellen, der bestimmt, ob zwei Gleit Komma Zahlen als gleich betrachtet werden können, müssen Sie einen Wert verwenden, der größer als die Konstante ist, <xref:System.Single.Epsilon> um die akzeptable absolute Differenz Spanne für die beiden Werte festzulegen, die als gleich betrachtet werden sollen. (In der Regel ist dieser Unterschieds Unterschied oft größer als <xref:System.Single.Epsilon> .)  
  
## <a name="platform-notes"></a>Hinweise zur Plattform  
 Auf ARM-Systemen ist der Wert der <xref:System.Single.Epsilon> Konstante zu klein, um erkannt zu werden, sodass er 0 (null) entspricht. Sie können stattdessen einen alternativen Epsilon-Wert definieren, der 1.175494351 e-38 gleich ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei Instanzen der <see cref="T:System.Single" />-Struktur denselben Wert darstellen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="single.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Ein Objekt, das mit dieser Instanz verglichen werden soll.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob diese Instanz gleich einem angegebenen Objekt ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="obj" /> eine Instanz von <see cref="T:System.Single" /> ist, deren Wert gleich dem Wert dieser Instanz ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Single.Equals%2A> Methode sollte mit Bedacht verwendet werden, da zwei scheinbar äquivalente Werte aufgrund der unterschiedlichen Genauigkeit der beiden Werte ungleich sein können. Im folgenden Beispiel wird berichtet, dass der <xref:System.Single> Wert. 3333 und der, der durch Division von <xref:System.Single> 1 durch 3 zurückgegeben wurde, ungleich sind.  
  
 [!code-csharp[System.Single.Epsilon#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#3)]
 [!code-vb[System.Single.Epsilon#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#3)]  
  
 Anstatt Vergleich, Gleichheit, eine empfohlene Verfahren besteht im Definieren einer zulässigen Rand Unterschied zwischen zwei Werten (z. B. 01 % einer der Werte). Wenn der absolute Wert des Unterschieds zwischen den beiden Werten kleiner oder gleich diesem Rand ist, ist der Unterschied wahrscheinlich auf Unterschiede bei der Genauigkeit zurückzuführen, und daher sind die Werte wahrscheinlich gleich. Im folgenden Beispiel wird dieses Verfahren zum Vergleichen von. 33333 und 1/3 verwendet, die zwei Werte, die <xref:System.Single> im vorherigen Codebeispiel als ungleich festgestellt wurden.  
  
 [!code-csharp[System.Single.Epsilon#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#4)]
 [!code-vb[System.Single.Epsilon#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#4)]  
  
 In diesem Fall sind die Werte gleich.  
  
> [!NOTE]
>  Da <xref:System.Single.Epsilon> den minimalen Ausdruck eines positiven Werts definiert, dessen Bereich nahe 0 (null) ist, muss der Rand der Differenz größer als sein <xref:System.Single.Epsilon> . In der Regel ist es oft größer als <xref:System.Single.Epsilon> .  
  
 Die Genauigkeit von Gleit Komma Zahlen jenseits der dokumentierten Genauigkeit ist spezifisch für die Implementierung und die Version der .NET Framework. Folglich kann sich ein Vergleich zweier bestimmter Zahlen zwischen den Versionen der .NET Framework ändern, da sich die Genauigkeit der internen Darstellung der Zahlen ändern kann.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die- <xref:System.Single.Equals%2A> Methode veranschaulicht.  
  
 [!code-cpp[System.Single#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#17)]
 [!code-csharp[System.Single#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#17)]
 [!code-vb[System.Single#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#17)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Die Auflösung der compilerüberladung kann einen offensichtlichen Unterschied im Verhalten der beiden <see cref="M:System.Single.Equals(System.Object)" /> Methoden Überladungen berücksichtigen. Wenn eine implizite Konvertierung zwischen dem <paramref name="obj" /> -Argument und einem <see cref="T:System.Single" /> -Argument definiert wird und das-Argument nicht als typisiert ist <see cref="T:System.Object" /> , können Compiler eine implizite Konvertierung durchführen und die-Methode aufzurufen <see cref="M:System.Single.Equals(System.Single)" /> . Andernfalls wird die- <see cref="M:System.Single.Equals(System.Object)" /> Methode aufgerufen, die immer zurückgibt, <see langword="false" /> Wenn das <paramref name="obj" /> Argument kein <see cref="T:System.Single" /> Wert ist. Das folgende Beispiel veranschaulicht den Unterschied im Verhalten zwischen den zwei Methoden Überladungen. Bei allen primitiven numerischen Typen mit Ausnahme von <see cref="T:System.Double" /> in Visual Basic und mit Ausnahme von <see cref="T:System.Decimal" /> und <see cref="T:System.Double" /> in c# gibt der erste Vergleich zurück, <see langword="true" /> da der Compiler automatisch eine erweiternde Konvertierung ausführt und die- <see cref="M:System.Single.Equals(System.Single)" /> Methode aufruft, während der zweite Vergleich zurückgibt, <see langword="false" /> da der Compiler die- <see cref="M:System.Single.Equals(System.Object)" /> Methode aufruft.  
  
[! Code-csharp[System. Single. ist # 2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsoverl.cs#2)] [! Code-vb[System. Single. ist # 2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsoverl.vb#2)]</para></block>
        <altmember cref="M:System.Single.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (float obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(float32 obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Equals(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (obj As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(float obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : single -&gt; bool" Usage="single.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">Ein Objekt, das mit dieser Instanz verglichen werden soll.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob diese Instanz und ein angegebenes <see cref="T:System.Single" />-Objekt den gleichen Wert darstellen.</summary>
        <returns><see langword="true" />, wenn <paramref name="obj" /> gleich dieser Instanz ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode implementiert die <xref:System.IEquatable%601?displayProperty=nameWithType> -Schnittstelle und führt etwas besser <xref:System.Single.Equals%2A> aus, als dass der-Parameter nicht `obj` in ein-Objekt konvertiert werden muss.  
  
## <a name="widening-conversions"></a>Erweiterungskonvertierungen  
 Abhängig von ihrer Programmiersprache kann es möglich sein, eine Methode zu codieren, <xref:System.Single.Equals%2A> bei der der Parametertyp weniger Bits (ist schmaler) als der Instanztyp aufweist. Dies ist möglich, weil einige Programmiersprachen eine implizite erweiternde Konvertierung durchführen, die den Parameter als Typ mit so vielen Bits wie die Instanz darstellt.  
  
 Angenommen, der Instanztyp ist, <xref:System.Single> und der Parametertyp ist <xref:System.Int32> . Der Microsoft c#-Compiler generiert Anweisungen, um den Wert des-Parameters als- <xref:System.Single> Objekt darzustellen, und generiert dann eine- <xref:System.Single.Equals%28System.Single%29?displayProperty=nameWithType> Methode, die die Werte der-Instanz und die erweiterte Darstellung des-Parameters vergleicht.  
  
 Überprüfen Sie die Dokumentation der Programmiersprache, um zu bestimmen, ob der Compiler implizite erweiternde Konvertierungen numerischer Typen durchführt. Weitere Informationen finden Sie im Thema [Typkonvertierungs Tabellen](/dotnet/standard/base-types/conversion-tables) .  
  
## <a name="precision-in-comparisons"></a>Genauigkeit in vergleichen  
 Die- <xref:System.Single.Equals%2A> Methode sollte mit Bedacht verwendet werden, da zwei scheinbar äquivalente Werte aufgrund der unterschiedlichen Genauigkeit der beiden Werte ungleich sein können. Im folgenden Beispiel wird berichtet, dass der <xref:System.Single> Wert. 3333 und der, der durch Division von <xref:System.Single> 1 durch 3 zurückgegeben wurde, ungleich sind.  
  
 [!code-csharp[System.Single.Epsilon#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#1)]
 [!code-vb[System.Single.Epsilon#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#1)]  
  
 Eine Vergleichsmethode, der vermeidet Probleme im Zusammenhang mit Vergleich für Gleichheit umfasst eine akzeptable Rand Unterschied zwischen zwei Werten definieren (z. B. 01 % einer der Werte). Wenn der absolute Wert des Unterschieds zwischen den beiden Werten kleiner oder gleich diesem Rand ist, ist der Unterschied wahrscheinlich ein Ergebnis der Genauigkeits Unterschiede, und die Werte sind daher wahrscheinlich gleich. Im folgenden Beispiel wird dieses Verfahren zum Vergleichen von. 33333 und 1/3 verwendet, bei denen es sich um die beiden Werte handelt, <xref:System.Single> die im vorherigen Codebeispiel als ungleich festgestellt wurden.  
  
 [!code-csharp[System.Single.Epsilon#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#2)]
 [!code-vb[System.Single.Epsilon#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#2)]  
  
 In diesem Fall sind die Werte gleich.  
  
> [!NOTE]
>  Da <xref:System.Single.Epsilon> den minimalen Ausdruck eines positiven Werts definiert, dessen Bereich nahe 0 (null) ist, muss der Rand der Differenz größer als sein <xref:System.Single.Epsilon> . In der Regel ist es oft größer als <xref:System.Single.Epsilon> . Aus diesem Grund wird empfohlen, <xref:System.Double.Epsilon> beim Vergleichen <xref:System.Double> von Werten auf Gleichheit nicht zu verwenden.  
  
 Ein zweites Verfahren, das die Probleme im Zusammenhang mit dem Vergleich auf Gleichheit vermeidet, besteht darin, den Unterschied zwischen zwei Gleit Komma Zahlen mit einem absoluten Wert zu vergleichen. Wenn die Differenz kleiner oder gleich dem absoluten Wert ist, sind die Zahlen gleich. Wenn Sie größer ist, sind die Zahlen nicht gleich. Eine Möglichkeit besteht darin, willkürlich einen absoluten Wert auszuwählen. Dies ist jedoch problematisch, da eine akzeptable Differenz Spanne von der Größe der <xref:System.Single> Werte abhängt. Eine zweite Möglichkeit nutzt eine Entwurfs Funktion des Gleit Komma Formats: der Unterschied zwischen den Mantisse-Komponenten in den ganzzahligen Darstellungen von zwei Gleit Komma Werten gibt die Anzahl möglicher Gleit Komma Werte an, die die beiden Werte trennen. Beispielsweise ist der Unterschied zwischen 0,0 und <xref:System.Single.Epsilon> 1, da <xref:System.Single.Epsilon> der kleinste darstellbare Wert ist, wenn Sie mit einem- <xref:System.Single> Wert gleich 0 (null) arbeiten. Im folgenden Beispiel wird diese Technik zum Vergleichen von. 33333 und 1/3 verwendet, bei denen es sich um die beiden Werte handelt, <xref:System.Double> die im vorherigen Codebeispiel mit der- <xref:System.Single.Equals%28System.Single%29> Methode ungleich gefunden wurden. Beachten Sie, dass im Beispiel die <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> -Methode und die- <xref:System.BitConverter.ToInt32%2A?displayProperty=nameWithType> Methode zum Konvertieren eines Gleit Komma Werts mit einfacher Genauigkeit in seine ganzzahlige Darstellung verwendet werden.  
  
 [!code-csharp[System.Single.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsabs1.cs#1)]
 [!code-vb[System.Single.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsabs1.vb#1)]  
  
 Die Genauigkeit von Gleit Komma Zahlen jenseits der dokumentierten Genauigkeit ist spezifisch für die Implementierung und die Version der .NET Framework. Folglich kann ein Vergleich zweier Zahlen abhängig von der Version des .NET Framework zu unterschiedlichen Ergebnissen führen, da sich die Genauigkeit der internen Darstellung der Zahlen ändern kann.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Die Auflösung der compilerüberladung kann einen offensichtlichen Unterschied im Verhalten der beiden <see cref="M:System.Single.Equals(System.Object)" /> Methoden Überladungen berücksichtigen. Wenn eine implizite Konvertierung zwischen dem <paramref name="obj" /> -Argument und einem <see cref="T:System.Single" /> -Argument definiert wird und das-Argument nicht als typisiert ist <see cref="T:System.Object" /> , können Compiler eine implizite Konvertierung durchführen und die-Methode aufzurufen <see cref="M:System.Single.Equals(System.Single)" /> . Andernfalls wird die- <see cref="M:System.Single.Equals(System.Object)" /> Methode aufgerufen, die immer zurückgibt, <see langword="false" /> Wenn das <paramref name="obj" /> Argument kein <see cref="T:System.Single" /> Wert ist. Das folgende Beispiel veranschaulicht den Unterschied im Verhalten zwischen den zwei Methoden Überladungen. Bei allen primitiven numerischen Typen mit Ausnahme von <see cref="T:System.Double" /> in Visual Basic und mit Ausnahme von <see cref="T:System.Decimal" /> und <see cref="T:System.Double" /> in c# gibt der erste Vergleich zurück, <see langword="true" /> da der Compiler automatisch eine erweiternde Konvertierung ausführt und die- <see cref="M:System.Single.Equals(System.Single)" /> Methode aufruft, während der zweite Vergleich zurückgibt, <see langword="false" /> da der Compiler die- <see cref="M:System.Single.Equals(System.Object)" /> Methode aufruft.  
  
[! Code-csharp[System. Single. ist # 2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsoverl.cs#2)] [! Code-vb[System. Single. ist # 2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsoverl.vb#2)]</para></block>
        <altmember cref="M:System.Single.Equals(System.Object)" />
        <altmember cref="Overload:System.Single.CompareTo" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="single.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hashcode für diese Instanz zurück.</summary>
        <returns>Ein 32-Bit-Hashcode als ganze Zahl mit Vorzeichen.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="single.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den <see cref="T:System.TypeCode" /> für den Werttyp <see cref="T:System.Single" /> zurück.</summary>
        <returns>Die Enumerationskonstante <see cref="F:System.TypeCode.Single" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.TypeCode" />
      </Docs>
    </Member>
    <Member MemberName="IsFinite">
      <MemberSignature Language="C#" Value="public static bool IsFinite (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsFinite(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsFinite(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFinite (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFinite(float f);" />
      <MemberSignature Language="F#" Value="static member IsFinite : single -&gt; bool" Usage="System.single.IsFinite f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="f">Eine Gleitkommazahl mit einfacher Genauigkeit.</param>
        <summary>Bestimmt, ob der angegebene Wert endlich ist (Null, subnormal oder normal).</summary>
        <returns><see langword="true" />, wenn der angegebene Wert endlich ist (Null, subnormal oder normal); sonst <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInfinity(float f);" />
      <MemberSignature Language="F#" Value="static member IsInfinity : single -&gt; bool" Usage="System.single.IsInfinity f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Eine Gleitkommazahl mit einfacher Genauigkeit.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob der Wert der angegebenen Zahl -unendlich oder +unendlich ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="f" /> entweder <see cref="F:System.Single.PositiveInfinity" /> oder <see cref="F:System.Single.NegativeInfinity" /> ergibt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gleit Komma Operationen geben <xref:System.Single.PositiveInfinity> oder zurück <xref:System.Single.NegativeInfinity> , um eine Überlauf Bedingung zu signalisieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die- <xref:System.Single.IsInfinity%2A> Methode veranschaulicht.  
  
 [!code-cpp[System.Single#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#11)]
 [!code-csharp[System.Single#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#11)]
 [!code-vb[System.Single#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNaN(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNaN (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNaN(float f);" />
      <MemberSignature Language="F#" Value="static member IsNaN : single -&gt; bool" Usage="System.single.IsNaN f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Eine Gleitkommazahl mit einfacher Genauigkeit.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob der angegebene Wert keine Zahl ist (<see cref="F:System.Single.NaN" />).</summary>
        <returns><see langword="true" />, wenn <paramref name="f" /> Not-a-Number (<see cref="F:System.Single.NaN" />) ergibt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gleit Komma Vorgänge geben zurück, <xref:System.Single.NaN> um zu signalisieren, dass das Ergebnis des Vorgangs nicht definiert ist. Beispielsweise führt die Division von 0,0 durch 0,0 zu <xref:System.Single.NaN> .  
  
> [!NOTE]
>  <xref:System.Single.IsNaN%2A> Gibt zurück, `false` Wenn ein <xref:System.Single> Wert entweder <xref:System.Single.PositiveInfinity> oder ist <xref:System.Single.NegativeInfinity> . Um diese Werte zu testen, verwenden Sie <xref:System.Single.IsInfinity%2A> die <xref:System.Single.IsPositiveInfinity%2A> Methoden, und <xref:System.Single.IsNegativeInfinity%2A> .  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die- <xref:System.Single.IsNaN%2A> Methode veranschaulicht.  
  
 [!code-cpp[System.Single#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#8)]
 [!code-csharp[System.Single#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#8)]
 [!code-vb[System.Single#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.NaN" />
      </Docs>
    </Member>
    <Member MemberName="IsNegative">
      <MemberSignature Language="C#" Value="public static bool IsNegative (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegative(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNegative(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegative (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegative(float f);" />
      <MemberSignature Language="F#" Value="static member IsNegative : single -&gt; bool" Usage="System.single.IsNegative f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="f">Eine Gleitkommazahl mit einfacher Genauigkeit.</param>
        <summary>Bestimmt, ob der angegebene Wert negativ ist.</summary>
        <returns><see langword="true" />, falls negativ; sonst <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegativeInfinity">
      <MemberSignature Language="C#" Value="public static bool IsNegativeInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegativeInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNegativeInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegativeInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegativeInfinity(float f);" />
      <MemberSignature Language="F#" Value="static member IsNegativeInfinity : single -&gt; bool" Usage="System.single.IsNegativeInfinity f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Eine Gleitkommazahl mit einfacher Genauigkeit.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die angegebene Zahl minus unendlich ergibt.</summary>
        <returns><see langword="true" />, wenn <paramref name="f" /><see cref="F:System.Single.NegativeInfinity" /> ergibt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gleit Komma Vorgänge geben zurück <xref:System.Single.NegativeInfinity> , um eine Überlauf Bedingung zu signalisieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die- <xref:System.Single.IsNegativeInfinity%2A> Methode veranschaulicht.  
  
 [!code-cpp[System.Single#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#13)]
 [!code-csharp[System.Single#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#13)]
 [!code-vb[System.Single#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNormal">
      <MemberSignature Language="C#" Value="public static bool IsNormal (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNormal(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNormal(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNormal (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNormal(float f);" />
      <MemberSignature Language="F#" Value="static member IsNormal : single -&gt; bool" Usage="System.single.IsNormal f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="f">Eine Gleitkommazahl mit einfacher Genauigkeit.</param>
        <summary>Bestimmt, ob der angegebene Wert normal ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="f" /> normal ist; sonst <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPositiveInfinity">
      <MemberSignature Language="C#" Value="public static bool IsPositiveInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositiveInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsPositiveInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPositiveInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPositiveInfinity(float f);" />
      <MemberSignature Language="F#" Value="static member IsPositiveInfinity : single -&gt; bool" Usage="System.single.IsPositiveInfinity f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Eine Gleitkommazahl mit einfacher Genauigkeit.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die angegebene Zahl plus unendlich ergibt.</summary>
        <returns><see langword="true" />, wenn <paramref name="f" /><see cref="F:System.Single.PositiveInfinity" /> ergibt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gleit Komma Vorgänge geben zurück <xref:System.Single.PositiveInfinity> , um eine Überlauf Bedingung zu signalisieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die- <xref:System.Single.IsPositiveInfinity%2A> Methode veranschaulicht.  
  
 [!code-cpp[System.Single#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#12)]
 [!code-csharp[System.Single#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#12)]
 [!code-vb[System.Single#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsSubnormal">
      <MemberSignature Language="C#" Value="public static bool IsSubnormal (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSubnormal(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsSubnormal(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSubnormal (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSubnormal(float f);" />
      <MemberSignature Language="F#" Value="static member IsSubnormal : single -&gt; bool" Usage="System.single.IsSubnormal f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="f">Eine Gleitkommazahl mit einfacher Genauigkeit.</param>
        <summary>Bestimmt, ob der angegebene Wert subnormal ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="f" /> subnormal ist; sonst <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const float MaxValue = 3.40282347E+38;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 MaxValue = float32(3.40282347E+38)" />
      <MemberSignature Language="DocId" Value="F:System.Single.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxValue As Single  = 3.40282347E+38" />
      <MemberSignature Language="C++ CLI" Value="public: float MaxValue = 3.40282347E+38;" />
      <MemberSignature Language="F#" Value="val mutable MaxValue : single" Usage="System.single.MaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>3.40282347E+38</MemberValue>
      <Docs>
        <summary>Stellt den größtmöglichen Wert von <see cref="T:System.Single" /> dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Konstante ist positiv 3.40282347 e + 38.  
  
 Das Ergebnis eines Vorgangs, der überschreitet, <xref:System.Single.MaxValue?displayProperty=nameWithType> ist <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> . Im folgenden Beispiel werden <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> Ergebnisse aus Additions-, Multiplikations-und exponentiations Vorgängen ausgegeben, wenn das Ergebnis überschreitet <xref:System.Single.MaxValue?displayProperty=nameWithType> .  
  
 [!code-csharp[System.Single.MaxValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.maxvalue/cs/maxvalueex.cs#1)]
 [!code-vb[System.Single.MaxValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.maxvalue/vb/maxvalueex.vb#1)]  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die- <xref:System.Single.MaxValue> Konstante veranschaulicht.  
  
 [!code-cpp[System.Single#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#4)]
 [!code-csharp[System.Single#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#4)]
 [!code-vb[System.Single#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.MinValue" />
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const float MinValue = -3.40282347E+38;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 MinValue = float32(-3.40282347E+38)" />
      <MemberSignature Language="DocId" Value="F:System.Single.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MinValue As Single  = -3.40282347E+38" />
      <MemberSignature Language="C++ CLI" Value="public: float MinValue = -3.40282347E+38;" />
      <MemberSignature Language="F#" Value="val mutable MinValue : single" Usage="System.single.MinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>-3.40282347E+38</MemberValue>
      <Docs>
        <summary>Stellt den kleinstmöglichen Wert von <see cref="T:System.Single" /> dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Konstante ist "negative 3.402823 E38".  
  
 Das Ergebnis eines Vorgangs, der kleiner als <xref:System.Single.MinValue?displayProperty=nameWithType> ist <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> . Im folgenden Beispiel werden <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> Ergebnisse aus Subtraktions-und Multiplikations Vorgängen ausgegeben, wenn das Ergebnis kleiner als ist <xref:System.Single.MinValue?displayProperty=nameWithType> .  
  
 [!code-csharp[System.Single.MinValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.minvalue/cs/minvalueex.cs#1)]
 [!code-vb[System.Single.MinValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.minvalue/vb/minvalueex.vb#1)]  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die- <xref:System.Single.MinValue> Konstante veranschaulicht.  
  
 [!code-cpp[System.Single#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#5)]
 [!code-csharp[System.Single#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#5)]
 [!code-vb[System.Single#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.MaxValue" />
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public const float NaN = NaN;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 NaN = float32(NaN)" />
      <MemberSignature Language="DocId" Value="F:System.Single.NaN" />
      <MemberSignature Language="VB.NET" Value="Public Const NaN As Single  = NaN" />
      <MemberSignature Language="C++ CLI" Value="public: float NaN = NaN;" />
      <MemberSignature Language="F#" Value="val mutable NaN : single" Usage="System.single.NaN" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>NaN</MemberValue>
      <Docs>
        <summary>Stellt Not-a-Number (<see langword="NaN" />) dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Methode oder ein Operator gibt zurück, <xref:System.Single.NaN> Wenn das Ergebnis eines Vorgangs nicht definiert ist. Das Ergebnis der Division von NULL durch Null ist beispielsweise <xref:System.Single.NaN> , wie im folgenden Beispiel gezeigt. (Beachten Sie jedoch, dass die Aufteilung einer Zahl ungleich NULL durch Null entweder oder zurückgibt <xref:System.Single.PositiveInfinity> <xref:System.Single.NegativeInfinity> , abhängig vom Vorzeichen des Divisors.)  
  
 [!code-csharp[System.Single.NaN#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/nan1.cs#1)]
 [!code-vb[System.Single.NaN#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/nan1.vb#1)]  
  
 Außerdem gibt ein Methodenaufrufe mit einem <xref:System.Single.NaN> Wert oder einem Vorgang für einen <xref:System.Single.NaN> Wert zurück <xref:System.Single.NaN> , wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Single.NaN#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/nan1.cs#2)]
 [!code-vb[System.Single.NaN#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/nan1.vb#2)]  
  
 Verwenden Sie die- <xref:System.Single.IsNaN%2A> Methode, um zu bestimmen, ob ein Wert keine Zahl ist. Im Allgemeinen können <xref:System.Single> Operatoren nicht zum Vergleichen <xref:System.Single.NaN?displayProperty=nameWithType> mit anderen Werten verwendet werden <xref:System.Single> , obwohl Vergleichsmethoden (z <xref:System.Single.Equals%2A> . b. und <xref:System.Single.CompareTo%2A> ) möglich sind. Das folgende Beispiel veranschaulicht den Unterschied im Verhalten zwischen <xref:System.Single> Vergleichs Operatoren und Methoden.  
  
 [!code-csharp[System.Single.NaN#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/single.nan4.cs#4)]
 [!code-vb[System.Single.NaN#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/single.nan4.vb#4)]  
  
   
  
## Examples  
 Im folgenden Beispiel wird die- <xref:System.Single.NaN> Konstante veranschaulicht.  
  
 [!code-cpp[System.Single#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#7)]
 [!code-csharp[System.Single#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#7)]
 [!code-vb[System.Single#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsNaN(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="NegativeInfinity">
      <MemberSignature Language="C#" Value="public const float NegativeInfinity = -Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 NegativeInfinity = float32(-Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Single.NegativeInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const NegativeInfinity As Single  = -Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: float NegativeInfinity = -Infinity;" />
      <MemberSignature Language="F#" Value="val mutable NegativeInfinity : single" Usage="System.single.NegativeInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>-Infinity</MemberValue>
      <Docs>
        <summary>Stellt minus unendlich dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Konstante ist das Ergebnis der Division einer negativen Zahl durch 0 (null).  
  
 Diese Konstante wird zurückgegeben, wenn das Ergebnis eines Vorgangs kleiner als ist <xref:System.Single.MinValue> .  
  
 Verwenden <xref:System.Single.IsNegativeInfinity%2A> Sie, um zu bestimmen, ob ein Wert minus unendlich ergibt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die- <xref:System.Single.NegativeInfinity> Konstante veranschaulicht.  
  
 [!code-cpp[System.Single#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#9)]
 [!code-csharp[System.Single#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#9)]
 [!code-vb[System.Single#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_Equality(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : single * single -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei angegebene <see cref="T:System.Single" />-Werte gleich sind.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Single.op_Equality%2A> Methode definiert den Gleichheits Operator für- <xref:System.Single> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_GreaterThan(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : single * single -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener <see cref="T:System.Single" />-Wert größer als ein anderer angegebener <see cref="T:System.Single" />-Wert ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Single.op_GreaterThan%2A> -Methode definiert den Vorgang des Operators "größer als" für- <xref:System.Single> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_GreaterThanOrEqual(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : single * single -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener <see cref="T:System.Single" />-Wert größer oder gleich einem anderen angegebenen <see cref="T:System.Single" />-Wert ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> größer oder gleich <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Single.op_GreaterThanOrEqual%2A> -Methode definiert den Vorgang des größer-als-oder-gleich-Operators für- <xref:System.Single> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_Inequality(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(float left, float right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : single * single -&gt; bool" Usage="System.single.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei angegebene <see cref="T:System.Single" />-Werte gleich sind.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Single.op_Inequality%2A> Methode definiert den Ungleichheits Operator für- <xref:System.Single> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_LessThan(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : single * single -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener <see cref="T:System.Single" />-Wert größer als ein anderer angegebener <see cref="T:System.Single" />-Wert ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> kleiner als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Single.op_LessThan%2A> Methode definiert den Vorgang des less-than-Operators für- <xref:System.Single> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_LessThanOrEqual(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : single * single -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener <see cref="T:System.Single" /> -Wert kleiner oder gleich einem anderen angegebenen <see cref="T:System.Single" />-Wert ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> kleiner oder gleich <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Single.op_LessThanOrEqual%2A> -Methode definiert den Vorgang des less-than-or-equal-Operators für- <xref:System.Single> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in die entsprechende Gleitkommazahl mit einfacher Genauigkeit.</summary>
        <altmember cref="Overload:System.Single.TryParse" />
        <remarks>In .net Core 3,0 und höher werden Werte, die zu groß für die Darstellung sind, auf <see cref="F:System.Single.PositiveInfinity" /> oder entsprechend <see cref="F:System.Single.NegativeInfinity" /> der IEEE 754-Spezifikation gerundet. In früheren Versionen, einschließlich .NET Framework, führte das Auswerten eines Werts, der zu groß für die Darstellung war, zu einem Fehler.</remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; single" Usage="System.single.Parse s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in die entsprechende Gleitkommazahl mit einfacher Genauigkeit.</summary>
        <returns>Eine Gleitkommazahl mit einfacher Genauigkeit, die dem numerischen Wert oder Symbol in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .net Core 3,0 und höher werden Werte, die zu groß für die Darstellung sind, auf <xref:System.Single.PositiveInfinity> oder entsprechend <xref:System.Single.NegativeInfinity> der IEEE 754-Spezifikation gerundet. In früheren Versionen, einschließlich .NET Framework, führte das Auswerten eines Werts, der zu groß für die Darstellung war, zu einem Fehler.

 Der `s` -Parameter kann die aktuelle Kultur <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> , <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> , <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> oder eine Zeichenfolge der folgenden Form enthalten:  
  
 [*WS*] [*Sign*] [ganzzahlige*Ziffern*[*,*]] ganzzahlige *Ziffern*[*.* [*Bruch Ziffern*]] [e [*Sign*]*exponentialziffern*] [*WS*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|BESCHREIBUNG|  
|-------------|-----------------|  
|*Gefangener*|Eine Reihe von Leerzeichen.|  
|*sign*|Ein negatives Vorzeichen Symbol oder ein positives Vorzeichen Symbol. Gültige Zeichen werden von der-Eigenschaft <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> und der-Eigenschaft <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> der aktuellen Kultur bestimmt. Es kann nur ein führendes Vorzeichen verwendet werden.|  
|*ganzzahlige Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die den ganzzahligen Teil der Zahl angeben. Ausführungen ganzzahliger *Ziffern* können durch ein Gruppen Trennzeichen partitioniert werden. In einigen Kulturen werden z. b. durch Kommas (,) Gruppen von Tausenden voneinander getrennt. Das *integrale Ziffern* Element kann nicht vorhanden sein, wenn die Zeichenfolge das Dezimal *stellen Element enthält* .|  
|*,*|Ein kulturspezifisches Tausender Trennzeichen.|  
|*.*|Ein kulturspezifisches Dezimaltrennzeichen.|  
|*Bruch Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die den Bruch Teil der Zahl angeben.|  
|E|Das Zeichen "e" oder "e", das angibt, dass der Wert in exponentieller Notation (Scientific) dargestellt wird.|  
|*exponentielle Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die einen Exponenten angeben.|  
  
 Der `s` -Parameter wird mit einer Kombination der <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> -und- <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> Flags interpretiert. Dies bedeutet, dass Leerzeichen und Tausender Trennzeichen zulässig sind, aber Währungssymbole nicht. `s`Verwenden Sie die-Methoden Überladung, um die Elemente explizit zu definieren (z. b. Währungssymbole, Tausende Trennzeichen und Leerzeichen), die in vorhanden sein können <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> .  
  
 Der- `s` Parameter wird mithilfe der Formatierungsinformationen in einem- <xref:System.Globalization.NumberFormatInfo> Objekt analysiert, das für die aktuelle System Kultur initialisiert wird. Weitere Informationen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>. Verwenden Sie die-Methode oder die-Methode, um eine Zeichenfolge mithilfe der Formatierungsinformationen einer bestimmten Kultur zu analysieren <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29> <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> .  
  
Wenn Sie der-Methode eine Zeichenfolge übergeben, die <xref:System.Single.Parse%2A> durch den Aufruf der-Methode erstellt wird <xref:System.Single.ToString%2A> , wird normalerweise der ursprüngliche <xref:System.Single> Wert zurückgegeben. Aufgrund eines Genauigkeits Verlusts sind die Werte jedoch möglicherweise nicht gleich.  

Wenn `s` außerhalb des Gültigkeits Bereichs des- <xref:System.Single> Datentyps liegt, löst die Methode eine <xref:System.OverflowException> auf .NET Framework und .net Core 2,2 und früheren Versionen aus. In .net Core 3,0 und höheren Versionen wird zurückgegeben, <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> Wenn `s` kleiner als ist <xref:System.Single.MinValue?displayProperty=nameWithType> und <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> Wenn `s` größer als ist <xref:System.Single.MaxValue?displayProperty=nameWithType> .

Wenn im-Parameter während eines Analyse Vorgangs ein Trennzeichen gefunden wird `s` und die entsprechende Währungs-oder Zahlen Dezimal-und Gruppen Trennzeichen identisch sind, geht der Analyse Vorgang davon aus, dass es sich bei dem Trennzeichen um ein Dezimaltrennzeichen und nicht um ein Gruppen Trennzeichen handelt. Weitere Informationen zu Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A> , <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A> , <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A> und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A> .  
  
## Examples  
 Im folgenden Beispiel wird die- <xref:System.Single.Parse%28System.String%29> Methode verwendet, um ein Array von Zeichen folgen in äquivalente Werte zu konvertieren <xref:System.Single> .  
  
 [!code-csharp[System.Single.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse1.cs#2)]
 [!code-vb[System.Single.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> stellt keine Zahl in einem gültigen Format dar.</exception>
        <exception cref="T:System.OverflowException">Nur .NET Framework und .NET Core 2.2 und früheren Versionen: <paramref name="s" /> stellt eine Zahl dar, die kleiner als <see cref="F:System.Single.MinValue" /> oder größer als <see cref="F:System.Single.MaxValue" /> ist.</exception>
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="/dotnet/standard/base-types/parsing-numeric">Analysieren numerischer Zeichenfolgen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; single" Usage="System.single.Parse (s, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <param name="style">Eine bitweise Kombination von Enumerationswerten, die die Stilelemente angeben, die in <paramref name="s" /> vorhanden sein können. Ein häufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Float" /> in Kombination mit <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil in die entsprechende Gleitkommazahl mit einfacher Genauigkeit.</summary>
        <returns>Eine Gleitkommazahl mit einfacher Genauigkeit, die dem numerischen Wert oder Symbol in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .net Core 3,0 und höher werden Werte, die zu groß für die Darstellung sind, auf <xref:System.Single.PositiveInfinity> oder entsprechend <xref:System.Single.NegativeInfinity> der IEEE 754-Spezifikation gerundet. In früheren Versionen, einschließlich .NET Framework, führte das Auswerten eines Werts, der zu groß für die Darstellung war, zu einem Fehler.

 Der- `style` Parameter definiert die Stilelemente (z. b. Leerzeichen, Tausender Trennzeichen und Währungssymbole), die im-Parameter zulässig sind, damit der Analyse Vorgang erfolgreich ausgeführt werden kann `s` . Dabei muss es sich um eine Kombination von Bitflags aus der- <xref:System.Globalization.NumberStyles> Enumeration handeln. Die folgenden Member <xref:System.Globalization.NumberStyles> werden nicht unterstützt:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 Der `s` -Parameter kann die <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> ,,, der aktuellen Kultur enthalten <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> . Abhängig vom Wert von `style` kann auch das folgende Format annehmen:  
  
 [*WS*] [ *$* ] [*Sign*] [*integrale Ziffern*[*,*]] ganzzahlige*Ziffern*[*.* [*Bruch Ziffern*]] [E [*Sign*]*exponentialziffern*] [*WS*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
 *Gefangener*  
 Eine Reihe von Leerzeichen. Leerräume können am Anfang von angezeigt `s` `style` werden, wenn das <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> -Flag enthält, und es kann am Ende von angezeigt werden, `s` Wenn `style` das- <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> Flag enthält.  
  
 $  
 Ein kulturspezifisches Währungssymbol. Die Position in der Zeichenfolge wird durch die <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> -Eigenschaft und die-Eigenschaft <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> der aktuellen Kultur definiert. Das Währungssymbol der aktuellen Kultur kann in angezeigt `s` werden, wenn `style` das- <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> Flag enthält.  
  
 *sign*  
 Ein negatives Vorzeichen Symbol (-) oder ein positives Vorzeichen Symbol (+). Das Vorzeichen kann am Anfang von angezeigt `s` `style` werden, wenn das <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> -Flag enthält, und es kann am Ende von angezeigt werden, `s` Wenn `style` das- <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> Flag enthält. Klammern können in verwendet werden `s` , um einen negativen Wert anzugeben, wenn `style` das- <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> Flag einschließt.  
  
 *ganzzahlige Ziffern*  
 Eine Reihe von Ziffern im Bereich von 0 bis 9, die den ganzzahligen Teil der Zahl angeben. Das *integrale Ziffern* Element kann nicht vorhanden sein, wenn die Zeichenfolge das Dezimal *stellen Element enthält* .  
  
 ,  
 Ein kulturspezifisches Gruppen Trennzeichen. Das Gruppen Trennzeichen der aktuellen Kultur kann in angezeigt `s` werden, wenn `style` das- <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> Flag enthält.  
  
 .  
 Ein kulturspezifisches Dezimaltrennzeichen. Das Dezimaltrennzeichen der aktuellen Kultur kann in auftreten, `s` Wenn `style` das- <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Flag enthält.  
  
 *Bruch Ziffern*  
 Eine Reihe von Ziffern im Bereich von 0 bis 9, die den Bruch Teil der Zahl angeben. Bruch Ziffern können in auftreten, `s` Wenn `style` das- <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Flag enthält.  
  
 E  
 Das Zeichen "e" oder "e", das angibt, dass der Wert in exponentieller Notation (Scientific) dargestellt wird. Der- `value` Parameter kann eine Zahl in Exponentialnotation darstellen, wenn `style` das- <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> Flag enthält.  
  
 *exponentielle Ziffern*  
 Eine Reihe von Ziffern im Bereich von 0 bis 9, die einen Exponenten angeben.  
  
> [!NOTE]
> Alle abschließenden NUL-Zeichen (U + 0000) in `s` werden vom Analyse-Vorgang unabhängig vom Wert des `style` Arguments ignoriert.

 Eine Zeichenfolge, die nur Ziffern (die dem Format entspricht) entspricht, <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> wird immer erfolgreich analysiert, wenn Sie sich im Bereich des <xref:System.Single> Typs befindet. Die übrigen Member <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> steuern Elemente, die in der Eingabe Zeichenfolge vorhanden sein können, aber nicht in der Eingabe Zeichenfolge vorhanden sein müssen. In der folgenden Tabelle wird angegeben <xref:System.Globalization.NumberStyles> , wie die einzelnen Flags die Elemente beeinflussen, die möglicherweise in vorhanden sind `s` .  
  
|NumberStyles-Wert|In zugelassene Elemente `s` zusätzlich zu Ziffern|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Nur das ganzzahlige *Ziffern* Element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Die Dezimaltrennzeichen (*.*) und die Elemente der *Bruch Ziffern* .|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Das Zeichen "e" oder "e", das die Exponentialschreibweise angibt. Dieses Flag allein unterstützt Werte in der Form *Ziffern*E*Ziffern*. zusätzliche Flags sind erforderlich, um Zeichen folgen mit solchen Elementen wie positive oder negative Vorzeichen und Dezimaltrennzeichen erfolgreich zu analysieren.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Das *WS* -Element am Anfang von `s` .|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Das *WS* -Element am Ende von `s` .|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Das *Sign* -Element am Anfang von `s` .|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Das *Sign* -Element am Ende von `s` .|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Das *Vorzeichen* Element in der Form von Klammern, das den numerischen Wert einschließt.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Das Tausender Trennzeichen (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Das Currency ($)-Element.|  
|<xref:System.Globalization.NumberStyles.Currency>|Alle-Elemente. Es ist jedoch nicht möglich, `s` eine hexadezimale Zahl oder eine Zahl in Exponentialnotation darzustellen.|  
|<xref:System.Globalization.NumberStyles.Float>|Das *WS* -Element am Anfang oder Ende von `s` *signiert* am Anfang von `s` und dem Dezimaltrennzeichen (.). Der- `s` Parameter kann auch die Exponentialnotation verwenden.|  
|<xref:System.Globalization.NumberStyles.Number>|Die `ws` `sign` Elemente,, Tausender Trennzeichen (,) und Dezimaltrennzeichen (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Alle-Elemente. `s`Eine hexadezimale Zahl kann jedoch nicht dargestellt werden.|  
  
 Einige Beispiele für `s` sind "100", "-123.456.789", "123,45 e + 6", "+ 500", "5e2", "3,1416", "600.", "-. 123" und "-Infinity".  
  
 Der- `s` Parameter wird mithilfe der Formatierungsinformationen in einem- <xref:System.Globalization.NumberFormatInfo> Objekt analysiert, das für die aktuelle System Kultur initialisiert wird. Um die Kultur anzugeben, deren Formatierungsinformationen für den Analyse Vorgang verwendet werden, müssen Sie die-Überladung aufrufen <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> .  
  
 Wenn Sie der-Methode eine Zeichenfolge übergeben, die <xref:System.Single.Parse%2A> durch den Aufruf der-Methode erstellt wird <xref:System.Single.ToString%2A> , wird normalerweise der ursprüngliche <xref:System.Single> Wert zurückgegeben. Aufgrund eines Genauigkeits Verlusts sind die Werte jedoch möglicherweise nicht gleich.  

Wenn `s` außerhalb des Gültigkeits Bereichs des- <xref:System.Single> Datentyps liegt, löst die Methode eine <xref:System.OverflowException> auf .NET Framework und .net Core 2,2 und früheren Versionen aus. In .net Core 3,0 und höheren Versionen wird zurückgegeben, <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> Wenn `s` kleiner als ist <xref:System.Single.MinValue?displayProperty=nameWithType> und <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> Wenn `s` größer als ist <xref:System.Single.MaxValue?displayProperty=nameWithType> .

Wenn im-Parameter während eines Analyse Vorgangs ein Trennzeichen gefunden wird `s` und die entsprechende Währungs-oder Zahlen Dezimal-und Gruppen Trennzeichen identisch sind, geht der Analyse Vorgang davon aus, dass es sich bei dem Trennzeichen um ein Dezimaltrennzeichen und nicht um ein Gruppen Trennzeichen handelt. Weitere Informationen zu Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A> , <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A> , <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A> und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A> .  

## Examples  
 Im folgenden Beispiel wird die- <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> Methode verwendet, um die Zeichen folgen Darstellungen von-Werten zu analysieren <xref:System.Single> . Das Beispiel verwendet Formatierungsinformationen für die Kultur "en-US".  
  
 [!code-csharp[System.Single.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse2.cs#3)]
 [!code-vb[System.Single.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> stellt keine Zahl in einem gültigen Format dar.</exception>
        <exception cref="T:System.OverflowException">Nur .NET Framework und .NET Core 2.2 und frühere Versionen: <paramref name="s" /> stellt eine Zahl dar, die kleiner als <see cref="F:System.Single.MinValue" /> oder größer als <see cref="F:System.Single.MaxValue" /> ist.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
- oder - 
 <paramref name="style" /> enthält den <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />-Wert.</exception>
        <altmember cref="M:System.Single.ToString" />
        <altmember cref="Overload:System.Single.TryParse" />
        <related type="Article" href="/dotnet/standard/base-types/parsing-numeric">Analysieren numerischer Zeichenfolgen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, IFormatProvider provider);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; single" Usage="System.single.Parse (s, provider)" />
      <MemberSignature Language="C#" Value="public static float Parse (string s, IFormatProvider? provider);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu <paramref name="s" /> bereitstellt.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem bestimmten kulturabhängigen Format in die entsprechende Gleitkommazahl mit einfacher Genauigkeit.</summary>
        <returns>Eine Gleitkommazahl mit einfacher Genauigkeit, die dem numerischen Wert oder Symbol in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .net Core 3,0 und höher werden Werte, die zu groß für die Darstellung sind, auf <xref:System.Single.PositiveInfinity> oder entsprechend <xref:System.Single.NegativeInfinity> der IEEE 754-Spezifikation gerundet. In früheren Versionen, einschließlich .NET Framework, führte das Auswerten eines Werts, der zu groß für die Darstellung war, zu einem Fehler.

 Diese Überladung wird normalerweise verwendet, um Text zu konvertieren, der auf unterschiedlichste Weise in einen-Wert formatiert werden kann <xref:System.Single> . Beispielsweise kann es verwendet werden, um den von einem Benutzer eingegebenen Text in ein HTML-Textfeld in einen numerischen Wert zu konvertieren.  
  
 Der `s` -Parameter wird mit einer Kombination der <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> -und- <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> Flags interpretiert. Der- `s` Parameter kann <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType> , <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType> oder <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> für die Kultur enthalten, die von angegeben `provider` wird, oder er kann eine Zeichenfolge in der Form enthalten:  
  
 [*WS*] [*Sign*] ganzzahlige *Ziffern*[*.* [*Bruch Ziffern*]] [E [*Sign*]*exponentialziffern*] [*WS*]  
  
 Optionale Elemente werden in eckige Klammern ([und]) eingeschlossen. Elemente, die den Begriff "Ziffern" enthalten, bestehen aus einer Reihe von numerischen Zeichen zwischen 0 und 9.  
  
|Element|BESCHREIBUNG|  
|-------------|-----------------|  
|*Gefangener*|Eine Reihe von Leerzeichen.|  
|*sign*|Ein negatives Vorzeichen Symbol (-) oder ein positives Vorzeichen Symbol (+).|  
|*ganzzahlige Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die den ganzzahligen Teil der Zahl angeben. Ausführungen ganzzahliger *Ziffern* können durch ein Gruppen Trennzeichen partitioniert werden. In einigen Kulturen werden z. b. durch Kommas (,) Gruppen von Tausenden voneinander getrennt. Das *integrale Ziffern* Element kann nicht vorhanden sein, wenn die Zeichenfolge das Dezimal *stellen Element enthält* .|  
|.|Ein kulturspezifisches Dezimaltrennzeichen.|  
|*Bruch Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die den Bruch Teil der Zahl angeben.|  
|E|Das Zeichen "e" oder "e", das angibt, dass der Wert in exponentieller Notation (Scientific) dargestellt wird.|  
|*exponentielle Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die einen Exponenten angeben.|  
  
 Weitere Informationen zu numerischen Formaten finden Sie im Thema [Formatierungs Typen](/dotnet/standard/base-types/formatting-types) .  
  
 Der- `provider` Parameter ist eine <xref:System.IFormatProvider> Implementierung <xref:System.IFormatProvider.GetFormat%2A> , deren-Methode ein-Objekt zurückgibt <xref:System.Globalization.NumberFormatInfo> , das kulturspezifische Formatierungsinformationen bereitstellt. Wenn die <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29> -Methode aufgerufen wird, ruft Sie die `provider` -Methode des-Parameters auf <xref:System.IFormatProvider.GetFormat%2A> und übergibt ihr ein- <xref:System.Type> Objekt, das den- <xref:System.Globalization.NumberFormatInfo> Typ darstellt. Die- <xref:System.IFormatProvider.GetFormat%2A> Methode gibt dann das- <xref:System.Globalization.NumberFormatInfo> Objekt zurück, das Informationen zum Format des- `s` Parameters bereitstellt. Es gibt drei Möglichkeiten, den-Parameter zu verwenden, `provider` um benutzerdefinierte Formatierungsinformationen für den Analyse Vorgang bereitzustellen:  
  
-   Sie können ein- <xref:System.Globalization.CultureInfo> Objekt übergeben, das die Kultur darstellt, die Formatierungsinformationen bereitstellt. <xref:System.Globalization.CultureInfo.GetFormat%2A>Die-Methode gibt das- <xref:System.Globalization.NumberFormatInfo> Objekt zurück, das numerische Formatierungsinformationen für diese Kultur bereitstellt.  
  
-   Sie können das tatsächliche- <xref:System.Globalization.NumberFormatInfo> Objekt übergeben, das numerische Formatierungsinformationen bereitstellt. (Die Implementierung von <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> gibt nur sich selbst zurück.)  
  
-   Sie können ein benutzerdefiniertes Objekt übergeben, das implementiert <xref:System.IFormatProvider> . <xref:System.IFormatProvider.GetFormat%2A>Die-Methode instanziiert und gibt das <xref:System.Globalization.NumberFormatInfo> Objekt zurück, das Formatierungsinformationen bereitstellt.  
  
 Wenn `provider` ist `null` oder <xref:System.Globalization.NumberFormatInfo> nicht abgerufen werden kann, werden die Formatierungsinformationen für die aktuelle System Kultur verwendet.  

Wenn `s` außerhalb des Gültigkeits Bereichs des- <xref:System.Single> Datentyps liegt, löst die Methode eine <xref:System.OverflowException> auf .NET Framework und .net Core 2,2 und früheren Versionen aus. In .net Core 3,0 und höheren Versionen wird zurückgegeben, <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> Wenn `s` kleiner als ist <xref:System.Single.MinValue?displayProperty=nameWithType> und <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> Wenn `s` größer als ist <xref:System.Single.MaxValue?displayProperty=nameWithType> . 

Wenn im-Parameter während eines Analyse Vorgangs ein Trennzeichen gefunden wird `s` und die entsprechende Währungs-oder Zahlen Dezimal-und Gruppen Trennzeichen identisch sind, geht der Analyse Vorgang davon aus, dass es sich bei dem Trennzeichen um ein Dezimaltrennzeichen und nicht um ein Gruppen Trennzeichen handelt. Weitere Informationen zu Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A> , <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A> , <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A> und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A> .  
  
Einige Beispiele für `s` sind "100", "-123.456.789", "123,45 e + 6", "+ 500", "5e2", "3,1416", "600.", "-. 123" und "-Infinity".  

## Examples  
 Das folgende Beispiel ist der Button Click-Ereignishandler eines Webformulars. Dabei wird das von der-Eigenschaft zurückgegebene Array verwendet <xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType> , um das Gebiets Schema des Benutzers zu bestimmen. Anschließend wird ein-Objekt instanziiert <xref:System.Globalization.CultureInfo> , das diesem Gebiets Schema entspricht. Das <xref:System.Globalization.NumberFormatInfo> -Objekt, das zu diesem Objekt gehört, <xref:System.Globalization.CultureInfo> wird dann an die <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29> -Methode weitergegeben, um die Eingabe des Benutzers in einen-Wert zu konvertieren <xref:System.Single> .  
  
 [!code-csharp[ParseMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR/ParseMethod/cs/Default.aspx.cs#1)]
 [!code-vb[ParseMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ParseMethod/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> stellt keine Zahl in einem gültigen Format dar.</exception>
        <exception cref="T:System.OverflowException">Nur .NET Framework und .NET Core 2.2 und früheren Versionen: <paramref name="s" /> stellt eine Zahl dar, die kleiner als <see cref="F:System.Single.MinValue" /> oder größer als <see cref="F:System.Single.MaxValue" /> ist.</exception>
        <altmember cref="M:System.Single.ToString" />
        <altmember cref="Overload:System.Single.TryParse" />
        <related type="Article" href="/dotnet/standard/base-types/parsing-numeric">Analysieren numerischer Zeichenfolgen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, IFormatProvider? provider = default);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = Nothing) As Single" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; single" Usage="System.single.Parse (s, style, provider)" />
      <MemberSignature Language="C#" Value="public static float Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, IFormatProvider provider = default);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenspanne, die die zu konvertierende Zahl enthält</param>
        <param name="style">Eine bitweise Kombination von Enumerationswerten, die die Stilelemente angeben, die in <paramref name="s" /> vorhanden sein können.  Ein häufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Float" /> in Kombination mit <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu <paramref name="s" /> bereitstellt.</param>
        <summary>Konvertiert eine Zeichenspanne mit der Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende Gleitkommazahl mit einfacher Genauigkeit</summary>
        <returns>Eine Gleitkommazahl mit einfacher Genauigkeit, die dem numerischen Wert oder Symbol in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

In .net Core 3,0 und höher werden Werte, die zu groß für die Darstellung sind, auf <xref:System.Single.PositiveInfinity> oder entsprechend <xref:System.Single.NegativeInfinity> der IEEE 754-Spezifikation gerundet. In früheren Versionen, einschließlich .NET Framework, führte das Auswerten eines Werts, der zu groß für die Darstellung war, zu einem Fehler.

Wenn `s` außerhalb des Gültigkeits Bereichs des <xref:System.Single> -Datentyps liegt, gibt die Methode zurück, <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> Wenn `s` kleiner als ist <xref:System.Single.MinValue?displayProperty=nameWithType> und <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> Wenn `s` größer als ist <xref:System.Single.MaxValue?displayProperty=nameWithType> .

         ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="s" /> stellt keinen numerischen Wert dar.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
- oder - 
<paramref name="style" /> ist der <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; single" Usage="System.single.Parse (s, style, provider)" />
      <MemberSignature Language="C#" Value="public static float Parse (string s, System.Globalization.NumberStyles style, IFormatProvider? provider);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <param name="style">Eine bitweise Kombination von Enumerationswerten, die die Stilelemente angeben, die in <paramref name="s" /> vorhanden sein können. Ein häufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Float" /> in Kombination mit <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu <paramref name="s" /> bereitstellt.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturabhängigen Format in die entsprechende Gleitkommazahl mit einfacher Genauigkeit.</summary>
        <returns>Eine Gleitkommazahl mit einfacher Genauigkeit, die dem numerischen Wert oder Symbol in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .net Core 3,0 und höher werden Werte, die zu groß für die Darstellung sind, auf <xref:System.Single.PositiveInfinity> oder entsprechend <xref:System.Single.NegativeInfinity> der IEEE 754-Spezifikation gerundet. In früheren Versionen, einschließlich .NET Framework, führte das Auswerten eines Werts, der zu groß für die Darstellung war, zu einem Fehler.

 Der- `style` Parameter definiert die Stilelemente (z. b. Leerzeichen, Tausender Trennzeichen und Währungssymbole), die im-Parameter zulässig sind, damit der Analyse Vorgang erfolgreich ausgeführt werden kann `s` . Dabei muss es sich um eine Kombination von Bitflags aus der- <xref:System.Globalization.NumberStyles> Enumeration handeln. Die folgenden Member <xref:System.Globalization.NumberStyles> werden nicht unterstützt:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 Der- `s` Parameter kann <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType> , <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType> oder <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> für die Kultur enthalten, die durch angegeben wird `provider` . Abhängig vom Wert von `style` kann auch das folgende Format annehmen:  
  
 [*WS*] [ *$* ] [*Sign*] [*integrale Ziffern*,] ganzzahlige*Ziffern*[. [ *Bruch Ziffern*]] [E [*Sign*]*exponentialziffern*] [*WS*]  
  
 In eckige Klammern ([und]) eineckige Elemente sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|BESCHREIBUNG|  
|-------------|-----------------|  
|*Gefangener*|Eine Reihe von Leerzeichen. Leerräume können am Anfang von angezeigt `s` `style` werden, wenn das <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> -Flag enthält, und es kann am Ende von angezeigt werden, `s` Wenn `style` das- <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> Flag enthält.|  
|$|Ein kulturspezifisches Währungssymbol. Die Position in der Zeichenfolge wird durch die <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> -Eigenschaft und die-Eigenschaft <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> der aktuellen Kultur definiert. Das Währungssymbol der aktuellen Kultur kann in angezeigt `s` werden, wenn `style` das- <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> Flag enthält.|  
|*sign*|Ein negatives Vorzeichen Symbol (-) oder ein positives Vorzeichen Symbol (+). Das Vorzeichen kann am Anfang von angezeigt `s` `style` werden, wenn das <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> -Flag enthält, und es kann am Ende von angezeigt werden, `s` Wenn `style` das- <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> Flag enthält. Klammern können in verwendet werden `s` , um einen negativen Wert anzugeben, wenn `style` das- <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> Flag einschließt.|  
|*ganzzahlige Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die den ganzzahligen Teil der Zahl angeben. Das *integrale Ziffern* Element kann nicht vorhanden sein, wenn die Zeichenfolge das Dezimal *stellen Element enthält* .|  
|,|Ein kulturspezifisches Gruppen Trennzeichen. Das Gruppen Trennzeichen der aktuellen Kultur kann in angezeigt `s` werden, wenn `style` das- <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> Flag enthält.|  
|.|Ein kulturspezifisches Dezimaltrennzeichen. Das Dezimaltrennzeichen der aktuellen Kultur kann in auftreten, `s` Wenn `style` das- <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Flag enthält.|  
|*Bruch Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die den Bruch Teil der Zahl angeben. Bruch Ziffern können in auftreten, `s` Wenn `style` das- <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Flag enthält.|  
|E|Das Zeichen "e" oder "e", das angibt, dass der Wert in exponentieller Notation (Scientific) dargestellt wird. Der- `s` Parameter kann eine Zahl in Exponentialnotation darstellen, wenn `style` das- <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> Flag enthält.|  
|*exponentielle Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die einen Exponenten angeben.|  
  
> [!NOTE]
> Alle abschließenden NUL-Zeichen (U + 0000) in `s` werden vom Analyse-Vorgang unabhängig vom Wert des `style` Arguments ignoriert.

 Eine Zeichenfolge, die nur Ziffern (die dem Format entspricht) entspricht, <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> wird immer erfolgreich analysiert, wenn Sie sich im Bereich des <xref:System.Single> Typs befindet. Die übrigen Member <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> steuern Elemente, die in der Eingabe Zeichenfolge vorhanden sein können, aber nicht in der Eingabe Zeichenfolge vorhanden sein müssen. In der folgenden Tabelle wird angegeben <xref:System.Globalization.NumberStyles> , wie die einzelnen Flags die Elemente beeinflussen, die möglicherweise in vorhanden sind `s` .  
  
|NumberStyles-Wert|In zugelassene Elemente `s` zusätzlich zu Ziffern|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Nur das ganzzahlige *Ziffern* Element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Die Dezimaltrennzeichen (*.*) und die Elemente der *Bruch Ziffern* .|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Das Zeichen "e" oder "e", das die Exponentialschreibweise angibt. Dieses Flag allein unterstützt Werte in der Form *Ziffern*E*Ziffern*. zusätzliche Flags sind erforderlich, um Zeichen folgen mit solchen Elementen wie positive oder negative Vorzeichen und Dezimaltrennzeichen erfolgreich zu analysieren.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Das *WS* -Element am Anfang von `s` .|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Das *WS* -Element am Ende von `s` .|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Das *Sign* -Element am Anfang von `s` .|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Das *Sign* -Element am Ende von `s` .|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Das *Vorzeichen* Element in der Form von Klammern, das den numerischen Wert einschließt.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Das Tausender Trennzeichen (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Das Currency ($)-Element.|  
|<xref:System.Globalization.NumberStyles.Currency>|Alle-Elemente. Es ist jedoch nicht möglich, `s` eine hexadezimale Zahl oder eine Zahl in Exponentialnotation darzustellen.|  
|<xref:System.Globalization.NumberStyles.Float>|Das *WS* -Element am Anfang oder Ende von `s` *signiert* am Anfang von `s` und dem Dezimaltrennzeichen (.). Der- `s` Parameter kann auch die Exponentialnotation verwenden.|  
|<xref:System.Globalization.NumberStyles.Number>|Die `ws` `sign` Elemente,, Tausender Trennzeichen (,) und Dezimaltrennzeichen (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Alle-Elemente. `s`Eine hexadezimale Zahl kann jedoch nicht dargestellt werden.|  
  
 Der- `provider` Parameter ist eine- <xref:System.IFormatProvider> Implementierung. Die zugehörige- <xref:System.IFormatProvider.GetFormat%2A> Methode gibt ein- <xref:System.Globalization.NumberFormatInfo> Objekt zurück, das kulturspezifische Informationen zum Format von bereitstellt `value` . In der Regel `provider` kann eine der folgenden sein:  
  
-   Ein- <xref:System.Globalization.CultureInfo> Objekt, das die Kultur darstellt, die numerische Formatierungsinformationen bereitstellt. <xref:System.Globalization.CultureInfo.GetFormat%2A>Die-Methode gibt das <xref:System.Globalization.NumberFormatInfo> Objekt zurück, das numerische Formatierungsinformationen bereitstellt.  
  
-   Ein- <xref:System.Globalization.NumberFormatInfo> Objekt, das Formatierungsinformationen bereitstellt. (Die Implementierung von <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> gibt nur sich selbst zurück.)  
  
-   Ein benutzerdefiniertes Objekt, das implementiert <xref:System.IFormatProvider> und die- <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> Methode verwendet, um das Objekt zu instanziieren <xref:System.Globalization.NumberFormatInfo> , das Formatierungsinformationen bereitstellt.  
  
Wenn `provider` `null` den Wert hat, wird das- <xref:System.Globalization.NumberFormatInfo> Objekt für die aktuelle Kultur verwendet.  

Wenn `s` außerhalb des Gültigkeits Bereichs des- <xref:System.Single> Datentyps liegt, löst die Methode eine <xref:System.OverflowException> auf .NET Framework und .net Core 2,2 und früheren Versionen aus. In .net Core 3,0 und höheren Versionen wird zurückgegeben, <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> Wenn `s` kleiner als ist <xref:System.Single.MinValue?displayProperty=nameWithType> und <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> Wenn `s` größer als ist <xref:System.Single.MaxValue?displayProperty=nameWithType> .

Wenn im-Parameter während eines Analyse Vorgangs ein Trennzeichen gefunden wird `s` und die entsprechende Währungs-oder Zahlen Dezimal-und Gruppen Trennzeichen identisch sind, geht der Analyse Vorgang davon aus, dass es sich bei dem Trennzeichen um ein Dezimaltrennzeichen und nicht um ein Gruppen Trennzeichen handelt. Weitere Informationen zu Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A> , <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A> , <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A> und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A> .  

## Examples  
 Im folgenden Codebeispiel wird die- <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> Methode verwendet, um die Zeichen folgen Darstellungen von-Werten zu analysieren <xref:System.Single> . Jede Zeichenfolge in einem Array wird mithilfe der Formatierungs Konventionen der en-US, nl-nl und einer benutzerdefinierten Kultur analysiert. Die benutzerdefinierte Kultur definiert das Gruppen Trennzeichen als Unterstrich ("_") und die Gruppengröße als zwei.  
  
 [!code-csharp[System.Single.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse3.cs#4)]
 [!code-vb[System.Single.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> stellt keinen numerischen Wert dar.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
- oder - 
 <paramref name="style" /> ist der <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />-Wert.</exception>
        <exception cref="T:System.OverflowException">Nur .NET Framework und .NET Core 2.2 und frühere Versionen: <paramref name="s" /> stellt eine Zahl dar, die kleiner als <see cref="F:System.Single.MinValue" /> oder größer als <see cref="F:System.Single.MaxValue" /> ist.</exception>
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="/dotnet/standard/base-types/parsing-numeric">Analysieren numerischer Zeichenfolgen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="PositiveInfinity">
      <MemberSignature Language="C#" Value="public const float PositiveInfinity = Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 PositiveInfinity = float32(Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Single.PositiveInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const PositiveInfinity As Single  = Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: float PositiveInfinity = Infinity;" />
      <MemberSignature Language="F#" Value="val mutable PositiveInfinity : single" Usage="System.single.PositiveInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>Infinity</MemberValue>
      <Docs>
        <summary>Stellt plus unendlich dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Konstante ist das Ergebnis der Division einer positiven Zahl durch 0 (null).  
  
 Diese Konstante wird zurückgegeben, wenn das Ergebnis eines Vorgangs größer als ist <xref:System.Single.MaxValue> .  
  
 Verwenden <xref:System.Single.IsPositiveInfinity%2A> Sie, um zu bestimmen, ob ein Wert als positiv unendlich ausgewertet wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die- <xref:System.Single.PositiveInfinity> Konstante veranschaulicht.  
  
 [!code-cpp[System.Single#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#10)]
 [!code-csharp[System.Single#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#10)]
 [!code-vb[System.Single#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberSignature Language="F#" Value="abstract member System.IComparable.CompareTo : obj -&gt; int&#xA;override this.System.IComparable.CompareTo : obj -&gt; int" Usage="single.System.IComparable.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="value">Das zu vergleichende Objekt.</param>
        <summary>Vergleicht die aktuelle Instanz mit einem anderen Objekt vom selben Typ und gibt eine ganze Zahl zurück, die angibt, ob die aktuelle Instanz in der Sortierreihenfolge vor oder nach dem anderen Objekt oder an derselben Position auftritt.</summary>
        <returns>Ein Wert, der die relative Reihenfolge der verglichenen Objekte angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IComparable>-Schnittstelle umgewandelt wird.

Der Rückgabewert hat folgende Bedeutung:

| Wert             | Bedeutung                                                                 |
|-------------------|-------------------------------------------------------------------------|
| Kleiner als 0 (null)    | Diese Instanz befindet sich in der Sortierreihenfolge vor `value`.                       |
| Zero              | Diese Instanz tritt in der Sortierreihenfolge an der gleichen Position wie `value` auf. |
| Größer als 0 (null) | Diese Instanz folgt in der Sortierreihenfolge auf `value`.                        |

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.GetTypeCode : unit -&gt; TypeCode&#xA;override this.System.IConvertible.GetTypeCode : unit -&gt; TypeCode" Usage="single.System.IConvertible.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den <see cref="T:System.TypeCode" /> für diese Instanz zurück.</summary>
        <returns>Die Enumerationskonstante, die den <see cref="T:System.TypeCode" /> des Klassen- oder Werttyps darstellt, der diese Schnittstelle implementiert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToBoolean : IFormatProvider -&gt; bool&#xA;override this.System.IConvertible.ToBoolean : IFormatProvider -&gt; bool" Usage="single.System.IConvertible.ToBoolean provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns><see langword="true" />, wenn der Wert der aktuellen Instanz nicht 0 (null) ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die-Methode aufzurufen <xref:System.Convert.ToBoolean%28System.Single%29?displayProperty=nameWithType> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToByte : IFormatProvider -&gt; byte&#xA;override this.System.IConvertible.ToByte : IFormatProvider -&gt; byte" Usage="single.System.IConvertible.ToByte provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Byte" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die-Methode aufzurufen <xref:System.Convert.ToByte%28System.Single%29?displayProperty=nameWithType> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToChar : IFormatProvider -&gt; char&#xA;override this.System.IConvertible.ToChar : IFormatProvider -&gt; char" Usage="single.System.IConvertible.ToChar provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Diese Konvertierung wird nicht unterstützt. Bei dem Versuch der Verwendung dieser Methode wird eine <see cref="T:System.InvalidCastException" /> ausgelöst.</summary>
        <returns>Diese Konvertierung wird nicht unterstützt. Es wird kein Wert zurückgegeben.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">In allen Fällen.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToDateTime : IFormatProvider -&gt; DateTime&#xA;override this.System.IConvertible.ToDateTime : IFormatProvider -&gt; DateTime" Usage="single.System.IConvertible.ToDateTime provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Diese Konvertierung wird nicht unterstützt. Bei dem Versuch der Verwendung dieser Methode wird eine <see cref="T:System.InvalidCastException" /> ausgelöst.</summary>
        <returns>Diese Konvertierung wird nicht unterstützt. Es wird kein Wert zurückgegeben.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">In allen Fällen.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToDecimal : IFormatProvider -&gt; decimal&#xA;override this.System.IConvertible.ToDecimal : IFormatProvider -&gt; decimal" Usage="single.System.IConvertible.ToDecimal provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Decimal" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die-Methode aufzurufen <xref:System.Convert.ToDecimal%28System.Single%29?displayProperty=nameWithType> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToDouble : IFormatProvider -&gt; double&#xA;override this.System.IConvertible.ToDouble : IFormatProvider -&gt; double" Usage="single.System.IConvertible.ToDouble provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Double" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die-Methode aufzurufen <xref:System.Convert.ToDouble%28System.Single%29?displayProperty=nameWithType> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToInt16 : IFormatProvider -&gt; int16&#xA;override this.System.IConvertible.ToInt16 : IFormatProvider -&gt; int16" Usage="single.System.IConvertible.ToInt16 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Int16" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die-Methode aufzurufen <xref:System.Convert.ToInt16%28System.Single%29?displayProperty=nameWithType> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToInt32 : IFormatProvider -&gt; int&#xA;override this.System.IConvertible.ToInt32 : IFormatProvider -&gt; int" Usage="single.System.IConvertible.ToInt32 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Int32" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die-Methode aufzurufen <xref:System.Convert.ToInt32%28System.Single%29?displayProperty=nameWithType> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToInt64 : IFormatProvider -&gt; int64&#xA;override this.System.IConvertible.ToInt64 : IFormatProvider -&gt; int64" Usage="single.System.IConvertible.ToInt64 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Int64" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die-Methode aufzurufen <xref:System.Convert.ToInt64%28System.Single%29?displayProperty=nameWithType> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToSByte : IFormatProvider -&gt; sbyte&#xA;override this.System.IConvertible.ToSByte : IFormatProvider -&gt; sbyte" Usage="single.System.IConvertible.ToSByte provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.SByte" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die-Methode aufzurufen <xref:System.Convert.ToSByte%28System.Single%29?displayProperty=nameWithType> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToSingle : IFormatProvider -&gt; single&#xA;override this.System.IConvertible.ToSingle : IFormatProvider -&gt; single" Usage="single.System.IConvertible.ToSingle provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>Der unveränderte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToType (type As Type, provider As IFormatProvider) As Object Implements IConvertible.ToType" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToType : Type * IFormatProvider -&gt; obj&#xA;override this.System.IConvertible.ToType : Type * IFormatProvider -&gt; obj" Usage="single.System.IConvertible.ToType (type, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ, in den dieser <see cref="T:System.Single" />-Wert konvertiert werden soll.</param>
        <param name="provider">Ein Objekt, das Informationen zum Format des zurückgegebenen Werts bereitstellt.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Der in <paramref name="type" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die `static` - `Shared` Methode (in Visual Basic) aufzurufen <xref:System.Convert.ChangeType%2A?displayProperty=nameWithType> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToUInt16 : IFormatProvider -&gt; uint16&#xA;override this.System.IConvertible.ToUInt16 : IFormatProvider -&gt; uint16" Usage="single.System.IConvertible.ToUInt16 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.UInt16" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die-Methode aufzurufen <xref:System.Convert.ToUInt16%28System.Single%29?displayProperty=nameWithType> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToUInt32 : IFormatProvider -&gt; uint32&#xA;override this.System.IConvertible.ToUInt32 : IFormatProvider -&gt; uint32" Usage="single.System.IConvertible.ToUInt32 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.UInt32" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die-Methode aufzurufen <xref:System.Convert.ToUInt32%28System.Single%29?displayProperty=nameWithType> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToUInt64 : IFormatProvider -&gt; uint64&#xA;override this.System.IConvertible.ToUInt64 : IFormatProvider -&gt; uint64" Usage="single.System.IConvertible.ToUInt64 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.UInt64" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die-Methode aufzurufen <xref:System.Convert.ToUInt64%28System.Single%29?displayProperty=nameWithType> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert den Wert dieser Instanz in die entsprechende Zeichenfolgendarstellung.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="single.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konvertiert den Wert dieser Instanz in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieser Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Single.ToString> Methode formatiert einen <xref:System.Single> Wert im Standardformat ("G" oder allgemein) der aktuellen Kultur. Wenn Sie ein anderes Format oder eine andere Kultur angeben möchten, verwenden Sie die anderen über Ladungen der- <xref:System.Single.ToString%2A> Methode wie folgt:  
  
|So verwenden Sie das Format|Für Kultur|Verwenden der Überladung|  
|-------------------|-----------------|----------------------|  
|Standardformat ("G")|Eine bestimmte Kultur|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|Ein bestimmtes Format|Standard Kultur (aktuell)|<xref:System.Single.ToString%28System.String%29>|  
|Ein bestimmtes Format|Eine bestimmte Kultur|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Der Rückgabewert kann <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> , <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> , <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> oder eine Zeichenfolge der folgenden Form sein:  
  
 [Sign] ganzzahlige Ziffern [. [ Bruch Ziffern]] [e [Sign] exponentialziffern]  
  
 Optionale Elemente werden in eckige Klammern ([und]) eingeschlossen. Elemente, die den Begriff "Ziffern" enthalten, bestehen aus einer Reihe von numerischen Zeichen zwischen 0 und 9. In der folgenden Tabelle sind die einzelnen Elemente aufgelistet:  
  
|Element|BESCHREIBUNG|  
|-------------|-----------------|  
|*sign*|Ein negatives Vorzeichen-oder positives Vorzeichen Symbol.|  
|*ganzzahlige Ziffern*|Eine Reihe von Ziffern, die den ganzzahligen Teil der Zahl angibt. Ganzzahlige Ziffern können nicht vorhanden sein, wenn es sich um Bruch Ziffern handelt.|  
|'.'|Ein kulturspezifisches Dezimaltrennzeichen.|  
|*Bruch Ziffern*|Eine Reihe von Ziffern, die den Bruch Teil der Zahl angibt.|  
|Fresser|Ein Kleinbuchstabe "e", der die exponentielle (wissenschaftliche) Notation angibt.|  
|*exponentielle Ziffern*|Eine Reihe von Ziffern, die einen Exponenten angeben.|  
  
 Einige Beispiele für den Rückgabewert sind "100", "-123.456.789", "123,45 e + 6", "500", "3,1416", "600", "-0,123" und "-Infinity".  
  
 Der .NET Framework bietet umfassende Formatierungs Unterstützung, die in den folgenden Formatierungs Themen ausführlicher beschrieben wird:  
  
-   Weitere Informationen zu numerischen Format Bezeichnerzeichen finden Sie unter [Standard mäßige Zahlenformat](/dotnet/standard/base-types/standard-numeric-format-strings) Zeichenfolgen und [benutzerdefinierte Zahlenformat](/dotnet/standard/base-types/custom-numeric-format-strings)Zeichenfolgen.  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatieren von Typen](/dotnet/standard/base-types/formatting-types).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die-Standard <xref:System.Single.ToString%2A?displayProperty=nameWithType> Methode verwendet, um die Zeichen folgen Darstellungen einer Reihe von <xref:System.Single> Werten anzuzeigen.  
  
 [!code-csharp[System.Single.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#1)]
 [!code-vb[System.Single.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#1)]  
  
 Im folgenden Codebeispiel wird die Verwendung der- <xref:System.Single.Parse%28System.String%29> Methode zusammen mit der- <xref:System.Single.ToString> Methode veranschaulicht.  
  
 [!code-cpp[System.Single#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#3)]
 [!code-csharp[System.Single#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#3)]
 [!code-vb[System.Single#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="/dotnet/standard/base-types/formatting-types">Formatieren von Typen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="single.ToString provider" />
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider? provider);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Konvertiert den numerischen Wert dieser Instanz unter Berücksichtigung der angegebenen kulturabhängigen Formatierungsinformationen in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieser Instanz entsprechend den Angaben von <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Single.ToString%28System.IFormatProvider%29> Methode formatiert einen <xref:System.Single> Wert im Standardformat ("G" oder allgemein) einer angegebenen Kultur. Wenn Sie ein anderes Format oder die aktuelle Kultur angeben möchten, verwenden Sie die anderen über Ladungen der- <xref:System.Single.ToString%2A> Methode wie folgt:  
  
|So verwenden Sie das Format|Für Kultur|Verwenden der Überladung|  
|-------------------|-----------------|----------------------|  
|Standardformat ("G")|Standard Kultur (aktuell)|<xref:System.Single.ToString>|  
|Ein bestimmtes Format|Standard Kultur (aktuell)|<xref:System.Single.ToString%28System.String%29>|  
|Ein bestimmtes Format|Eine bestimmte Kultur|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Der Rückgabewert kann <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> , <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> , <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> oder eine Zeichenfolge der folgenden Form sein:  
  
 [Sign] ganzzahlige Ziffern [. [ Bruch Ziffern]] [e [Sign] exponentialziffern]  
  
 Optionale Elemente werden in eckige Klammern ([und]) eingeschlossen. Elemente, die den Begriff "Ziffern" enthalten, bestehen aus einer Reihe von numerischen Zeichen zwischen 0 und 9. In der folgenden Tabelle werden die einzelnen-Elemente aufgelistet.  
  
|Element|BESCHREIBUNG|  
|-------------|-----------------|  
|Signieren|Ein negatives Vorzeichen-oder positives Vorzeichen Symbol.|  
|ganzzahlige Ziffern|Eine Reihe von Ziffern, die den ganzzahligen Teil der Zahl angibt. Ganzzahlige Ziffern können nicht vorhanden sein, wenn es sich um Bruch Ziffern handelt.|  
|'.'|Ein kulturspezifisches Dezimaltrennzeichen.|  
|Bruch Ziffern|Eine Reihe von Ziffern, die den Bruch Teil der Zahl angibt.|  
|Fresser|Ein Kleinbuchstabe "e", der die exponentielle (wissenschaftliche) Notation angibt.|  
|exponentielle Ziffern|Eine Reihe von Ziffern, die einen Exponenten angeben.|  
  
 Einige Beispiele für den Rückgabewert sind "100", "-123.456.789", "123,45 e + 6", "500", "3,1416", "600", "-0,123" und "-Infinity".  
  
 Der .NET Framework bietet umfassende Formatierungs Unterstützung, die in den folgenden Formatierungs Themen ausführlicher beschrieben wird:  
  
-   Weitere Informationen zu numerischen Format Bezeichnerzeichen finden Sie unter [Standard mäßige Zahlenformat](/dotnet/standard/base-types/standard-numeric-format-strings) Zeichenfolgen und [benutzerdefinierte Zahlenformat](/dotnet/standard/base-types/custom-numeric-format-strings)Zeichenfolgen.  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatieren von Typen](/dotnet/standard/base-types/formatting-types).  
  
 Der- `provider` Parameter ist eine <xref:System.IFormatProvider> Implementierung, deren- <xref:System.IFormatProvider.GetFormat%2A> Methode ein-Objekt zurückgibt <xref:System.Globalization.NumberFormatInfo> . In der Regel `provider` ist ein- <xref:System.Globalization.CultureInfo> Objekt oder ein- <xref:System.Globalization.NumberFormatInfo> Objekt. Der- `provider` Parameter liefert kulturspezifische Informationen, die bei der Formatierung verwendet werden. Wenn `provider` `null` den Wert hat, wird der Rückgabewert mit den <xref:System.Globalization.NumberFormatInfo> Daten für die aktuelle Kultur formatiert.  
  
 Um einen <xref:System.Single> Wert in seine Zeichen folgen Darstellung zu konvertieren, indem Sie eine angegebene Kultur und eine bestimmte Format Zeichenfolge verwenden, müssen Sie die- <xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Zeichen folgen Darstellung von zwei <xref:System.Single> Werten mithilfe von-Objekten angezeigt, die <xref:System.Globalization.CultureInfo> verschiedene Kulturen darstellen.  
  
 [!code-csharp[System.Single.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#2)]
 [!code-vb[System.Single.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="/dotnet/standard/base-types/formatting-types">Formatieren von Typen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="single.ToString format" />
      <MemberSignature Language="C#" Value="public string ToString (string? format);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Eine numerische Formatierungszeichenfolge.</param>
        <summary>Konvertiert den numerischen Wert dieser Instanz in die entsprechende Zeichenfolgendarstellung unter Berücksichtigung des angegebenen Formats.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieser Instanz entsprechend den Angaben von <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Single.ToString%28System.String%29> Methode formatiert einen <xref:System.Single> Wert in einem angegebenen Format unter Verwendung der Konventionen der aktuellen Kultur. Wenn Sie das Standardformat ("G" oder "Allgemein") verwenden oder eine andere Kultur angeben möchten, verwenden Sie die anderen über Ladungen der- <xref:System.Single.ToString%2A> Methode wie folgt:  
  
|So verwenden Sie das Format|Für Kultur|Verwenden der Überladung|  
|-------------------|-----------------|----------------------|  
|Standardformat ("G")|Standard Kultur (aktuell)|<xref:System.Single.ToString>|  
|Standardformat ("G")|Eine bestimmte Kultur|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|Ein bestimmtes Format|Eine bestimmte Kultur|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Der Rückgabewert kann <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> , <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> , <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> oder die Zeichen folgen Darstellung des Werts der aktuellen Instanz sein, wie von angegeben `format` .  
  
 Der `format` -Parameter kann ein beliebiger gültiger numerischer Standardformat Bezeichner mit Ausnahme von D und X sowie eine beliebige Kombination von benutzerdefinierten numerischen Format Bezeichnern sein. Wenn Format `null` oder eine leere Zeichenfolge ist, wird der Rückgabewert mit dem allgemeinen numerischen Format Bezeichner ("G") formatiert.  
  
 Der .NET Framework bietet umfassende Formatierungs Unterstützung, die in den folgenden Formatierungs Themen ausführlicher beschrieben wird:  
  
-   Weitere Informationen zu numerischen Format Bezeichnerzeichen finden Sie unter [Standard mäßige Zahlenformat](/dotnet/standard/base-types/standard-numeric-format-strings) Zeichenfolgen und [benutzerdefinierte Zahlenformat](/dotnet/standard/base-types/custom-numeric-format-strings)Zeichenfolgen.  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatieren von Typen](/dotnet/standard/base-types/formatting-types).  
  
 Standardmäßig enthält der Rückgabewert nur 7 Dezimalstellen, obwohl intern maximal 9 Ziffern aufbewahrt werden. Wenn der Wert dieser Instanz größer als 7 Ziffern ist, wird <xref:System.Single.ToString%28System.String%29> <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> oder <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> anstelle der erwarteten Zahl zurückgegeben. Wenn Sie mehr Genauigkeit benötigen, geben Sie `format` mit der Format Spezifikation "G9" an, die immer 9 Ziffern der Genauigkeit zurückgibt, oder "R", die sieben Ziffern zurückgibt, wenn die Zahl mit dieser Genauigkeit oder 9 Ziffern dargestellt werden kann, wenn die Zahl nur mit maximaler Genauigkeit dargestellt werden kann.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein numerischer Wert definiert und als Währungswert formatiert, indem die standardmäßige numerische Format Zeichenfolge "C" und ein numerischer Wert für drei Dezimalstellen mit der standardmäßigen numerischen Format Zeichenfolge "N" verwendet wird. Die Ergebnis Zeichenfolgen werden anhand der Konventionen der Kultur "en-US" formatiert. Weitere Informationen zu numerischen Format Zeichenfolgen finden Sie unter [Standard mäßige Zahlenformat](/dotnet/standard/base-types/standard-numeric-format-strings) Zeichenfolgen und [benutzerdefinierte Zahlenformat](/dotnet/standard/base-types/custom-numeric-format-strings)Zeichenfolgen.  
  
 [!code-csharp[System.Single.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString7.cs#7)]
 [!code-vb[System.Single.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString7.vb#7)]  
  
 Im folgenden Beispiel werden mehrere <xref:System.Single> Werte mit den unterstützten numerischen Standardformat bezeichnerwerten mit zwei benutzerdefinierten numerischen Format Zeichenfolgen angezeigt. Eine dieser benutzerdefinierten Format Zeichenfolgen veranschaulicht, wie ein <xref:System.Single> Wert mit führenden Nullen aufgefüllt wird. Beim Umrechnen der numerischen Werte in Zeichen folgen verwendet das Beispiel die Formatierungs Konventionen der Kultur "en-US".  
  
 [!code-csharp[System.Single.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#3)]
 [!code-vb[System.Single.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" /> ist ungültig.</exception>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="/dotnet/standard/base-types/formatting-types">Formatieren von Typen in .NET</related>
        <related type="Article" href="/dotnet/standard/base-types/how-to-pad-a-number-with-leading-zeros">Vorgehensweise: Auffüllen einer Zahl mit führenden Nullen</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="single.ToString (format, provider)" />
      <MemberSignature Language="C#" Value="public string? ToString (string format, IFormatProvider provider);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Eine numerische Formatierungszeichenfolge.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Konvertiert den numerischen Wert dieser Instanz unter Verwendung des angegebenen Formats und der angegebenen kulturabhängigen Formatierungsinformationen in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieser Instanz entsprechend den Angaben von <paramref name="format" /> und <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29> Methode formatiert einen <xref:System.Single> Wert in einem angegebenen Format einer angegebenen Kultur. Wenn Sie die Standardformat-oder Kultur Einstellungen verwenden möchten, verwenden Sie die anderen über Ladungen der- <xref:System.Single.ToString%2A> Methode wie folgt:  
  
|So verwenden Sie das Format|Für Kultur|Verwenden der Überladung|  
|-------------------|-----------------|----------------------|  
|Standardformat ("G")|Standard Kultur (aktuell)|<xref:System.Single.ToString>|  
|Standardformat ("G")|Eine bestimmte Kultur|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|Ein bestimmtes Format|Standard Kultur (aktuell)|<xref:System.Single.ToString%28System.String%29>|  
  
 Der Rückgabewert kann <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> , <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> , <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> oder die Zeichen folgen Darstellung des Werts der aktuellen Instanz sein, wie von angegeben `format` .  
  
 Der `format` -Parameter kann ein beliebiger gültiger numerischer Standardformat Bezeichner mit Ausnahme von D und X sowie eine beliebige Kombination von benutzerdefinierten numerischen Format Bezeichnern sein. Wenn `format` `null` oder eine leere Zeichenfolge ist, wird der Rückgabewert für diese Instanz mit dem allgemeinen numerischen Format Bezeichner ("G") formatiert.  
  
 Der .NET Framework bietet umfassende Formatierungs Unterstützung, die in den folgenden Formatierungs Themen ausführlicher beschrieben wird:  
  
-   Weitere Informationen zu numerischen Format Bezeichnerzeichen finden Sie unter [Standard mäßige Zahlenformat](/dotnet/standard/base-types/standard-numeric-format-strings) Zeichenfolgen und [benutzerdefinierte Zahlenformat](/dotnet/standard/base-types/custom-numeric-format-strings)Zeichenfolgen.  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatieren von Typen](/dotnet/standard/base-types/formatting-types).  
  
 Der- `provider` Parameter ist eine <xref:System.IFormatProvider> Implementierung, deren- <xref:System.IFormatProvider.GetFormat%2A> Methode ein-Objekt zurückgibt <xref:System.Globalization.NumberFormatInfo> . In der Regel `provider` ist ein- <xref:System.Globalization.CultureInfo> Objekt oder ein- <xref:System.Globalization.NumberFormatInfo> Objekt. Der- `provider` Parameter liefert kulturspezifische Informationen, die bei der Formatierung verwendet werden. Wenn `provider` `null` den Wert hat, wird der Rückgabewert mit dem- <xref:System.Globalization.NumberFormatInfo> Objekt für die aktuelle Kultur formatiert.  
  
 Standardmäßig enthält der Rückgabewert nur 7 Dezimalstellen, obwohl intern maximal 9 Ziffern aufbewahrt werden. Wenn der Wert dieser Instanz größer als 7 Ziffern ist, wird <xref:System.Single.ToString%2A> <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> oder <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> anstelle der erwarteten Zahl zurückgegeben. Wenn Sie mehr Genauigkeit benötigen, geben Sie `format` mit der Format Spezifikation "G9" an, die immer 9 Ziffern der Genauigkeit zurückgibt, oder "R", die sieben Ziffern zurückgibt, wenn die Zahl mit dieser Genauigkeit oder 9 Ziffern dargestellt werden kann, wenn die Zahl nur mit maximaler Genauigkeit dargestellt werden kann.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein <xref:System.Single> Wert mit jedem der unterstützten numerischen Standardformat Bearbeiter für verschiedene Kulturen angezeigt.  
  
 [!code-csharp[System.Single.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#4)]
 [!code-vb[System.Single.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="/dotnet/standard/base-types/formatting-types">Formatieren von Typen in .NET</related>
        <related type="Article" href="/dotnet/standard/base-types/how-to-pad-a-number-with-leading-zeros">Vorgehensweise: Auffüllen einer Zahl mit führenden Nullen</related>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default, IFormatProvider? provider = default);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = Nothing, Optional provider As IFormatProvider = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; * int * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="single.TryFormat (destination, charsWritten, format, provider)" />
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default, IFormatProvider provider = default);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination">Wenn diese Methode zurückgegeben wird, wird der Wert dieser Instanz als Zeichenspanne formatiert.</param>
        <param name="charsWritten">Nach Ausführung dieser Methode die Anzahl der in <paramref name="destination" /> geschriebenen Zeichen.</param>
        <param name="format">Eine Spanne, die die Zeichen enthält, die eine standardmäßig festgelegte oder benutzerdefinierte Formatzeichenfolge darstellen, die das akzeptable Format für <paramref name="destination" /> definiert.</param>
        <param name="provider">Ein optionales Objekt, das kulturspezifische Formatierungsinformationen für <paramref name="destination" /> bereitstellt.</param>
        <summary>Versucht, den Wert der aktuellen Instanz der Gleitkommazahl in die angegebene Zeichenspanne zu formatieren</summary>
        <returns><see langword="true" />, wenn die Formatierung erfolgreich war, andernfalls <see langword="false" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in die entsprechende Gleitkommazahl mit einfacher Genauigkeit. Ein Rückgabewert gibt an, ob die Konvertierung erfolgreich war oder nicht.</summary>
        <altmember cref="Overload:System.Single.Parse" />
        <remarks>In .net Core 3,0 und höher werden Werte, die zu groß für die Darstellung sind, auf <see cref="F:System.Single.PositiveInfinity" /> oder entsprechend <see cref="F:System.Single.NegativeInfinity" /> der IEEE 754-Spezifikation gerundet. In früheren Versionen, einschließlich .NET Framework, führte das Auswerten eines Werts, der zu groß für die Darstellung war, zu einem Fehler.</remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.ReadOnlySpan{System.Char},System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * single -&gt; bool" Usage="System.single.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="result" Type="System.Single" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="s">&gt;Eine Zeichenspanne, die die Zeichenfolgendarstellung der zu konvertierenden Zahl enthält.</param>
        <param name="result">&gt;Wenn diese Methode zurückgegeben wird, enthält sie bei erfolgreicher Konvertierung eine Gleitkommazahl mit einfacher Genauigkeit, die dem <paramref name="s" />-Parameter entspricht, oder „0“ (null), wenn die Konvertierung fehlgeschlagen ist. Die Konvertierung schlägt fehl, wenn der <paramref name="s" />-Parameter <see langword="null" />, leer oder keine Zahl im gültigen Format ist. Wenn <parmref name="s" /> eine gültige Zahl kleiner als <see cref="F:System.Single.MinValue" /> ist, ist <paramref name="result" /> gleich <see cref="F:System.Single.NegativeInfinity" />. Wenn <parmref name="s" /> eine gültige Zahl größer als <see cref="F:System.Single.MaxValue" /> ist, ist <paramref name="result" /> gleich <see cref="F:System.Single.PositiveInfinity" />. Dieser Parameter wird nicht initialisiert übergeben. Jeder Wert, der ursprünglich im bereitgestellten <paramref name="result" /> überschrieben werden.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einer Zeichenspanne in die entsprechende Gleitkommazahl mit einfacher Genauigkeit. Ein Rückgabewert gibt an, ob die Konvertierung erfolgreich war oder nicht.</summary>
        <returns><see langword="true" />, wenn <paramref name="s" /> erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>In .net Core 3,0 und höher werden Werte, die zu groß für die Darstellung sind, auf <see cref="F:System.Single.PositiveInfinity" /> oder entsprechend <see cref="F:System.Single.NegativeInfinity" /> der IEEE 754-Spezifikation gerundet. In früheren Versionen, einschließlich .NET Framework, führte das Auswerten eines Werts, der zu groß für die Darstellung war, zu einem Fehler.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.String,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * single -&gt; bool" Usage="System.single.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Single" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die die zu konvertierende Zahl darstellt.</param>
        <param name="result">Diese Methode gibt bei erfolgreicher Konvertierung eine Gleitkommazahl mit einfacher Genauigkeit zurück, die dem numerischen Wert oder dem in <paramref name="s" /> enthaltenen Symbol entspricht, und 0 (null), wenn die Konvertierung nicht durchgeführt werden konnte. Die Konvertierung schlägt fehl, wenn der <paramref name="s" />-Parameter <see langword="null" />, <see cref="F:System.String.Empty" /> oder keine Zahl im gültigen Format ist. Außerdem schlägt sie in .NET Framework und .NET Core 2.2 und früheren Versionen fehl, wenn <paramref name="s" /> eine Zahl kleiner als <see cref="F:System.Single.MinValue" /> oder größer als <see cref="F:System.Single.MaxValue" /> darstellt. Dieser Parameter wird nicht initialisiert übergeben. Jeder Wert, der ursprünglich im bereitgestellten <paramref name="result" /> überschrieben werden.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in die entsprechende Gleitkommazahl mit einfacher Genauigkeit. Ein Rückgabewert gibt an, ob die Konvertierung erfolgreich war oder nicht.</summary>
        <returns><see langword="true" />, wenn <paramref name="s" /> erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .net Core 3,0 und höher werden Werte, die zu groß für die Darstellung sind, auf <xref:System.Single.PositiveInfinity> oder entsprechend <xref:System.Single.NegativeInfinity> der IEEE 754-Spezifikation gerundet. In früheren Versionen, einschließlich .NET Framework, führte das Auswerten eines Werts, der zu groß für die Darstellung war, zu einem Fehler.

 Diese Überladung unterscheidet sich von der- <xref:System.Single.Parse%28System.String%29?displayProperty=nameWithType> Methode, indem ein boolescher Wert zurückgegeben wird, der angibt, ob der Analyse Vorgang erfolgreich war, anstatt den analysierten numerischen Wert zurückzugeben. Es entfällt, dass die Ausnahmebehandlung verwendet werden muss, um ein <xref:System.FormatException> im Ereignis zu testen, das `s` ungültig ist und nicht erfolgreich analysiert werden kann.  
  
 Der- `s` Parameter kann <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> , <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> , <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> (der Zeichen folgen Vergleich unter Beachtung der Groß-/Kleinschreibung) oder eine Zeichenfolge in der Form enthalten:  
  
 Gefangener Gebärden [integrale Ziffern,] ganzzahlige Ziffern [. [ Bruch Ziffern]] [e [Sign] exponentialziffern] [WS]  
  
 Elemente in eckigen Klammern sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|BESCHREIBUNG|  
|-------------|-----------------|  
|*Gefangener*|Eine Reihe von Leerzeichen.|  
|*sign*|Ein negatives Vorzeichen-oder positives Vorzeichen Symbol.|  
|*ganzzahlige Ziffern*|Eine Reihe von numerischen Zeichen im Bereich von 0 bis 9, die den ganzzahligen Teil der Zahl angeben. Ganzzahlige Ziffern können nicht vorhanden sein, wenn es sich um Bruch Ziffern handelt.|  
|*,*|Ein kulturspezifisches Gruppen Trennzeichen.|  
|*.*|Ein kulturspezifisches Dezimaltrennzeichen.|  
|*Bruch Ziffern*|Eine Reihe von numerischen Zeichen im Bereich von 0 bis 9, die den Bruchteil der Zahl angeben.|  
|*Fresser*|Ein Großbuchstabe oder ein Kleinbuchstabe "e", der die exponentielle (wissenschaftliche) Notation angibt.|  
|*exponentielle Ziffern*|Eine Reihe von numerischen Zeichen im Bereich von 0 bis 9, die einen Exponenten angeben.|  
  
 Der `s` -Parameter wird mit einer Kombination der <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> -und- <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> Flags interpretiert. Dies bedeutet, dass Leerzeichen und Tausender Trennzeichen zulässig sind, aber Währungssymbole nicht. `s`Verwenden Sie die-Methoden Überladung, um die Elemente explizit zu definieren (z. b. Währungssymbole, Tausende Trennzeichen und Leerzeichen), die in vorhanden sein können <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29> .  
  
 Der- `s` Parameter wird mithilfe der Formatierungsinformationen in einem- <xref:System.Globalization.NumberFormatInfo> Objekt analysiert, das für die aktuelle System Kultur initialisiert wird. Weitere Informationen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>. Verwenden Sie die-Methoden Überladung, um eine Zeichenfolge mit den Formatierungsinformationen einer anderen angegebenen Kultur zu analysieren <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29> .  
  
 Wenn Sie der-Methode eine Zeichenfolge übergeben, die <xref:System.Single.TryParse%2A?displayProperty=nameWithType> durch den Aufruf der-Methode erstellt wird <xref:System.Single.ToString%2A?displayProperty=nameWithType> , wird normalerweise der ursprüngliche <xref:System.Single> Wert zurückgegeben. Aufgrund eines Genauigkeits Verlusts sind die Werte jedoch möglicherweise nicht gleich.  

Wenn `s` außerhalb des Gültigkeits Bereichs des- <xref:System.Single> Datentyps liegt, gibt die Methode `false` auf .NET Framework und .net Core 2,2 und früheren Versionen zurück. In .net Core 3,0 und höheren Versionen wird zurückgegeben, <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> Wenn `s` kleiner als ist <xref:System.Single.MinValue?displayProperty=nameWithType> und <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> Wenn `s` größer als ist <xref:System.Single.MaxValue?displayProperty=nameWithType> .

Wenn im-Parameter während eines Analyse Vorgangs ein Trennzeichen gefunden wird `s` und die entsprechende Währungs-oder Zahlen Dezimal-und Gruppen Trennzeichen identisch sind, geht der Analyse Vorgang davon aus, dass es sich bei dem Trennzeichen um ein Dezimaltrennzeichen und nicht um ein Gruppen Trennzeichen handelt. Weitere Informationen zu Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A> , <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A> , <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A> und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A> .  
  
   
  
## Examples  
 Im folgenden Beispiel wird die- <xref:System.Single.TryParse%28System.String%2CSystem.Single%40%29> Methode verwendet, um die Zeichen folgen Darstellungen numerischer Werte in-Werte zu konvertieren <xref:System.Single> . Dabei wird davon ausgegangen, dass "en-US" die aktuelle Kultur ist.  
  
 [!code-csharp[System.Single.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.tryparse/cs/tryparse1.cs#1)]
 [!code-vb[System.Single.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.tryparse/vb/tryparse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="/dotnet/standard/base-types/parsing-numeric">Analysieren numerischer Zeichenfolgen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider? provider, out float result);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider * single -&gt; bool" Usage="System.single.TryParse (s, style, provider, result)" />
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider provider, out float result);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="result" Type="System.Single" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="s">Eine schreibgeschützte Zeichenspanne, die die zu konvertierende Zahl enthält. Die Zeichenspanne wird unter Verwendung des durch <paramref name="style" /> angegebenen Formats interpretiert.</param>
        <param name="style">Eine bitweise Kombination von Enumerationswerten, die das zulässige Format von <paramref name="s" /> angibt. Ein häufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Float" /> in Kombination mit <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu <paramref name="s" /> bereitstellt.</param>
        <param name="result">Diese Methode gibt bei erfolgreicher Konvertierung eine Gleitkommazahl mit einfacher Genauigkeit zurück, die dem numerischen Wert oder dem in <paramref name="s" /> enthaltenen Symbol entspricht, und 0 (null), wenn die Konvertierung nicht durchgeführt werden konnte. Die Konvertierung kann nicht durchgeführt werden, wenn der <paramref name="s" />-Parameter <see langword="null" /> oder <see cref="F:System.String.Empty" /> ist, kein mit <paramref name="style" /> kompatibles Format aufweist, eine Zahl kleiner als <see cref="F:System.Single.MinValue" /> oder größer als <see cref="F:System.Single.MaxValue" /> darstellt, oder wenn <paramref name="style" /> keine gültige Kombination von <see cref="T:System.Globalization.NumberStyles" />-Enumerationskonstanten ist. Dieser Parameter wird nicht initialisiert übergeben. Jeder Wert, der ursprünglich im bereitgestellten <paramref name="result" /> überschrieben werden.</param>
        <summary>Konvertiert die Spannendarstellung einer Zahl in einem angegebenen Stil und einem kulturabhängigen Format in die entsprechende Gleitkommazahl mit einfacher Genauigkeit Ein Rückgabewert gibt an, ob die Konvertierung erfolgreich war oder nicht.</summary>
        <returns><see langword="true" />, wenn <paramref name="s" /> erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>In .net Core 3,0 und höher werden Werte, die zu groß für die Darstellung sind, auf <see cref="F:System.Single.PositiveInfinity" /> oder entsprechend <see cref="F:System.Single.NegativeInfinity" /> der IEEE 754-Spezifikation gerundet. In früheren Versionen, einschließlich .NET Framework, führte das Auswerten eines Werts, der zu groß für die Darstellung war, zu einem Fehler.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider * single -&gt; bool" Usage="System.single.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Single" RefType="out" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die die zu konvertierende Zahl darstellt.</param>
        <param name="style">Eine bitweise Kombination von Enumerationswerten, die das zulässige Format von <paramref name="s" /> angibt. Ein häufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Float" /> in Kombination mit <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu <paramref name="s" /> bereitstellt.</param>
        <param name="result">Diese Methode gibt bei erfolgreicher Konvertierung eine Gleitkommazahl mit einfacher Genauigkeit zurück, die dem numerischen Wert oder dem in <paramref name="s" /> enthaltenen Symbol entspricht, und 0 (null), wenn die Konvertierung nicht durchgeführt werden konnte. Die Konvertierung kann nicht durchgeführt werden, wenn der <paramref name="s" />-Parameter <see langword="null" /> oder <see cref="F:System.String.Empty" /> ist, kein mit <paramref name="style" /> kompatibles Format aufweist oder <paramref name="style" /> keine gültige Kombination von <see cref="T:System.Globalization.NumberStyles" />-Enumerationskonstanten ist. Außerdem schlägt sie in .NET Framework oder .NET Core 2.2 und früheren Versionen fehl, wenn <paramref name="s" /> eine Zahl kleiner als <see cref="F:System.Single.MinValue" /> oder größer als <see cref="F:System.Single.MaxValue" /> darstellt. Dieser Parameter wird nicht initialisiert übergeben. Jeder Wert, der ursprünglich im bereitgestellten <paramref name="result" /> überschrieben werden.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturabhängigen Format in die entsprechende Gleitkommazahl mit einfacher Genauigkeit. Ein Rückgabewert gibt an, ob die Konvertierung erfolgreich war oder nicht.</summary>
        <returns><see langword="true" />, wenn <paramref name="s" /> erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .net Core 3,0 und höher werden Werte, die zu groß für die Darstellung sind, auf <xref:System.Single.PositiveInfinity> oder entsprechend <xref:System.Single.NegativeInfinity> der IEEE 754-Spezifikation gerundet. In früheren Versionen, einschließlich .NET Framework, führte das Auswerten eines Werts, der zu groß für die Darstellung war, zu einem Fehler.

 Diese Überladung unterscheidet sich von der- <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> Methode, indem ein boolescher Wert zurückgegeben wird, der angibt, ob der Analyse Vorgang erfolgreich war, anstatt den analysierten numerischen Wert zurückzugeben. Es entfällt, dass die Ausnahmebehandlung verwendet werden muss, um ein <xref:System.FormatException> im Ereignis zu testen, das `s` ungültig ist und nicht erfolgreich analysiert werden kann.  
  
 Der- `style` Parameter definiert das zulässige Format des- `s` Parameters, damit der Analyse Vorgang erfolgreich ausgeführt wird. Dabei muss es sich um eine Kombination von Bitflags aus der- <xref:System.Globalization.NumberStyles> Enumeration handeln. Die folgenden Member <xref:System.Globalization.NumberStyles> werden nicht unterstützt:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>  
  
 Der- `s` Parameter kann <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> , <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> , <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> für die Kultur enthalten, die durch angegeben wird `provider` . Außerdem kann der-Parameter abhängig vom Wert von `style` `s` die folgenden Elemente enthalten:  
  
 Gefangener [$] Gebärden [ganzzahlige Ziffern,] ganzzahlige Ziffern [. Bruch Ziffern] [e [Sign] exponentialziffern] [WS]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|BESCHREIBUNG|  
|-------------|-----------------|  
|*Gefangener*|Optionaler Leerraum. Leerraum kann am Anfang von angezeigt `s` werden, wenn `style` das- <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> Flag enthält. Sie kann am Ende von angezeigt `s` werden, wenn `style` das- <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> Flag enthält.|  
|*$*|Ein kulturspezifisches Währungssymbol. Die Position in der Zeichenfolge wird durch die-Eigenschaft oder die-Eigenschaft <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> des von der- <xref:System.Globalization.NumberFormatInfo> <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> Methode des-Parameters zurückgegebenen-Objekts definiert `provider` . Das Währungssymbol kann in angezeigt `s` werden, wenn `style` das- <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> Flag enthält.|  
|*sign*|Ein optionales Vorzeichen. Das Vorzeichen kann am Anfang von angezeigt `s` `style` werden, wenn das <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> -Flag enthält, und es kann am Ende von angezeigt werden, `s` Wenn `style` das- <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> Flag enthält. Klammern können in verwendet werden `s` , um einen negativen Wert anzugeben, wenn `style` das- <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> Flag einschließt.|  
|*ganzzahlige Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die den ganzzahligen Teil der Zahl angeben. Ganzzahlige Ziffern können nicht vorhanden sein, wenn es sich um Bruch Ziffern handelt.|  
|*,*|Ein kulturspezifisches Tausender Trennzeichen. Das Tausender Trennzeichen der aktuellen Kultur kann in auftreten, `s` Wenn `style` das- <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> Flag enthält.|  
|*.*|Ein kulturspezifisches Dezimaltrennzeichen. Das Dezimaltrennzeichen der aktuellen Kultur kann in auftreten, `s` Wenn `style` das- <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Flag enthält.|  
|*Bruch Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die den Bruch Teil der Zahl angeben. Bruch Ziffern können in auftreten, `s` Wenn `style` das- <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Flag enthält.|  
|*e*|Das e-oder e-Zeichen, das angibt, dass `s` eine Zahl mit exponentieller Notation darstellen kann. Der- `s` Parameter kann eine Zahl in Exponentialnotation darstellen, wenn style das- <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> Flag enthält.|  
|*exponentielle Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die einen Exponenten angeben.|  
  
> [!NOTE]
> Alle abschließenden NUL-Zeichen (U + 0000) in `s` werden vom Analyse-Vorgang unabhängig vom Wert des `style` Arguments ignoriert.

 Eine Zeichenfolge, die nur Ziffern (die dem Format entspricht) entspricht, <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> wird immer erfolgreich analysiert, wenn Sie sich im Bereich des <xref:System.Single> Typs befindet. Die übrigen Member <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> steuern Elemente, die möglicherweise nicht in der Eingabe Zeichenfolge vorhanden sind, jedoch nicht erforderlich sind. In der folgenden Tabelle wird angegeben <xref:System.Globalization.NumberStyles> , wie die einzelnen Flags die Elemente beeinflussen, die möglicherweise in vorhanden sind `s` .  
  
|NumberStyles-Wert|In s zulässige Elemente zusätzlich zu Ziffern|  
|------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Nur das ganzzahlige *Ziffern* Element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Das Sprachelement *.* und *Bruch Ziffern* Elemente.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Der- `s` Parameter kann auch die Exponentialnotation verwenden. Dieses Flag allein unterstützt Werte in der Form ganzzahlige *Ziffern*E*exponentialziffern*. zusätzliche Flags sind erforderlich, um Zeichen folgen in Exponentialnotation mit solchen Elementen wie positive oder negative Vorzeichen und Dezimaltrennzeichen erfolgreich zu analysieren.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Das *WS* -Element am Anfang von `s` .|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Das *WS* -Element am Ende von `s` .|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Das *Sign* -Element am Anfang von `s` .|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Das *Sign* -Element am Ende von `s` .|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Das *Vorzeichen* Element in der Form von Klammern, das den numerischen Wert einschließt.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Das *-* Element.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Das *$* Element.|  
|<xref:System.Globalization.NumberStyles.Currency>|Alle. Der- `s` Parameter kann keine hexadezimal Zahl oder eine Zahl in Exponentialnotation darstellen.|  
|<xref:System.Globalization.NumberStyles.Float>|Das *WS* -Element am Anfang oder Ende von `s` *signiert* am Anfang von `s` und *.* Tick. Der- `s` Parameter kann auch die Exponentialnotation verwenden.|  
|<xref:System.Globalization.NumberStyles.Number>|Die `ws` `sign` Elemente,, Tausender Trennzeichen (*,)* und Dezimaltrennzeichen (*.*).|  
|<xref:System.Globalization.NumberStyles.Any>|Alle Stile, außer `s` können keine hexadezimal Zahl darstellen.|  
  
 Der- `provider` Parameter ist eine <xref:System.IFormatProvider> Implementierung <xref:System.IFormatProvider.GetFormat%2A> , deren-Methode ein-Objekt zurückgibt <xref:System.Globalization.NumberFormatInfo> , das kulturspezifische Formatierungsinformationen bereitstellt. Wenn die <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29> -Methode aufgerufen wird, ruft Sie die `provider` -Methode des-Parameters auf <xref:System.IFormatProvider.GetFormat%2A> und übergibt ihr ein- <xref:System.Type> Objekt, das den- <xref:System.Globalization.NumberFormatInfo> Typ darstellt. Die- <xref:System.IFormatProvider.GetFormat%2A> Methode gibt dann das- <xref:System.Globalization.NumberFormatInfo> Objekt zurück, das Informationen zum Format des- `s` Parameters bereitstellt. Es gibt drei Möglichkeiten, den-Parameter zu verwenden, `provider` um benutzerdefinierte Formatierungsinformationen für den Analyse Vorgang bereitzustellen:  
  
-   Sie können ein- <xref:System.Globalization.CultureInfo> Objekt übergeben, das die Kultur darstellt, die Formatierungsinformationen bereitstellt. <xref:System.Globalization.CultureInfo.GetFormat%2A>Die-Methode gibt das- <xref:System.Globalization.NumberFormatInfo> Objekt zurück, das numerische Formatierungsinformationen für diese Kultur bereitstellt.  
  
-   Sie können das tatsächliche- <xref:System.Globalization.NumberFormatInfo> Objekt übergeben, das numerische Formatierungsinformationen bereitstellt. (Die Implementierung von <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> gibt nur sich selbst zurück.)  
  
-   Sie können ein benutzerdefiniertes Objekt übergeben, das implementiert <xref:System.IFormatProvider> . <xref:System.IFormatProvider.GetFormat%2A>Die-Methode instanziiert und gibt das <xref:System.Globalization.NumberFormatInfo> Objekt zurück, das Formatierungsinformationen bereitstellt.  
  
 Wenn `provider` `null` den Wert hat, wird die Formatierung von `s` basierend auf dem- <xref:System.Globalization.NumberFormatInfo> Objekt der aktuellen Kultur interpretiert.  

Wenn `s` außerhalb des Gültigkeits Bereichs des- <xref:System.Single> Datentyps liegt, löst die Methode eine <xref:System.OverflowException> auf .NET Framework und .net Core 2,2 und früheren Versionen aus. In .net Core 3,0 und höheren Versionen wird zurückgegeben, <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> Wenn `s` kleiner als ist <xref:System.Single.MinValue?displayProperty=nameWithType> und <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> Wenn `s` größer als ist <xref:System.Single.MaxValue?displayProperty=nameWithType> .

 Wenn im-Parameter während eines Analyse Vorgangs ein Trennzeichen gefunden wird `s` und die entsprechende Währungs-oder Zahlen Dezimal-und Gruppen Trennzeichen identisch sind, geht der Analyse Vorgang davon aus, dass es sich bei dem Trennzeichen um ein Dezimaltrennzeichen und nicht um ein Gruppen Trennzeichen handelt. Weitere Informationen zu Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A> , <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A> , <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A> und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A> .  
 
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die- <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29?displayProperty=nameWithType> Methode verwendet wird, um die Zeichen folgen Darstellung von Zahlen zu analysieren, die einen bestimmten Stil aufweisen und mit den Konventionen einer bestimmten Kultur formatiert werden.  
  
 [!code-csharp[System.Single.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.tryparse/cs/tryparse1.cs#2)]
 [!code-vb[System.Single.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.tryparse/vb/tryparse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
- oder - 
 <paramref name="style" /> ist der <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />-Wert.</exception>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="/dotnet/standard/base-types/parsing-numeric">Analysieren numerischer Zeichenfolgen in .NET</related>
      </Docs>
    </Member>
  </Members>
</Type>
