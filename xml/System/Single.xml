<Type Name="Single" FullName="System.Single">
  <Metadata><Meta Name="ms.openlocfilehash" Value="accd85d0263130f5737d186a22ff0bc88f06c7bb" /><Meta Name="ms.sourcegitcommit" Value="b6b9d5f3f9c7eb43f14a8a1a68d044603cb8ed73" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/18/2020" /><Meta Name="ms.locfileid" Value="83528668" /></Metadata><TypeSignature Language="C#" Value="public struct Single : IComparable, IComparable&lt;float&gt;, IConvertible, IEquatable&lt;float&gt;, IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit float32 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float32&gt;, class System.IConvertible, class System.IEquatable`1&lt;float32&gt;, class System.IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Single" />
  <TypeSignature Language="VB.NET" Value="Public Structure Single&#xA;Implements IComparable, IComparable(Of Single), IConvertible, IEquatable(Of Single), IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public value class Single : IComparable, IComparable&lt;float&gt;, IConvertible, IEquatable&lt;float&gt;, IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type single = struct&#xA;    interface IConvertible&#xA;    interface IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="C#" Value="public struct Single : IComparable, IConvertible, IFormattable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit float32 extends System.ValueType implements class System.IComparable, class System.IConvertible, class System.IFormattable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="VB.NET" Value="Public Structure Single&#xA;Implements IComparable, IConvertible, IFormattable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="C++ CLI" Value="public value class Single : IComparable, IConvertible, IFormattable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="F#" Value="type single = struct&#xA;    interface IFormattable&#xA;    interface IConvertible" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit float32 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float32&gt;, class System.IConvertible, class System.IEquatable`1&lt;float32&gt;, class System.IFormattable" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C#" Value="public struct Single : IComparable, IComparable&lt;float&gt;, IEquatable&lt;float&gt;, IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit float32 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float32&gt;, class System.IEquatable`1&lt;float32&gt;, class System.IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="VB.NET" Value="Public Structure Single&#xA;Implements IComparable, IComparable(Of Single), IEquatable(Of Single), IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="C++ CLI" Value="public value class Single : IComparable, IComparable&lt;float&gt;, IEquatable&lt;float&gt;, IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="F#" Value="type single = struct&#xA;    interface IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Single&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Single&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine Gleitkommazahl mit einfacher Genauigkeit dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Single> Werttyp stellt eine 32-Bit-Zahl mit einfacher Genauigkeit dar, deren Werte zwischen negativer 3.402823 E38 und positiv 3.402823 E38 liegen, sowie positive oder negative NULL-Werte, <xref:System.Single.PositiveInfinity>, <xref:System.Single.NegativeInfinity>und keine Zahl (<xref:System.Single.NaN>). Er soll Werte darstellen, die sehr gro√ü sind (z. b. Entfernungen zwischen Planeten oder Galaxien) oder extrem klein sind (z. b. die molekulare Masse eines Stoffs in Kilo Meter) und h√§ufig unpr√§zise sind (z. b. die Entfernung von der Erde zu einem anderen Sonnensystem). Der <xref:System.Single>-Typ entspricht dem IEC 60559:1989 (IEEE 754)-Standard f√ºr bin√§re Gleit Komma Arithmetik.  
  
 Dieses Thema enth√§lt folgende Abschnitte:  
  
-   [Darstellung und Genauigkeit von Gleit Komma Werten](#Precision)  
  
-   [Testen auf Gleichheit](#Equality)  
  
-   [Gleit Komma Werte und-Ausnahmen](#Exceptions)  
  
-   [Typkonvertierung und einzelne Struktur](#Conversion)  
  
-   [Gleit Komma Funktionen](#Functionality)  
  
 <xref:System.Single?displayProperty=nameWithType> stellt Methoden bereit, um Instanzen dieses Typs zu vergleichen, den Wert einer-Instanz in seine Zeichen folgen Darstellung zu konvertieren und die Zeichen folgen Darstellung einer Zahl in eine Instanz dieses Typs zu konvertieren. Informationen dazu, wie Format Spezifikations Codes die Zeichen folgen Darstellung von Werttypen steuern, finden Sie unter [Formatieren von Typen](~/docs/standard/base-types/formatting-types.md), [Standard m√§√üigen Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md)Zeichenfolgen und [benutzerdefinierte Zahlenformat](~/docs/standard/base-types/custom-numeric-format-strings.md)Zeichen  
  
<a name="Precision"></a>   
## <a name="floating-point-representation-and-precision"></a>Darstellung und Genauigkeit von Gleit Komma Werten  
 Der <xref:System.Single>-Datentyp speichert Gleit Komma Werte mit einfacher Genauigkeit in einem 32-Bit-Bin√§rformat, wie in der folgenden Tabelle dargestellt:  
  
|-Komponente|Bits|  
|----------|----------|  
|Signifikanor oder Mantisse|0-22|  
|Exponent|23-30|  
|Vorzeichen (0 = positiv, 1 = negativ)|31|  
  
 Ebenso wie dezimale Bruchteile einige Bruchzahlen nicht exakt darstellen k√∂nnen (z. b. 1/3 oder <xref:System.Math.PI?displayProperty=nameWithType>), k√∂nnen bin√§re Bruchteile einige Bruchzahlen nicht darstellen. Beispielsweise wird 2/10, der genau durch einen Dezimal Bruch dargestellt wird, durch. 0011111001001100 als bin√§rer Bruchteil dargestellt, wobei das Muster "1100" in unendlich wiederholt wird. In diesem Fall stellt der Gleit Komma Wert eine ungenaue Darstellung der Zahl dar, die er darstellt. Das Ausf√ºhren zus√§tzlicher mathematischer Operationen f√ºr den urspr√ºnglichen Gleit Komma Wert erh√∂ht h√§ufig den Mangel an Genauigkeit. Wenn Sie z. b. die Ergebnisse der Multiplikation von 3 bis 10 und das Hinzuf√ºgen von 3 bis 3 9 mal vergleichen, sehen Sie, dass Addition das weniger genaue Ergebnis erzeugt, da es acht weitere Vorg√§nge als Multiplikation umfasst. Beachten Sie, dass diese Differenz nur offensichtlich ist, wenn Sie die beiden <xref:System.Single> Werte mit der [standardm√§√üigen numerischen Format Zeichenfolge](~/docs/standard/base-types/standard-numeric-format-strings.md)"R" anzeigen, die ggf. alle 9 Ziffern der Genauigkeit anzeigt, die vom <xref:System.Single>-Typ unterst√ºtzt werden.  
  
 [!code-csharp[System.Single.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/representation1.cs#3)]
 [!code-vb[System.Single.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/representation1.vb#3)]  
  
 Da einige Zahlen nicht exakt als bin√§re Bin√§r Werte dargestellt werden k√∂nnen, k√∂nnen Gleit Komma zahlen nur in Bezug auf reelle Zahlen stehen.  
  
 Alle Gleit Komma Zahlen verf√ºgen √ºber eine begrenzte Anzahl signifikanter Ziffern, die au√üerdem bestimmen, wie genau ein Gleit Komma Wert einer reellen Zahl entspricht. Ein <xref:System.Single> Wert hat bis zu 7 Dezimalstellen, obwohl intern maximal 9 Ziffern aufbewahrt werden. Dies bedeutet, dass einige Gleit Komma Vorg√§nge m√∂glicherweise nicht die Genauigkeit zum √Ñndern eines Gleit Komma Werts haben. Im folgenden Beispiel wird ein gro√üer Gleit Komma Wert mit einfacher Genauigkeit definiert, und dann wird das Produkt von <xref:System.Single.Epsilon?displayProperty=nameWithType> und einem vier F√ºnftel hinzugef√ºgt. Das Produkt ist jedoch zu klein, um den urspr√ºnglichen Gleit Komma Wert zu √§ndern. Die am wenigsten bedeutende Ziffer ist Tausendstel, wohingegen die signifikanteste Ziffer im Produkt 10<sup>-30</sup>betr√§gt.  
  
 [!code-csharp[System.Single.Structure#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/representation2.cs#4)]
 [!code-vb[System.Single.Structure#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/representation2.vb#4)]  
  
 Die begrenzte Genauigkeit einer Gleit Komma Zahl hat mehrere folgen:  
  
-   Zwei Gleitkommazahlen, die f√ºr eine bestimmte Genauigkeit identisch zu sein scheinen, k√∂nnen sich als unterschiedlich erweisen, wenn sich die zwei letzten Ziffern unterscheiden. Im folgenden Beispiel wird eine Reihe von Zahlen addiert, und ihr Gesamtwert wird mit dem erwarteten Gesamtwert verglichen. Obwohl die beiden Werte identisch sind, gibt ein Aufrufder `Equals`-Methode an, dass dies nicht der Fall ist.  
  
     [!code-csharp[System.Single.Structure#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist3.cs#6)]
     [!code-vb[System.Single.Structure#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/precisionlist3.vb#6)]  
  
     Wenn Sie die Format Elemente in der <xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%29?displayProperty=nameWithType> `{1}`-Anweisung von `{0}` √§ndern und in `{0:R}` und `{1:R}` alle wichtigen Ziffern der beiden <xref:System.Single> Werte anzeigen, ist klar, dass die beiden Werte aufgrund eines Genauigkeits Verlusts bei den Additions Vorg√§ngen ungleich sind. In diesem Fall kann das Problem gel√∂st werden, indem Sie die <xref:System.Math.Round%28System.Double%2CSystem.Int32%29?displayProperty=nameWithType>-Methode aufrufen, um die <xref:System.Single> Werte auf die gew√ºnschte Genauigkeit zu runden, bevor Sie den Vergleich durchf√ºhren.  
  
-   Eine mathematische oder Vergleichsoperation, die eine Gleit Komma Zahl verwendet, ergibt m√∂glicherweise nicht dasselbe Ergebnis, wenn eine Dezimalzahl verwendet wird, da die bin√§re Gleit Komma Zahl m√∂glicherweise nicht mit der Dezimalzahl √ºbereinstimmt. Im vorherigen Beispiel wurde dies veranschaulicht, indem das Ergebnis der Multiplikation von 3 bis 10 und das Hinzuf√ºgen von "3 bis 3 9" angezeigt wird.  
  
     Wenn die Genauigkeit in numerischen Vorg√§ngen mit Bruch Werten wichtig ist, verwenden Sie den <xref:System.Decimal>-Typ anstelle des <xref:System.Single> Typs. Wenn die Genauigkeit in numerischen Vorg√§ngen mit ganzzahligen Werten au√üerhalb des Bereichs der <xref:System.Int64>-oder <xref:System.UInt64> Typen wichtig ist, verwenden Sie den <xref:System.Numerics.BigInteger>-Typ.  
  
-   Ein Wert ist m√∂glicherweise kein Roundtrip, wenn eine Gleit Komma Zahl beteiligt ist. Ein Wert wird als Roundtrip bezeichnet, wenn ein Vorgang eine urspr√ºngliche Gleit Komma Zahl in ein anderes Format konvertiert, ein umgekehrter Vorgang das konvertierte Formular wieder in eine Gleit Komma Zahl umwandelt und die abschlie√üende Gleit Komma Zahl gleich der urspr√ºnglichen Gleit Komma Zahl ist. Der Roundtrip kann fehlschlagen, weil mindestens eine signifikante Ziffer verloren geht oder bei einer Konvertierung ge√§ndert wird. Im folgenden Beispiel werden drei <xref:System.Single> Werte in Zeichen folgen konvertiert und in einer Datei gespeichert. Wie die Ausgabe zeigt, sind die wiederhergestellten Werte nicht gleich den urspr√ºnglichen Werten, obwohl die Werte als identisch erscheinen.  
  
     [!code-csharp[System.Single.Structure#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist4a.cs#17)]
     [!code-vb[System.Single.Structure#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/PrecisionList4a.vb#17)]  
  
     In diesem Fall k√∂nnen die Werte erfolgreich mit der [standardm√§√üigen numerischen Format Zeichenfolge](~/docs/standard/base-types/standard-numeric-format-strings.md) "G9" abgerundet werden, um die vollst√§ndige Genauigkeit <xref:System.Single> Werte beizubehalten, wie im folgenden Beispiel gezeigt.  
  
     [!code-csharp[System.Single.Structure#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/PrecisionList5a.cs#18)]
     [!code-vb[System.Single.Structure#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/PrecisionList5a.vb#18)]  
  
-   <xref:System.Single> Werte haben weniger Genauigkeit als <xref:System.Double> Werte. Ein <xref:System.Single> Wert, der in eine scheinbar √§quivalente <xref:System.Double> konvertiert wird, ist aufgrund der Unterschiede in der Genauigkeit oft nicht mit dem <xref:System.Double> Wert identisch. Im folgenden Beispiel wird das Ergebnis von identischen Divisions Vorg√§ngen einem <xref:System.Double> Wert und einem <xref:System.Single> Wert zugewiesen. Nachdem der <xref:System.Single> Wert in eine <xref:System.Double>umgewandelt wurde, zeigt ein Vergleich der beiden Werte, dass Sie ungleich sind.  
  
     [!code-csharp[System.Double.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Double.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist1.vb#5)]  
  
     Um dieses Problem zu vermeiden, verwenden Sie entweder den <xref:System.Double>-Datentyp anstelle des <xref:System.Single> Datentyps, oder verwenden Sie die <xref:System.Math.Round%2A>-Methode, sodass beide Werte dieselbe Genauigkeit aufweisen.  
  
<a name="Equality"></a>   
## <a name="testing-for-equality"></a>Testen auf Gleichheit  
 Um als gleich betrachtet zu werden, m√ºssen zwei <xref:System.Single> Werte identische Werte darstellen. Aufgrund von Unterschieden in der Genauigkeit zwischen Werten oder aufgrund eines Genauigkeits Verlusts durch einen oder beide Werte werden Gleit Komma Werte, die als identisch erwartet werden, h√§ufig aufgrund von Unterschieden in ihren am wenigsten signifikanten Ziffern als ungleich dargestellt. Dies f√ºhrt dazu, dass Aufrufe der-Methode <xref:System.Single.Equals%2A>, um zu bestimmen, ob zwei Werte gleich sind, oder Aufrufe der <xref:System.Single.CompareTo%2A>-Methode, um die Beziehung zwischen zwei <xref:System.Single>-Werten zu ermitteln, oft unerwartete Ergebnisse ergeben. Dies wird im folgenden Beispiel gezeigt, in dem zwei scheinbar gleich <xref:System.Single> Werte sich als ungleich erweisen, da der erste Wert 7 Ziffern der Genauigkeit aufweist, w√§hrend der zweite Wert 9 ist.  
  
 [!code-csharp[System.Single.Structure#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison1.cs#9)]
 [!code-vb[System.Single.Structure#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison1.vb#9)]  
  
 Berechnete Werte, die auf unterschiedliche Codepfade folgen und auf unterschiedliche Weise bearbeitet werden, werden oft als ungleich feststellen. Im folgenden Beispiel ist ein <xref:System.Single> Wert quadratisch, und dann wird die Quadratwurzel berechnet, um den urspr√ºnglichen Wert wiederherzustellen. Ein zweiter <xref:System.Single> wird mit 3,51 und quadriert, bevor die Quadratwurzel des Ergebnisses durch 3,51 geteilt wird, um den urspr√ºnglichen Wert wiederherzustellen. Obwohl die beiden Werte scheinbar identisch sind, gibt ein Aufrufder <xref:System.Single.Equals%28System.Single%29>-Methode an, dass Sie nicht gleich sind. Wenn Sie die Standardformat Zeichenfolge "G9" verwenden, um eine Ergebnis Zeichenfolge zur√ºckzugeben, die alle signifikanten Ziffern jedes <xref:System.Single> Werts anzeigt, wird angezeigt, dass der zweite Wert .0000000000001 kleiner als der erste Wert ist.  
  
 [!code-csharp[System.Single.Structure#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison2.cs#10)]
 [!code-vb[System.Single.Structure#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison2.vb#10)]  
  
 In F√§llen, in denen sich der Genauigkeits Verlust wahrscheinlich auf das Ergebnis eines Vergleichs auswirkt, k√∂nnen Sie die folgenden Techniken verwenden, anstatt die <xref:System.Single.Equals%2A> oder <xref:System.Single.CompareTo%2A>-Methode aufrufen:  
  
-   Ruft die <xref:System.Math.Round%2A?displayProperty=nameWithType>-Methode auf, um sicherzustellen, dass beide Werte dieselbe Genauigkeit aufweisen. Im folgenden Beispiel wird ein vorheriges Beispiel dahingehend ge√§ndert, dass diese Vorgehensweise verwendet wird, damit zwei Dezimalzahlen gleichwertig sind.  
  
     [!code-csharp[System.Single.Structure#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison3.cs#11)]
     [!code-vb[System.Single.Structure#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison3.vb#11)]  
  
     Beachten Sie, dass das Problem der Genauigkeit weiterhin f√ºr die Rundung von Mittelpunkt Werten gilt. Weitere Informationen finden Sie unter der Methode <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29?displayProperty=nameWithType>.  
  
-   Testen Sie anstelle von Gleichheit die ungef√§hre Gleichheit. Diese Technik erfordert, dass Sie einen absoluten Betrag definieren, um den sich die beiden Werte unterscheiden k√∂nnen, aber dennoch gleich sind, oder dass Sie einen relativen Betrag definieren, um den der kleinere Wert vom gr√∂√üeren Wert abweichen kann.  
  
    > [!WARNING]
    >  <xref:System.Single.Epsilon?displayProperty=nameWithType> wird manchmal als absolutes Ma√ü der Entfernung zwischen zwei <xref:System.Single> Werten beim Testen auf Gleichheit verwendet.  <xref:System.Single.Epsilon?displayProperty=nameWithType> misst jedoch den kleinsten m√∂glichen Wert, der einem <xref:System.Single>, dessen Wert gleich 0 (null) ist, hinzugef√ºgt oder von diesem subtrahiert werden kann. Bei den meisten positiven und negativen <xref:System.Single> Werten ist der Wert <xref:System.Single.Epsilon?displayProperty=nameWithType> zu klein, um erkannt zu werden. Mit Ausnahme von Werten, die 0 (null) sind, empfiehlt es sich daher nicht, die Verwendung in Tests auf Gleichheit zu √ºbernehmen.  
  
     Im folgenden Beispiel wird der letztere Ansatz verwendet, um eine `IsApproximatelyEqual` Methode zu definieren, die den relativen Unterschied zwischen zwei Werten testet. Au√üerdem wird das Ergebnis von Aufrufen der `IsApproximatelyEqual`-Methode und der <xref:System.Single.Equals%28System.Single%29>-Methode als gegen√ºbersteht.  
  
     [!code-csharp[System.Single.Structure#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison4.cs#12)]
     [!code-vb[System.Single.Structure#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison4.vb#12)]  
  
<a name="Exceptions"></a>   
## <a name="floating-point-values-and-exceptions"></a>Gleit Komma Werte und-Ausnahmen  
 Vorg√§nge mit Gleit Komma Werten l√∂sen keine Ausnahmen aus, im Gegensatz zu Operationen mit ganzzahligen Typen, die Ausnahmen in F√§llen von unzul√§ssigen Vorg√§ngen ausl√∂sen, z. b. Division durch 0 (null) oder √úberlauf.  Stattdessen ist das Ergebnis einer Gleit Komma Operation in diesen F√§llen 0 (null), positiv unendlich, minus unendlich oder keine Zahl (NaN):  
  
-   Wenn das Ergebnis einer Gleit Komma Operation f√ºr das Zielformat zu klein ist, ist das Ergebnis 0 (null). Dies kann vorkommen, wenn zwei sehr kleine Gleit Komma Zahlen multipliziert werden, wie im folgenden Beispiel gezeigt.  
  
     [!code-csharp[System.Single.Structure#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/exceptional1.cs#1)]
     [!code-vb[System.Single.Structure#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/exceptional1.vb#1)]  
  
-   Wenn die Gr√∂√üe des Ergebnisses einer Gleit Komma Operation den Bereich des Ziel Formats √ºberschreitet, wird das Ergebnis des Vorgangs <xref:System.Single.PositiveInfinity> oder <xref:System.Single.NegativeInfinity>, was f√ºr das Vorzeichen des Ergebnisses geeignet ist. Das Ergebnis eines Vorgangs, der einen √úberlauf verursacht <xref:System.Single.MaxValue?displayProperty=nameWithType> ist <xref:System.Single.PositiveInfinity>, und das Ergebnis eines Vorgangs, der <xref:System.Single.MinValue?displayProperty=nameWithType> √ºber l√§uft, ist <xref:System.Single.NegativeInfinity>, wie im folgenden Beispiel gezeigt.  
  
     [!code-csharp[System.Single.Structure#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/exceptional2.cs#2)]
     [!code-vb[System.Single.Structure#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/exceptional2.vb#2)]  
  
     <xref:System.Single.PositiveInfinity> auch Ergebnisse aus einer Division durch 0 (null) mit einer positiven Dividende und <xref:System.Single.NegativeInfinity> Ergebnisse aus einer Division durch 0 (null) mit einer negativen Dividende.  
  
-   Wenn ein Gleit Komma Vorgang ung√ºltig ist, wird das Ergebnis des Vorgangs <xref:System.Single.NaN>. <xref:System.Single.NaN> z. b. die Ergebnisse der folgenden Vorg√§nge:  
  
    -   Division durch 0 (null) mit einer Dividende von NULL. Beachten Sie, dass andere F√§lle der Division durch Null entweder zu <xref:System.Single.PositiveInfinity> oder <xref:System.Single.NegativeInfinity>f√ºhren.  
  
    -   Eine beliebige Gleit Komma Operation mit ung√ºltiger Eingabe. Wenn Sie z. b. versuchen, die Quadratwurzel eines negativen Werts zu finden, wird <xref:System.Single.NaN>zur√ºckgegeben.  
  
    -   Jeder Vorgang mit einem Argument, dessen Wert <xref:System.Single.NaN?displayProperty=nameWithType>ist.  
  
<a name="Conversion"></a>   
## <a name="type-conversions-and-the-single-structure"></a>Typkonvertierungen und die einzelne Struktur  
 Die <xref:System.Single> Struktur definiert keine expliziten oder impliziten Konvertierungs Operatoren. Stattdessen werden Konvertierungen vom Compiler implementiert.  
  
 In der folgenden Tabelle werden die m√∂glichen Konvertierungen eines Werts der anderen primitiven numerischen Typen in einen <xref:System.Single> Wert aufgelistet. Au√üerdem wird angegeben, ob die Konvertierung erweitert oder einschr√§nkend ist und ob die resultierende <xref:System.Single> eine geringere Genauigkeit als der urspr√ºngliche Wert aufweisen kann.  
  
|Konvertierung von|Erweiterung/Einschr√§nkung|M√∂glicher Genauigkeits Verlust|  
|---------------------|-------------------------|--------------------------------|  
|<xref:System.Byte>|Widening|Nein|  
|<xref:System.Decimal>|Widening<br /><br /> Beachten Sie C# , dass einen Cast Operator erfordert.|Ja. <xref:System.Decimal> unterst√ºtzt 29 Dezimalziffern der Genauigkeit. <xref:System.Single> unterst√ºtzt 9.|  
|<xref:System.Double>|Schmaler Werte au√üerhalb des g√ºltigen Bereichs werden in <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> oder <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>konvertiert.|Ja. <xref:System.Double> unterst√ºtzt 17 Dezimalziffern der Genauigkeit. <xref:System.Single> unterst√ºtzt 9.|  
|<xref:System.Int16>|Widening|Nein|  
|<xref:System.Int32>|Widening|Ja. <xref:System.Int32> unterst√ºtzt 10 Dezimalziffern der Genauigkeit. <xref:System.Single> unterst√ºtzt 9.|  
|<xref:System.Int64>|Widening|Ja. <xref:System.Int64> unterst√ºtzt 19 Dezimalziffern der Genauigkeit. <xref:System.Single> unterst√ºtzt 9.|  
|<xref:System.SByte>|Widening|Nein|  
|<xref:System.UInt16>|Widening|Nein|  
|<xref:System.UInt32>|Widening|Ja. <xref:System.UInt32> unterst√ºtzt 10 Dezimalziffern der Genauigkeit. <xref:System.Single> unterst√ºtzt 9.|  
|<xref:System.UInt64>|Widening|Ja. <xref:System.Int64> unterst√ºtzt 20 Dezimalziffern der Genauigkeit. <xref:System.Single> unterst√ºtzt 9.|  
  
 Im folgenden Beispiel wird der minimale oder maximale Wert anderer primitiver numerischer Typen in einen <xref:System.Single> Wert konvertiert.  
  
 [!code-csharp[System.Single.Structure#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/convert1.cs#20)]
 [!code-vb[System.Single.Structure#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/convert1.vb#20)]  
  
 Au√üerdem werden die <xref:System.Double> Werte <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>und <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> in <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>bzw. <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>konvertiert.  
  
 Beachten Sie, dass die Konvertierung des Werts einiger numerischer Typen in einen <xref:System.Single> Wert einen Genauigkeits Verlust beinhalten kann. Wie das Beispiel veranschaulicht, ist ein Genauigkeits Verlust bei der Umstellung von <xref:System.Decimal>-, <xref:System.Double>-, <xref:System.Int32>-, <xref:System.Int64>-, <xref:System.UInt32>-und <xref:System.UInt64>-Werten in <xref:System.Single> Werte m√∂glich.  
  
 Die Konvertierung eines <xref:System.Single> Werts in eine <xref:System.Double> ist eine erweiternde Konvertierung. Die Konvertierung kann zu einem Genauigkeits Verlust f√ºhren, wenn der <xref:System.Double> Typ nicht √ºber eine exakte Darstellung f√ºr den <xref:System.Single> Wert verf√ºgt.  
  
 Die Konvertierung eines <xref:System.Single> Werts in einen beliebigen primitiven numerischen Datentyp als ein <xref:System.Double> ist eine einschr√§nkende Konvertierung und erfordert einen Cast Operator (in C#) oder eine Konvertierungsmethode (in Visual Basic). Werte, die sich au√üerhalb des Bereichs des Ziel Datentyps befinden, der durch die Eigenschaften `MinValue` und `MaxValue` des Zieltyps definiert wird, Verhalten sich wie in der folgenden Tabelle gezeigt.  
  
|Zieltyp|Ergebnis|  
|-----------------|------------|  
|Beliebige ganzzahlige Typen|Eine <xref:System.OverflowException> Ausnahme, wenn die Konvertierung in einem √ºberpr√ºften Kontext erfolgt.<br /><br /> Wenn die Konvertierung in einem nicht √ºberpr√ºften Kontext erfolgt (der C#Standardwert in), wird der Konvertierungs Vorgang erfolgreich ausgef√ºhrt, der Wert wird jedoch √ºberlaufen.|  
|<xref:System.Decimal>|Eine <xref:System.OverflowException> Ausnahme,|  
  
 <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>und <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> l√∂sen au√üerdem eine <xref:System.OverflowException> f√ºr Konvertierungen in ganze Zahlen in einem √ºberpr√ºften Kontext aus, diese Werte √ºberschreiten jedoch bei der Konvertierung in ganze Zahlen in einem nicht √ºberpr√ºften Kontext einen √úberlauf. Bei Konvertierungen in <xref:System.Decimal>wird immer ein <xref:System.OverflowException>ausgel√∂st. Konvertierung in <xref:System.Double>, sie konvertieren in <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, und <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>bzw.  
  
 Beachten Sie, dass ein Genauigkeits Verlust m√∂glicherweise durch die <xref:System.Single>-Wert in einen anderen numerischen Typ verursacht wird. Wenn nicht integrale <xref:System.Single> Werte konvertiert werden, wie die Ausgabe des Beispiels zeigt, geht die Dezimalstelle verloren, wenn der <xref:System.Single> Wert entweder gerundet wird (wie in Visual Basic) oder abgeschnitten wird (wie in C#). Bei Konvertierungen in <xref:System.Decimal> Werte hat der <xref:System.Single> Wert m√∂glicherweise keine genaue Darstellung im Ziel Datentyp.  
  
 Im folgenden Beispiel wird eine Anzahl von <xref:System.Single> Werten in mehrere andere numerische Typen konvertiert. Die Konvertierungen erfolgen in einem √ºberpr√ºften Kontext in Visual Basic (Standardeinstellung) C# und in (aufgrund des [gepr√ºften](~/docs/csharp/language-reference/keywords/checked.md) Schl√ºssel Worts). Die Ausgabe aus dem Beispiel zeigt das Ergebnis f√ºr Konvertierungen in einem √ºberpr√ºften, nicht √ºberpr√ºften Kontext. Sie k√∂nnen Konvertierungen in einem nicht √ºberpr√ºften Kontext in Visual Basic ausf√ºhren, indem Sie mit dem `/removeintchecks+` C# -Compilerschalter und in durch Kompilieren der `checked`-Anweisung kompilieren.  
  
 [!code-csharp[System.Single.Structure#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/convert2.cs#21)]
 [!code-vb[System.Single.Structure#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/convert2.vb#21)]  
  
 Weitere Informationen zur Konvertierung numerischer Typen finden Sie unter [Typkonvertierung in den .NET Framework](~/docs/standard/base-types/type-conversion.md) -und [Typkonvertierungs Tabellen](~/docs/standard/base-types/conversion-tables.md).  
  
<a name="Functionality"></a>   
## <a name="floating-point-functionality"></a>Gleit Komma Funktionen  
 Die <xref:System.Single> Struktur und verwandte Typen stellen Methoden bereit, mit denen die folgenden Vorgangs Kategorien durchgef√ºhrt werden k√∂nnen:  
  
-   **Vergleich von-Werten**. Sie k√∂nnen die <xref:System.Single.Equals%2A>-Methode aufzurufen, um zu bestimmen, ob zwei <xref:System.Single> Werte gleich sind, oder die <xref:System.Single.CompareTo%2A>-Methode, um die Beziehung zwischen zwei Werten zu bestimmen.  
  
     Die <xref:System.Single>-Struktur unterst√ºtzt auch einen kompletten Satz von Vergleichs Operatoren. Beispielsweise k√∂nnen Sie auf Gleichheit oder Ungleichheit testen oder feststellen, ob ein Wert gr√∂√üer oder gleich einem anderen Wert ist. Wenn einer der Operanden eine <xref:System.Double>ist, wird der <xref:System.Single> Wert vor der Durchf√ºhrung des Vergleichs in eine <xref:System.Double> konvertiert. Wenn einer der Operanden ein ganzzahliger Typ ist, wird er vor der Durchf√ºhrung des Vergleichs in eine <xref:System.Single> konvertiert. Obwohl es sich um erweiternde Konvertierungen handelt, kann dies zu einem Genauigkeits Verlust f√ºhren.  
  
    > [!WARNING]
    >  Aufgrund von Unterschieden in der Genauigkeit k√∂nnen zwei <xref:System.Single> Werte, die erwartet werden, sich als ungleich erweisen. Dies wirkt sich auf das Ergebnis des Vergleichs aus. Weitere Informationen zum Vergleichen von zwei <xref:System.Single> Werten finden Sie im Abschnitt [Tests f√ºr Gleichheit](#Equality) .  
  
     Sie k√∂nnen auch die Methoden <xref:System.Single.IsNaN%2A>, <xref:System.Single.IsInfinity%2A>, <xref:System.Single.IsPositiveInfinity%2A>und <xref:System.Single.IsNegativeInfinity%2A> aufzurufen, um diese speziellen Werte zu testen.  
  
-   **Mathematische Vorg√§nge**. G√§ngige arithmetische Operationen wie Addition, Subtraktion, Multiplikation und Division werden von sprach Compilern und Common Intermediate Language-Anweisungen (CIL) anstelle von <xref:System.Single> Methoden implementiert. Wenn der andere Operand in einer mathematischen Operation ein <xref:System.Double>ist, wird der <xref:System.Single> vor dem Ausf√ºhren des Vorgangs in eine <xref:System.Double> konvertiert, und das Ergebnis des Vorgangs ist ebenfalls ein <xref:System.Double> Wert. Wenn der andere Operand ein ganzzahliger Typ ist, wird er vor dem Ausf√ºhren des Vorgangs in eine <xref:System.Single> konvertiert, und das Ergebnis des Vorgangs ist ebenfalls ein <xref:System.Single> Wert.  
  
     Sie k√∂nnen andere mathematische Vorg√§nge durchf√ºhren, indem Sie `static` (`Shared` in Visual Basic)-Methoden in der <xref:System.Math?displayProperty=nameWithType>-Klasse aufrufen. Dazu z√§hlen zus√§tzliche Methoden, die h√§ufig f√ºr arithmetische (z. b. <xref:System.Math.Abs%2A?displayProperty=nameWithType>, <xref:System.Math.Sign%2A?displayProperty=nameWithType>und <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>), Geometrie (z. b. <xref:System.Math.Cos%2A?displayProperty=nameWithType> und <xref:System.Math.Sin%2A?displayProperty=nameWithType>) und Berechnungen (z. b. <xref:System.Math.Log%2A?displayProperty=nameWithType>) verwendet werden.  In allen F√§llen wird der <xref:System.Single> Wert in einen <xref:System.Double>konvertiert.  
  
     Sie k√∂nnen auch die einzelnen Bits in einem <xref:System.Single> Wert bearbeiten. Die <xref:System.BitConverter.GetBytes%28System.Single%29?displayProperty=nameWithType>-Methode gibt das Bitmuster in einem Bytearray zur√ºck.  Wenn Sie dieses Bytearray an die <xref:System.BitConverter.ToInt32%2A?displayProperty=nameWithType>-Methode √ºbergeben, k√∂nnen Sie auch das Bitmuster des <xref:System.Single> Werts in einer 32-Bit-Ganzzahl beibehalten.  
  
-   **Rundung**. Die Rundung wird h√§ufig als Technik zum Verringern der Auswirkung von Unterschieden zwischen Werten verwendet, die durch Probleme mit der Gleit Komma Darstellung und-Genauigkeit verursacht werden. Sie k√∂nnen einen <xref:System.Single> Wert Runden, indem Sie die <xref:System.Math.Round%2A?displayProperty=nameWithType>-Methode aufrufen. Beachten Sie jedoch, dass der <xref:System.Single> Wert vor dem Aufrufen der-Methode in eine <xref:System.Double> konvertiert wird, und die Konvertierung kann einen Genauigkeits Verlust einschlie√üen.  
  
-   **Formatierung**. Sie k√∂nnen einen <xref:System.Single> Wert in seine Zeichen folgen Darstellung konvertieren, indem Sie die <xref:System.Single.ToString%2A>-Methode aufrufen oder die Funktion f√ºr die [kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) verwenden. Informationen dazu, wie Format Zeichenfolgen die Zeichen folgen Darstellung von Gleit Komma Werten steuern, finden Sie in den Themen [Standard Format](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen f√ºr Zahlen und [benutzerdefinierte Zahlenformat](~/docs/standard/base-types/custom-numeric-format-strings.md) Zeichenfolgen.  
  
-   Zeichen folgen werden **verarbeitet.** Sie k√∂nnen die Zeichen folgen Darstellung eines Gleit Komma Werts in einen <xref:System.Single> Wert konvertieren, indem Sie die <xref:System.Single.Parse%2A>-oder <xref:System.Single.TryParse%2A>-Methode aufrufen. Wenn der Analyse Vorgang fehlschl√§gt, l√∂st die <xref:System.Single.Parse%2A> Methode eine Ausnahme aus, w√§hrend die <xref:System.Single.TryParse%2A> Methode `false`zur√ºckgibt.  
  
-   **Typkonvertierung**. Die <xref:System.Single>-Struktur stellt eine explizite Schnittstellen Implementierung f√ºr die <xref:System.IConvertible>-Schnittstelle bereit, die die Konvertierung zwischen zwei Datentypen vom Typ Standard .NET Framework unterst√ºtzt. Sprach Compiler unterst√ºtzen auch die implizite Konvertierung von Werten f√ºr alle anderen numerischen Standardtypen, mit Ausnahme der Konvertierung von <xref:System.Double> in <xref:System.Single> Werte. Die Konvertierung eines Werts eines beliebigen standardm√§√üigen numerischen Typs als einer <xref:System.Double> in eine <xref:System.Single> ist eine erweiternde Konvertierung und erfordert nicht die Verwendung eines Umwandlungs Operators oder einer Konvertierungsmethode.  
  
     Die Konvertierung von ganzzahligen 32-Bit-und 64-Bit-Werten kann jedoch einen Genauigkeits Verlust beinhalten. In der folgenden Tabelle sind die Unterschiede in der Genauigkeit f√ºr 32-Bit-, 64-Bit-und <xref:System.Double> Typen aufgef√ºhrt:  
  
    |Typ|Maximale Genauigkeit (in Dezimalziffern)|Interne Genauigkeit (in Dezimalziffern)|  
    |----------|---------------------------------------------|----------------------------------------------|  
    |<xref:System.Double>|15|17|  
    |<xref:System.Int32> und <xref:System.UInt32>|10|10|  
    |<xref:System.Int64> und <xref:System.UInt64>|19|19|  
    |<xref:System.Single>|7|9|  
  
     Das Problem der Genauigkeit wirkt sich am h√§ufigsten auf <xref:System.Single> Werte aus, die in <xref:System.Double> Werte konvertiert werden. Im folgenden Beispiel sind zwei Werte, die von identischen Divisions Vorg√§ngen erzeugt werden, ungleich, da einer der-Werte ein Gleit Komma Wert mit einfacher Genauigkeit ist, der in einen <xref:System.Double>konvertiert wird.  
  
     [!code-csharp[System.Single.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Single.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/precisionlist1.vb#5)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Alle Member dieses Typs sind Thread sicher. Member, die scheinbar den Instanzzustand √§ndern, geben tats√§chlich eine neue Instanz zur√ºck, die mit dem neuen Wert initialisiert wurde. Wie bei jedem anderen Typ muss das Lesen und Schreiben in eine freigegebene Variable, die eine Instanz dieses Typs enth√§lt, durch eine Sperre gesch√ºtzt werden, um die Thread Sicherheit zu gew√§hrleisten.</threadsafe>
    <altmember cref="T:System.Decimal" />
    <altmember cref="T:System.Double" />
  </Docs>
  <Members>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Vergleicht diese Instanz mit einem angegebenen Objekt oder mit einer anderen <see cref="T:System.Single" />-Instanz und gibt eine ganze Zahl zur√ºck, die angibt, ob der Wert dieser Instanz kleiner oder gr√∂√üer als der Wert des angegebenen Objekts bzw. der anderen <see cref="T:System.Single" />-Instanz ist oder mit diesem √ºbereinstimmt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="single.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value">Ein Vergleichsobjekt oder <see langword="null" />.</param>
        <summary>Vergleicht diese Instanz mit einem angegebenen Objekt und gibt eine ganze Zahl zur√ºck, die angibt, ob der Wert dieser Instanz kleiner oder gr√∂√üer als der Wert des angegebenen Objekts ist oder mit diesem √ºbereinstimmt.</summary>
        <returns>Eine Zahl mit Vorzeichen, die das Verh√§ltnis zwischen dem Wert dieser Instanz und <paramref name="value" /> angibt.  
  
 <list type="table"><listheader><term> R√ºckgabewert 
 </term><description> Beschreibung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description> Diese Instanz ist kleiner als <paramref name="value" />.  
  
- oder - 
Diese Instanz ist keine Zahl (<see cref="F:System.Single.NaN" />), und <paramref name="value" /> ist eine Zahl.  
  
 </description></item><item><term> Null 
 </term><description> Diese Instanz ist gleich <paramref name="value" />.  
  
- oder - 
Diese Instanz und value sind beide keine Zahl (<see cref="F:System.Single.NaN" />), <see cref="F:System.Single.PositiveInfinity" /> oder <see cref="F:System.Single.NegativeInfinity" />.  
  
 </description></item><item><term> Gr√∂√üer als 0 (null) 
 </term><description> Diese Instanz ist gr√∂√üer als <paramref name="value" />.  
  
- oder - 
Diese Instanz ist eine Zahl, und <paramref name="value" /> ist keine Zahl (<see cref="F:System.Single.NaN" />).  
  
- oder - 
 <paramref name="value" /> ist <see langword="null" />  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `value`-Parameter muss `null` oder eine Instanz von <xref:System.Single>sein. Andernfalls wird eine Ausnahme ausgel√∂st. Jede Instanz von <xref:System.Single>unabh√§ngig von ihrem Wert als gr√∂√üer als `null`.  
  
 Werte m√ºssen identisch sein, damit Sie als gleich betrachtet werden. Insbesondere wenn Gleit Komma Werte von mehreren mathematischen Operationen abh√§ngen, ist es √ºblich, dass Sie Genauigkeit verlieren und ihre Werte nahezu identisch sind, mit Ausnahme der am wenigsten signifikanten Ziffern. Aus diesem Grund erscheint der R√ºckgabewert der <xref:System.Single.CompareTo%2A>-Methode m√∂glicherweise manchmal √ºberraschend. Beispielsweise sollte die Multiplikation mit einem bestimmten Wert, gefolgt von der Division durch denselben Wert, den urspr√ºnglichen Wert (im folgenden Beispiel) ergeben, aber der berechnete Wert ist gr√∂√üer als der urspr√ºngliche Wert. Wenn alle signifikanten Ziffern der beiden Werte mithilfe der [standardm√§√üigen numerischen Format Zeichenfolge](~/docs/standard/base-types/standard-numeric-format-strings.md) "R" angezeigt werden, wird angegeben, dass der berechnete Wert vom urspr√ºnglichen Wert in den geringsten Ziffern abweicht. Weitere Informationen zur Behandlung solcher Vergleiche finden Sie im Abschnitt "Hinweise" der <xref:System.Single.Equals%28System.Single%29>-Methode.  
  
 [!code-csharp[System.Single.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.compareto/cs/compareto3.cs#2)]
 [!code-vb[System.Single.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.compareto/vb/compareto3.vb#2)]  
  
 Diese Methode wird implementiert, um die <xref:System.IComparable>-Schnittstelle zu unterst√ºtzen. Beachten Sie Folgendes: Obwohl eine <xref:System.Single.NaN> nicht als gleich einer anderen <xref:System.Single.NaN> betrachtet wird, erfordert die <xref:System.IComparable>-Schnittstelle, dass `A.CompareTo(A)` 0 (null) zur√ºckgibt.  
  
## <a name="precision-in-comparisons"></a>Genauigkeit in vergleichen  
 Die Genauigkeit von Gleit Komma Zahlen jenseits der dokumentierten Genauigkeit ist spezifisch f√ºr die Implementierung und die Version der .NET Framework. Folglich kann sich ein Vergleich zweier bestimmter Zahlen zwischen den Versionen der .NET Framework √§ndern, da sich die Genauigkeit der internen Darstellung der Zahlen √§ndern kann.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Single.CompareTo%2A>-Methode veranschaulicht.  
  
 [!code-cpp[System.Single#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#16)]
 [!code-csharp[System.Single#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#16)]
 [!code-vb[System.Single#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> ist keine <see cref="T:System.Single" />.</exception>
        <altmember cref="M:System.Single.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.CompareTo(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Single) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(float value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : single -&gt; int&#xA;override this.CompareTo : single -&gt; int" Usage="single.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Eine Gleitkommazahl mit einfacher Genauigkeit, mit der der Vergleich erfolgen soll.</param>
        <summary>Vergleicht diese Instanz mit einer angegebenen Gleitkommazahl mit einfacher Genauigkeit und gibt eine ganze Zahl zur√ºck, die angibt, ob der Wert dieser Instanz kleiner oder gr√∂√üer als der Wert der angegebenen Gleitkommazahl mit einfacher Genauigkeit ist oder mit dieser √ºbereinstimmt.</summary>
        <returns>Eine Zahl mit Vorzeichen, die das Verh√§ltnis zwischen dem Wert dieser Instanz und <paramref name="value" /> angibt.  
  
 <list type="table"><listheader><term> R√ºckgabewert 
 </term><description> Beschreibung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description> Diese Instanz ist kleiner als <paramref name="value" />.  
  
- oder - 
Diese Instanz ist keine Zahl (<see cref="F:System.Single.NaN" />), und <paramref name="value" /> ist eine Zahl.  
  
 </description></item><item><term> Null 
 </term><description> Diese Instanz ist gleich <paramref name="value" />.  
  
- oder - 
Sowohl diese Instanz als auch <paramref name="value" /> sind keine Zahl (<see cref="F:System.Single.NaN" />), <see cref="F:System.Single.PositiveInfinity" />, oder <see cref="F:System.Single.NegativeInfinity" />.  
  
 </description></item><item><term> Gr√∂√üer als 0 (null) 
 </term><description> Diese Instanz ist gr√∂√üer als <paramref name="value" />.  
  
- oder - 
Diese Instanz ist eine Zahl, und <paramref name="value" /> ist keine Zahl (<see cref="F:System.Single.NaN" />).  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Werte m√ºssen identisch sein, damit Sie als gleich betrachtet werden. Es kommt h√§ufig vor, dass Gleit Komma Werte Genauigkeit verlieren und nahezu identisch sind, mit Ausnahme der am wenigsten signifikanten Ziffern, insbesondere dann, wenn die Werte von mehreren mathematischen Operationen abh√§ngen. Aus diesem Grund mag der R√ºckgabewert der <xref:System.Single.CompareTo%2A>-Methode zu Zeiten √ºberraschend erscheinen. Beispielsweise sollte durch Multiplikation durch einen beliebigen Wert, gefolgt von der Division durch denselben Wert, der urspr√ºngliche Wert erzeugt werden. Im folgenden Beispiel erweist sich der berechnete Wert jedoch als gr√∂√üer als der urspr√ºngliche Wert. Wenn alle signifikanten Ziffern der beiden Werte mithilfe der [standardm√§√üigen numerischen Format Zeichenfolge](~/docs/standard/base-types/standard-numeric-format-strings.md) "R" angezeigt werden, wird angegeben, dass der berechnete Wert vom urspr√ºnglichen Wert in den geringsten Ziffern abweicht. Weitere Informationen zur Behandlung solcher Vergleiche finden Sie im Abschnitt "Hinweise" der <xref:System.Single.Equals%28System.Single%29>-Methode.  
  
 [!code-csharp[System.Single.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.compareto/cs/compareto2.cs#1)]
 [!code-vb[System.Single.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.compareto/vb/compareto2.vb#1)]  
  
 Diese Methode implementiert die <xref:System.IComparable%601?displayProperty=nameWithType>-Schnittstelle und bietet eine etwas bessere Leistung als die <xref:System.Single.CompareTo%2A?displayProperty=nameWithType>-Methode, da der `value`-Parameter nicht in ein-Objekt konvertiert werden muss.  
  
 Beachten Sie, dass ein Objekt, dessen Wert <xref:System.Single.NaN> ist, nicht gleich einem anderen Objekt ist, dessen Wert <xref:System.Single.NaN> (selbst) ist, die <xref:System.IComparable%601>-Schnittstelle erfordert, dass `A.CompareTo(A)` 0 (null) zur√ºckgibt.  
  
## <a name="widening-conversions"></a>Erweiternde Konvertierungen  
 Abh√§ngig von ihrer Programmiersprache kann es m√∂glich sein, eine <xref:System.Single.CompareTo%2A> Methode zu codieren, bei der der Parametertyp weniger Bits (ist schmaler) als der Instanztyp aufweist. Dies ist m√∂glich, weil einige Programmiersprachen eine implizite erweiternde Konvertierung durchf√ºhren, die den Parameter als Typ mit so vielen Bits wie die Instanz darstellt.  
  
 Angenommen, der Instanztyp ist <xref:System.Single>, und der Parametertyp ist <xref:System.Int32>. Der Microsoft C# -Compiler generiert Anweisungen, um den Wert des Parameters als <xref:System.Single> Objekt darzustellen, und generiert dann eine <xref:System.Single.CompareTo%28System.Single%29?displayProperty=nameWithType> Methode, die die Werte der Instanz und die erweiterte Darstellung des Parameters vergleicht.  
  
 √úberpr√ºfen Sie die Dokumentation der Programmiersprache, um zu bestimmen, ob der Compiler implizite erweiternde Konvertierungen numerischer Typen durchf√ºhrt. Weitere Informationen finden Sie im Thema [Typkonvertierungs Tabellen](~/docs/standard/base-types/conversion-tables.md) .  
  
## <a name="precision-in-comparisons"></a>Genauigkeit in vergleichen  
 Die Genauigkeit von Gleit Komma Zahlen jenseits der dokumentierten Genauigkeit ist spezifisch f√ºr die Implementierung und die Version der .NET Framework. Folglich kann sich ein Vergleich zweier bestimmter Zahlen zwischen den Versionen der .NET Framework √§ndern, da sich die Genauigkeit der internen Darstellung der Zahlen √§ndern kann.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden generische und nicht generische Versionen der <xref:System.Single.CompareTo%2A>-Methode f√ºr verschiedene Wert-und Verweis Typen veranschaulicht.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Epsilon">
      <MemberSignature Language="C#" Value="public const float Epsilon = 1.401298E-45;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 Epsilon = float32(1.401298E-45)" />
      <MemberSignature Language="DocId" Value="F:System.Single.Epsilon" />
      <MemberSignature Language="VB.NET" Value="Public Const Epsilon As Single  = 1.401298E-45" />
      <MemberSignature Language="C++ CLI" Value="public: float Epsilon = 1.401298E-45;" />
      <MemberSignature Language="F#" Value="val mutable Epsilon : single" Usage="System.single.Epsilon" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>1.401298E-45</MemberValue>
      <Docs>
        <summary>Stellt den kleinsten positiven <see cref="T:System.Single" />-Wert dar, der gr√∂√üer als 0 (null) ist. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert der <xref:System.Single.Epsilon>-Eigenschaft gibt den kleinsten positiven <xref:System.Single> Wert wieder, der bei numerischen Vorg√§ngen oder Vergleichen von Bedeutung ist, wenn der Wert der <xref:System.Single> Instanz 0 (null) ist. Der folgende Code zeigt z. b., dass NULL und <xref:System.Single.Epsilon> als ungleich Werte angesehen werden, wohingegen NULL und die H√§lfte des Werts <xref:System.Single.Epsilon> als gleich betrachtet werden.  
  
 [!code-csharp[System.Single.Epsilon#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/epsilon.cs#5)]
 [!code-vb[System.Single.Epsilon#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/epsilon.vb#5)]  
  
 Genauer gesehen besteht das Gleit Komma Format mit einfacher Genauigkeit aus einem Vorzeichen, einer 23-Bit-Mantisse oder einem signifikanten und einem 8-Bit-Exponenten. Wie das folgende Beispiel zeigt, hat null einen Exponenten von-126 und eine Mantisse von 0. <xref:System.Single.Epsilon> hat einen Exponenten von-126 und eine Mantisse von 1. Dies bedeutet, dass <xref:System.Single.Epsilon?displayProperty=nameWithType> der kleinste positive <xref:System.Single> Wert gr√∂√üer als 0 (null) ist und den kleinsten m√∂glichen Wert und das kleinste m√∂gliche Inkrement f√ºr einen <xref:System.Single> darstellt, dessen Exponent-126 ist.  
  
 [!code-csharp[System.Single.Epsilon#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/epsilon1.cs#6)]
 [!code-vb[System.Single.Epsilon#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/epsilon1.vb#6)]  
  
 Die <xref:System.Single.Epsilon>-Eigenschaft ist jedoch kein allgemeines Ma√ü f√ºr die Genauigkeit des <xref:System.Single> Typs. Dies gilt nur f√ºr <xref:System.Single> Instanzen, die den Wert 0 (null) aufweisen.  
  
> [!NOTE]
>  Der Wert der <xref:System.Single.Epsilon>-Eigenschaft entspricht nicht dem Computer Epsilon, der die obere Grenze des relativen Fehlers darstellt, weil die Gleit Komma Arithmetik gerundet wird.  
  
 Der Wert dieser Konstante ist 1.4 e-45.  
  
 Zwei scheinbar √§quivalente Gleit Komma Zahlen k√∂nnen aufgrund von Unterschieden in den geringsten Ziffern nicht gleich sein. Beispielsweise vergleicht der C# Ausdruck `(float)1/3 == (float)0.33333`nicht gleich, da der Divisions Vorgang auf der linken Seite eine maximale Genauigkeit aufweist, w√§hrend die Konstante auf der rechten Seite nur f√ºr die angegebenen Ziffern pr√§zise ist. Wenn Sie einen benutzerdefinierten Algorithmus erstellen, der bestimmt, ob zwei Gleit Komma Zahlen als gleich betrachtet werden k√∂nnen, m√ºssen Sie einen Wert verwenden, der gr√∂√üer als die <xref:System.Single.Epsilon> Konstante ist, um die akzeptable absolute Differenz Spanne f√ºr die beiden Werte festzulegen, die als gleich betrachtet werden sollen. (In der Regel ist dieser Unterschieds Unterschied oft gr√∂√üer als <xref:System.Single.Epsilon>.)  
  
## <a name="platform-notes"></a>Hinweise zur Plattform  
 Auf ARM-Systemen ist der Wert der <xref:System.Single.Epsilon> Konstante zu klein, um erkannt zu werden, sodass er 0 (null) entspricht. Sie k√∂nnen stattdessen einen alternativen Epsilon-Wert definieren, der 1.175494351 e-38 gleich ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen Wert zur√ºck, der angibt, ob zwei Instanzen der <see cref="T:System.Single" />-Struktur denselben Wert darstellen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="single.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Ein Objekt, das mit dieser Instanz verglichen werden soll.</param>
        <summary>Gibt einen Wert zur√ºck, der angibt, ob diese Instanz mit einem angegebenen Objekt √ºbereinstimmt.</summary>
        <returns><see langword="true" />, wenn <paramref name="obj" /> eine Instanz von <see cref="T:System.Single" /> ist, deren Wert gleich dem Wert dieser Instanz ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Single.Equals%2A>-Methode sollte mit Bedacht verwendet werden, da zwei scheinbar √§quivalente Werte aufgrund der unterschiedlichen Genauigkeit der beiden Werte ungleich sein k√∂nnen. Im folgenden Beispiel wird berichtet, dass der <xref:System.Single> Wert. 3333 und die von Division 1 durch 3 zur√ºckgegebenen <xref:System.Single> ungleich sind.  
  
 [!code-csharp[System.Single.Epsilon#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#3)]
 [!code-vb[System.Single.Epsilon#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#3)]  
  
 Anstatt Vergleich, Gleichheit, eine empfohlene Verfahren besteht im Definieren einer zul√§ssigen Rand Unterschied zwischen zwei Werten (z. B. 01 % einer der Werte). Wenn der absolute Wert des Unterschieds zwischen den beiden Werten kleiner oder gleich diesem Rand ist, ist der Unterschied wahrscheinlich auf Unterschiede bei der Genauigkeit zur√ºckzuf√ºhren, und daher sind die Werte wahrscheinlich gleich. Im folgenden Beispiel wird diese Technik zum Vergleichen von. 33333 und 1/3 verwendet, die beiden <xref:System.Single> Werte, die im vorherigen Codebeispiel als ungleich festgestellt wurden.  
  
 [!code-csharp[System.Single.Epsilon#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#4)]
 [!code-vb[System.Single.Epsilon#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#4)]  
  
 In diesem Fall sind die Werte gleich.  
  
> [!NOTE]
>  Da <xref:System.Single.Epsilon> den minimalen Ausdruck eines positiven Werts definiert, dessen Bereich nahe 0 (null) liegt, muss die Differenz Spanne gr√∂√üer als <xref:System.Single.Epsilon>sein. In der Regel ist es oft gr√∂√üer als <xref:System.Single.Epsilon>.  
  
 Die Genauigkeit von Gleit Komma Zahlen jenseits der dokumentierten Genauigkeit ist spezifisch f√ºr die Implementierung und die Version der .NET Framework. Folglich kann sich ein Vergleich zweier bestimmter Zahlen zwischen den Versionen der .NET Framework √§ndern, da sich die Genauigkeit der internen Darstellung der Zahlen √§ndern kann.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Single.Equals%2A>-Methode veranschaulicht.  
  
 [!code-cpp[System.Single#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#17)]
 [!code-csharp[System.Single#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#17)]
 [!code-vb[System.Single#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#17)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Die Aufl√∂sung der compiler√ºberladung kann einen offensichtlichen Unterschied im Verhalten der beiden <see cref="M:System.Single.Equals(System.Object)" /> Methoden √úberladungen ber√ºcksichtigen. Wenn eine implizite Konvertierung zwischen dem <paramref name="obj" />-Argument und einem <see cref="T:System.Single" /> definiert ist und das-Argument nicht als <see cref="T:System.Object" />typisiert ist, k√∂nnen Compiler eine implizite Konvertierung durchf√ºhren und die <see cref="M:System.Single.Equals(System.Single)" />-Methode aufzurufen. Andernfalls wird die <see cref="M:System.Single.Equals(System.Object)" />-Methode aufgerufen, die immer <see langword="false" /> zur√ºckgibt, wenn das <paramref name="obj" />-Argument kein <see cref="T:System.Single" /> Wert ist. Das folgende Beispiel veranschaulicht den Unterschied im Verhalten zwischen den zwei Methoden √úberladungen. Bei allen primitiven numerischen Typen, mit Ausnahme von <see cref="T:System.Double" /> in Visual Basic und mit Ausnahme von <see cref="T:System.Decimal" /> und <see cref="T:System.Double" /> in C#, gibt der erste Vergleich <see langword="true" /> zur√ºck, da der Compiler automatisch eine erweiternde Konvertierung ausf√ºhrt und die <see cref="M:System.Single.Equals(System.Single)" />-Methode aufruft, w√§hrend der zweite Vergleich <see langword="false" /> zur√ºckgibt, da der Compiler die <see cref="M:System.Single.Equals(System.Object)" />-Methode aufruft.  
  
[! Code-csharp[System. Single. ist # 2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsoverl.cs#2)] [! Code-vb[System. Single. ist # 2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsoverl.vb#2)]</para></block>
        <altmember cref="M:System.Single.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (float obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(float32 obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Equals(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (obj As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(float obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : single -&gt; bool" Usage="single.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">Ein Objekt, das mit dieser Instanz verglichen werden soll.</param>
        <summary>Gibt einen Wert zur√ºck, der angibt, ob diese Instanz und ein angegebenes <see cref="T:System.Single" />-Objekt den gleichen Wert darstellen.</summary>
        <returns><see langword="true" />, wenn <paramref name="obj" /> gleich dieser Instanz ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode implementiert die <xref:System.IEquatable%601?displayProperty=nameWithType>-Schnittstelle und bietet eine etwas bessere Leistung als <xref:System.Single.Equals%2A>, da der `obj`-Parameter nicht in ein-Objekt konvertiert werden muss.  
  
## <a name="widening-conversions"></a>Erweiternde Konvertierungen  
 Abh√§ngig von ihrer Programmiersprache kann es m√∂glich sein, eine <xref:System.Single.Equals%2A> Methode zu codieren, bei der der Parametertyp weniger Bits (ist schmaler) als der Instanztyp aufweist. Dies ist m√∂glich, weil einige Programmiersprachen eine implizite erweiternde Konvertierung durchf√ºhren, die den Parameter als Typ mit so vielen Bits wie die Instanz darstellt.  
  
 Angenommen, der Instanztyp ist <xref:System.Single>, und der Parametertyp ist <xref:System.Int32>. Der Microsoft C# -Compiler generiert Anweisungen, um den Wert des Parameters als <xref:System.Single> Objekt darzustellen, und generiert dann eine <xref:System.Single.Equals%28System.Single%29?displayProperty=nameWithType> Methode, die die Werte der Instanz und die erweiterte Darstellung des Parameters vergleicht.  
  
 √úberpr√ºfen Sie die Dokumentation der Programmiersprache, um zu bestimmen, ob der Compiler implizite erweiternde Konvertierungen numerischer Typen durchf√ºhrt. Weitere Informationen finden Sie im Thema [Typkonvertierungs Tabellen](~/docs/standard/base-types/conversion-tables.md) .  
  
## <a name="precision-in-comparisons"></a>Genauigkeit in vergleichen  
 Die <xref:System.Single.Equals%2A>-Methode sollte mit Bedacht verwendet werden, da zwei scheinbar √§quivalente Werte aufgrund der unterschiedlichen Genauigkeit der beiden Werte ungleich sein k√∂nnen. Im folgenden Beispiel wird berichtet, dass der <xref:System.Single> Wert. 3333 und die von Division 1 durch 3 zur√ºckgegebenen <xref:System.Single> ungleich sind.  
  
 [!code-csharp[System.Single.Epsilon#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#1)]
 [!code-vb[System.Single.Epsilon#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#1)]  
  
 Eine Vergleichsmethode, der vermeidet Probleme im Zusammenhang mit Vergleich f√ºr Gleichheit umfasst eine akzeptable Rand Unterschied zwischen zwei Werten definieren (z. B. 01 % einer der Werte). Wenn der absolute Wert des Unterschieds zwischen den beiden Werten kleiner oder gleich diesem Rand ist, ist der Unterschied wahrscheinlich ein Ergebnis der Genauigkeits Unterschiede, und die Werte sind daher wahrscheinlich gleich. Im folgenden Beispiel wird dieses Verfahren zum Vergleichen von. 33333 und 1/3 verwendet, bei denen es sich um die beiden <xref:System.Single> Werte handelt, die im vorherigen Codebeispiel als ungleich festgestellt wurden.  
  
 [!code-csharp[System.Single.Epsilon#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#2)]
 [!code-vb[System.Single.Epsilon#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#2)]  
  
 In diesem Fall sind die Werte gleich.  
  
> [!NOTE]
>  Da <xref:System.Single.Epsilon> den minimalen Ausdruck eines positiven Werts definiert, dessen Bereich nahe 0 (null) liegt, muss die Differenz Spanne gr√∂√üer als <xref:System.Single.Epsilon>sein. In der Regel ist es oft gr√∂√üer als <xref:System.Single.Epsilon>. Aus diesem Grund wird empfohlen, dass Sie beim Vergleichen <xref:System.Double> Werte auf Gleichheit <xref:System.Double.Epsilon> nicht verwenden.  
  
 Ein zweites Verfahren, das die Probleme im Zusammenhang mit dem Vergleich auf Gleichheit vermeidet, besteht darin, den Unterschied zwischen zwei Gleit Komma Zahlen mit einem absoluten Wert zu vergleichen. Wenn die Differenz kleiner oder gleich dem absoluten Wert ist, sind die Zahlen gleich. Wenn Sie gr√∂√üer ist, sind die Zahlen nicht gleich. Eine M√∂glichkeit besteht darin, willk√ºrlich einen absoluten Wert auszuw√§hlen. Dies ist jedoch problematisch, da eine akzeptable Differenz Spanne von der Gr√∂√üe der <xref:System.Single> Werte abh√§ngt. Eine zweite M√∂glichkeit nutzt eine Entwurfs Funktion des Gleit Komma Formats: der Unterschied zwischen den Mantisse-Komponenten in den ganzzahligen Darstellungen von zwei Gleit Komma Werten gibt die Anzahl m√∂glicher Gleit Komma Werte an, die die beiden Werte trennen. Beispielsweise ist der Unterschied zwischen 0,0 und <xref:System.Single.Epsilon> 1, da <xref:System.Single.Epsilon> der kleinste darstellbare Wert ist, wenn Sie mit einer <xref:System.Single> arbeiten, deren Wert 0 (null) ist. Im folgenden Beispiel wird dieses Verfahren zum Vergleichen von. 33333 und 1/3 verwendet, bei denen es sich um die beiden <xref:System.Double> Werte handelt, die das vorherige Codebeispiel mit der <xref:System.Single.Equals%28System.Single%29>-Methode als ungleich gefunden hat. Beachten Sie, dass im Beispiel die Methoden <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> und <xref:System.BitConverter.ToInt32%2A?displayProperty=nameWithType> verwendet werden, um einen Gleit Komma Wert mit einfacher Genauigkeit in seine ganzzahlige Darstellung zu konvertieren.  
  
 [!code-csharp[System.Single.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsabs1.cs#1)]
 [!code-vb[System.Single.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsabs1.vb#1)]  
  
 Die Genauigkeit von Gleit Komma Zahlen jenseits der dokumentierten Genauigkeit ist spezifisch f√ºr die Implementierung und die Version der .NET Framework. Folglich kann ein Vergleich zweier Zahlen abh√§ngig von der Version des .NET Framework zu unterschiedlichen Ergebnissen f√ºhren, da sich die Genauigkeit der internen Darstellung der Zahlen √§ndern kann.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Die Aufl√∂sung der compiler√ºberladung kann einen offensichtlichen Unterschied im Verhalten der beiden <see cref="M:System.Single.Equals(System.Object)" /> Methoden √úberladungen ber√ºcksichtigen. Wenn eine implizite Konvertierung zwischen dem <paramref name="obj" />-Argument und einem <see cref="T:System.Single" /> definiert ist und das-Argument nicht als <see cref="T:System.Object" />typisiert ist, k√∂nnen Compiler eine implizite Konvertierung durchf√ºhren und die <see cref="M:System.Single.Equals(System.Single)" />-Methode aufzurufen. Andernfalls wird die <see cref="M:System.Single.Equals(System.Object)" />-Methode aufgerufen, die immer <see langword="false" /> zur√ºckgibt, wenn das <paramref name="obj" />-Argument kein <see cref="T:System.Single" /> Wert ist. Das folgende Beispiel veranschaulicht den Unterschied im Verhalten zwischen den zwei Methoden √úberladungen. Bei allen primitiven numerischen Typen, mit Ausnahme von <see cref="T:System.Double" /> in Visual Basic und mit Ausnahme von <see cref="T:System.Decimal" /> und <see cref="T:System.Double" /> in C#, gibt der erste Vergleich <see langword="true" /> zur√ºck, da der Compiler automatisch eine erweiternde Konvertierung ausf√ºhrt und die <see cref="M:System.Single.Equals(System.Single)" />-Methode aufruft, w√§hrend der zweite Vergleich <see langword="false" /> zur√ºckgibt, da der Compiler die <see cref="M:System.Single.Equals(System.Object)" />-Methode aufruft.  
  
[! Code-csharp[System. Single. ist # 2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsoverl.cs#2)] [! Code-vb[System. Single. ist # 2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsoverl.vb#2)]</para></block>
        <altmember cref="M:System.Single.Equals(System.Object)" />
        <altmember cref="Overload:System.Single.CompareTo" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="single.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hashcode f√ºr diese Instanz zur√ºck.</summary>
        <returns>Ein Hashcode in Form einer 32-Bit-Ganzzahl mit Vorzeichen.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="single.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den <see cref="T:System.TypeCode" /> f√ºr den Werttyp <see cref="T:System.Single" /> zur√ºck.</summary>
        <returns>Die Enumerationskonstante <see cref="F:System.TypeCode.Single" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.TypeCode" />
      </Docs>
    </Member>
    <Member MemberName="IsFinite">
      <MemberSignature Language="C#" Value="public static bool IsFinite (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsFinite(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsFinite(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFinite (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFinite(float f);" />
      <MemberSignature Language="F#" Value="static member IsFinite : single -&gt; bool" Usage="System.single.IsFinite f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="f">Eine Gleitkommazahl mit einfacher Genauigkeit.</param>
        <summary>Bestimmt, ob der angegebene Wert endlich ist (Null, subnormal oder normal).</summary>
        <returns><see langword="true" />, wenn der angegebene Wert endlich ist (Null, subnormal oder normal); sonst <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInfinity(float f);" />
      <MemberSignature Language="F#" Value="static member IsInfinity : single -&gt; bool" Usage="System.single.IsInfinity f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Eine Gleitkommazahl mit einfacher Genauigkeit.</param>
        <summary>Gibt einen Wert zur√ºck, der angibt, ob der Wert der angegebenen Zahl -unendlich oder +unendlich ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="f" /> entweder <see cref="F:System.Single.PositiveInfinity" /> oder <see cref="F:System.Single.NegativeInfinity" /> ergibt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gleit Komma Operationen geben <xref:System.Single.PositiveInfinity> oder <xref:System.Single.NegativeInfinity> zur√ºck, um eine √úberlauf Bedingung zu signalisieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Single.IsInfinity%2A>-Methode veranschaulicht.  
  
 [!code-cpp[System.Single#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#11)]
 [!code-csharp[System.Single#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#11)]
 [!code-vb[System.Single#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNaN(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNaN (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNaN(float f);" />
      <MemberSignature Language="F#" Value="static member IsNaN : single -&gt; bool" Usage="System.single.IsNaN f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Eine Gleitkommazahl mit einfacher Genauigkeit.</param>
        <summary>Gibt einen Wert zur√ºck, der angibt, ob der angegebene Wert keine Zahl ist (<see cref="F:System.Single.NaN" />).</summary>
        <returns><see langword="true" />, wenn <paramref name="f" /> Not-a-Number (<see cref="F:System.Single.NaN" />) ergibt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gleit Komma Vorg√§nge geben <xref:System.Single.NaN> zur√ºck, um zu signalisieren, dass das Ergebnis des Vorgangs nicht definiert ist. Beispielsweise f√ºhrt die Division von 0,0 durch 0,0 zu <xref:System.Single.NaN>.  
  
> [!NOTE]
>  <xref:System.Single.IsNaN%2A> gibt `false` zur√ºck, wenn ein <xref:System.Single> Wert entweder <xref:System.Single.PositiveInfinity> oder <xref:System.Single.NegativeInfinity>ist. Um diese Werte zu testen, verwenden Sie die Methoden <xref:System.Single.IsInfinity%2A>, <xref:System.Single.IsPositiveInfinity%2A>und <xref:System.Single.IsNegativeInfinity%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Single.IsNaN%2A>-Methode veranschaulicht.  
  
 [!code-cpp[System.Single#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#8)]
 [!code-csharp[System.Single#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#8)]
 [!code-vb[System.Single#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.NaN" />
      </Docs>
    </Member>
    <Member MemberName="IsNegative">
      <MemberSignature Language="C#" Value="public static bool IsNegative (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegative(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNegative(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegative (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegative(float f);" />
      <MemberSignature Language="F#" Value="static member IsNegative : single -&gt; bool" Usage="System.single.IsNegative f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="f">Eine Gleitkommazahl mit einfacher Genauigkeit.</param>
        <summary>Bestimmt, ob der angegebene Wert negativ ist.</summary>
        <returns><see langword="true" />, falls negativ; sonst <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegativeInfinity">
      <MemberSignature Language="C#" Value="public static bool IsNegativeInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegativeInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNegativeInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegativeInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegativeInfinity(float f);" />
      <MemberSignature Language="F#" Value="static member IsNegativeInfinity : single -&gt; bool" Usage="System.single.IsNegativeInfinity f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Eine Gleitkommazahl mit einfacher Genauigkeit.</param>
        <summary>Gibt einen Wert zur√ºck, der angibt, ob die angegebene Zahl minus unendlich ergibt.</summary>
        <returns><see langword="true" />, wenn <paramref name="f" /><see cref="F:System.Single.NegativeInfinity" /> ergibt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gleit Komma Operationen geben <xref:System.Single.NegativeInfinity> zur√ºck, um eine √úberlauf Bedingung zu signalisieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Single.IsNegativeInfinity%2A>-Methode veranschaulicht.  
  
 [!code-cpp[System.Single#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#13)]
 [!code-csharp[System.Single#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#13)]
 [!code-vb[System.Single#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNormal">
      <MemberSignature Language="C#" Value="public static bool IsNormal (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNormal(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNormal(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNormal (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNormal(float f);" />
      <MemberSignature Language="F#" Value="static member IsNormal : single -&gt; bool" Usage="System.single.IsNormal f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="f">Eine Gleitkommazahl mit einfacher Genauigkeit.</param>
        <summary>Bestimmt, ob der angegebene Wert normal ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="f" /> normal ist; sonst <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPositiveInfinity">
      <MemberSignature Language="C#" Value="public static bool IsPositiveInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositiveInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsPositiveInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPositiveInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPositiveInfinity(float f);" />
      <MemberSignature Language="F#" Value="static member IsPositiveInfinity : single -&gt; bool" Usage="System.single.IsPositiveInfinity f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Eine Gleitkommazahl mit einfacher Genauigkeit.</param>
        <summary>Gibt einen Wert zur√ºck, der angibt, ob die angegebene Zahl plus unendlich ergibt.</summary>
        <returns><see langword="true" />, wenn <paramref name="f" /><see cref="F:System.Single.PositiveInfinity" /> ergibt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gleit Komma Operationen geben <xref:System.Single.PositiveInfinity> zur√ºck, um eine √úberlauf Bedingung zu signalisieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Single.IsPositiveInfinity%2A>-Methode veranschaulicht.  
  
 [!code-cpp[System.Single#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#12)]
 [!code-csharp[System.Single#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#12)]
 [!code-vb[System.Single#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsSubnormal">
      <MemberSignature Language="C#" Value="public static bool IsSubnormal (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSubnormal(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsSubnormal(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSubnormal (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSubnormal(float f);" />
      <MemberSignature Language="F#" Value="static member IsSubnormal : single -&gt; bool" Usage="System.single.IsSubnormal f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="f">Eine Gleitkommazahl mit einfacher Genauigkeit.</param>
        <summary>Bestimmt, ob der angegebene Wert subnormal ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="f" /> subnormal ist; sonst <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const float MaxValue = 3.40282347E+38;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 MaxValue = float32(3.40282347E+38)" />
      <MemberSignature Language="DocId" Value="F:System.Single.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxValue As Single  = 3.40282347E+38" />
      <MemberSignature Language="C++ CLI" Value="public: float MaxValue = 3.40282347E+38;" />
      <MemberSignature Language="F#" Value="val mutable MaxValue : single" Usage="System.single.MaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>3.40282347E+38</MemberValue>
      <Docs>
        <summary>Stellt den gr√∂√ütm√∂glichen Wert von <see cref="T:System.Single" /> dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Konstante ist positiv 3.40282347 e + 38.  
  
 Das Ergebnis eines Vorgangs, der die <xref:System.Single.MaxValue?displayProperty=nameWithType> √ºberschreitet, ist <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>. Im folgenden Beispiel <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> Ergebnisse aus Addition, Multiplikation und exponentiations Vorg√§ngen, wenn das Ergebnis <xref:System.Single.MaxValue?displayProperty=nameWithType>√ºberschreitet.  
  
 [!code-csharp[System.Single.MaxValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.maxvalue/cs/maxvalueex.cs#1)]
 [!code-vb[System.Single.MaxValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.maxvalue/vb/maxvalueex.vb#1)]  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Single.MaxValue> Konstante veranschaulicht.  
  
 [!code-cpp[System.Single#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#4)]
 [!code-csharp[System.Single#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#4)]
 [!code-vb[System.Single#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.MinValue" />
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const float MinValue = -3.40282347E+38;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 MinValue = float32(-3.40282347E+38)" />
      <MemberSignature Language="DocId" Value="F:System.Single.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MinValue As Single  = -3.40282347E+38" />
      <MemberSignature Language="C++ CLI" Value="public: float MinValue = -3.40282347E+38;" />
      <MemberSignature Language="F#" Value="val mutable MinValue : single" Usage="System.single.MinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>-3.40282347E+38</MemberValue>
      <Docs>
        <summary>Stellt den kleinstm√∂glichen Wert von <see cref="T:System.Single" /> dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Konstante ist "negative 3.402823 E38".  
  
 Das Ergebnis eines Vorgangs, der kleiner als <xref:System.Single.MinValue?displayProperty=nameWithType> ist, ist <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>. Im folgenden Beispiel <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> Ergebnisse aus Subtraktions-und Multiplikations Vorg√§ngen, wenn das Ergebnis kleiner als <xref:System.Single.MinValue?displayProperty=nameWithType>ist.  
  
 [!code-csharp[System.Single.MinValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.minvalue/cs/minvalueex.cs#1)]
 [!code-vb[System.Single.MinValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.minvalue/vb/minvalueex.vb#1)]  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Single.MinValue> Konstante veranschaulicht.  
  
 [!code-cpp[System.Single#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#5)]
 [!code-csharp[System.Single#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#5)]
 [!code-vb[System.Single#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.MaxValue" />
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public const float NaN = NaN;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 NaN = float32(NaN)" />
      <MemberSignature Language="DocId" Value="F:System.Single.NaN" />
      <MemberSignature Language="VB.NET" Value="Public Const NaN As Single  = NaN" />
      <MemberSignature Language="C++ CLI" Value="public: float NaN = NaN;" />
      <MemberSignature Language="F#" Value="val mutable NaN : single" Usage="System.single.NaN" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>NaN</MemberValue>
      <Docs>
        <summary>Stellt Not-a-Number (<see langword="NaN" />) dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Methode oder ein Operator gibt <xref:System.Single.NaN> zur√ºck, wenn das Ergebnis eines Vorgangs nicht definiert ist. Beispielsweise wird das Ergebnis der Division von NULL durch Null <xref:System.Single.NaN>, wie im folgenden Beispiel gezeigt. (Beachten Sie jedoch, dass die Division einer Zahl ungleich NULL durch Null entweder <xref:System.Single.PositiveInfinity> oder <xref:System.Single.NegativeInfinity>zur√ºckgibt, je nach Vorzeichen des Divisors.)  
  
 [!code-csharp[System.Single.NaN#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/nan1.cs#1)]
 [!code-vb[System.Single.NaN#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/nan1.vb#1)]  
  
 Au√üerdem gibt ein Methodenaufrufe mit einem <xref:System.Single.NaN> Wert oder einem Vorgang f√ºr einen <xref:System.Single.NaN> Wert <xref:System.Single.NaN>zur√ºck, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Single.NaN#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/nan1.cs#2)]
 [!code-vb[System.Single.NaN#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/nan1.vb#2)]  
  
 Verwenden Sie die <xref:System.Single.IsNaN%2A>-Methode, um zu bestimmen, ob ein Wert keine Zahl ist. Im Allgemeinen k√∂nnen <xref:System.Single>-Operatoren nicht zum Vergleichen von <xref:System.Single.NaN?displayProperty=nameWithType> mit anderen <xref:System.Single>-Werten verwendet werden, obwohl Vergleichsmethoden (z. b. <xref:System.Single.Equals%2A> und <xref:System.Single.CompareTo%2A>) m√∂glich sind. Das folgende Beispiel veranschaulicht den Unterschied im Verhalten zwischen <xref:System.Single> Vergleichs Operatoren und Methoden.  
  
 [!code-csharp[System.Single.NaN#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/single.nan4.cs#4)]
 [!code-vb[System.Single.NaN#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/single.nan4.vb#4)]  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Single.NaN> Konstante veranschaulicht.  
  
 [!code-cpp[System.Single#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#7)]
 [!code-csharp[System.Single#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#7)]
 [!code-vb[System.Single#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsNaN(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="NegativeInfinity">
      <MemberSignature Language="C#" Value="public const float NegativeInfinity = -Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 NegativeInfinity = float32(-Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Single.NegativeInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const NegativeInfinity As Single  = -Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: float NegativeInfinity = -Infinity;" />
      <MemberSignature Language="F#" Value="val mutable NegativeInfinity : single" Usage="System.single.NegativeInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>-Infinity</MemberValue>
      <Docs>
        <summary>Stellt minus unendlich dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Konstante ist das Ergebnis der Division einer negativen Zahl durch 0 (null).  
  
 Diese Konstante wird zur√ºckgegeben, wenn das Ergebnis eines Vorgangs kleiner als <xref:System.Single.MinValue>ist.  
  
 Verwenden Sie <xref:System.Single.IsNegativeInfinity%2A>, um zu bestimmen, ob ein Wert zu minus unendlich ausgewertet wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Single.NegativeInfinity> Konstante veranschaulicht.  
  
 [!code-cpp[System.Single#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#9)]
 [!code-csharp[System.Single#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#9)]
 [!code-vb[System.Single#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_Equality(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : single * single -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zur√ºck, der angibt, ob zwei angegebene <see cref="T:System.Single" />-Werte gleich sind.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit der <xref:System.Single.op_Equality%2A>-Methode wird der Gleichheits Operator f√ºr <xref:System.Single> Werte definiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_GreaterThan(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : single * single -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zur√ºck, der angibt, ob ein angegebener <see cref="T:System.Single" />-Wert gr√∂√üer als ein anderer angegebener <see cref="T:System.Single" />-Wert ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> gr√∂√üer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Single.op_GreaterThan%2A>-Methode definiert den Vorgang des Operators "gr√∂√üer als" f√ºr <xref:System.Single> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_GreaterThanOrEqual(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : single * single -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zur√ºck, der angibt, ob ein angegebener <see cref="T:System.Single" />-Wert gr√∂√üer oder gleich einem anderen angegebenen <see cref="T:System.Single" />-Wert ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> gr√∂√üer oder gleich <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Single.op_GreaterThanOrEqual%2A>-Methode definiert den Vorgang des gr√∂√üer-als-oder-gleich-Operators f√ºr <xref:System.Single> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_Inequality(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(float left, float right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : single * single -&gt; bool" Usage="System.single.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zur√ºck, der angibt, ob zwei angegebene <see cref="T:System.Single" />-Werte gleich sind.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Single.op_Inequality%2A>-Methode definiert den Ungleichheits Operator f√ºr <xref:System.Single> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_LessThan(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : single * single -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zur√ºck, der angibt, ob ein angegebener <see cref="T:System.Single" />-Wert gr√∂√üer als ein anderer angegebener <see cref="T:System.Single" />-Wert ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> kleiner als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Single.op_LessThan%2A>-Methode definiert den Vorgang des less-than-Operators f√ºr <xref:System.Single> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_LessThanOrEqual(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : single * single -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Single" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zur√ºck, der angibt, ob ein angegebener <see cref="T:System.Single" /> -Wert kleiner oder gleich einem anderen angegebenen <see cref="T:System.Single" />-Wert ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> kleiner oder gleich <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Single.op_LessThanOrEqual%2A>-Methode definiert den Vorgang des less-than-or-equal-Operators f√ºr <xref:System.Single> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in die entsprechende Gleitkommazahl mit einfacher Genauigkeit.</summary>
        <altmember cref="Overload:System.Single.TryParse" />
        <remarks>In .net Core 3,0 und h√∂her werden Werte, die zu gro√ü f√ºr die Darstellung sind, auf <see cref="F:System.Single.PositiveInfinity" /> oder <see cref="F:System.Single.NegativeInfinity" /> gerundet, wie f√ºr die IEEE 754-Spezifikation erforderlich. In fr√ºheren Versionen, einschlie√ülich .NET Framework, f√ºhrte das Auswerten eines Werts, der zu gro√ü f√ºr die Darstellung war, zu einem Fehler.</remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; single" Usage="System.single.Parse s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die eine zu konvertierende Zahl enth√§lt.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in die entsprechende Gleitkommazahl mit einfacher Genauigkeit.</summary>
        <returns>Eine Gleitkommazahl mit einfacher Genauigkeit, die dem numerischen Wert oder Symbol in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .net Core 3,0 und h√∂her werden Werte, die zu gro√ü f√ºr die Darstellung sind, auf <xref:System.Single.PositiveInfinity> oder <xref:System.Single.NegativeInfinity> gerundet, wie f√ºr die IEEE 754-Spezifikation erforderlich. In fr√ºheren Versionen, einschlie√ülich .NET Framework, f√ºhrte das Auswerten eines Werts, der zu gro√ü f√ºr die Darstellung war, zu einem Fehler.

 Der `s`-Parameter kann die <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>oder eine Zeichenfolge der aktuellen Kultur enthalten:  
  
 [*WS*] [*Sign*] [ganzzahlige*Ziffern*[*,*]] ganzzahlige *Ziffern*[*.* [*Bruch Ziffern*]] [e [*Sign*]*exponentialziffern*] [*WS*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Eine Reihe von Leerzeichen.|  
|*sign*|Ein negatives Vorzeichen Symbol oder ein positives Vorzeichen Symbol. G√ºltige Zeichen werden durch die Eigenschaften <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> und <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> der aktuellen Kultur bestimmt. Es kann nur ein f√ºhrendes Vorzeichen verwendet werden.|  
|*ganzzahlige Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die den ganzzahligen Teil der Zahl angeben. Ausf√ºhrungen ganzzahliger *Ziffern* k√∂nnen durch ein Gruppen Trennzeichen partitioniert werden. In einigen Kulturen werden z. b. durch Kommas (,) Gruppen von Tausenden voneinander getrennt. Das *integrale Ziffern* Element kann nicht vorhanden sein, wenn die Zeichenfolge das Dezimal *stellen Element enth√§lt* .|  
|*,*|Ein kulturspezifisches Tausender Trennzeichen.|  
|*.*|Ein kulturspezifisches Dezimaltrennzeichen.|  
|*Bruch Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die den Bruch Teil der Zahl angeben.|  
|E|Das Zeichen "e" oder "e", das angibt, dass der Wert in exponentieller Notation (Scientific) dargestellt wird.|  
|*exponentielle Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die einen Exponenten angeben.|  
  
 Der `s`-Parameter wird mit einer Kombination der <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType>-und <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>-Flags interpretiert. Dies bedeutet, dass Leerzeichen und Tausender Trennzeichen zul√§ssig sind, aber W√§hrungssymbole nicht. Verwenden Sie die <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%29>-Methoden √úberladung, um die Elemente (z. b. W√§hrungssymbole, Tausende Trennzeichen und Leerzeichen), die in `s`vorhanden sein k√∂nnen, explizit zu definieren.  
  
 Der `s`-Parameter wird mithilfe der Formatierungsinformationen in einem <xref:System.Globalization.NumberFormatInfo>-Objekt analysiert, das f√ºr die aktuelle System Kultur initialisiert wird. Weitere Informationen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>. Um eine Zeichenfolge mithilfe der Formatierungsinformationen einer bestimmten Kultur zu analysieren, verwenden Sie die Methode <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29> oder <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29>.  
  
Wenn Sie der <xref:System.Single.Parse%2A>-Methode eine Zeichenfolge √ºbergeben, die durch Aufrufen der <xref:System.Single.ToString%2A>-Methode erstellt wird, wird normalerweise der urspr√ºngliche <xref:System.Single> Wert zur√ºckgegeben. Aufgrund eines Genauigkeits Verlusts sind die Werte jedoch m√∂glicherweise nicht gleich.  

Wenn sich `s` au√üerhalb des Bereichs des <xref:System.Single> Datentyps befindet, l√∂st die Methode eine <xref:System.OverflowException> auf .NET Framework und .net Core 2,2 und fr√ºheren Versionen aus. In .net Core 3,0 und h√∂heren Versionen wird <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> zur√ºckgegeben, wenn `s` kleiner als <xref:System.Single.MinValue?displayProperty=nameWithType> ist, und <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, wenn `s` gr√∂√üer als <xref:System.Single.MaxValue?displayProperty=nameWithType>ist.

Wenn w√§hrend eines Analyse Vorgangs ein Trennzeichen im `s`-Parameter gefunden wird und die entsprechende W√§hrungs-oder Zahlen Dezimal-und Gruppen Trennzeichen identisch sind, geht der Analyse Vorgang davon aus, dass das Trennzeichen ein Dezimaltrennzeichen und nicht ein Gruppen Trennzeichen ist. Weitere Informationen zu Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Single.Parse%28System.String%29>-Methode verwendet, um ein Array von Zeichen folgen in √§quivalente <xref:System.Single> Werte zu konvertieren.  
  
 [!code-csharp[System.Single.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse1.cs#2)]
 [!code-vb[System.Single.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> ist <see langword="null" /></exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> stellt keine Zahl in einem g√ºltigen Format dar.</exception>
        <exception cref="T:System.OverflowException">Nur .NET Framework und .NET Core¬†2.2 und fr√ºheren Versionen: <paramref name="s" /> stellt eine Zahl dar, die kleiner als <see cref="F:System.Single.MinValue" /> oder gr√∂√üer als <see cref="F:System.Single.MaxValue" /> ist.</exception>
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analysieren numerischer Zeichenfolgen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; single" Usage="System.single.Parse (s, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die eine zu konvertierende Zahl enth√§lt.</param>
        <param name="style">Eine bitweise Kombination von Enumerationswerten, die die Stilelemente angeben, die in <paramref name="s" /> vorhanden sein k√∂nnen. Ein h√§ufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Float" /> in Kombination mit <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil in die entsprechende Gleitkommazahl mit einfacher Genauigkeit.</summary>
        <returns>Eine Gleitkommazahl mit einfacher Genauigkeit, die dem numerischen Wert oder Symbol in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .net Core 3,0 und h√∂her werden Werte, die zu gro√ü f√ºr die Darstellung sind, auf <xref:System.Single.PositiveInfinity> oder <xref:System.Single.NegativeInfinity> gerundet, wie f√ºr die IEEE 754-Spezifikation erforderlich. In fr√ºheren Versionen, einschlie√ülich .NET Framework, f√ºhrte das Auswerten eines Werts, der zu gro√ü f√ºr die Darstellung war, zu einem Fehler.

 Der `style`-Parameter definiert die Stilelemente (z. b. Leerzeichen, Tausender Trennzeichen und W√§hrungssymbole), die im `s`-Parameter zul√§ssig sind, damit der Analyse Vorgang erfolgreich ausgef√ºhrt werden kann. Dabei muss es sich um eine Kombination von Bitflags aus der <xref:System.Globalization.NumberStyles> Enumeration handeln. Die folgenden <xref:System.Globalization.NumberStyles> Elemente werden nicht unterst√ºtzt:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 Der `s`-Parameter kann die <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A><xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>der aktuellen Kultur enthalten. Abh√§ngig vom Wert von `style`kann dies auch folgende Form annehmen:  
  
 [*WS*] [*$*] [*Sign*] [ganzzahlige*Ziffern*[*,*]] ganzzahlige *Ziffern*[*.* [*Bruch Ziffern*]] [E [*Sign*]*exponentialziffern*] [*WS*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
 *ws*  
 Eine Reihe von Leerzeichen. Leerraum kann am Anfang der `s` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>-Flag enth√§lt, und es kann am Ende `s` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>-Flag enth√§lt.  
  
 $  
 Ein kulturspezifisches W√§hrungssymbol. Die Position in der Zeichenfolge wird durch die Eigenschaften <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> und <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> der aktuellen Kultur definiert. Das W√§hrungssymbol der aktuellen Kultur kann in `s` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>-Flag enth√§lt.  
  
 *sign*  
 Ein negatives Vorzeichen Symbol (-) oder ein positives Vorzeichen Symbol (+). Das Vorzeichen kann am Anfang `s` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType>-Flag enth√§lt, und es kann am Ende `s` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>-Flag enth√§lt. In `s` k√∂nnen Klammern verwendet werden, um einen negativen Wert anzugeben, wenn `style` das <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>-Flag enth√§lt.  
  
 *ganzzahlige Ziffern*  
 Eine Reihe von Ziffern im Bereich von 0 bis 9, die den ganzzahligen Teil der Zahl angeben. Das *integrale Ziffern* Element kann nicht vorhanden sein, wenn die Zeichenfolge das Dezimal *stellen Element enth√§lt* .  
  
 ,  
 Ein kulturspezifisches Gruppen Trennzeichen. Das Gruppen Trennzeichen der aktuellen Kultur kann in `s` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>-Flag enth√§lt.  
  
 .  
 Ein kulturspezifisches Dezimaltrennzeichen. Das Dezimaltrennzeichen der aktuellen Kultur kann in `s` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>-Flag enth√§lt.  
  
 *Bruch Ziffern*  
 Eine Reihe von Ziffern im Bereich von 0 bis 9, die den Bruch Teil der Zahl angeben. Bruch Ziffern k√∂nnen in `s` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>-Flag enth√§lt.  
  
 E  
 Das Zeichen "e" oder "e", das angibt, dass der Wert in exponentieller Notation (Scientific) dargestellt wird. Der `value`-Parameter kann eine Zahl in Exponentialnotation darstellen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>-Flag enth√§lt.  
  
 *exponentielle Ziffern*  
 Eine Reihe von Ziffern im Bereich von 0 bis 9, die einen Exponenten angeben.  
  
> [!NOTE]
> Alle abschlie√üenden NUL-Zeichen (U + 0000) in `s` werden vom Analyse-Vorgang unabh√§ngig vom Wert des `style` Arguments ignoriert.

 Eine Zeichenfolge mit nur Ziffern (die dem <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> Stil entspricht) wird immer erfolgreich analysiert, wenn Sie sich im Bereich des <xref:System.Single> Typs befindet. Die verbleibenden <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Member steuern Elemente, die m√∂glicherweise vorhanden sind, jedoch nicht in der Eingabe Zeichenfolge vorhanden sein m√ºssen. In der folgenden Tabelle wird angegeben, wie einzelne <xref:System.Globalization.NumberStyles> Flags die Elemente beeinflussen, die m√∂glicherweise in `s`vorhanden sind.  
  
|NumberStyles-Wert|In `s` zul√§ssige Elemente zus√§tzlich zu Ziffern|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Nur das ganzzahlige *Ziffern* Element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Die Dezimaltrennzeichen (*.*) und die Elemente der *Bruch Ziffern* .|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Das Zeichen "e" oder "e", das die Exponentialschreibweise angibt. Dieses Flag allein unterst√ºtzt Werte in der Form *Ziffern*E*Ziffern*. zus√§tzliche Flags sind erforderlich, um Zeichen folgen mit solchen Elementen wie positive oder negative Vorzeichen und Dezimaltrennzeichen erfolgreich zu analysieren.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Das *WS* -Element am Anfang `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Das *WS* -Element am Ende `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Das *Sign* -Element am Anfang `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Das *Sign* -Element am Ende `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Das *Vorzeichen* Element in der Form von Klammern, das den numerischen Wert einschlie√üt.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Das Tausender Trennzeichen (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Das Currency ($)-Element.|  
|<xref:System.Globalization.NumberStyles.Currency>|Alle-Elemente. `s` kann jedoch keine hexadezimal Zahl oder eine Zahl in Exponentialnotation darstellen.|  
|<xref:System.Globalization.NumberStyles.Float>|Das *WS* -Element am Anfang oder Ende `s`, Signieren am Anfang `s`und das Dezimal *Trennzeichen* (.). Der `s`-Parameter kann auch die Exponentialnotation verwenden.|  
|<xref:System.Globalization.NumberStyles.Number>|Die Elemente `ws`, `sign`, Tausender Trennzeichen (,) und Dezimaltrennzeichen (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Alle-Elemente. Allerdings kann `s` keine hexadezimal Zahl darstellen.|  
  
 Einige Beispiele f√ºr `s` sind "100", "-123.456.789", "123,45 e + 6", "+ 500", "5e2", "3,1416", "600.", "-. 123" und "-Infinity".  
  
 Der `s`-Parameter wird mithilfe der Formatierungsinformationen in einem <xref:System.Globalization.NumberFormatInfo>-Objekt analysiert, das f√ºr die aktuelle System Kultur initialisiert wird. Um die Kultur anzugeben, deren Formatierungsinformationen f√ºr den Analyse Vorgang verwendet werden, m√ºssen Sie die <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> √úberladung aufrufen.  
  
 Wenn Sie der <xref:System.Single.Parse%2A>-Methode eine Zeichenfolge √ºbergeben, die durch Aufrufen der <xref:System.Single.ToString%2A>-Methode erstellt wird, wird normalerweise der urspr√ºngliche <xref:System.Single> Wert zur√ºckgegeben. Aufgrund eines Genauigkeits Verlusts sind die Werte jedoch m√∂glicherweise nicht gleich.  

Wenn sich `s` au√üerhalb des Bereichs des <xref:System.Single> Datentyps befindet, l√∂st die Methode eine <xref:System.OverflowException> auf .NET Framework und .net Core 2,2 und fr√ºheren Versionen aus. In .net Core 3,0 und h√∂heren Versionen wird <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> zur√ºckgegeben, wenn `s` kleiner als <xref:System.Single.MinValue?displayProperty=nameWithType> ist, und <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, wenn `s` gr√∂√üer als <xref:System.Single.MaxValue?displayProperty=nameWithType>ist.

Wenn w√§hrend eines Analyse Vorgangs ein Trennzeichen im `s`-Parameter gefunden wird und die entsprechende W√§hrungs-oder Zahlen Dezimal-und Gruppen Trennzeichen identisch sind, geht der Analyse Vorgang davon aus, dass das Trennzeichen ein Dezimaltrennzeichen und nicht ein Gruppen Trennzeichen ist. Weitere Informationen zu Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  

## Examples  
 Im folgenden Beispiel wird die <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%29>-Methode verwendet, um die Zeichen folgen Darstellungen von <xref:System.Single> Werten zu analysieren. Das Beispiel verwendet Formatierungsinformationen f√ºr die Kultur "en-US".  
  
 [!code-csharp[System.Single.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse2.cs#3)]
 [!code-vb[System.Single.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> ist <see langword="null" /></exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> stellt keine Zahl in einem g√ºltigen Format dar.</exception>
        <exception cref="T:System.OverflowException">Nur .NET Framework und .NET Core 2.2 und fr√ºheren Versionen: <paramref name="s" /> stellt eine Zahl dar, die kleiner als <see cref="F:System.Single.MinValue" /> oder gr√∂√üer als <see cref="F:System.Single.MaxValue" /> ist.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
- oder - 
 <paramref name="style" /> enth√§lt den <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />-Wert.</exception>
        <altmember cref="M:System.Single.ToString" />
        <altmember cref="Overload:System.Single.TryParse" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analysieren numerischer Zeichenfolgen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; single" Usage="System.single.Parse (s, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die eine zu konvertierende Zahl enth√§lt.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu <paramref name="s" /> bereitstellt.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem bestimmten kulturabh√§ngigen Format in die entsprechende Gleitkommazahl mit einfacher Genauigkeit.</summary>
        <returns>Eine Gleitkommazahl mit einfacher Genauigkeit, die dem numerischen Wert oder Symbol in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .net Core 3,0 und h√∂her werden Werte, die zu gro√ü f√ºr die Darstellung sind, auf <xref:System.Single.PositiveInfinity> oder <xref:System.Single.NegativeInfinity> gerundet, wie f√ºr die IEEE 754-Spezifikation erforderlich. In fr√ºheren Versionen, einschlie√ülich .NET Framework, f√ºhrte das Auswerten eines Werts, der zu gro√ü f√ºr die Darstellung war, zu einem Fehler.

 Diese √úberladung wird normalerweise verwendet, um Text zu konvertieren, der auf verschiedene Weise auf einen <xref:System.Single> Wert formatiert werden kann. Beispielsweise kann es verwendet werden, um den von einem Benutzer eingegebenen Text in ein HTML-Textfeld in einen numerischen Wert zu konvertieren.  
  
 Der `s`-Parameter wird mit einer Kombination der <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType>-und <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>-Flags interpretiert. Der `s`-Parameter kann f√ºr die durch `provider`angegebene Kultur <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>oder <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> enthalten, oder er kann eine Zeichenfolge in der Form enthalten:  
  
 [*WS*] [*Sign*] ganzzahlige *Ziffern*[*.* [*Bruch Ziffern*]] [E [*Sign*]*exponentialziffern*] [*WS*]  
  
 Optionale Elemente werden in eckige Klammern ([und]) eingeschlossen. Elemente, die den Begriff "Ziffern" enthalten, bestehen aus einer Reihe von numerischen Zeichen zwischen 0 und 9.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Eine Reihe von Leerzeichen.|  
|*sign*|Ein negatives Vorzeichen Symbol (-) oder ein positives Vorzeichen Symbol (+).|  
|*ganzzahlige Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die den ganzzahligen Teil der Zahl angeben. Ausf√ºhrungen ganzzahliger *Ziffern* k√∂nnen durch ein Gruppen Trennzeichen partitioniert werden. In einigen Kulturen werden z. b. durch Kommas (,) Gruppen von Tausenden voneinander getrennt. Das *integrale Ziffern* Element kann nicht vorhanden sein, wenn die Zeichenfolge das Dezimal *stellen Element enth√§lt* .|  
|.|Ein kulturspezifisches Dezimaltrennzeichen.|  
|*Bruch Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die den Bruch Teil der Zahl angeben.|  
|E|Das Zeichen "e" oder "e", das angibt, dass der Wert in exponentieller Notation (Scientific) dargestellt wird.|  
|*exponentielle Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die einen Exponenten angeben.|  
  
 Weitere Informationen zu numerischen Formaten finden Sie im Thema [Formatierungs Typen](~/docs/standard/base-types/formatting-types.md) .  
  
 Der `provider`-Parameter ist eine <xref:System.IFormatProvider> Implementierung, deren <xref:System.IFormatProvider.GetFormat%2A>-Methode ein <xref:System.Globalization.NumberFormatInfo> Objekt zur√ºckgibt, das kulturspezifische Formatierungsinformationen bereitstellt. Wenn die <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29>-Methode aufgerufen wird, ruft Sie die <xref:System.IFormatProvider.GetFormat%2A>-Methode des `provider`-Parameters auf und √ºbergibt ihr ein <xref:System.Type> Objekt, das den <xref:System.Globalization.NumberFormatInfo> Typ darstellt. Die <xref:System.IFormatProvider.GetFormat%2A>-Methode gibt dann das <xref:System.Globalization.NumberFormatInfo>-Objekt zur√ºck, das Informationen zum Format des `s`-Parameters bereitstellt. Es gibt drei M√∂glichkeiten, den `provider`-Parameter zu verwenden, um benutzerdefinierte Formatierungsinformationen f√ºr den Analyse Vorgang bereitzustellen:  
  
-   Sie k√∂nnen ein <xref:System.Globalization.CultureInfo> Objekt √ºbergeben, das die Kultur darstellt, die Formatierungsinformationen bereitstellt. Die <xref:System.Globalization.CultureInfo.GetFormat%2A>-Methode gibt das <xref:System.Globalization.NumberFormatInfo> Objekt zur√ºck, das numerische Formatierungsinformationen f√ºr diese Kultur bereitstellt.  
  
-   Sie k√∂nnen das tats√§chliche <xref:System.Globalization.NumberFormatInfo> Objekt √ºbergeben, das numerische Formatierungsinformationen bereitstellt. (Die Implementierung von <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> nur sich selbst zur√ºckgegeben.)  
  
-   Sie k√∂nnen ein benutzerdefiniertes Objekt √ºbergeben, das <xref:System.IFormatProvider>implementiert. Die <xref:System.IFormatProvider.GetFormat%2A>-Methode instanziiert und gibt das <xref:System.Globalization.NumberFormatInfo> Objekt zur√ºck, das Formatierungsinformationen bereitstellt.  
  
 Wenn `provider` `null` oder ein <xref:System.Globalization.NumberFormatInfo> nicht abgerufen werden kann, werden die Formatierungsinformationen f√ºr die aktuelle System Kultur verwendet.  

Wenn sich `s` au√üerhalb des Bereichs des <xref:System.Single> Datentyps befindet, l√∂st die Methode eine <xref:System.OverflowException> auf .NET Framework und .net Core 2,2 und fr√ºheren Versionen aus. In .net Core 3,0 und h√∂heren Versionen wird <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> zur√ºckgegeben, wenn `s` kleiner als <xref:System.Single.MinValue?displayProperty=nameWithType> ist, und <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, wenn `s` gr√∂√üer als <xref:System.Single.MaxValue?displayProperty=nameWithType>ist. 

Wenn w√§hrend eines Analyse Vorgangs ein Trennzeichen im `s`-Parameter gefunden wird und die entsprechende W√§hrungs-oder Zahlen Dezimal-und Gruppen Trennzeichen identisch sind, geht der Analyse Vorgang davon aus, dass das Trennzeichen ein Dezimaltrennzeichen und nicht ein Gruppen Trennzeichen ist. Weitere Informationen zu Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
Einige Beispiele f√ºr `s` sind "100", "-123.456.789", "123,45 e + 6", "+ 500", "5e2", "3,1416", "600.", "-. 123" und "-Infinity".  

## Examples  
 Das folgende Beispiel ist der Button Click-Ereignishandler eines Webformulars. Er verwendet das von der <xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType>-Eigenschaft zur√ºckgegebene Array, um das Gebiets Schema des Benutzers zu bestimmen. Anschlie√üend wird ein <xref:System.Globalization.CultureInfo> Objekt instanziiert, das diesem Gebiets Schema entspricht. Das <xref:System.Globalization.NumberFormatInfo> Objekt, das zu diesem <xref:System.Globalization.CultureInfo> Objekt geh√∂rt, wird dann an die <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29>-Methode weitergegeben, um die Eingabe des Benutzers in einen <xref:System.Single> Wert zu konvertieren.  
  
 [!code-csharp[ParseMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR/ParseMethod/cs/Default.aspx.cs#1)]
 [!code-vb[ParseMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ParseMethod/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> ist <see langword="null" /></exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> stellt keine Zahl in einem g√ºltigen Format dar.</exception>
        <exception cref="T:System.OverflowException">Nur .NET Framework und .NET Core¬†2.2 und fr√ºheren Versionen: <paramref name="s" /> stellt eine Zahl dar, die kleiner als <see cref="F:System.Single.MinValue" /> oder gr√∂√üer als <see cref="F:System.Single.MaxValue" /> ist.</exception>
        <altmember cref="M:System.Single.ToString" />
        <altmember cref="Overload:System.Single.TryParse" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analysieren numerischer Zeichenfolgen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, IFormatProvider provider = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As Single" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; single" Usage="System.single.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenspanne, die die zu konvertierende Zahl enth√§lt</param>
        <param name="style">Eine bitweise Kombination von Enumerationswerten, die die Stilelemente angeben, die in <paramref name="s" /> vorhanden sein k√∂nnen.  Ein h√§ufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Float" /> in Kombination mit <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu <paramref name="s" /> bereitstellt.</param>
        <summary>Konvertiert eine Zeichenspanne mit der Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende Gleitkommazahl mit einfacher Genauigkeit</summary>
        <returns>Eine Gleitkommazahl mit einfacher Genauigkeit, die dem numerischen Wert oder Symbol in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

In .net Core 3,0 und h√∂her werden Werte, die zu gro√ü f√ºr die Darstellung sind, auf <xref:System.Single.PositiveInfinity> oder <xref:System.Single.NegativeInfinity> gerundet, wie f√ºr die IEEE 754-Spezifikation erforderlich. In fr√ºheren Versionen, einschlie√ülich .NET Framework, f√ºhrte das Auswerten eines Werts, der zu gro√ü f√ºr die Darstellung war, zu einem Fehler.

Wenn `s` au√üerhalb des Bereichs des <xref:System.Single> Datentyps liegt, gibt die Methode <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> zur√ºck, wenn `s` kleiner als <xref:System.Single.MinValue?displayProperty=nameWithType> ist, und <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, wenn `s` gr√∂√üer als <xref:System.Single.MaxValue?displayProperty=nameWithType>ist.

         ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="s" /> stellt keinen numerischen Wert dar.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
- oder - 
<paramref name="style" /> ist der <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; single" Usage="System.single.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die eine zu konvertierende Zahl enth√§lt.</param>
        <param name="style">Eine bitweise Kombination von Enumerationswerten, die die Stilelemente angeben, die in <paramref name="s" /> vorhanden sein k√∂nnen. Ein h√§ufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Float" /> in Kombination mit <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu <paramref name="s" /> bereitstellt.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturabh√§ngigen Format in die entsprechende Gleitkommazahl mit einfacher Genauigkeit.</summary>
        <returns>Eine Gleitkommazahl mit einfacher Genauigkeit, die dem numerischen Wert oder Symbol in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .net Core 3,0 und h√∂her werden Werte, die zu gro√ü f√ºr die Darstellung sind, auf <xref:System.Single.PositiveInfinity> oder <xref:System.Single.NegativeInfinity> gerundet, wie f√ºr die IEEE 754-Spezifikation erforderlich. In fr√ºheren Versionen, einschlie√ülich .NET Framework, f√ºhrte das Auswerten eines Werts, der zu gro√ü f√ºr die Darstellung war, zu einem Fehler.

 Der `style`-Parameter definiert die Stilelemente (z. b. Leerzeichen, Tausender Trennzeichen und W√§hrungssymbole), die im `s`-Parameter zul√§ssig sind, damit der Analyse Vorgang erfolgreich ausgef√ºhrt werden kann. Dabei muss es sich um eine Kombination von Bitflags aus der <xref:System.Globalization.NumberStyles> Enumeration handeln. Die folgenden <xref:System.Globalization.NumberStyles> Elemente werden nicht unterst√ºtzt:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 Der `s`-Parameter kann f√ºr die durch `provider`angegebene Kultur <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>oder <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> enthalten. Abh√§ngig vom Wert von `style`kann dies auch folgende Form annehmen:  
  
 [*WS*] [*$*] [*Sign*] [ganzzahlige*Ziffern*,] ganzzahlige *Ziffern*[. [ *Bruch Ziffern*]] [E [*Sign*]*exponentialziffern*] [*WS*]  
  
 In eckige Klammern ([und]) eineckige Elemente sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Eine Reihe von Leerzeichen. Leerraum kann am Anfang der `s` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>-Flag enth√§lt, und es kann am Ende `s` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>-Flag enth√§lt.|  
|$|Ein kulturspezifisches W√§hrungssymbol. Die Position in der Zeichenfolge wird durch die Eigenschaften <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> und <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> der aktuellen Kultur definiert. Das W√§hrungssymbol der aktuellen Kultur kann in `s` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>-Flag enth√§lt.|  
|*sign*|Ein negatives Vorzeichen Symbol (-) oder ein positives Vorzeichen Symbol (+). Das Vorzeichen kann am Anfang `s` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType>-Flag enth√§lt, und es kann am Ende `s` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>-Flag enth√§lt. In `s` k√∂nnen Klammern verwendet werden, um einen negativen Wert anzugeben, wenn `style` das <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>-Flag enth√§lt.|  
|*ganzzahlige Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die den ganzzahligen Teil der Zahl angeben. Das *integrale Ziffern* Element kann nicht vorhanden sein, wenn die Zeichenfolge das Dezimal *stellen Element enth√§lt* .|  
|,|Ein kulturspezifisches Gruppen Trennzeichen. Das Gruppen Trennzeichen der aktuellen Kultur kann in `s` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>-Flag enth√§lt.|  
|.|Ein kulturspezifisches Dezimaltrennzeichen. Das Dezimaltrennzeichen der aktuellen Kultur kann in `s` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>-Flag enth√§lt.|  
|*Bruch Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die den Bruch Teil der Zahl angeben. Bruch Ziffern k√∂nnen in `s` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>-Flag enth√§lt.|  
|E|Das Zeichen "e" oder "e", das angibt, dass der Wert in exponentieller Notation (Scientific) dargestellt wird. Der `s`-Parameter kann eine Zahl in Exponentialnotation darstellen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>-Flag enth√§lt.|  
|*exponentielle Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die einen Exponenten angeben.|  
  
> [!NOTE]
> Alle abschlie√üenden NUL-Zeichen (U + 0000) in `s` werden vom Analyse-Vorgang unabh√§ngig vom Wert des `style` Arguments ignoriert.

 Eine Zeichenfolge mit nur Ziffern (die dem <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> Stil entspricht) wird immer erfolgreich analysiert, wenn Sie sich im Bereich des <xref:System.Single> Typs befindet. Die verbleibenden <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Member steuern Elemente, die m√∂glicherweise vorhanden sind, jedoch nicht in der Eingabe Zeichenfolge vorhanden sein m√ºssen. In der folgenden Tabelle wird angegeben, wie einzelne <xref:System.Globalization.NumberStyles> Flags die Elemente beeinflussen, die m√∂glicherweise in `s`vorhanden sind.  
  
|NumberStyles-Wert|In `s` zul√§ssige Elemente zus√§tzlich zu Ziffern|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Nur das ganzzahlige *Ziffern* Element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Die Dezimaltrennzeichen (*.*) und die Elemente der *Bruch Ziffern* .|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Das Zeichen "e" oder "e", das die Exponentialschreibweise angibt. Dieses Flag allein unterst√ºtzt Werte in der Form *Ziffern*E*Ziffern*. zus√§tzliche Flags sind erforderlich, um Zeichen folgen mit solchen Elementen wie positive oder negative Vorzeichen und Dezimaltrennzeichen erfolgreich zu analysieren.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Das *WS* -Element am Anfang `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Das *WS* -Element am Ende `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Das *Sign* -Element am Anfang `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Das *Sign* -Element am Ende `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Das *Vorzeichen* Element in der Form von Klammern, das den numerischen Wert einschlie√üt.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Das Tausender Trennzeichen (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Das Currency ($)-Element.|  
|<xref:System.Globalization.NumberStyles.Currency>|Alle-Elemente. `s` kann jedoch keine hexadezimal Zahl oder eine Zahl in Exponentialnotation darstellen.|  
|<xref:System.Globalization.NumberStyles.Float>|Das *WS* -Element am Anfang oder Ende `s`, Signieren am Anfang `s`und das Dezimal *Trennzeichen* (.). Der `s`-Parameter kann auch die Exponentialnotation verwenden.|  
|<xref:System.Globalization.NumberStyles.Number>|Die Elemente `ws`, `sign`, Tausender Trennzeichen (,) und Dezimaltrennzeichen (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Alle-Elemente. Allerdings kann `s` keine hexadezimal Zahl darstellen.|  
  
 Der `provider`-Parameter ist eine <xref:System.IFormatProvider> Implementierung. Die <xref:System.IFormatProvider.GetFormat%2A>-Methode gibt ein <xref:System.Globalization.NumberFormatInfo> Objekt zur√ºck, das kulturspezifische Informationen zum Format von `value`bereitstellt. In der Regel kann `provider` eine der folgenden sein:  
  
-   Ein <xref:System.Globalization.CultureInfo>-Objekt, das die Kultur darstellt, die numerische Formatierungsinformationen bereitstellt. Die <xref:System.Globalization.CultureInfo.GetFormat%2A>-Methode gibt das <xref:System.Globalization.NumberFormatInfo>-Objekt zur√ºck, das numerische Formatierungsinformationen bereitstellt.  
  
-   Ein <xref:System.Globalization.NumberFormatInfo>-Objekt, das Formatierungsinformationen bereitstellt. (Die Implementierung von <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> nur sich selbst zur√ºckgegeben.)  
  
-   Ein benutzerdefiniertes Objekt, das <xref:System.IFormatProvider> implementiert und die <xref:System.Globalization.NumberFormatInfo.GetFormat%2A>-Methode zum Instanziieren und Zur√ºckgeben des <xref:System.Globalization.NumberFormatInfo> Objekts verwendet, das Formatierungsinformationen bereitstellt.  
  
Wenn `provider` `null`ist, wird das <xref:System.Globalization.NumberFormatInfo>-Objekt f√ºr die aktuelle Kultur verwendet.  

Wenn sich `s` au√üerhalb des Bereichs des <xref:System.Single> Datentyps befindet, l√∂st die Methode eine <xref:System.OverflowException> auf .NET Framework und .net Core 2,2 und fr√ºheren Versionen aus. In .net Core 3,0 und h√∂heren Versionen wird <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> zur√ºckgegeben, wenn `s` kleiner als <xref:System.Single.MinValue?displayProperty=nameWithType> ist, und <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, wenn `s` gr√∂√üer als <xref:System.Single.MaxValue?displayProperty=nameWithType>ist.

Wenn w√§hrend eines Analyse Vorgangs ein Trennzeichen im `s`-Parameter gefunden wird und die entsprechende W√§hrungs-oder Zahlen Dezimal-und Gruppen Trennzeichen identisch sind, geht der Analyse Vorgang davon aus, dass das Trennzeichen ein Dezimaltrennzeichen und nicht ein Gruppen Trennzeichen ist. Weitere Informationen zu Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  

## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29>-Methode verwendet, um die Zeichen folgen Darstellungen von <xref:System.Single> Werten zu analysieren. Jede Zeichenfolge in einem Array wird mithilfe der Formatierungs Konventionen der en-US, nl-nl und einer benutzerdefinierten Kultur analysiert. Die benutzerdefinierte Kultur definiert das Gruppen Trennzeichen als Unterstrich ("_") und die Gruppengr√∂√üe als zwei.  
  
 [!code-csharp[System.Single.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse3.cs#4)]
 [!code-vb[System.Single.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> ist <see langword="null" /></exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> stellt keinen numerischen Wert dar.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
- oder - 
 <paramref name="style" /> ist der <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />-Wert.</exception>
        <exception cref="T:System.OverflowException">Nur .NET Framework und .NET Core 2.2 und fr√ºheren Versionen: <paramref name="s" /> stellt eine Zahl dar, die kleiner als <see cref="F:System.Single.MinValue" /> oder gr√∂√üer als <see cref="F:System.Single.MaxValue" /> ist.</exception>
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analysieren numerischer Zeichenfolgen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="PositiveInfinity">
      <MemberSignature Language="C#" Value="public const float PositiveInfinity = Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 PositiveInfinity = float32(Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Single.PositiveInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const PositiveInfinity As Single  = Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: float PositiveInfinity = Infinity;" />
      <MemberSignature Language="F#" Value="val mutable PositiveInfinity : single" Usage="System.single.PositiveInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>Infinity</MemberValue>
      <Docs>
        <summary>Stellt plus unendlich dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Konstante ist das Ergebnis der Division einer positiven Zahl durch 0 (null).  
  
 Diese Konstante wird zur√ºckgegeben, wenn das Ergebnis eines Vorgangs gr√∂√üer als <xref:System.Single.MaxValue>ist.  
  
 Verwenden Sie <xref:System.Single.IsPositiveInfinity%2A>, um zu bestimmen, ob ein Wert als positiv unendlich ausgewertet wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Single.PositiveInfinity> Konstante veranschaulicht.  
  
 [!code-cpp[System.Single#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#10)]
 [!code-csharp[System.Single#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#10)]
 [!code-vb[System.Single#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberSignature Language="F#" Value="abstract member System.IComparable.CompareTo : obj -&gt; int&#xA;override this.System.IComparable.CompareTo : obj -&gt; int" Usage="single.System.IComparable.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="value">Das zu vergleichende Objekt.</param>
        <summary>Vergleicht die aktuelle Instanz mit einem anderen Objekt vom selben Typ und gibt eine ganze Zahl zur√ºck, die angibt, ob die aktuelle Instanz in der Sortierreihenfolge vor oder nach dem anderen Objekt oder an derselben Position auftritt.</summary>
        <returns>Ein Wert, der die relative Reihenfolge der verglichenen Objekte angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Dieser Member ist eine explizite Schnittstellen-Memberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IComparable>-Schnittstelle umgewandelt wird.

Der R√ºckgabewert hat folgende Bedeutungen:

| Wert             | Bedeutung                                                                 |
|-------------------|-------------------------------------------------------------------------|
| Kleiner als 0 (null)    | Diese Instanz befindet sich in der Sortierreihenfolge vor `value`.                       |
| Null              | Diese Instanz tritt in der Sortierreihenfolge an der gleichen Position wie `value` auf. |
| Gr√∂√üer als 0 (null) | Diese Instanz folgt in der Sortierreihenfolge auf `value`.                        |

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.GetTypeCode : unit -&gt; TypeCode&#xA;override this.System.IConvertible.GetTypeCode : unit -&gt; TypeCode" Usage="single.System.IConvertible.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den <see cref="T:System.TypeCode" /> f√ºr diese Instanz zur√ºck.</summary>
        <returns>Die Enumerationskonstante, die den <see cref="T:System.TypeCode" /> des Klassen- oder Werttyps darstellt, der diese Schnittstelle implementiert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Dieser Member ist eine explizite Schnittstellen-Memberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToBoolean : IFormatProvider -&gt; bool&#xA;override this.System.IConvertible.ToBoolean : IFormatProvider -&gt; bool" Usage="single.System.IConvertible.ToBoolean provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns><see langword="true" />, wenn der Wert der aktuellen Instanz nicht 0¬†(null) ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist eine explizite Schnittstellen-Memberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToBoolean%28System.Single%29?displayProperty=nameWithType>-Methode aufzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToByte : IFormatProvider -&gt; byte&#xA;override this.System.IConvertible.ToByte : IFormatProvider -&gt; byte" Usage="single.System.IConvertible.ToByte provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Byte" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist eine explizite Schnittstellen-Memberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToByte%28System.Single%29?displayProperty=nameWithType>-Methode aufzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToChar : IFormatProvider -&gt; char&#xA;override this.System.IConvertible.ToChar : IFormatProvider -&gt; char" Usage="single.System.IConvertible.ToChar provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Diese Konvertierung wird nicht unterst√ºtzt. Bei dem Versuch der Verwendung dieser Methode wird eine <see cref="T:System.InvalidCastException" /> ausgel√∂st.</summary>
        <returns>Diese Konvertierung wird nicht unterst√ºtzt. Es wird kein Wert zur√ºckgegeben.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">In allen F√§llen.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToDateTime : IFormatProvider -&gt; DateTime&#xA;override this.System.IConvertible.ToDateTime : IFormatProvider -&gt; DateTime" Usage="single.System.IConvertible.ToDateTime provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Diese Konvertierung wird nicht unterst√ºtzt. Bei dem Versuch der Verwendung dieser Methode wird eine <see cref="T:System.InvalidCastException" /> ausgel√∂st.</summary>
        <returns>Diese Konvertierung wird nicht unterst√ºtzt. Es wird kein Wert zur√ºckgegeben.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">In allen F√§llen.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToDecimal : IFormatProvider -&gt; decimal&#xA;override this.System.IConvertible.ToDecimal : IFormatProvider -&gt; decimal" Usage="single.System.IConvertible.ToDecimal provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Decimal" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist eine explizite Schnittstellen-Memberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToDecimal%28System.Single%29?displayProperty=nameWithType>-Methode aufzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToDouble : IFormatProvider -&gt; double&#xA;override this.System.IConvertible.ToDouble : IFormatProvider -&gt; double" Usage="single.System.IConvertible.ToDouble provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Double" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist eine explizite Schnittstellen-Memberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToDouble%28System.Single%29?displayProperty=nameWithType>-Methode aufzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToInt16 : IFormatProvider -&gt; int16&#xA;override this.System.IConvertible.ToInt16 : IFormatProvider -&gt; int16" Usage="single.System.IConvertible.ToInt16 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Int16" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist eine explizite Schnittstellen-Memberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToInt16%28System.Single%29?displayProperty=nameWithType>-Methode aufzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToInt32 : IFormatProvider -&gt; int&#xA;override this.System.IConvertible.ToInt32 : IFormatProvider -&gt; int" Usage="single.System.IConvertible.ToInt32 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Int32" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist eine explizite Schnittstellen-Memberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToInt32%28System.Single%29?displayProperty=nameWithType>-Methode aufzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToInt64 : IFormatProvider -&gt; int64&#xA;override this.System.IConvertible.ToInt64 : IFormatProvider -&gt; int64" Usage="single.System.IConvertible.ToInt64 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Int64" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist eine explizite Schnittstellen-Memberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToInt64%28System.Single%29?displayProperty=nameWithType>-Methode aufzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToSByte : IFormatProvider -&gt; sbyte&#xA;override this.System.IConvertible.ToSByte : IFormatProvider -&gt; sbyte" Usage="single.System.IConvertible.ToSByte provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.SByte" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist eine explizite Schnittstellen-Memberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToSByte%28System.Single%29?displayProperty=nameWithType>-Methode aufzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToSingle : IFormatProvider -&gt; single&#xA;override this.System.IConvertible.ToSingle : IFormatProvider -&gt; single" Usage="single.System.IConvertible.ToSingle provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>Der unver√§nderte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist eine explizite Schnittstellen-Memberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToType (type As Type, provider As IFormatProvider) As Object Implements IConvertible.ToType" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToType : Type * IFormatProvider -&gt; obj&#xA;override this.System.IConvertible.ToType : Type * IFormatProvider -&gt; obj" Usage="single.System.IConvertible.ToType (type, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ, in den dieser <see cref="T:System.Single" />-Wert konvertiert werden soll.</param>
        <param name="provider">Ein Objekt, das Informationen zum Format des zur√ºckgegebenen Werts bereitstellt.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Der in <paramref name="type" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist eine explizite Schnittstellen-Memberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die `static` (`Shared` in Visual Basic) <xref:System.Convert.ChangeType%2A?displayProperty=nameWithType>-Methode aufzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToUInt16 : IFormatProvider -&gt; uint16&#xA;override this.System.IConvertible.ToUInt16 : IFormatProvider -&gt; uint16" Usage="single.System.IConvertible.ToUInt16 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.UInt16" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist eine explizite Schnittstellen-Memberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToUInt16%28System.Single%29?displayProperty=nameWithType>-Methode aufzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToUInt32 : IFormatProvider -&gt; uint32&#xA;override this.System.IConvertible.ToUInt32 : IFormatProvider -&gt; uint32" Usage="single.System.IConvertible.ToUInt32 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.UInt32" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist eine explizite Schnittstellen-Memberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToUInt32%28System.Single%29?displayProperty=nameWithType>-Methode aufzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToUInt64 : IFormatProvider -&gt; uint64&#xA;override this.System.IConvertible.ToUInt64 : IFormatProvider -&gt; uint64" Usage="single.System.IConvertible.ToUInt64 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.UInt64" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist eine explizite Schnittstellen-Memberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToUInt64%28System.Single%29?displayProperty=nameWithType>-Methode aufzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert den Wert dieser Instanz in die entsprechende Zeichenfolgendarstellung.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="single.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konvertiert den Wert dieser Instanz in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieser Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Single.ToString>-Methode formatiert einen <xref:System.Single>-Wert im Standardformat ("G" oder allgemein) der aktuellen Kultur. Wenn Sie ein anderes Format oder eine andere Kultur angeben m√∂chten, verwenden Sie die anderen √ºber Ladungen der <xref:System.Single.ToString%2A>-Methode wie folgt:  
  
|So verwenden Sie das Format|F√ºr Kultur|Verwenden der √úberladung|  
|-------------------|-----------------|----------------------|  
|Standardformat ("G")|Eine bestimmte Kultur|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|Ein bestimmtes Format|Standard Kultur (aktuell)|<xref:System.Single.ToString%28System.String%29>|  
|Ein bestimmtes Format|Eine bestimmte Kultur|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Der R√ºckgabewert kann <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>oder eine Zeichenfolge in der Form lauten:  
  
 [Sign] ganzzahlige Ziffern [. [ Bruch Ziffern]] [e [Sign] exponentialziffern]  
  
 Optionale Elemente werden in eckige Klammern ([und]) eingeschlossen. Elemente, die den Begriff "Ziffern" enthalten, bestehen aus einer Reihe von numerischen Zeichen zwischen 0 und 9. In der folgenden Tabelle sind die einzelnen Elemente aufgelistet:  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*sign*|Ein negatives Vorzeichen-oder positives Vorzeichen Symbol.|  
|*ganzzahlige Ziffern*|Eine Reihe von Ziffern, die den ganzzahligen Teil der Zahl angibt. Ganzzahlige Ziffern k√∂nnen nicht vorhanden sein, wenn es sich um Bruch Ziffern handelt.|  
|'.'|Ein kulturspezifisches Dezimaltrennzeichen.|  
|*Bruch Ziffern*|Eine Reihe von Ziffern, die den Bruch Teil der Zahl angibt.|  
|Fresser|Ein Kleinbuchstabe "e", der die exponentielle (wissenschaftliche) Notation angibt.|  
|*exponentielle Ziffern*|Eine Reihe von Ziffern, die einen Exponenten angeben.|  
  
 Einige Beispiele f√ºr den R√ºckgabewert sind "100", "-123.456.789", "123,45 e + 6", "500", "3,1416", "600", "-0,123" und "-Infinity".  
  
 Der .NET Framework bietet umfassende Formatierungs Unterst√ºtzung, die in den folgenden Formatierungs Themen ausf√ºhrlicher beschrieben wird:  
  
-   Weitere Informationen zu numerischen Format Bezeichnerzeichen finden Sie unter [Standard m√§√üige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und [benutzerdefinierte Zahlenformat](~/docs/standard/base-types/custom-numeric-format-strings.md)Zeichenfolgen.  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatieren von Typen](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Standard <xref:System.Single.ToString%2A?displayProperty=nameWithType>-Methode verwendet, um die Zeichen folgen Darstellungen einer Reihe von <xref:System.Single> Werten anzuzeigen.  
  
 [!code-csharp[System.Single.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#1)]
 [!code-vb[System.Single.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#1)]  
  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.Single.Parse%28System.String%29>-Methode zusammen mit der <xref:System.Single.ToString>-Methode veranschaulicht.  
  
 [!code-cpp[System.Single#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#3)]
 [!code-csharp[System.Single#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#3)]
 [!code-vb[System.Single#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="single.ToString provider" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Konvertiert den numerischen Wert dieser Instanz unter Ber√ºcksichtigung der angegebenen kulturabh√§ngigen Formatierungsinformationen in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieser Instanz entsprechend den Angaben von <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Single.ToString%28System.IFormatProvider%29>-Methode formatiert einen <xref:System.Single>-Wert im Standardformat ("G" oder allgemein) einer angegebenen Kultur. Wenn Sie ein anderes Format oder die aktuelle Kultur angeben m√∂chten, verwenden Sie die anderen √ºber Ladungen der <xref:System.Single.ToString%2A>-Methode wie folgt:  
  
|So verwenden Sie das Format|F√ºr Kultur|Verwenden der √úberladung|  
|-------------------|-----------------|----------------------|  
|Standardformat ("G")|Standard Kultur (aktuell)|<xref:System.Single.ToString>|  
|Ein bestimmtes Format|Standard Kultur (aktuell)|<xref:System.Single.ToString%28System.String%29>|  
|Ein bestimmtes Format|Eine bestimmte Kultur|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Der R√ºckgabewert kann <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>oder eine Zeichenfolge in der Form lauten:  
  
 [Sign] ganzzahlige Ziffern [. [ Bruch Ziffern]] [e [Sign] exponentialziffern]  
  
 Optionale Elemente werden in eckige Klammern ([und]) eingeschlossen. Elemente, die den Begriff "Ziffern" enthalten, bestehen aus einer Reihe von numerischen Zeichen zwischen 0 und 9. In der folgenden Tabelle werden die einzelnen-Elemente aufgelistet.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|Signieren|Ein negatives Vorzeichen-oder positives Vorzeichen Symbol.|  
|ganzzahlige Ziffern|Eine Reihe von Ziffern, die den ganzzahligen Teil der Zahl angibt. Ganzzahlige Ziffern k√∂nnen nicht vorhanden sein, wenn es sich um Bruch Ziffern handelt.|  
|'.'|Ein kulturspezifisches Dezimaltrennzeichen.|  
|Bruch Ziffern|Eine Reihe von Ziffern, die den Bruch Teil der Zahl angibt.|  
|Fresser|Ein Kleinbuchstabe "e", der die exponentielle (wissenschaftliche) Notation angibt.|  
|exponentielle Ziffern|Eine Reihe von Ziffern, die einen Exponenten angeben.|  
  
 Einige Beispiele f√ºr den R√ºckgabewert sind "100", "-123.456.789", "123,45 e + 6", "500", "3,1416", "600", "-0,123" und "-Infinity".  
  
 Der .NET Framework bietet umfassende Formatierungs Unterst√ºtzung, die in den folgenden Formatierungs Themen ausf√ºhrlicher beschrieben wird:  
  
-   Weitere Informationen zu numerischen Format Bezeichnerzeichen finden Sie unter [Standard m√§√üige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und [benutzerdefinierte Zahlenformat](~/docs/standard/base-types/custom-numeric-format-strings.md)Zeichenfolgen.  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatieren von Typen](~/docs/standard/base-types/formatting-types.md).  
  
 Der `provider`-Parameter ist eine <xref:System.IFormatProvider> Implementierung, deren <xref:System.IFormatProvider.GetFormat%2A>-Methode ein <xref:System.Globalization.NumberFormatInfo> Objekt zur√ºckgibt. In der Regel ist `provider` ein <xref:System.Globalization.CultureInfo>-Objekt oder ein <xref:System.Globalization.NumberFormatInfo>-Objekt. Der `provider`-Parameter liefert kulturspezifische Informationen, die bei der Formatierung verwendet werden. Wenn `provider` `null`ist, wird der R√ºckgabewert mit den <xref:System.Globalization.NumberFormatInfo> Daten f√ºr die aktuelle Kultur formatiert.  
  
 Um einen <xref:System.Single> Wert unter Verwendung einer angegebenen Kultur und einer bestimmten Format Zeichenfolge in seine Zeichen folgen Darstellung zu konvertieren, m√ºssen Sie die <xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>-Methode aufzurufen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Zeichen folgen Darstellung von zwei <xref:System.Single>-Werten mit <xref:System.Globalization.CultureInfo> Objekten angezeigt, die verschiedene Kulturen darstellen.  
  
 [!code-csharp[System.Single.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#2)]
 [!code-vb[System.Single.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="single.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Eine numerische Formatierungszeichenfolge.</param>
        <summary>Konvertiert den numerischen Wert dieser Instanz in die entsprechende Zeichenfolgendarstellung unter Ber√ºcksichtigung des angegebenen Formats.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieser Instanz entsprechend den Angaben von <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Single.ToString%28System.String%29>-Methode formatiert einen <xref:System.Single>-Wert in einem angegebenen Format unter Verwendung der Konventionen der aktuellen Kultur. Wenn Sie das Standardformat ("G" oder "Allgemein") verwenden oder eine andere Kultur angeben m√∂chten, verwenden Sie die anderen √ºber Ladungen der <xref:System.Single.ToString%2A>-Methode wie folgt:  
  
|So verwenden Sie das Format|F√ºr Kultur|Verwenden der √úberladung|  
|-------------------|-----------------|----------------------|  
|Standardformat ("G")|Standard Kultur (aktuell)|<xref:System.Single.ToString>|  
|Standardformat ("G")|Eine bestimmte Kultur|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|Ein bestimmtes Format|Eine bestimmte Kultur|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Der R√ºckgabewert kann <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>oder die Zeichen folgen Darstellung des Werts der aktuellen Instanz sein, wie in `format`angegeben.  
  
 Der `format`-Parameter kann ein beliebiger g√ºltiger numerischer Standardformat Bezeichner mit Ausnahme von D und X sowie eine beliebige Kombination von benutzerdefinierten numerischen Format Bezeichnern sein. Wenn Format `null` oder eine leere Zeichenfolge ist, wird der R√ºckgabewert mit dem allgemeinen numerischen Format Bezeichner ("G") formatiert.  
  
 Der .NET Framework bietet umfassende Formatierungs Unterst√ºtzung, die in den folgenden Formatierungs Themen ausf√ºhrlicher beschrieben wird:  
  
-   Weitere Informationen zu numerischen Format Bezeichnerzeichen finden Sie unter [Standard m√§√üige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und [benutzerdefinierte Zahlenformat](~/docs/standard/base-types/custom-numeric-format-strings.md)Zeichenfolgen.  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatieren von Typen](~/docs/standard/base-types/formatting-types.md).  
  
 Standardm√§√üig enth√§lt der R√ºckgabewert nur 7 Dezimalstellen, obwohl intern maximal 9 Ziffern aufbewahrt werden. Wenn der Wert dieser Instanz mehr als 7 Ziffern hat, gibt <xref:System.Single.ToString%28System.String%29> <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> oder <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> anstelle der erwarteten Zahl zur√ºck. Wenn Sie mehr Genauigkeit ben√∂tigen, geben Sie `format` mit der Format Spezifikation "G9" an, die immer 9 Ziffern der Genauigkeit zur√ºckgibt, oder "R", die sieben Ziffern zur√ºckgibt, wenn die Zahl mit dieser Genauigkeit oder 9 Ziffern dargestellt werden kann, wenn die Zahl nur mit maximaler Genauigkeit dargestellt werden kann.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein numerischer Wert definiert und als W√§hrungswert formatiert, indem die standardm√§√üige numerische Format Zeichenfolge "C" und ein numerischer Wert f√ºr drei Dezimalstellen mit der standardm√§√üigen numerischen Format Zeichenfolge "N" verwendet wird. Die Ergebnis Zeichenfolgen werden anhand der Konventionen der Kultur "en-US" formatiert. Weitere Informationen zu numerischen Format Zeichenfolgen finden Sie unter [Standard m√§√üige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und [benutzerdefinierte Zahlenformat](~/docs/standard/base-types/custom-numeric-format-strings.md)Zeichenfolgen.  
  
 [!code-csharp[System.Single.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString7.cs#7)]
 [!code-vb[System.Single.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString7.vb#7)]  
  
 Im folgenden Beispiel werden mehrere <xref:System.Single> Werte angezeigt, wobei jeder der unterst√ºtzten numerischen Standardformat Bearbeiter mit zwei benutzerdefinierten numerischen Format Zeichenfolgen verwendet wird. Eine dieser benutzerdefinierten Format Zeichenfolgen veranschaulicht, wie ein <xref:System.Single> Wert mit f√ºhrenden Nullen aufgef√ºllt wird. Beim Umrechnen der numerischen Werte in Zeichen folgen verwendet das Beispiel die Formatierungs Konventionen der Kultur "en-US".  
  
 [!code-csharp[System.Single.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#3)]
 [!code-vb[System.Single.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" /> ist ung√ºltig.</exception>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-pad-a-number-with-leading-zeros.md">Gewusst wie: Auff√ºllen einer Zahl mit f√ºhrenden Nullen</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="single.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Eine numerische Formatierungszeichenfolge.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Konvertiert den numerischen Wert dieser Instanz unter Verwendung des angegebenen Formats und der angegebenen kulturabh√§ngigen Formatierungsinformationen in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieser Instanz entsprechend den Angaben von <paramref name="format" /> und <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>-Methode formatiert einen <xref:System.Single>-Wert in einem angegebenen Format einer angegebenen Kultur. Wenn Sie die Standardformat-oder Kultur Einstellungen verwenden m√∂chten, verwenden Sie die anderen √ºber Ladungen der <xref:System.Single.ToString%2A>-Methode wie folgt:  
  
|So verwenden Sie das Format|F√ºr Kultur|Verwenden der √úberladung|  
|-------------------|-----------------|----------------------|  
|Standardformat ("G")|Standard Kultur (aktuell)|<xref:System.Single.ToString>|  
|Standardformat ("G")|Eine bestimmte Kultur|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|Ein bestimmtes Format|Standard Kultur (aktuell)|<xref:System.Single.ToString%28System.String%29>|  
  
 Der R√ºckgabewert kann <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>oder die Zeichen folgen Darstellung des Werts der aktuellen Instanz sein, wie in `format`angegeben.  
  
 Der `format`-Parameter kann ein beliebiger g√ºltiger numerischer Standardformat Bezeichner mit Ausnahme von D und X sowie eine beliebige Kombination von benutzerdefinierten numerischen Format Bezeichnern sein. Wenn `format` `null` oder eine leere Zeichenfolge ist, wird der R√ºckgabewert f√ºr diese Instanz mit dem allgemeinen numerischen Format Bezeichner ("G") formatiert.  
  
 Der .NET Framework bietet umfassende Formatierungs Unterst√ºtzung, die in den folgenden Formatierungs Themen ausf√ºhrlicher beschrieben wird:  
  
-   Weitere Informationen zu numerischen Format Bezeichnerzeichen finden Sie unter [Standard m√§√üige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und [benutzerdefinierte Zahlenformat](~/docs/standard/base-types/custom-numeric-format-strings.md)Zeichenfolgen.  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatieren von Typen](~/docs/standard/base-types/formatting-types.md).  
  
 Der `provider`-Parameter ist eine <xref:System.IFormatProvider> Implementierung, deren <xref:System.IFormatProvider.GetFormat%2A>-Methode ein <xref:System.Globalization.NumberFormatInfo> Objekt zur√ºckgibt. In der Regel ist `provider` ein <xref:System.Globalization.CultureInfo>-Objekt oder ein <xref:System.Globalization.NumberFormatInfo>-Objekt. Der `provider`-Parameter liefert kulturspezifische Informationen, die bei der Formatierung verwendet werden. Wenn `provider` `null`ist, wird der R√ºckgabewert mit dem <xref:System.Globalization.NumberFormatInfo>-Objekt f√ºr die aktuelle Kultur formatiert.  
  
 Standardm√§√üig enth√§lt der R√ºckgabewert nur 7 Dezimalstellen, obwohl intern maximal 9 Ziffern aufbewahrt werden. Wenn der Wert dieser Instanz mehr als 7 Ziffern hat, gibt <xref:System.Single.ToString%2A> <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> oder <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> anstelle der erwarteten Zahl zur√ºck. Wenn Sie mehr Genauigkeit ben√∂tigen, geben Sie `format` mit der Format Spezifikation "G9" an, die immer 9 Ziffern der Genauigkeit zur√ºckgibt, oder "R", die sieben Ziffern zur√ºckgibt, wenn die Zahl mit dieser Genauigkeit oder 9 Ziffern dargestellt werden kann, wenn die Zahl nur mit maximaler Genauigkeit dargestellt werden kann.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein <xref:System.Single> Wert mit den unterst√ºtzten numerischen Standardformat bezeichnerwerten f√ºr verschiedene Kulturen angezeigt.  
  
 [!code-csharp[System.Single.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#4)]
 [!code-vb[System.Single.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-pad-a-number-with-leading-zeros.md">Gewusst wie: Auff√ºllen einer Zahl mit f√ºhrenden Nullen</related>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default, IFormatProvider provider = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; * int * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="single.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination">Nach Ausf√ºhrung dieser Methode wird der Wert dieser Instanz als Zeichenspanne formatiert.</param>
        <param name="charsWritten">Nach Ausf√ºhrung dieser Methode die Anzahl der in <paramref name="destination" /> geschriebenen Zeichen.</param>
        <param name="format">Eine Spanne, die die Zeichen enth√§lt, die eine standardm√§√üig festgelegte oder benutzerdefinierte Formatzeichenfolge darstellen, die das akzeptable Format f√ºr <paramref name="destination" /> definiert.</param>
        <param name="provider">Ein optionales Objekt, das kulturspezifische Formatierungsinformationen f√ºr <paramref name="destination" /> bereitstellt</param>
        <summary>Versucht, den Wert der aktuellen Instanz der Gleitkommazahl in die angegebene Zeichenspanne zu formatieren</summary>
        <returns><see langword="true" />, wenn die Formatierung erfolgreich war, andernfalls <see langword="false" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in die entsprechende Gleitkommazahl mit einfacher Genauigkeit. Ein R√ºckgabewert gibt an, ob die Konvertierung erfolgreich war oder nicht.</summary>
        <altmember cref="Overload:System.Single.Parse" />
        <remarks>In .net Core 3,0 und h√∂her werden Werte, die zu gro√ü f√ºr die Darstellung sind, auf <see cref="F:System.Single.PositiveInfinity" /> oder <see cref="F:System.Single.NegativeInfinity" /> gerundet, wie f√ºr die IEEE 754-Spezifikation erforderlich. In fr√ºheren Versionen, einschlie√ülich .NET Framework, f√ºhrte das Auswerten eines Werts, der zu gro√ü f√ºr die Darstellung war, zu einem Fehler.</remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.ReadOnlySpan{System.Char},System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * single -&gt; bool" Usage="System.single.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="result" Type="System.Single" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="s">&gt;Eine Zeichenspanne, die die Zeichenfolgendarstellung der zu konvertierenden Zahl enth√§lt.</param>
        <param name="result">&gt;Wenn diese Methode zur√ºckgegeben wird, enth√§lt sie bei erfolgreicher Konvertierung eine Gleitkommazahl mit einfacher Genauigkeit, die dem <paramref name="s" />-Parameter entspricht, oder ‚Äû0‚Äú (null), wenn die Konvertierung fehlgeschlagen ist. Die Konvertierung schl√§gt fehl, wenn der <paramref name="s" />-Parameter <see langword="null" />, leer oder keine Zahl im g√ºltigen Format ist. Wenn <parmref name="s" /> eine g√ºltige Zahl kleiner als <see cref="F:System.Single.MinValue" /> ist, ist <paramref name="result" /> gleich <see cref="F:System.Single.NegativeInfinity" />. Wenn <parmref name="s" /> eine g√ºltige Zahl gr√∂√üer als <see cref="F:System.Single.MaxValue" /> ist, ist <paramref name="result" /> gleich <see cref="F:System.Single.PositiveInfinity" />. Dieser Parameter wird nicht initialisiert √ºbergeben. Jeder Wert, der urspr√ºnglich im bereitgestellten <paramref name="result" /> √ºberschrieben werden.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einer Zeichenspanne in die entsprechende Gleitkommazahl mit einfacher Genauigkeit. Ein R√ºckgabewert gibt an, ob die Konvertierung erfolgreich war oder nicht.</summary>
        <returns><see langword="true" />, wenn <paramref name="s" /> erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>In .net Core 3,0 und h√∂her werden Werte, die zu gro√ü f√ºr die Darstellung sind, auf <see cref="F:System.Single.PositiveInfinity" /> oder <see cref="F:System.Single.NegativeInfinity" /> gerundet, wie f√ºr die IEEE 754-Spezifikation erforderlich. In fr√ºheren Versionen, einschlie√ülich .NET Framework, f√ºhrte das Auswerten eines Werts, der zu gro√ü f√ºr die Darstellung war, zu einem Fehler.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.String,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * single -&gt; bool" Usage="System.single.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Single" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die die zu konvertierende Zahl darstellt.</param>
        <param name="result">Diese Methode gibt bei erfolgreicher Konvertierung eine Gleitkommazahl mit einfacher Genauigkeit zur√ºck, die dem numerischen Wert oder dem in <paramref name="s" /> enthaltenen Symbol entspricht, und¬†0¬†(null), wenn die Konvertierung nicht durchgef√ºhrt werden konnte. Die Konvertierung schl√§gt fehl, wenn der <paramref name="s" />-Parameter <see langword="null" />, <see cref="F:System.String.Empty" /> oder keine Zahl im g√ºltigen Format ist. Au√üerdem schl√§gt sie in .NET Framework und .NET Core 2.2 und fr√ºheren Versionen fehl, wenn <paramref name="s" /> eine Zahl kleiner als <see cref="F:System.Single.MinValue" /> oder gr√∂√üer als <see cref="F:System.Single.MaxValue" /> darstellt. Dieser Parameter wird nicht initialisiert √ºbergeben. Jeder Wert, der urspr√ºnglich im bereitgestellten <paramref name="result" /> √ºberschrieben werden.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in die entsprechende Gleitkommazahl mit einfacher Genauigkeit. Ein R√ºckgabewert gibt an, ob die Konvertierung erfolgreich war oder nicht.</summary>
        <returns><see langword="true" />, wenn <paramref name="s" /> erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .net Core 3,0 und h√∂her werden Werte, die zu gro√ü f√ºr die Darstellung sind, auf <xref:System.Single.PositiveInfinity> oder <xref:System.Single.NegativeInfinity> gerundet, wie f√ºr die IEEE 754-Spezifikation erforderlich. In fr√ºheren Versionen, einschlie√ülich .NET Framework, f√ºhrte das Auswerten eines Werts, der zu gro√ü f√ºr die Darstellung war, zu einem Fehler.

 Diese √úberladung unterscheidet sich von der <xref:System.Single.Parse%28System.String%29?displayProperty=nameWithType>-Methode, indem ein boolescher Wert zur√ºckgegeben wird, der angibt, ob der Analyse Vorgang erfolgreich war, anstatt den analysierten numerischen Wert zur√ºckzugeben. Es entf√§llt, dass die Ausnahmebehandlung verwendet werden muss, um auf eine <xref:System.FormatException> zu testen, wenn `s` ung√ºltig ist und nicht erfolgreich analysiert werden kann.  
  
 Der `s`-Parameter kann <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> (der Zeichen folgen Vergleich unter Beachtung der Gro√ü-/Kleinschreibung) oder eine Zeichenfolge in der Form enthalten:  
  
 Gefangener Geb√§rden [integrale Ziffern,] ganzzahlige Ziffern [. [ Bruch Ziffern]] [e [Sign] exponentialziffern] [WS]  
  
 Elemente in eckigen Klammern sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Eine Reihe von Leerzeichen.|  
|*sign*|Ein negatives Vorzeichen-oder positives Vorzeichen Symbol.|  
|*ganzzahlige Ziffern*|Eine Reihe von numerischen Zeichen im Bereich von 0 bis 9, die den ganzzahligen Teil der Zahl angeben. Ganzzahlige Ziffern k√∂nnen nicht vorhanden sein, wenn es sich um Bruch Ziffern handelt.|  
|*,*|Ein kulturspezifisches Gruppen Trennzeichen.|  
|*.*|Ein kulturspezifisches Dezimaltrennzeichen.|  
|*Bruch Ziffern*|Eine Reihe von numerischen Zeichen im Bereich von 0 bis 9, die den Bruchteil der Zahl angeben.|  
|*E*|Ein Gro√übuchstabe oder ein Kleinbuchstabe "e", der die exponentielle (wissenschaftliche) Notation angibt.|  
|*exponentielle Ziffern*|Eine Reihe von numerischen Zeichen im Bereich von 0 bis 9, die einen Exponenten angeben.|  
  
 Der `s`-Parameter wird mit einer Kombination der <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType>-und <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>-Flags interpretiert. Dies bedeutet, dass Leerzeichen und Tausender Trennzeichen zul√§ssig sind, aber W√§hrungssymbole nicht. Verwenden Sie die <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29>-Methoden √úberladung, um die Elemente (z. b. W√§hrungssymbole, Tausende Trennzeichen und Leerzeichen), die in `s`vorhanden sein k√∂nnen, explizit zu definieren.  
  
 Der `s`-Parameter wird mithilfe der Formatierungsinformationen in einem <xref:System.Globalization.NumberFormatInfo>-Objekt analysiert, das f√ºr die aktuelle System Kultur initialisiert wird. Weitere Informationen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>. Verwenden Sie die <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29>-Methoden √úberladung, um eine Zeichenfolge mit den Formatierungsinformationen einer anderen angegebenen Kultur zu analysieren.  
  
 Wenn Sie der <xref:System.Single.TryParse%2A?displayProperty=nameWithType>-Methode eine Zeichenfolge √ºbergeben, die durch Aufrufen der <xref:System.Single.ToString%2A?displayProperty=nameWithType>-Methode erstellt wird, wird normalerweise der urspr√ºngliche <xref:System.Single> Wert zur√ºckgegeben. Aufgrund eines Genauigkeits Verlusts sind die Werte jedoch m√∂glicherweise nicht gleich.  

Wenn `s` au√üerhalb des Bereichs des <xref:System.Single> Datentyps liegt, gibt die Methode `false` auf .NET Framework und .net Core 2,2 und fr√ºheren Versionen zur√ºck. In .net Core 3,0 und h√∂heren Versionen wird <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> zur√ºckgegeben, wenn `s` kleiner als <xref:System.Single.MinValue?displayProperty=nameWithType> ist, und <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, wenn `s` gr√∂√üer als <xref:System.Single.MaxValue?displayProperty=nameWithType>ist.

Wenn w√§hrend eines Analyse Vorgangs ein Trennzeichen im `s`-Parameter gefunden wird und die entsprechende W√§hrungs-oder Zahlen Dezimal-und Gruppen Trennzeichen identisch sind, geht der Analyse Vorgang davon aus, dass das Trennzeichen ein Dezimaltrennzeichen und nicht ein Gruppen Trennzeichen ist. Weitere Informationen zu Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Single.TryParse%28System.String%2CSystem.Single%40%29>-Methode verwendet, um die Zeichen folgen Darstellungen numerischer Werte in <xref:System.Single> Werte zu konvertieren. Dabei wird davon ausgegangen, dass "en-US" die aktuelle Kultur ist.  
  
 [!code-csharp[System.Single.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.tryparse/cs/tryparse1.cs#1)]
 [!code-vb[System.Single.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.tryparse/vb/tryparse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analysieren numerischer Zeichenfolgen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider provider, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider * single -&gt; bool" Usage="System.single.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="result" Type="System.Single" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="s">Eine schreibgesch√ºtzte Zeichenspanne, die die zu konvertierende Zahl enth√§lt. Die Zeichenspanne wird unter Verwendung des durch <paramref name="style" /> angegebenen Formats interpretiert.</param>
        <param name="style">Eine bitweise Kombination von Enumerationswerten, die das zul√§ssige Format von <paramref name="s" /> angibt. Ein h√§ufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Float" /> in Kombination mit <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu <paramref name="s" /> bereitstellt.</param>
        <param name="result">Diese Methode gibt bei erfolgreicher Konvertierung eine Gleitkommazahl mit einfacher Genauigkeit zur√ºck, die dem numerischen Wert oder dem in <paramref name="s" /> enthaltenen Symbol entspricht, und¬†0¬†(null), wenn die Konvertierung nicht durchgef√ºhrt werden konnte. Die Konvertierung kann nicht durchgef√ºhrt werden, wenn der <paramref name="s" />-Parameter <see langword="null" /> oder <see cref="F:System.String.Empty" /> ist, kein mit <paramref name="style" /> kompatibles Format aufweist, eine Zahl kleiner als <see cref="F:System.Single.MinValue" /> oder gr√∂√üer als <see cref="F:System.Single.MaxValue" /> darstellt, oder wenn <paramref name="style" /> keine g√ºltige Kombination von <see cref="T:System.Globalization.NumberStyles" />-Enumerationskonstanten ist. Dieser Parameter wird nicht initialisiert √ºbergeben. Jeder Wert, der urspr√ºnglich im bereitgestellten <paramref name="result" /> √ºberschrieben werden.</param>
        <summary>Konvertiert die Spannendarstellung einer Zahl in einem angegebenen Stil und einem kulturabh√§ngigen Format in die entsprechende Gleitkommazahl mit einfacher Genauigkeit Ein R√ºckgabewert gibt an, ob die Konvertierung erfolgreich war oder nicht.</summary>
        <returns><see langword="true" />, wenn <paramref name="s" /> erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>In .net Core 3,0 und h√∂her werden Werte, die zu gro√ü f√ºr die Darstellung sind, auf <see cref="F:System.Single.PositiveInfinity" /> oder <see cref="F:System.Single.NegativeInfinity" /> gerundet, wie f√ºr die IEEE 754-Spezifikation erforderlich. In fr√ºheren Versionen, einschlie√ülich .NET Framework, f√ºhrte das Auswerten eines Werts, der zu gro√ü f√ºr die Darstellung war, zu einem Fehler.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider * single -&gt; bool" Usage="System.single.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Single" RefType="out" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die die zu konvertierende Zahl darstellt.</param>
        <param name="style">Eine bitweise Kombination von Enumerationswerten, die das zul√§ssige Format von <paramref name="s" /> angibt. Ein h√§ufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Float" /> in Kombination mit <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu <paramref name="s" /> bereitstellt.</param>
        <param name="result">Diese Methode gibt bei erfolgreicher Konvertierung eine Gleitkommazahl mit einfacher Genauigkeit zur√ºck, die dem numerischen Wert oder dem in <paramref name="s" /> enthaltenen Symbol entspricht, und¬†0¬†(null), wenn die Konvertierung nicht durchgef√ºhrt werden konnte. Die Konvertierung kann nicht durchgef√ºhrt werden, wenn der <paramref name="s" />-Parameter <see langword="null" /> oder <see cref="F:System.String.Empty" /> ist, kein mit <paramref name="style" /> kompatibles Format aufweist oder <paramref name="style" /> keine g√ºltige Kombination von <see cref="T:System.Globalization.NumberStyles" />-Enumerationskonstanten ist. Au√üerdem schl√§gt sie in .NET Framework oder .NET Core 2.2 und fr√ºheren Versionen fehl, wenn <paramref name="s" /> eine Zahl kleiner als <see cref="F:System.Single.MinValue" /> oder gr√∂√üer als <see cref="F:System.Single.MaxValue" /> darstellt. Dieser Parameter wird nicht initialisiert √ºbergeben. Jeder Wert, der urspr√ºnglich im bereitgestellten <paramref name="result" /> √ºberschrieben werden.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturabh√§ngigen Format in die entsprechende Gleitkommazahl mit einfacher Genauigkeit. Ein R√ºckgabewert gibt an, ob die Konvertierung erfolgreich war oder nicht.</summary>
        <returns><see langword="true" />, wenn <paramref name="s" /> erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .net Core 3,0 und h√∂her werden Werte, die zu gro√ü f√ºr die Darstellung sind, auf <xref:System.Single.PositiveInfinity> oder <xref:System.Single.NegativeInfinity> gerundet, wie f√ºr die IEEE 754-Spezifikation erforderlich. In fr√ºheren Versionen, einschlie√ülich .NET Framework, f√ºhrte das Auswerten eines Werts, der zu gro√ü f√ºr die Darstellung war, zu einem Fehler.

 Diese √úberladung unterscheidet sich von der <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29>-Methode, indem ein boolescher Wert zur√ºckgegeben wird, der angibt, ob der Analyse Vorgang erfolgreich war, anstatt den analysierten numerischen Wert zur√ºckzugeben. Es entf√§llt, dass die Ausnahmebehandlung verwendet werden muss, um auf eine <xref:System.FormatException> zu testen, wenn `s` ung√ºltig ist und nicht erfolgreich analysiert werden kann.  
  
 Der `style`-Parameter definiert das zul√§ssige Format des `s`-Parameters, damit der Analyse Vorgang erfolgreich ausgef√ºhrt wird. Dabei muss es sich um eine Kombination von Bitflags aus der <xref:System.Globalization.NumberStyles> Enumeration handeln. Die folgenden <xref:System.Globalization.NumberStyles> Elemente werden nicht unterst√ºtzt:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>  
  
 Der `s`-Parameter kann <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A><xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> f√ºr die Kultur enthalten, die durch `provider`angegeben wird. Au√üerdem kann der `s` Parameter abh√§ngig vom Wert `style`die folgenden Elemente enthalten:  
  
 Gefangener [$] Geb√§rden [ganzzahlige Ziffern,] ganzzahlige Ziffern [. Bruch Ziffern] [e [Sign] exponentialziffern] [WS]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Optionaler Leerraum. Leerraum kann am Anfang `s` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>-Flag enth√§lt. Sie kann am Ende der `s` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>-Flag enth√§lt.|  
|*$*|Ein kulturspezifisches W√§hrungssymbol. Die Position in der Zeichenfolge wird durch die Eigenschaften <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> oder <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> des <xref:System.Globalization.NumberFormatInfo> Objekts definiert, das von der <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType>-Methode des `provider`-Parameters zur√ºckgegeben wird. Das W√§hrungssymbol kann in `s` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>-Flag enth√§lt.|  
|*sign*|Ein optionales Vorzeichen. Das Vorzeichen kann am Anfang `s` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType>-Flag enth√§lt, und es kann am Ende `s` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>-Flag enth√§lt. In `s` k√∂nnen Klammern verwendet werden, um einen negativen Wert anzugeben, wenn `style` das <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>-Flag enth√§lt.|  
|*ganzzahlige Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die den ganzzahligen Teil der Zahl angeben. Ganzzahlige Ziffern k√∂nnen nicht vorhanden sein, wenn es sich um Bruch Ziffern handelt.|  
|*,*|Ein kulturspezifisches Tausender Trennzeichen. Das Tausender Trennzeichen der aktuellen Kultur kann in `s` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>-Flag enth√§lt.|  
|*.*|Ein kulturspezifisches Dezimaltrennzeichen. Das Dezimaltrennzeichen der aktuellen Kultur kann in `s` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>-Flag enth√§lt.|  
|*Bruch Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die den Bruch Teil der Zahl angeben. Bruch Ziffern k√∂nnen in `s` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>-Flag enth√§lt.|  
|*e*|Das e-oder e-Zeichen, das angibt, dass `s` eine Zahl mit exponentieller Notation darstellen kann. Der `s`-Parameter kann eine Zahl in Exponentialnotation darstellen, wenn style das <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>-Flag enth√§lt.|  
|*exponentielle Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die einen Exponenten angeben.|  
  
> [!NOTE]
> Alle abschlie√üenden NUL-Zeichen (U + 0000) in `s` werden vom Analyse-Vorgang unabh√§ngig vom Wert des `style` Arguments ignoriert.

 Eine Zeichenfolge mit nur Ziffern (die dem <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> Stil entspricht) wird immer erfolgreich analysiert, wenn Sie sich im Bereich des <xref:System.Single> Typs befindet. Die verbleibenden <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Member steuern Elemente, die m√∂glicherweise, jedoch nicht in der Eingabe Zeichenfolge vorhanden sein m√ºssen. In der folgenden Tabelle wird angegeben, wie einzelne <xref:System.Globalization.NumberStyles> Flags die Elemente beeinflussen, die m√∂glicherweise in `s`vorhanden sind.  
  
|NumberStyles-Wert|In s zul√§ssige Elemente zus√§tzlich zu Ziffern|  
|------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Nur das ganzzahlige *Ziffern* Element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Das Sprachelement *.* und *Bruch Ziffern* Elemente.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Der `s`-Parameter kann auch die Exponentialnotation verwenden. Dieses Flag allein unterst√ºtzt Werte in der Form ganzzahlige *Ziffern*E*exponentialziffern*. zus√§tzliche Flags sind erforderlich, um Zeichen folgen in Exponentialnotation mit solchen Elementen wie positive oder negative Vorzeichen und Dezimaltrennzeichen erfolgreich zu analysieren.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Das *WS* -Element am Anfang `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Das *WS* -Element am Ende `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Das *Sign* -Element am Anfang `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Das *Sign* -Element am Ende `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Das *Vorzeichen* Element in der Form von Klammern, das den numerischen Wert einschlie√üt.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Das *-* Element.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Das *$* Element.|  
|<xref:System.Globalization.NumberStyles.Currency>|All. Der `s`-Parameter kann keine hexadezimal Zahl oder eine Zahl in Exponentialnotation darstellen.|  
|<xref:System.Globalization.NumberStyles.Float>|Das *WS* -Element am Anfang oder Ende `s`, *signiert* am Anfang `s`und *.* Tick. Der `s`-Parameter kann auch die Exponentialnotation verwenden.|  
|<xref:System.Globalization.NumberStyles.Number>|Die Elemente `ws`, `sign`, Tausender Trennzeichen (*,)* und Dezimaltrennzeichen (*.*).|  
|<xref:System.Globalization.NumberStyles.Any>|Alle Stile, au√üer `s` k√∂nnen keine hexadezimal Zahl darstellen.|  
  
 Der `provider`-Parameter ist eine <xref:System.IFormatProvider> Implementierung, deren <xref:System.IFormatProvider.GetFormat%2A>-Methode ein <xref:System.Globalization.NumberFormatInfo> Objekt zur√ºckgibt, das kulturspezifische Formatierungsinformationen bereitstellt. Wenn die <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29>-Methode aufgerufen wird, ruft Sie die <xref:System.IFormatProvider.GetFormat%2A>-Methode des `provider`-Parameters auf und √ºbergibt ihr ein <xref:System.Type> Objekt, das den <xref:System.Globalization.NumberFormatInfo> Typ darstellt. Die <xref:System.IFormatProvider.GetFormat%2A>-Methode gibt dann das <xref:System.Globalization.NumberFormatInfo>-Objekt zur√ºck, das Informationen zum Format des `s`-Parameters bereitstellt. Es gibt drei M√∂glichkeiten, den `provider`-Parameter zu verwenden, um benutzerdefinierte Formatierungsinformationen f√ºr den Analyse Vorgang bereitzustellen:  
  
-   Sie k√∂nnen ein <xref:System.Globalization.CultureInfo> Objekt √ºbergeben, das die Kultur darstellt, die Formatierungsinformationen bereitstellt. Die <xref:System.Globalization.CultureInfo.GetFormat%2A>-Methode gibt das <xref:System.Globalization.NumberFormatInfo> Objekt zur√ºck, das numerische Formatierungsinformationen f√ºr diese Kultur bereitstellt.  
  
-   Sie k√∂nnen das tats√§chliche <xref:System.Globalization.NumberFormatInfo> Objekt √ºbergeben, das numerische Formatierungsinformationen bereitstellt. (Die Implementierung von <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> nur sich selbst zur√ºckgegeben.)  
  
-   Sie k√∂nnen ein benutzerdefiniertes Objekt √ºbergeben, das <xref:System.IFormatProvider>implementiert. Die <xref:System.IFormatProvider.GetFormat%2A>-Methode instanziiert und gibt das <xref:System.Globalization.NumberFormatInfo> Objekt zur√ºck, das Formatierungsinformationen bereitstellt.  
  
 Wenn `provider` `null`ist, wird die Formatierung der `s` basierend auf dem <xref:System.Globalization.NumberFormatInfo> Objekt der aktuellen Kultur interpretiert.  

Wenn sich `s` au√üerhalb des Bereichs des <xref:System.Single> Datentyps befindet, l√∂st die Methode eine <xref:System.OverflowException> auf .NET Framework und .net Core 2,2 und fr√ºheren Versionen aus. In .net Core 3,0 und h√∂heren Versionen wird <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> zur√ºckgegeben, wenn `s` kleiner als <xref:System.Single.MinValue?displayProperty=nameWithType> ist, und <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, wenn `s` gr√∂√üer als <xref:System.Single.MaxValue?displayProperty=nameWithType>ist.

 Wenn w√§hrend eines Analyse Vorgangs ein Trennzeichen im `s`-Parameter gefunden wird und die entsprechende W√§hrungs-oder Zahlen Dezimal-und Gruppen Trennzeichen identisch sind, geht der Analyse Vorgang davon aus, dass das Trennzeichen ein Dezimaltrennzeichen und nicht ein Gruppen Trennzeichen ist. Weitere Informationen zu Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
 
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29?displayProperty=nameWithType>-Methode verwendet wird, um die Zeichen folgen Darstellung von Zahlen zu analysieren, die einen bestimmten Stil aufweisen und mit den Konventionen einer bestimmten Kultur formatiert werden.  
  
 [!code-csharp[System.Single.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.tryparse/cs/tryparse1.cs#2)]
 [!code-vb[System.Single.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.tryparse/vb/tryparse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
- oder - 
 <paramref name="style" /> ist der <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />-Wert.</exception>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analysieren numerischer Zeichenfolgen in .NET</related>
      </Docs>
    </Member>
  </Members>
</Type>
