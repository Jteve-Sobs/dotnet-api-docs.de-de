<Type Name="Single" FullName="System.Single">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="244d6ba71dbadc7d75916a9dfce8a1c810e4224d" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48617219" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Single : IComparable, IComparable&lt;float&gt;, IConvertible, IEquatable&lt;float&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit float32 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float32&gt;, class System.IConvertible, class System.IEquatable`1&lt;float32&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Single" />
  <TypeSignature Language="VB.NET" Value="Public Structure Single&#xA;Implements IComparable, IComparable(Of Single), IConvertible, IEquatable(Of Single), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Single : IComparable, IComparable&lt;float&gt;, IConvertible, IEquatable&lt;float&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type single = struct&#xA;    interface IFormattable&#xA;    interface IConvertible" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Single&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Single&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine Gleitkommazahl mit einfacher Genauigkeit dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Single> Werttyp stellt eine 32-Bit-Zahl mit einfacher Genauigkeit mit Werten, die im Bereich von negativen 3,402823E38 bis positive 3,402823E38 als auch positive oder negative 0 (null), <xref:System.Single.PositiveInfinity>, <xref:System.Single.NegativeInfinity>, und keine Zahl (<xref:System.Single.NaN>). Es dient zur Darstellung der Werte, die sich (z. B. die Abstände zwischen Planeten oder Galaxies) sehr große oder sehr klein ist (z. B. die molekulare Masse einer Substanz in Kilogramm) und häufig unpräzise sind (wie der Abstand zwischen der Erde und eine andere Sonnensystem sind ). Die <xref:System.Single> Typ den IEC 60559: 1989 (IEEE 754) für binäre Gleitkommaarithmetik standard entspricht.  
  
 Dieses Thema enthält folgende Abschnitte:  
  
-   [Gleitkommadarstellung und Genauigkeit](#Precision)  
  
-   [Testen auf Gleichheit](#Equality)  
  
-   [Gleitkommazahlen-Punktwerte und Ausnahmen](#Exceptions)  
  
-   [Typkonvertierung und das einzelne Struktur](#Conversion)  
  
-   [Gleitkomma-Funktion](#Functionality)  
  
 <xref:System.Single?displayProperty=nameWithType> Stellt Methoden zum Vergleichen von Instanzen dieses Typs, um den Wert einer Instanz in seine Zeichenfolgendarstellung zu konvertieren, und klicken Sie auf die angegebene Zeichenfolgendarstellung einer Zahl in eine Instanz dieses Typs zu konvertieren. Weitere Informationen dazu, wie die Zeichenfolgendarstellung von Werttypen Formatcodes-Spezifikation gesteuert werden, finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md), [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md), und [benutzerdefinierte numerische Formatzeichenfolgen](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
<a name="Precision"></a>   
## <a name="floating-point-representation-and-precision"></a>Gleitkommadarstellung und Genauigkeit  
 Die <xref:System.Single> -Datentyp speichert in einem binären Format 32-Bit-Gleitkommawerten mit einfacher Genauigkeit, wie in der folgenden Tabelle dargestellt:  
  
|Segment|Bits|  
|----------|----------|  
|Signifikanden oder Mantisse|0-22|  
|Exponent|23-30|  
|Sign (0 = positiv, 1 = negative)|31|  
  
 Genau wie die Dezimalstellen nicht einige Werte genau darstellen können (z. B. 1/3 oder <xref:System.Math.PI?displayProperty=nameWithType>), binäre Brüche sind nicht möglich, einige Werte darstellen. 2/10, wodurch die genaue durch.2 als Dezimalbruch dargestellt wird, wird z. B. durch.0011111001001100 als Binärbruch, mit dem Muster "1100" Wiederholen bis unendlich dargestellt. In diesem Fall bietet der Gleitkommawert eine ungenaue Darstellung der Zahl, die es darstellt. Zusätzliche mathematische Operationen für den ursprünglichen Gleitkommawert häufig ausführen, erhöht der Mangel an Genauigkeit. Beispielsweise erzeugt, wenn Sie das Ergebnis Vergleichen der Multiplikation.3 von 10 und.3,.3 neun Mal hinzufügen, außerdem angezeigt wird das Ergebnis nicht präzise genug da hierbei acht weitere Vorgänge als Multiplikation. Beachten Sie, dass die Abweichung ist offensichtlich, nur dann, wenn Sie anzeigen, dass die beiden <xref:System.Single> Werte mithilfe der "R" [standardmäßige numerische Formatzeichenfolge](~/docs/standard/base-types/standard-numeric-format-strings.md), das, wenn erforderlich, zeigt alle 9 Ziffern von unterstützt die <xref:System.Single> Typ.  
  
 [!code-csharp[System.Single.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/representation1.cs#3)]
 [!code-vb[System.Single.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/representation1.vb#3)]  
  
 Da einige Zahlen, genau wie Sekundenbruchteile binäre Werte dargestellt werden können, können Gleitkommazahlen ungefähre reelle Zahlen.  
  
 Alle Gleitkommazahlen haben eine begrenzte Anzahl von signifikanten Stellen, die auch bestimmt, wie genau ein Gleitkommawert eine reellen Zahl entspricht. Ein <xref:System.Single> Wert hat bis zu 7 Dezimalstellen der Genauigkeit, obwohl intern ein Maximum von 9 Ziffern gespeichert wird. Dies bedeutet, dass einige Operationen mit Gleitkommazahlen, die zum Ändern eines Gleitkommawerts mit einfacher Genauigkeit fehlen. Das folgende Beispiel definiert einen große Gleitkommawert mit einfacher Genauigkeit und fügt dann das Produkt der <xref:System.Single.Epsilon?displayProperty=nameWithType> und dabei darauf. Allerdings ist das Produkt zu klein, um den ursprünglichen Gleitkommawert zu ändern. Die am wenigsten signifikante Ziffer ist Zehntausendstel-, während die signifikanteste Ziffer des Produkts 10 ist<sup>-30</sup>.  
  
 [!code-csharp[System.Single.Structure#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/representation2.cs#4)]
 [!code-vb[System.Single.Structure#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/representation2.vb#4)]  
  
 Der eingeschränkte Genauigkeit einer Gleitkommazahl hat mehrere folgen:  
  
-   Zwei Gleitkommazahlen, die für eine bestimmte Genauigkeit gleich angezeigt werden möglicherweise nicht gleich, da es sich bei ihrer letzten gültigen Ziffern unterscheiden. Im folgenden Beispiel werden eine Reihe von Zahlen addiert, und deren Summe wird mit der ihre erwartete Summe verglichen. Obwohl die beiden Werte angezeigt werden, identisch, einen Aufruf der `Equals` -Methode gibt an, dass dies nicht der Fall.  
  
     [!code-csharp[System.Single.Structure#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist3.cs#6)]
     [!code-vb[System.Single.Structure#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/precisionlist3.vb#6)]  
  
     Wenn Sie die Formatelemente in Ändern der <xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%29?displayProperty=nameWithType> -Anweisung aus `{0}` und `{1}` zu `{0:R}` und `{1:R}` anzuzeigende alle signifikanten Ziffern der beiden <xref:System.Single> Werte, es ist klar, dass die beiden Werte ungleich sind, da von einem Genauigkeitsverlust während der Vorgänge hinzufügen. In diesem Fall kann das Problem gelöst werden, durch den Aufruf der <xref:System.Math.Round%28System.Double%2CSystem.Int32%29?displayProperty=nameWithType> Methode, um das Abrunden der <xref:System.Single> Werte vor dem Vergleich der gewünschten Genauigkeit.  
  
-   Eine mathematische oder Vergleichsoperation-Operation, die eine Gleitkommazahl verwendet möglicherweise nicht das gleiche Ergebnis erzielt, wenn eine Dezimalzahl verwendet wird, da die binäre Gleitkommazahl möglicherweise nicht die Dezimalzahl Wert. In einem vorherigen Beispiel veranschaulicht dies durch das Ergebnis der Multiplikation.3 von 10 und das Hinzufügen von.3,.3 neun Mal anzeigen.  
  
     Wenn die Genauigkeit der numerischen Operationen mit Bruchwerten wichtig ist, verwenden die <xref:System.Decimal> -Typ anstelle des der <xref:System.Single> Typ. Bei der Genauigkeit der numerischen Operationen mit ganzzahligen Werten außerhalb des Gültigkeitsbereichs für die <xref:System.Int64> oder <xref:System.UInt64> Typen ist wichtig, verwenden Sie die <xref:System.Numerics.BigInteger> Typ.  
  
-   Ein Wert kann nicht zurückkonvertiert, wenn eine Gleitkommazahl einbezogen ist. Ein Wert wird als Roundtrip bezeichnet, wenn ein Vorgang eine ursprüngliche Gleitkommazahl in ein anderes Format wandelt, ein umgekehrter Vorgang das konvertierte Format zurück in eine Gleitkommazahl transformiert und die endgültige Gleitkommazahl gleich dem ursprünglichen ist Gleitkommazahl. Der Roundtrip kann fehlschlagen, da eine oder mehrere Ziffern verloren gehen oder bei einer Konvertierung geändert. Im folgenden Beispiel drei <xref:System.Single> Werte in Zeichenfolgen konvertiert und in einer Datei gespeichert werden. Die Ausgabe zeigt, obwohl die Werte angezeigt werden, identisch sein, sind die wiederhergestellten Werte nicht gleich die ursprünglichen Werte.  
  
     [!code-csharp[System.Single.Structure#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist4a.cs#17)]
     [!code-vb[System.Single.Structure#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/PrecisionList4a.vb#17)]  
  
     In diesem Fall den möglich erfolgreich Roundtrip mithilfe der "G9" [standardmäßige numerische Formatzeichenfolge](~/docs/standard/base-types/standard-numeric-format-strings.md) die vollständige Genauigkeit beibehalten <xref:System.Single> -Werte, wie im folgenden Beispiel gezeigt.  
  
     [!code-csharp[System.Single.Structure#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/PrecisionList5a.cs#18)]
     [!code-vb[System.Single.Structure#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/PrecisionList5a.vb#18)]  
  
-   <xref:System.Single> Werte müssen weniger Genauigkeit als <xref:System.Double> Werte. Ein <xref:System.Single> -Wert, der in eine entsprechende scheinbar konvertiert wird <xref:System.Double> häufig entspricht nicht der <xref:System.Double> Wert aufgrund der Unterschiede bei mit einfacher Genauigkeit. Im folgenden Beispiel ist das Ergebnis identisch divisionsvorgängen zugewiesen wird eine <xref:System.Double> Wert und einem <xref:System.Single> Wert. Nach der <xref:System.Single> Wert umgewandelt wird eine <xref:System.Double>, ein Vergleich der beiden Werte wird gezeigt, dass sie ungleich sind.  
  
     [!code-csharp[System.Double.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Double.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist1.vb#5)]  
  
     Um dieses Problem zu vermeiden, verwenden Sie entweder die <xref:System.Double> -Datentyp anstelle von der <xref:System.Single> Datentyp aufweisen, oder Verwenden der <xref:System.Math.Round%2A> Methode, damit beide die gleiche Genauigkeit verfügen.  
  
<a name="Equality"></a>   
## <a name="testing-for-equality"></a>Testen auf Gleichheit  
 Um als gleich betrachtet werden zwei <xref:System.Single> Werte müssen identische Werte darstellen. Jedoch aktivieren aufgrund von Unterschieden in der Genauigkeit zwischen Werten oder aufgrund einer Unterbrechung der Genauigkeit von einem oder beiden Werten, Gleitkommazahlen-Punktwerte, die häufig identisch sein sollen aufgrund von Unterschieden in ihren letzten gültigen Ziffern berücksichtigt werden. Daher Aufrufe von der <xref:System.Single.Equals%2A> Methode, um zu bestimmen, ob zwei Werte gleich sind, oder Aufrufe an die <xref:System.Single.CompareTo%2A> Methode, um zu bestimmen, die Beziehung zwischen zwei <xref:System.Single> Werte ergeben häufig unerwartete Ergebnisse. Dies ist im folgenden Beispiel ersichtlich, gleich, in denen zwei scheinbar <xref:System.Single> erweisen Werte ungleich sind, werden, da der erste Wert einer Genauigkeit von 7 Stellen während der zweite Wert 9 aufweist.  
  
 [!code-csharp[System.Single.Structure#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison1.cs#9)]
 [!code-vb[System.Single.Structure#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison1.vb#9)]  
  
 Berechnete Werte, die unterschiedliche Codepfade folgen und, die bearbeitet werden auf unterschiedliche Weise häufig, nachweisen berücksichtigt werden. Im folgenden Beispiel eine <xref:System.Single> Wert quadriert wird, und klicken Sie dann die Quadratwurzel berechnet wird, um den ursprünglichen Wert wiederherzustellen. Ein zweites <xref:System.Single> 3.51 multipliziert und Quadrat, bevor die Quadratwurzel des Ergebnisses durch 3.51 auf den ursprünglichen Wert wiederherzustellen dividiert wird. Obwohl die beiden Werte angezeigt werden, identisch sein einen Aufruf der <xref:System.Single.Equals%28System.Single%29> -Methode gibt an, dass sie nicht gleich sind. Mit der standardmäßigen Formatzeichenfolge "G9", um eine Ergebniszeichenfolge zurückzugeben, die alle signifikanten Stellen der einzelnen zeigt <xref:System.Single> Wert zeigt, dass der zweite Wert.0000000000001 ist kleiner als die erste.  
  
 [!code-csharp[System.Single.Structure#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison2.cs#10)]
 [!code-vb[System.Single.Structure#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison2.vb#10)]  
  
 In Fällen, in denen ein Verlust der Genauigkeit, die das Ergebnis eines Vergleichs beeinflussen, können Sie die folgenden Techniken verwenden, statt die <xref:System.Single.Equals%2A> oder <xref:System.Single.CompareTo%2A> Methode:  
  
-   Rufen Sie die <xref:System.Math.Round%2A?displayProperty=nameWithType> Methode, um sicherzustellen, dass beide Werte die gleiche Genauigkeit enthalten. Das folgende Beispiel ändert die in einem vorherigen Beispiel zum Verwenden dieses Ansatzes damit, dass zwei Bruchzahlen äquivalent sind.  
  
     [!code-csharp[System.Single.Structure#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison3.cs#11)]
     [!code-vb[System.Single.Structure#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison3.vb#11)]  
  
     Beachten Sie, dass das Problem der Genauigkeit weiterhin gilt auf der mittleren Werte gerundet. Weitere Informationen finden Sie unter der Methode <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29?displayProperty=nameWithType>.  
  
-   Test auf Gleichheit ungefähre statt auf Gleichheit. Diese Technik erfordert, dass Sie entweder ein absoluter definieren Menge mit dem die beiden Werte unterscheiden sich aber trotzdem können identisch sein, oder, die Sie definieren einen relativen Betrag an, die mit dem der kleinere Wert von der jeweils größere Wert voneinander abweichen kann.  
  
    > [!WARNING]
    >  <xref:System.Single.Epsilon?displayProperty=nameWithType> wird manchmal als eine absolute Maßeinheit für die Entfernung zwischen zwei verwendet <xref:System.Single> Werten, wenn der Test auf Gleichheit.  Allerdings <xref:System.Single.Epsilon?displayProperty=nameWithType> misst den kleinstmöglichen Wert, der hinzugefügt oder davon subtrahiert werden kann eine <xref:System.Single> , deren Wert ist 0 (null). Für die meisten Positive und negative <xref:System.Single> Werte wird der Wert des <xref:System.Single.Epsilon?displayProperty=nameWithType> ist zu klein, um erkannt zu werden. Aus diesem Grund mit Ausnahme der Werte, die 0 (null) sind, empfehlen wir nicht die Verwendung in prüft auf Gleichheit.  
  
     Im folgenden Beispiel wird den zweiten Ansatz zum Definieren einer `IsApproximatelyEqual` -Methode, die die relative Differenz zwischen zwei Werten überprüft. Außerdem im Gegensatz dazu des Ergebnis von Aufrufen an die `IsApproximatelyEqual` Methode und die <xref:System.Single.Equals%28System.Single%29> Methode.  
  
     [!code-csharp[System.Single.Structure#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison4.cs#12)]
     [!code-vb[System.Single.Structure#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison4.vb#12)]  
  
<a name="Exceptions"></a>   
## <a name="floating-point-values-and-exceptions"></a>Gleitkommazahlen-Punktwerte und Ausnahmen  
 Operationen mit Gleitkommazahlen-Punktwerte lösen keine Ausnahmen, im Gegensatz zu den Operationen mit Ganzzahltypen, die Ausnahmen in Fällen, der nicht zulässige Vorgänge, z. B. Division durch 0 (null) oder ein Überlauffehler ausgelöst.  Stattdessen ist das Ergebnis einer Gleitkommaoperation in diesen Situationen können 0 (null), + unendlich, negativ unendlich oder keine Zahl (NaN):  
  
-   Wenn das Ergebnis einer Gleitkommaoperation zu klein für das Zielformat ist, ist das Ergebnis 0 (null). Dies kann auftreten, wenn zwei sehr kleine Gleitkommazahlen, wie im folgenden Beispiel gezeigt multipliziert werden.  
  
     [!code-csharp[System.Single.Structure#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/exceptional1.cs#1)]
     [!code-vb[System.Single.Structure#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/exceptional1.vb#1)]  
  
-   Wenn das Ergebnis einer Gleitkommaoperation des Bereichs des Ziel-Formats überschreitet, wird das Ergebnis des Vorgangs <xref:System.Single.PositiveInfinity> oder <xref:System.Single.NegativeInfinity>je nach Bedarf für das Vorzeichen des Ergebnisses. Das Ergebnis eines Vorgangs, der führt zu einem Überlauf <xref:System.Single.MaxValue?displayProperty=nameWithType> ist <xref:System.Single.PositiveInfinity>, und das Ergebnis eines Vorgangs, der führt zu einem Überlauf <xref:System.Single.MinValue?displayProperty=nameWithType> ist <xref:System.Single.NegativeInfinity>, wie im folgende Beispiel gezeigt.  
  
     [!code-csharp[System.Single.Structure#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/exceptional2.cs#2)]
     [!code-vb[System.Single.Structure#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/exceptional2.vb#2)]  
  
     <xref:System.Single.PositiveInfinity> auch aus einer Division durch 0 (null), mit der eine positive Dividenden, ausgegeben und <xref:System.Single.NegativeInfinity> führt eine Division durch 0 (null) mit einem negativen Dividend.  
  
-   Wenn eine Gleitkommaoperation ungültig ist, ist das Ergebnis des Vorgangs <xref:System.Single.NaN>. Z. B. <xref:System.Single.NaN> ergibt die folgenden Vorgänge:  
  
    -   Division durch 0 (null) mit einer Dividende 0 (null). Beachten Sie, dass andere Fälle der Division durch 0 (null) Ergebnis entweder <xref:System.Single.PositiveInfinity> oder <xref:System.Single.NegativeInfinity>.  
  
    -   Alle Gleitkommaoperation mit ungültige Eingabe. Beispielsweise versuchen, zu suchen, gibt die Quadratwurzel eines negativen Werts <xref:System.Single.NaN>.  
  
    -   Jeder Vorgang mit einem Argument, dessen Wert <xref:System.Single.NaN?displayProperty=nameWithType>.  
  
<a name="Conversion"></a>   
## <a name="type-conversions-and-the-single-structure"></a>Typumwandlungen und die einmalige Struktur  
 Die <xref:System.Single> Struktur definiert explizite oder implizite Konvertierungsoperatoren keine; stattdessen Konvertierungen werden vom Compiler implementiert werden.  
  
 Die folgende Tabelle enthält möglichen konversionen eines Werts, der den anderen primitiven numerischen Typen zu einer <xref:System.Single> Wert außerdem zeigt es an, ob die Konvertierung erweiternde oder einschränkende und ob die resultierende <xref:System.Single> möglicherweise geringere Genauigkeit als den ursprüngliche Wert.  
  
|Konvertierung von|Erweiternde/einschränkende|Möglicher Datenverlust mit einfacher Genauigkeit|  
|---------------------|-------------------------|--------------------------------|  
|<xref:System.Byte>|Widening|Nein|  
|<xref:System.Decimal>|Widening<br /><br /> Beachten Sie, dass c# ein Umwandlungsoperator erforderlich ist.|Ja. <xref:System.Decimal> unterstützt die Genauigkeit von 29 Ziffern. <xref:System.Single> 9 unterstützt.|  
|<xref:System.Double>|Einschränkende; außerhalb des gültigen Bereichs Werte werden in konvertiert <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> oder <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.|Ja. <xref:System.Double> unterstützt die Genauigkeit von 17 Dezimalziffern. <xref:System.Single> 9 unterstützt.|  
|<xref:System.Int16>|Widening|Nein|  
|<xref:System.Int32>|Widening|Ja. <xref:System.Int32> unterstützt die 10 Dezimalstellen der Genauigkeit. <xref:System.Single> 9 unterstützt.|  
|<xref:System.Int64>|Widening|Ja. <xref:System.Int64> unterstützt die 19 Dezimalstellen. <xref:System.Single> 9 unterstützt.|  
|<xref:System.SByte>|Widening|Nein|  
|<xref:System.UInt16>|Widening|Nein|  
|<xref:System.UInt32>|Widening|Ja. <xref:System.UInt32> unterstützt die 10 Dezimalstellen der Genauigkeit. <xref:System.Single> 9 unterstützt.|  
|<xref:System.UInt64>|Widening|Ja. <xref:System.Int64> unterstützt für die Genauigkeit von 20 Dezimalziffern. <xref:System.Single> 9 unterstützt.|  
  
 Im folgenden Beispiel wird die minimalen oder maximalen Wert von anderen primitiven numerischen Typen in einem <xref:System.Single> Wert.  
  
 [!code-csharp[System.Single.Structure#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/convert1.cs#20)]
 [!code-vb[System.Single.Structure#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/convert1.vb#20)]  
  
 Darüber hinaus die <xref:System.Double> Werte <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, und <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> konvertieren, <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, und <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>bzw.  
  
 Beachten Sie, dass die Konvertierung des Werts der einige numerischen Typen und eine <xref:System.Single> Wert kann ein Genauigkeitsverlust umfassen. Wie im Beispiel wird veranschaulicht, ein Genauigkeitsverlust kann bei der Konvertierung <xref:System.Decimal>, <xref:System.Double>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.UInt32>, und <xref:System.UInt64> Werte <xref:System.Single> Werte.  
  
 Die Konvertierung von einer <xref:System.Single> -Werts in einen <xref:System.Double> eine erweiternde Konvertierung. Die Konvertierung kann zu einem Genauigkeitsverlust führen, wenn die <xref:System.Double> Typ verfügt nicht über eine genaue Darstellung der <xref:System.Single> Wert.  
  
 Die Konvertierung von einem <xref:System.Single> auf einen Wert eines beliebigen primitiven numerischen Datentyps anderen Wert als eine <xref:System.Double> ist eine einschränkende Konvertierung und erfordert ein Cast-Operator (in c#) oder eine Konvertierungsmethode (in Visual Basic). Werte außerhalb des Bereichs der der Zieldatentyp, die von des Zieltyps definiert werden `MinValue` und `MaxValue` Eigenschaften verhalten sich wie in der folgenden Tabelle gezeigt.  
  
|Zieltyp|Ergebnis|  
|-----------------|------------|  
|Beliebiger ganzzahliger Typ|Ein <xref:System.OverflowException> -Ausnahme aus, wenn die Konvertierung in einem überprüften Kontext auftritt.<br /><br /> Bei die Konvertierung in einem ungeprüften Kontext (die Standardeinstellung in c#) wird der Konvertierungsvorgang erfolgreich ist, aber der Wert überläuft.|  
|<xref:System.Decimal>|Ein <xref:System.OverflowException> -Ausnahme|  
  
 Darüber hinaus <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, und <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> Auslösen einer <xref:System.OverflowException> für Konvertierungen zu einer ganzen Zahl in einem überprüften Kontext, aber diese Werte Überlauf beim Konvertieren in einem nicht geprüften Kontext zu ganzen Zahlen. Konvertierung in <xref:System.Decimal>, sie immer eine aus einer <xref:System.OverflowException>. Konvertierung in <xref:System.Double>, sie konvertieren in <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, und <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>bzw.  
  
 Beachten Sie, dass es sich bei einem Genauigkeitsverlust führen kann, durch Konvertieren einer <xref:System.Single> Wert in einen anderen numerischen Typ. Bei der Konvertierung von nicht ganzzahligen <xref:System.Single> Werte, wie die Ausgabe des Beispiels zeigt, der Nachkommawert wird abgebrochen, wenn die <xref:System.Single> Wert ist entweder (wie in Visual Basic) gerundet oder gekürzt (wie in C# -Referenz). Konvertierung in <xref:System.Decimal> Werte, die <xref:System.Single> Wert möglicherweise nicht präzise dargestellt in den Zieldatentyp.  
  
 Im folgenden Beispiel wird eine Anzahl von <xref:System.Single> Werte in verschiedene andere numerischen Typen. Die Konvertierungen erfolgen, in einem überprüften Kontext, in Visual Basic (Standard) und in c# (aufgrund von der [überprüft](~/docs/csharp/language-reference/keywords/checked.md) Schlüsselwort). Die Ausgabe des Beispiels zeigt das Ergebnis für Konvertierungen in einen aktivierten einem nicht geprüften Kontext. Sie können die Konvertierungen in einem nicht geprüften Kontext in Visual Basic durchführen, durch die Kompilierung mit der `/removeintchecks+` Compilerschalter und in c# durch Auskommentieren der `checked` Anweisung.  
  
 [!code-csharp[System.Single.Structure#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/convert2.cs#21)]
 [!code-vb[System.Single.Structure#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/convert2.vb#21)]  
  
 Weitere Informationen zur Konvertierung von numerischen Typen finden Sie unter [Typkonvertierung in .NET Framework](~/docs/standard/base-types/type-conversion.md) und [Typkonvertierungstabellen](~/docs/standard/base-types/conversion-tables.md).  
  
<a name="Functionality"></a>   
## <a name="floating-point-functionality"></a>Gleitkomma-Funktion  
 Die <xref:System.Single> Struktur und verwandte Typen bieten Ihnen Methoden zum Ausführen der folgenden Kategorien von Vorgängen:  
  
-   **Vergleich von Werten**. Rufen Sie die <xref:System.Single.Equals%2A> Methode, um zu bestimmen, ob zwei <xref:System.Single> Werte gleich sind, oder die <xref:System.Single.CompareTo%2A> Methode, um die Beziehung zwischen zwei Werten festzulegen.  
  
     Die <xref:System.Single> Struktur unterstützt auch einen vollständigen Satz von Vergleichsoperatoren. Sie können z. B. für Gleichheit oder Ungleichheit testen oder bestimmen, ob ein Wert größer als oder gleich einem anderen Wert ist. Wenn einer der Operanden ist ein <xref:System.Double>, <xref:System.Single> konvertierte Wert ist eine <xref:System.Double> vor dem Vergleich. Wenn einer der Operanden ein ganzzahliger Typ ist, wird eine Konvertierung in einen <xref:System.Single> vor dem Vergleich. Obwohl diese erweiternde Konvertierungen sind, können sie einem Genauigkeitsverlust führen.  
  
    > [!WARNING]
    >  Aufgrund der Unterschiede bei der Genauigkeit von zwei <xref:System.Single> Werte, die Sie erwarten, gleich sind möglicherweise ausgeschaltet werden, werden die wirkt sich auf das Ergebnis des Vergleichs. Finden Sie unter den [Testen auf Gleichheit](#Equality) Abschnitt, um weitere Informationen zum Vergleichen von zwei <xref:System.Single> Werte.  
  
     Sie können auch aufrufen, die <xref:System.Single.IsNaN%2A>, <xref:System.Single.IsInfinity%2A>, <xref:System.Single.IsPositiveInfinity%2A>, und <xref:System.Single.IsNegativeInfinity%2A> Methoden, um diese speziellen Werte testen.  
  
-   **Mathematische Operationen**. Allgemeine arithmetische Operationen wie Addition, Subtraktion, Multiplikation und Division werden durch Sprachcompiler und Common Intermediate Language (CIL)-Anweisungen anstelle von implementiert <xref:System.Single> Methoden. Wenn der andere Operand in einer mathematischen Operation ist eine <xref:System.Double>, die <xref:System.Single> konvertiert wird eine <xref:System.Double> vor dem Ausführen des Vorgangs und das Ergebnis des Vorgangs auch eine <xref:System.Double> Wert. Wenn der andere Operand ein ganzzahliger Typ ist, wird eine Konvertierung in einen <xref:System.Single> vor dem Ausführen des Vorgangs und das Ergebnis des Vorgangs auch eine <xref:System.Single> Wert.  
  
     Sie können andere mathematische Vorgänge ausführen, durch den Aufruf `static` (`Shared` in Visual Basic) Methoden in der <xref:System.Math?displayProperty=nameWithType> Klasse. Dazu zählen zusätzliche Methoden, die häufig für arithmetische verwendet (z. B. <xref:System.Math.Abs%2A?displayProperty=nameWithType>, <xref:System.Math.Sign%2A?displayProperty=nameWithType>, und <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>), Geometrie (z. B. <xref:System.Math.Cos%2A?displayProperty=nameWithType> und <xref:System.Math.Sin%2A?displayProperty=nameWithType>), und berechnen (z. B. <xref:System.Math.Log%2A?displayProperty=nameWithType>).  In allen Fällen die <xref:System.Single> konvertierte Wert ist eine <xref:System.Double>.  
  
     Sie können auch den einzelnen Bits in Bearbeiten einer <xref:System.Single> Wert. Die <xref:System.BitConverter.GetBytes%28System.Single%29?displayProperty=nameWithType> Methode verwendet wird, gibt die Bitmuster in ein Bytearray zurück.  Durch übergeben dieses Bytearray, das die <xref:System.BitConverter.ToInt32%2A?displayProperty=nameWithType> -Methode, Sie können auch beibehalten, die <xref:System.Single> Wert die Bitmuster in einer 32-Bit-Ganzzahl.  
  
-   **Rundung**. Rundung wird häufig als eine Methode verwendet zum Reduzieren der Auswirkungen der unterschiedlichen Werte, die aufgrund von Problemen mit der gleitkommadarstellung und die Genauigkeit. Runden Sie können eine <xref:System.Single> -Wert durch Aufrufen der <xref:System.Math.Round%2A?displayProperty=nameWithType> Methode. Beachten Sie jedoch, dass die <xref:System.Single> konvertierte Wert ist eine <xref:System.Double> , bevor die Methode wird aufgerufen, und der Konvertierung kann mit einem Genauigkeitsverlust verbunden.  
  
-   **Formatieren von**. Sie konvertieren ein <xref:System.Single> Wert in seine Zeichenfolgendarstellung durch Aufrufen der <xref:System.Single.ToString%2A> Methode oder mithilfe der [kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) Feature. Weitere Informationen dazu, wie die Zeichenfolgendarstellung von Gleitkommazahlen-Punktwerte Formatzeichenfolgen gesteuert werden, finden Sie unter den [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md) Themen.  
  
-   **Analysieren von Zeichenfolgen**. Sie können die angegebene Zeichenfolgendarstellung eines Gleitkommawerts auf konvertieren eine <xref:System.Single> -Wert durch Aufrufen der <xref:System.Single.Parse%2A> oder <xref:System.Single.TryParse%2A> Methode. Wenn der Analysevorgang misslingt, die <xref:System.Single.Parse%2A> Methode eine Ausnahme auslöst, während die <xref:System.Single.TryParse%2A> Methodenrückgabe `false`.  
  
-   **Typkonvertierung**. Die <xref:System.Single> -Struktur bietet eine explizite schnittstellenimplementierung für die <xref:System.IConvertible> -Schnittstelle, die Konvertierung zwischen jedem zwei standardmäßigen .NET Framework-Datentypen unterstützt. Sprachcompiler unterstützen auch die implizite Konvertierung von Werten für alle anderen standardmäßigen numerischen Typen mit Ausnahme von der Konvertierung <xref:System.Double> zu <xref:System.Single> Werte. Konvertierung eines Werts, der alle standardmäßigen numerischen Typen außer einem <xref:System.Double> auf eine <xref:System.Single> eine erweiternde Konvertierung und die Verwendung einer Umwandlung Operator oder Konvertierung-Methode ist nicht erforderlich.  
  
     Konvertierung von 32-Bit und 64-Bit-Ganzzahlwerte kann jedoch ein Genauigkeitsverlust führen. Die folgende Tabelle enthält die Unterschiede bei der Genauigkeit für 32-Bit, 64-Bit- und <xref:System.Double> Typen:  
  
    |Typ|Maximale Genauigkeit (in Dezimalstellen)|Interne Genauigkeit (in Dezimalstellen)|  
    |----------|---------------------------------------------|----------------------------------------------|  
    |<xref:System.Double>|15|17|  
    |<xref:System.Int32> und <xref:System.UInt32>|10|10|  
    |<xref:System.Int64> und <xref:System.UInt64>|19|19|  
    |<xref:System.Single>|7|9|  
  
     Das Problem der Genauigkeit am häufigsten wirkt sich auf <xref:System.Single> Werte, die konvertiert werden <xref:System.Double> Werte. Im folgenden Beispiel zwei identische divisionsvorgängen erzeugten Werte ungleich sind, da einer der Werte einen Gleitkommawert mit einfacher Genauigkeit ist, der in konvertiert ist eine <xref:System.Double>.  
  
     [!code-csharp[System.Single.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Single.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/precisionlist1.vb#5)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Alle Member dieses Typs sind threadsicher. Mitglieder, die angezeigt werden, so ändern Sie den Zustand der Instanz zurück tatsächlich eine neue Instanz initialisiert wird, mit dem neuen Wert an. Wie bei jeder anderen Art werden lesen und Schreiben in eine freigegebene Variable, die eine Instanz dieses Typs enthält durch eine Sperre um Threadsicherheit zu gewährleisten geschützt.</threadsafe>
    <altmember cref="T:System.Decimal" />
    <altmember cref="T:System.Double" />
  </Docs>
  <Members>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Vergleicht diese Instanz mit einem angegebenen Objekt oder mit einer anderen <see cref="T:System.Single" />-Instanz und gibt eine ganze Zahl zurück, die angibt, ob der Wert dieser Instanz kleiner oder größer als der Wert des angegebenen Objekts bzw. der anderen <see cref="T:System.Single" />-Instanz ist oder mit diesem übereinstimmt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="single.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Ein Vergleichsobjekt oder <see langword="null" />.</param>
        <summary>Vergleicht diese Instanz mit einem angegebenen Objekt und gibt eine ganze Zahl zurück, die angibt, ob der Wert dieser Instanz kleiner oder größer als der Wert des angegebenen Objekts ist oder mit diesem übereinstimmt.</summary>
        <returns>Eine Zahl mit Vorzeichen, die das Verhältnis zwischen dem Wert dieser Instanz und <paramref name="value" /> angibt.  
  
 <list type="table"><listheader><term> Rückgabewert 
 </term><description> Beschreibung  
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description> Diese Instanz ist kleiner als <paramref name="value" />.  
  
- oder -  
Diese Instanz ist keine Zahl (<see cref="F:System.Single.NaN" />), und <paramref name="value" /> ist eine Zahl.  
  
 </description></item><item><term> Zero 
 </term><description> Diese Instanz ist gleich <paramref name="value" />.  
  
- oder -  
Diese Instanz und value sind beide keine Zahl (<see cref="F:System.Single.NaN" />), <see cref="F:System.Single.PositiveInfinity" /> oder <see cref="F:System.Single.NegativeInfinity" />.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description> Diese Instanz ist größer als <paramref name="value" />.  
  
- oder -  
Diese Instanz ist eine Zahl, und <paramref name="value" /> ist keine Zahl (<see cref="F:System.Single.NaN" />).  
  
- oder -  
 <paramref name="value" /> ist <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `value` -Parameter muss sein `null` oder eine Instanz von <xref:System.Single>ist, andernfalls wird eine Ausnahme ausgelöst. Jede Instanz von <xref:System.Single>, unabhängig von seinem Wert wird als größer betrachtet `null`.  
  
 Werte müssen als gleich betrachtet werden identisch sein. Insbesondere dann, wenn mehrere mathematische Vorgänge Gleitkommazahlen-Punktwerte abhängig sind, ist es üblich, bis sie an Genauigkeit verlieren und ihre Werte nahezu identisch mit Ausnahme von ihren letzten gültigen Ziffern. Daher den Rückgabewert der <xref:System.Single.CompareTo%2A> Methode mag überraschend manchmal. Z. B. Multiplikation nach einem bestimmten Wert gefolgt von einer Division durch den gleichen Wert sollten den ursprünglichen Wert erzeugt, aber im folgenden Beispiel ist der berechnete Wert erweist sich größer als der ursprüngliche Wert. Zeigt alle signifikanten Ziffern der beiden Werte mithilfe der "R" [standardmäßige numerische Formatzeichenfolge](~/docs/standard/base-types/standard-numeric-format-strings.md) gibt an, dass der ursprüngliche Wert in der letzten gültigen Ziffern der berechnete Wert unterscheidet. Informationen zur Behandlung solcher Vergleiche können, finden Sie im Abschnitt "Hinweise" der <xref:System.Single.Equals%28System.Single%29> Methode.  
  
 [!code-csharp[System.Single.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.compareto/cs/compareto3.cs#2)]
 [!code-vb[System.Single.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.compareto/vb/compareto3.vb#2)]  
  
 Diese Methode wird implementiert, zur Unterstützung der <xref:System.IComparable> Schnittstelle. Beachten Sie, dass, obwohl ein <xref:System.Single.NaN> ist nicht als gleich einem anderen <xref:System.Single.NaN> (selbst selbst), die <xref:System.IComparable> Schnittstelle erfordert, dass `A.CompareTo(A)` 0 (null) zurück.  
  
## <a name="precision-in-comparisons"></a>Genauigkeit in Vergleichen  
 Die Genauigkeit von Gleitkommazahlen außerhalb der dokumentierten Genauigkeit richtet sich nach der Implementierung und die Version von .NET Framework zur Verfügung. Daher kann ein Vergleich von zwei bestimmten Zahlen zwischen den Versionen von .NET Framework geändert werden, da die Genauigkeit der internen Darstellung der Zahlen ändern kann.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Single.CompareTo%2A> Methode.  
  
 [!code-cpp[System.Single#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#16)]
 [!code-csharp[System.Single#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#16)]
 [!code-vb[System.Single#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> ist keine <see cref="T:System.Single" />.</exception>
        <altmember cref="M:System.Single.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.CompareTo(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Single) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(float value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : single -&gt; int&#xA;override this.CompareTo : single -&gt; int" Usage="single.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Eine Gleitkommazahl mit einfacher Genauigkeit, mit der der Vergleich erfolgen soll.</param>
        <summary>Vergleicht diese Instanz mit einer angegebenen Gleitkommazahl mit einfacher Genauigkeit und gibt eine ganze Zahl zurück, die angibt, ob der Wert dieser Instanz kleiner oder größer als der Wert der angegebenen Gleitkommazahl mit einfacher Genauigkeit ist oder mit dieser übereinstimmt.</summary>
        <returns>Eine Zahl mit Vorzeichen, die das Verhältnis zwischen dem Wert dieser Instanz und <paramref name="value" /> angibt.  
  
 <list type="table"><listheader><term> Rückgabewert 
 </term><description> Beschreibung  
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description> Diese Instanz ist kleiner als <paramref name="value" />.  
  
- oder -  
Diese Instanz ist keine Zahl (<see cref="F:System.Single.NaN" />), und <paramref name="value" /> ist eine Zahl.  
  
 </description></item><item><term> Zero 
 </term><description> Diese Instanz ist gleich <paramref name="value" />.  
  
- oder -  
Sowohl diese Instanz als auch <paramref name="value" /> sind keine Zahl (<see cref="F:System.Single.NaN" />), <see cref="F:System.Single.PositiveInfinity" />, oder <see cref="F:System.Single.NegativeInfinity" />.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description> Diese Instanz ist größer als <paramref name="value" />.  
  
- oder -  
Diese Instanz ist eine Zahl, und <paramref name="value" /> ist keine Zahl (<see cref="F:System.Single.NaN" />).  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Werte müssen als gleich betrachtet werden identisch sein. Es ist üblich für Gleitkommawerte mit einfacher Genauigkeit verloren gehen und nahezu identisch, mit Ausnahme von ihren letzten gültigen Ziffern werden, insbesondere, wenn die Werte auf mehrere mathematische Vorgänge abhängig sind. Daher den Rückgabewert der <xref:System.Single.CompareTo%2A> Methode manchmal mag überraschend. Multiplikation, die durch einen beliebigen Wert gefolgt von einer Division durch den gleichen Wert sollte z. B. den ursprünglichen Wert ergeben. Im folgenden Beispiel wird der berechnete Wert größer sein als der ursprüngliche Wert jedoch aktiviert. Zeigt alle signifikanten Ziffern der beiden Werte mithilfe der "R" [standardmäßige numerische Formatzeichenfolge](~/docs/standard/base-types/standard-numeric-format-strings.md) gibt an, dass der ursprüngliche Wert in der letzten gültigen Ziffern der berechnete Wert unterscheidet. Informationen zur Behandlung solcher Vergleiche können, finden Sie im Abschnitt "Hinweise" der <xref:System.Single.Equals%28System.Single%29> Methode.  
  
 [!code-csharp[System.Single.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.compareto/cs/compareto2.cs#1)]
 [!code-vb[System.Single.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.compareto/vb/compareto2.vb#1)]  
  
 Diese Methode implementiert die <xref:System.IComparable%601?displayProperty=nameWithType> -Schnittstelle und führt etwas bessere Leistung als die <xref:System.Single.CompareTo%2A?displayProperty=nameWithType> Methode, da es keine konvertieren die `value` Parameter für ein Objekt.  
  
 Beachten Sie, dass, obwohl ein Objekt, dessen Wert <xref:System.Single.NaN> gilt als nicht gleich einem anderen Objekt, dessen Wert <xref:System.Single.NaN> (selbst selbst), die <xref:System.IComparable%601> Schnittstelle erfordert, dass `A.CompareTo(A)` 0 (null) zurück.  
  
## <a name="widening-conversions"></a>Erweiterungskonvertierungen  
 Abhängig von der Programmiersprache, ist es eventuell möglich, Code eine <xref:System.Single.CompareTo%2A> Methode, bei der Parametertyp weniger Bits hat (schmaler ist) als der Instanztyp. Dies ist möglich, da einige Programmiersprachen eine implizite erweiternde Konvertierung durchführen, die den Parameter als einen Typ mit wie vielen Bits als die Instanz darstellt.  
  
 Nehmen wir beispielsweise an, der Instanztyp <xref:System.Single> und der Parametertyp ist <xref:System.Int32>. Microsoft c#-Compiler generiert den Anweisungen, um den Wert des Parameters als darstellen einer <xref:System.Single> Objekt und erstellt dann eine <xref:System.Single.CompareTo%28System.Single%29?displayProperty=nameWithType> -Methode, die die Werte der Instanz und die erweiterten Darstellung des Parameters vergleicht.  
  
 Ihre bevorzugte Programmiersprache Dokumentation, um festzustellen, ob der Compiler führt eine implizite erweiternde Konvertierungen von numerischen Typen. Weitere Informationen finden Sie unter den [Typkonvertierungstabellen](~/docs/standard/base-types/conversion-tables.md) Thema.  
  
## <a name="precision-in-comparisons"></a>Genauigkeit in Vergleichen  
 Die Genauigkeit von Gleitkommazahlen außerhalb der dokumentierten Genauigkeit richtet sich nach der Implementierung und die Version von .NET Framework zur Verfügung. Daher kann ein Vergleich von zwei bestimmten Zahlen zwischen den Versionen von .NET Framework geändert werden, da die Genauigkeit der internen Darstellung der Zahlen ändern kann.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, generische und nicht generische Versionen der <xref:System.Single.CompareTo%2A> Methode für verschiedene Wert- und Verweistypen.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Epsilon">
      <MemberSignature Language="C#" Value="public const float Epsilon = 1.401298E-45;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 Epsilon = float32(1.401298E-45)" />
      <MemberSignature Language="DocId" Value="F:System.Single.Epsilon" />
      <MemberSignature Language="VB.NET" Value="Public Const Epsilon As Single  = 1.401298E-45" />
      <MemberSignature Language="C++ CLI" Value="public: float Epsilon = 1.401298E-45;" />
      <MemberSignature Language="F#" Value="val mutable Epsilon : single" Usage="System.single.Epsilon" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>1.401298E-45</MemberValue>
      <Docs>
        <summary>Stellt den kleinsten positiven <see cref="T:System.Single" />-Wert dar, der größer als 0 (null) ist. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert des der <xref:System.Single.Epsilon> -Eigenschaft gibt den kleinsten positiven <xref:System.Single> Wert, der in numerischen Operationen oder vergleichen besonders wichtig ist bei den Wert des der <xref:System.Single> Instanz ist 0 (null). Beispielsweise der folgende Code zeigt, die 0 (null) und <xref:System.Single.Epsilon> gelten ungleiche Werte sein, während 0 (null) und die Hälfte der Wert der <xref:System.Single.Epsilon> werden als gleich angesehen.  
  
 [!code-csharp[System.Single.Epsilon#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/epsilon.cs#5)]
 [!code-vb[System.Single.Epsilon#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/epsilon.vb#5)]  
  
 Genauer gesagt, besteht das Gleitkommaformat mit einfacher Genauigkeit ein Zeichen, einer Mantisse 23-Bit- oder -Signifikanden und einen 8-Bit-Exponenten. Wie im folgenden Beispiel wird gezeigt, verfügt über 0 (null), einen Exponenten von-126 und einer Mantisse 0. <xref:System.Single.Epsilon> verfügt über einen Exponenten von-126 und einer Mantisse von 1. Dies bedeutet, dass <xref:System.Single.Epsilon?displayProperty=nameWithType> ist von der kleinste positiven <xref:System.Single> Wert, der größer als 0 (null) und stellt den kleinstmöglichen Wert und das kleinste mögliche Inkrement für eine <xref:System.Single> , deren Exponent ist-126.  
  
 [!code-csharp[System.Single.Epsilon#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/epsilon1.cs#6)]
 [!code-vb[System.Single.Epsilon#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/epsilon1.vb#6)]  
  
 Jedoch die <xref:System.Single.Epsilon> Eigenschaft ist nicht als allgemeines Maß für die Genauigkeit des der <xref:System.Single> -Typ. es gilt nur für <xref:System.Single> -Instanzen, die den Wert 0 (null) aufweisen.  
  
> [!NOTE]
>  Der Wert des der <xref:System.Single.Epsilon> Eigenschaft ist nicht identisch mit Computer Epsilon, der die obere Grenze der relativen Fehlers durch runden in der Gleitkommaarithmetik darstellt.  
  
 Der Wert dieser Konstanten 1.4e-45.  
  
 Aufgrund der Unterschiede bei ihrer letzten gültigen Ziffern können nicht zwei scheinbar gleichwertige Gleitkommazahlen gleich vergleichen. Z. B. der C#-Ausdruck, `(float)1/3 == (float)0.33333`, die nicht gleich, da die Division auf der linken Seite die maximale Genauigkeit ausgeführt, während die Konstante auf der rechten Seite befindet sich nur auf die angegebenen Ziffern. Bei der Erstellung eines benutzerdefinierten Algorithmus, der bestimmt, ob zwei Gleitkommazahlen als gleich betrachtet werden können, müssen Sie verwenden einen Wert, der größer ist als die <xref:System.Single.Epsilon> Konstante, die den zulässigen absoluten Differenz für die beiden Werte gleich festzulegen als gleich betrachtet. (Dieser Unterschied wird in der Regel deutlich größer als <xref:System.Single.Epsilon>.)  
  
## <a name="platform-notes"></a>Anmerkungen zur Plattform  
 Auf ARM-Systemen, den Wert des der <xref:System.Single.Epsilon> Konstante ist zu klein, um erkannt zu werden, damit er 0 (null) entspricht. Sie können definieren, einen alternative Epsilonwert, der gleich 1.175494351E-38 stattdessen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei Instanzen der <see cref="T:System.Single" />-Struktur denselben Wert darstellen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="single.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Ein Objekt, das mit dieser Instanz verglichen werden soll.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob diese Instanz gleich einem angegebenen Objekt ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="obj" /> eine Instanz von <see cref="T:System.Single" /> ist, deren Wert gleich dem Wert dieser Instanz ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Single.Equals%2A> -Methode sollte mit Vorsicht, verwendet werden, da zwei offensichtlich gleiche Werte ungleich aufgrund der unterschiedlichen Genauigkeit von zwei Werten sein können. Im folgenden Beispiel gemeldet, die die <xref:System.Single> .3333 Wert und die <xref:System.Single> zurückgegeben durch Dividieren 1 von 3 ungleich sind.  
  
 [!code-csharp[System.Single.Epsilon#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#3)]
 [!code-vb[System.Single.Epsilon#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#3)]  
  
 Anstatt Vergleich, Gleichheit, eine empfohlene Verfahren besteht im Definieren einer zulässigen Rand Unterschied zwischen zwei Werten (z. B. 01 % einer der Werte). Ist der Absolute Wert des Unterschieds zwischen den beiden Werten kleiner als oder gleich der jeweilige Rand, der Unterschied ist wahrscheinlich aufgrund von Unterschieden in Genauigkeit, und daher die Werte gleich wahrscheinlich sind. Im folgenden Beispiel wird dieses Verfahren zum Vergleichen von.33333 und 1/3, die beiden <xref:System.Single> Werte, die im vorherigen Codebeispiel gefunden werden.  
  
 [!code-csharp[System.Single.Epsilon#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#4)]
 [!code-vb[System.Single.Epsilon#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#4)]  
  
 In diesem Fall sind die Werte gleich.  
  
> [!NOTE]
>  Da <xref:System.Single.Epsilon> definiert den Ausdruck "Mindestwert" des einen positiven Wert, dessen Bereich in der Nähe von 0 (null) ist, der Unterschied muss größer sein als <xref:System.Single.Epsilon>. Es ist in der Regel deutlich größer als <xref:System.Single.Epsilon>.  
  
 Die Genauigkeit von Gleitkommazahlen außerhalb der dokumentierten Genauigkeit richtet sich nach der Implementierung und die Version von .NET Framework zur Verfügung. Daher kann ein Vergleich von zwei bestimmten Zahlen zwischen den Versionen von .NET Framework geändert werden, da die Genauigkeit der internen Darstellung der Zahlen ändern kann.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Single.Equals%2A> Methode.  
  
 [!code-cpp[System.Single#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#17)]
 [!code-csharp[System.Single#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#17)]
 [!code-vb[System.Single#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#17)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Überladungsauflösung des Compiler möglicherweise einen offensichtlichen Unterschied im Verhalten der beiden berücksichtigen <see cref="M:System.Single.Equals(System.Object)" /> Überladungen der Methode. Wenn eine implizite Konvertierung zwischen den <paramref name="obj" /> Argument und ein <see cref="T:System.Single" /> definiert ist und das Argument als nicht typisiert ist ein <see cref="T:System.Object" />, Compilern möglicherweise führen Sie eine implizite Konvertierung und rufen die <see cref="M:System.Single.Equals(System.Single)" /> Methode. Sie rufen Sie andernfalls die <see cref="M:System.Single.Equals(System.Object)" /> Methode, die immer zurückgibt <see langword="false" /> wenn seine <paramref name="obj" /> Argument ist keine <see cref="T:System.Single" /> Wert. Das folgende Beispiel veranschaulicht den Unterschied im Verhalten zwischen den zwei Überladungen. Im Fall von alle primitiven numerischen Typen mit Ausnahme von <see cref="T:System.Double" /> in Visual Basic und mit Ausnahme von <see cref="T:System.Decimal" /> und <see cref="T:System.Double" /> in c# ist der erste Vergleich gibt <see langword="true" /> , da der Compiler automatisch eine erweiternde Konvertierung und Aufrufe führt die <see cref="M:System.Single.Equals(System.Single)" /> -Methode, während die zweite Vergleich gibt <see langword="false" /> , da der Compiler Ruft die <see cref="M:System.Single.Equals(System.Object)" /> Methode.  
  
[! Code-Csharp[System.Single.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsoverl.cs#2)] [! Code – Vb[System.Single.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsoverl.vb#2)]</para>
        </block>
        <altmember cref="M:System.Single.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (float obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(float32 obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Equals(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (obj As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(float obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : single -&gt; bool" Usage="single.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="obj">Ein Objekt, das mit dieser Instanz verglichen werden soll.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob diese Instanz und ein angegebenes <see cref="T:System.Single" />-Objekt den gleichen Wert darstellen.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="obj" /> gleich dieser Instanz ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode implementiert die <xref:System.IEquatable%601?displayProperty=nameWithType> -Schnittstelle und führt etwas bessere Leistung als <xref:System.Single.Equals%2A> , da es keine konvertieren die `obj` Parameter für ein Objekt.  
  
## <a name="widening-conversions"></a>Erweiterungskonvertierungen  
 Abhängig von der Programmiersprache, ist es eventuell möglich, Code eine <xref:System.Single.Equals%2A> Methode, bei der Parametertyp weniger Bits hat (schmaler ist) als der Instanztyp. Dies ist möglich, da einige Programmiersprachen eine implizite erweiternde Konvertierung durchführen, die den Parameter als einen Typ mit wie vielen Bits als die Instanz darstellt.  
  
 Nehmen wir beispielsweise an, der Instanztyp <xref:System.Single> und der Parametertyp ist <xref:System.Int32>. Microsoft c#-Compiler generiert den Anweisungen, um den Wert des Parameters als darstellen einer <xref:System.Single> Objekt aus, und generiert dann eine <xref:System.Single.Equals%28System.Single%29?displayProperty=nameWithType> -Methode, die die Werte der Instanz und die erweiterten Darstellung des Parameters vergleicht.  
  
 Ihre bevorzugte Programmiersprache Dokumentation, um festzustellen, ob der Compiler führt eine implizite erweiternde Konvertierungen von numerischen Typen. Weitere Informationen finden Sie unter den [Typkonvertierungstabellen](~/docs/standard/base-types/conversion-tables.md) Thema.  
  
## <a name="precision-in-comparisons"></a>Genauigkeit in Vergleichen  
 Die <xref:System.Single.Equals%2A> Methode sollte mit Vorsicht, verwendet werden, da zwei scheinbar gleichwertig aufgrund der unterschiedlichen Genauigkeit der beiden Werte berücksichtigt werden können. Im folgenden Beispiel gemeldet, die die <xref:System.Single> .3333 Wert und die <xref:System.Single> zurückgegeben durch Dividieren 1 von 3 ungleich sind.  
  
 [!code-csharp[System.Single.Epsilon#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#1)]
 [!code-vb[System.Single.Epsilon#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#1)]  
  
 Eine Vergleichsmethode, der vermeidet Probleme im Zusammenhang mit Vergleich für Gleichheit umfasst eine akzeptable Rand Unterschied zwischen zwei Werten definieren (z. B. 01 % einer der Werte). Ist der Absolute Wert des Unterschieds zwischen den beiden Werten kleiner als oder gleich der jeweilige Rand, der Unterschied ist wahrscheinlich ein Ergebnis der Unterschiede in der Genauigkeit, und daher die Werte gleich wahrscheinlich sind. Im folgenden Beispiel wird dieses Verfahren zum Vergleichen von.33333 und 1/3, handelt es sich um <xref:System.Single> Werte, die im vorherigen Codebeispiel gefunden werden.  
  
 [!code-csharp[System.Single.Epsilon#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#2)]
 [!code-vb[System.Single.Epsilon#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#2)]  
  
 In diesem Fall sind die Werte gleich.  
  
> [!NOTE]
>  Da <xref:System.Single.Epsilon> definiert den Ausdruck "Mindestwert" des einen positiven Wert, dessen Bereich in der Nähe von 0 (null) ist, der Unterschied muss größer sein als <xref:System.Single.Epsilon>. Es ist in der Regel deutlich größer als <xref:System.Single.Epsilon>. Aus diesem Grund wird empfohlen, dass Sie nicht verwenden <xref:System.Double.Epsilon> beim Vergleich von <xref:System.Double> Werte hinsichtlich ihrer Gleichheit.  
  
 Eine zweite Methode, der vermeidet Probleme im Zusammenhang mit Vergleich, Gleichheit umfasst das Vergleichen des Unterschied zwischen zwei Gleitkommazahlen mit einem absoluten Wert. Kleiner oder gleich diesem absoluten Wert der Unterschied besteht darin, dass die Zahlen gleich sind. Wenn sie größer ist, sind die Zahlen ungleich. Eine Möglichkeit dazu ist einen absoluter Wert nach dem Zufallsprinzip auswählen. Dies ist jedoch problematisch, da eine akzeptable Rand Unterschied, die Größe abhängt der <xref:System.Single> Werte. Eine zweite Möglichkeit nutzt die Vorteile einer Design-Funktion, der das Gleitkommaformat: der Unterschied zwischen den Komponenten der Mantisse in den Integer-Darstellungen der zwei Gleitkommawerten gibt die Anzahl der möglichen Gleitkommawerte, die trennt die zwei Werte. Beispielsweise der Unterschied zwischen 0,0 und <xref:System.Single.Epsilon> beträgt 1, da <xref:System.Single.Epsilon> die kleinste darstellbare Wert ist, bei der Arbeit mit einem <xref:System.Single> , deren Wert ist 0 (null). Im folgenden Beispiel wird dieses Verfahren zum Vergleichen von.33333 und 1/3, handelt es sich um <xref:System.Double> Werte, mit dem vorherigen Codebeispiel die <xref:System.Single.Equals%28System.Single%29> Methode gefunden werden. Beachten Sie, die im Beispiel wird die <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> und <xref:System.BitConverter.ToInt32%2A?displayProperty=nameWithType> Methoden, um einen Gleitkommawert mit einfacher Genauigkeit in die Integer-Darstellung zu konvertieren.  
  
 [!code-csharp[System.Single.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsabs1.cs#1)]
 [!code-vb[System.Single.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsabs1.vb#1)]  
  
 Die Genauigkeit von Gleitkommazahlen außerhalb der dokumentierten Genauigkeit richtet sich nach der Implementierung und die Version von .NET Framework zur Verfügung. Daher kann ein Vergleich von zwei Zahlen unterschiedliche Ergebnisse abhängig von der Version von .NET Framework, erzeugen, da sich die Genauigkeit der internen Darstellung der Zahlen ändern kann.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Überladungsauflösung des Compiler möglicherweise einen offensichtlichen Unterschied im Verhalten der beiden berücksichtigen <see cref="M:System.Single.Equals(System.Object)" /> Überladungen der Methode. Wenn eine implizite Konvertierung zwischen den <paramref name="obj" /> Argument und ein <see cref="T:System.Single" /> definiert ist und das Argument als nicht typisiert ist ein <see cref="T:System.Object" />, Compilern möglicherweise führen Sie eine implizite Konvertierung und rufen die <see cref="M:System.Single.Equals(System.Single)" /> Methode. Sie rufen Sie andernfalls die <see cref="M:System.Single.Equals(System.Object)" /> Methode, die immer zurückgibt <see langword="false" /> wenn seine <paramref name="obj" /> Argument ist keine <see cref="T:System.Single" /> Wert. Das folgende Beispiel veranschaulicht den Unterschied im Verhalten zwischen den zwei Überladungen. Im Fall von alle primitiven numerischen Typen mit Ausnahme von <see cref="T:System.Double" /> in Visual Basic und mit Ausnahme von <see cref="T:System.Decimal" /> und <see cref="T:System.Double" /> in c# ist der erste Vergleich gibt <see langword="true" /> , da der Compiler automatisch eine erweiternde Konvertierung und Aufrufe führt die <see cref="M:System.Single.Equals(System.Single)" /> -Methode, während die zweite Vergleich gibt <see langword="false" /> , da der Compiler Ruft die <see cref="M:System.Single.Equals(System.Object)" /> Methode.  
  
[! Code-Csharp[System.Single.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsoverl.cs#2)] [! Code – Vb[System.Single.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsoverl.vb#2)]</para>
        </block>
        <altmember cref="M:System.Single.Equals(System.Object)" />
        <altmember cref="Overload:System.Single.CompareTo" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="single.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hashcode für diese Instanz zurück.</summary>
        <returns>Ein 32-Bit-Hashcode als ganze Zahl mit Vorzeichen.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="single.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den <see cref="T:System.TypeCode" /> für den Werttyp <see cref="T:System.Single" /> zurück.</summary>
        <returns>Die Enumerationskonstante <see cref="F:System.TypeCode.Single" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.TypeCode" />
      </Docs>
    </Member>
    <Member MemberName="IsFinite">
      <MemberSignature Language="C#" Value="public static bool IsFinite (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsFinite(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsFinite(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFinite (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFinite(float f);" />
      <MemberSignature Language="F#" Value="static member IsFinite : single -&gt; bool" Usage="System.single.IsFinite f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInfinity(float f);" />
      <MemberSignature Language="F#" Value="static member IsInfinity : single -&gt; bool" Usage="System.single.IsInfinity f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Eine Gleitkommazahl mit einfacher Genauigkeit.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob der Wert der angegebenen Zahl -unendlich oder +unendlich ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="f" /> entweder <see cref="F:System.Single.PositiveInfinity" /> oder <see cref="F:System.Single.NegativeInfinity" /> ergibt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zurückgeben von Gleitkommaoperationen <xref:System.Single.PositiveInfinity> oder <xref:System.Single.NegativeInfinity> ein Überlauf an.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Single.IsInfinity%2A> Methode.  
  
 [!code-cpp[System.Single#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#11)]
 [!code-csharp[System.Single#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#11)]
 [!code-vb[System.Single#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNaN(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNaN (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNaN(float f);" />
      <MemberSignature Language="F#" Value="static member IsNaN : single -&gt; bool" Usage="System.single.IsNaN f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Eine Gleitkommazahl mit einfacher Genauigkeit.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob der angegebene Wert keine Zahl ist (<see cref="F:System.Single.NaN" />).</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="f" /> Not-a-Number (<see cref="F:System.Single.NaN" />) ergibt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zurückgeben von Gleitkommaoperationen <xref:System.Single.NaN> zu signalisieren, dass das Ergebnis des Vorgangs nicht definiert ist. Z. B. Division von 0.0 von 0.0 führt <xref:System.Single.NaN>.  
  
> [!NOTE]
>  <xref:System.Single.IsNaN%2A> Gibt `false` Wenn eine <xref:System.Single> Wert lautet entweder <xref:System.Single.PositiveInfinity> oder <xref:System.Single.NegativeInfinity>. Um diese Werte zu testen, verwenden Sie die <xref:System.Single.IsInfinity%2A>, <xref:System.Single.IsPositiveInfinity%2A>, und <xref:System.Single.IsNegativeInfinity%2A> Methoden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Single.IsNaN%2A> Methode.  
  
 [!code-cpp[System.Single#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#8)]
 [!code-csharp[System.Single#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#8)]
 [!code-vb[System.Single#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.NaN" />
      </Docs>
    </Member>
    <Member MemberName="IsNegative">
      <MemberSignature Language="C#" Value="public static bool IsNegative (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegative(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNegative(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegative (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegative(float f);" />
      <MemberSignature Language="F#" Value="static member IsNegative : single -&gt; bool" Usage="System.single.IsNegative f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegativeInfinity">
      <MemberSignature Language="C#" Value="public static bool IsNegativeInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegativeInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNegativeInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegativeInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegativeInfinity(float f);" />
      <MemberSignature Language="F#" Value="static member IsNegativeInfinity : single -&gt; bool" Usage="System.single.IsNegativeInfinity f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Eine Gleitkommazahl mit einfacher Genauigkeit.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die angegebene Zahl minus unendlich ergibt.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="f" /><see cref="F:System.Single.NegativeInfinity" /> ergibt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zurückgeben von Gleitkommaoperationen <xref:System.Single.NegativeInfinity> ein Überlauf an.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Single.IsNegativeInfinity%2A> Methode.  
  
 [!code-cpp[System.Single#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#13)]
 [!code-csharp[System.Single#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#13)]
 [!code-vb[System.Single#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNormal">
      <MemberSignature Language="C#" Value="public static bool IsNormal (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNormal(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNormal(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNormal (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNormal(float f);" />
      <MemberSignature Language="F#" Value="static member IsNormal : single -&gt; bool" Usage="System.single.IsNormal f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPositiveInfinity">
      <MemberSignature Language="C#" Value="public static bool IsPositiveInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositiveInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsPositiveInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPositiveInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPositiveInfinity(float f);" />
      <MemberSignature Language="F#" Value="static member IsPositiveInfinity : single -&gt; bool" Usage="System.single.IsPositiveInfinity f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Eine Gleitkommazahl mit einfacher Genauigkeit.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die angegebene Zahl plus unendlich ergibt.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="f" /><see cref="F:System.Single.PositiveInfinity" /> ergibt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zurückgeben von Gleitkommaoperationen <xref:System.Single.PositiveInfinity> ein Überlauf an.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Single.IsPositiveInfinity%2A> Methode.  
  
 [!code-cpp[System.Single#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#12)]
 [!code-csharp[System.Single#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#12)]
 [!code-vb[System.Single#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsSubnormal">
      <MemberSignature Language="C#" Value="public static bool IsSubnormal (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSubnormal(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsSubnormal(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSubnormal (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSubnormal(float f);" />
      <MemberSignature Language="F#" Value="static member IsSubnormal : single -&gt; bool" Usage="System.single.IsSubnormal f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const float MaxValue = 3.402823E+38;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 MaxValue = float32(3.402823E+38)" />
      <MemberSignature Language="DocId" Value="F:System.Single.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxValue As Single  = 3.402823E+38" />
      <MemberSignature Language="C++ CLI" Value="public: float MaxValue = 3.402823E+38;" />
      <MemberSignature Language="F#" Value="val mutable MaxValue : single" Usage="System.single.MaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>3.402823E+38</MemberValue>
      <Docs>
        <summary>Stellt den größtmöglichen Wert von <see cref="T:System.Single" /> dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Konstanten ist die positive 3.40282347E + 38.  
  
 Das Ergebnis eines Vorgangs, der überschreitet <xref:System.Single.MaxValue?displayProperty=nameWithType> ist <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>. Im folgenden Beispiel <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> von Vorgängen für Addition, muliplikation und Potenzierung führt, wenn das Ergebnis überschreitet <xref:System.Single.MaxValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Single.MaxValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.maxvalue/cs/maxvalueex.cs#1)]
 [!code-vb[System.Single.MaxValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.maxvalue/vb/maxvalueex.vb#1)]  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Single.MaxValue> Konstanten.  
  
 [!code-cpp[System.Single#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#4)]
 [!code-csharp[System.Single#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#4)]
 [!code-vb[System.Single#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.MinValue" />
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const float MinValue = -3.402823E+38;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 MinValue = float32(-3.402823E+38)" />
      <MemberSignature Language="DocId" Value="F:System.Single.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MinValue As Single  = -3.402823E+38" />
      <MemberSignature Language="C++ CLI" Value="public: float MinValue = -3.402823E+38;" />
      <MemberSignature Language="F#" Value="val mutable MinValue : single" Usage="System.single.MinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>-3.402823E+38</MemberValue>
      <Docs>
        <summary>Stellt den kleinstmöglichen Wert von <see cref="T:System.Single" /> dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Konstanten ist negativ 3,402823E38.  
  
 Das Ergebnis eines Vorgangs, der kleiner als <xref:System.Single.MinValue?displayProperty=nameWithType> ist <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>. Im folgenden Beispiel <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> Subtraktion und Multiplikation Vorgänge führt, wenn das Ergebnis ist kleiner als <xref:System.Single.MinValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Single.MinValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.minvalue/cs/minvalueex.cs#1)]
 [!code-vb[System.Single.MinValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.minvalue/vb/minvalueex.vb#1)]  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Single.MinValue> Konstanten.  
  
 [!code-cpp[System.Single#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#5)]
 [!code-csharp[System.Single#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#5)]
 [!code-vb[System.Single#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.MaxValue" />
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public const float NaN = NaN;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 NaN = float32(NaN)" />
      <MemberSignature Language="DocId" Value="F:System.Single.NaN" />
      <MemberSignature Language="VB.NET" Value="Public Const NaN As Single  = NaN" />
      <MemberSignature Language="C++ CLI" Value="public: float NaN = NaN;" />
      <MemberSignature Language="F#" Value="val mutable NaN : single" Usage="System.single.NaN" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>NaN</MemberValue>
      <Docs>
        <summary>Stellt Not-a-Number (<see langword="NaN" />) dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gibt eine Methode oder einen Operator <xref:System.Single.NaN> Wenn das Ergebnis eines Vorgangs ist nicht definiert. Das Ergebnis der Division von 0 (null) von 0 (null) ist z. B. <xref:System.Single.NaN>, wie im folgende Beispiel gezeigt. (Aber beachten Sie, dass eine Zahl ungleich NULL durch 0 (null) dividiert einen zurückgibt <xref:System.Single.PositiveInfinity> oder <xref:System.Single.NegativeInfinity>, je nachdem, auf das Vorzeichen des Divisors.)  
  
 [!code-csharp[System.Single.NaN#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/nan1.cs#1)]
 [!code-vb[System.Single.NaN#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/nan1.vb#1)]  
  
 Darüber hinaus eine Methode aufzurufen, mit einer <xref:System.Single.NaN> Wert oder einen Vorgang für eine <xref:System.Single.NaN> Wert gibt <xref:System.Single.NaN>, wie im folgende Beispiel gezeigt.  
  
 [!code-csharp[System.Single.NaN#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/nan1.cs#2)]
 [!code-vb[System.Single.NaN#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/nan1.vb#2)]  
  
 Verwenden der <xref:System.Single.IsNaN%2A> Methode, um zu bestimmen, ob ein Wert keine Zahl ist. Im allgemeinen <xref:System.Single> Operatoren können nicht verwendet werden, zu vergleichenden <xref:System.Single.NaN?displayProperty=nameWithType> mit anderen <xref:System.Single> Werte, obwohl Methoden zum Zeichenfolgenvergleich (z. B. <xref:System.Single.Equals%2A> und <xref:System.Single.CompareTo%2A>) kann. Das folgende Beispiel veranschaulicht den Unterschied im Verhalten zwischen <xref:System.Single> Vergleichsoperatoren und Methoden.  
  
 [!code-csharp[System.Single.NaN#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/single.nan4.cs#4)]
 [!code-vb[System.Single.NaN#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/single.nan4.vb#4)]  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.Single.NaN> Konstanten.  
  
 [!code-cpp[System.Single#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#7)]
 [!code-csharp[System.Single#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#7)]
 [!code-vb[System.Single#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsNaN(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="NegativeInfinity">
      <MemberSignature Language="C#" Value="public const float NegativeInfinity = -Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 NegativeInfinity = float32(-Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Single.NegativeInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const NegativeInfinity As Single  = -Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: float NegativeInfinity = -Infinity;" />
      <MemberSignature Language="F#" Value="val mutable NegativeInfinity : single" Usage="System.single.NegativeInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>-Infinity</MemberValue>
      <Docs>
        <summary>Stellt minus unendlich dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Konstanten ist das Ergebnis der Division einer negativen Zahl durch 0 (null).  
  
 Diese Konstante wird zurückgegeben, wenn das Ergebnis eines Vorgangs ist kleiner als <xref:System.Single.MinValue>.  
  
 Verwendung <xref:System.Single.IsNegativeInfinity%2A> zu bestimmen, ob ein Wert minus unendlich ergibt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Single.NegativeInfinity> Konstanten.  
  
 [!code-cpp[System.Single#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#9)]
 [!code-csharp[System.Single#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#9)]
 [!code-vb[System.Single#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_Equality(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : single * single -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei angegebene <see cref="T:System.Single" />-Werte gleich sind.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Single.op_Equality%2A> Methode definiert den Gleichheitsoperator für <xref:System.Single> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_GreaterThan(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : single * single -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener <see cref="T:System.Single" />-Wert größer als ein anderer angegebener <see cref="T:System.Single" />-Wert ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Single.op_GreaterThan%2A> Methode definiert, den Vorgang des größer-als-Operators für <xref:System.Single> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_GreaterThanOrEqual(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : single * single -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener <see cref="T:System.Single" />-Wert größer oder gleich einem anderen angegebenen <see cref="T:System.Single" />-Wert ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> größer oder gleich <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Single.op_GreaterThanOrEqual%2A> Methode definiert, das größer-als-oder-gleich-Operator für den Betrieb <xref:System.Single> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_Inequality(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(float left, float right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : single * single -&gt; bool" Usage="System.single.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei angegebene <see cref="T:System.Single" />-Werte gleich sind.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Single.op_Inequality%2A> Methode definiert der Ungleichheitsoperator zum <xref:System.Single> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_LessThan(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : single * single -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener <see cref="T:System.Single" />-Wert größer als ein anderer angegebener <see cref="T:System.Single" />-Wert ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> kleiner als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Single.op_LessThan%2A> Methode definiert, den Vorgang des kleiner-als-Operators für <xref:System.Single> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_LessThanOrEqual(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : single * single -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener <see cref="T:System.Single" /> -Wert kleiner oder gleich einem anderen angegebenen <see cref="T:System.Single" />-Wert ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> kleiner oder gleich <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Single.op_LessThanOrEqual%2A> Methode definiert, der kleiner-als-oder-gleich-Operator für den Betrieb <xref:System.Single> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in die entsprechende Gleitkommazahl mit einfacher Genauigkeit.</summary>
        <altmember cref="Overload:System.Single.TryParse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; single" Usage="System.single.Parse s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in die entsprechende Gleitkommazahl mit einfacher Genauigkeit.</summary>
        <returns>Eine Gleitkommazahl mit einfacher Genauigkeit, die dem numerischen Wert oder Symbol in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `s` Parameter kann der aktuellen Kultur enthalten <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, oder eine Zeichenfolge der Form:  
  
 [*ws*] [*anmelden*] [*ganzzahligen Ziffern*[*,*]]*ganzzahligen Ziffern*[*.* [*Bruchziffern*]] [e [*anmelden*]*Exponenten-Ziffern*] [*ws*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*ws*|Eine Reihe von Leerraumzeichen.|  
|*sign*|Minuszeichen oder Pluszeichen. Gültige Zeichen für Vorzeichen hängen von der <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> und <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> Eigenschaften der aktuellen Kultur. Es können nur ein Vorzeichen verwendet werden.|  
|*Ganzzahl-Ziffern*|Eine Folge von Ziffern zwischen 0 und 9, die den ganzzahligen Teil der Zahl angeben. Wird *ganzzahligen Ziffern* durch ein Gruppentrennzeichen partitioniert werden kann. In einigen Kulturen trennt ein Komma (,) z. B. Gruppen von Tausenden. Die *ganzzahligen Ziffern* Element kann nicht vorhanden, wenn die Zeichenfolge enthält den *Bruchziffern* Element.|  
|*,*|Ein Tausendertrennzeichen kulturspezifische Trennzeichen-Symbol.|  
|*.*|Eine kulturspezifische Dezimaltrennzeichen.|  
|*fractional-digits*|Eine Folge von Ziffern zwischen 0 und 9, die die Nachkommastellen der Zahl angeben.|  
|E|Das "e" oder "E"-Zeichen, die angibt, dass der Wert in Exponentialschreibweise (wissenschaftlich) dargestellt wird.|  
|*exponential-digits*|Eine Folge von Ziffern zwischen 0 und 9, die einen Exponenten angeben.|  
  
 Die `s` Parameter wird eine Kombination von interpretiert die <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> und <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> Flags. Dies bedeutet, dass Leerraum und Tausende Trennzeichen zulässig sind Währungssymbole sind jedoch nicht. Die Elemente explizit zu definieren (wie Währungssymbole, Tausende Trennzeichen und Leerraum) in vorhanden sein können `s`, verwenden die <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> -methodenüberladung.  
  
 Die `s` Parameter analysiert wird, mithilfe den Formatierungsinformationen in eine <xref:System.Globalization.NumberFormatInfo> -Objekt, das für die aktuelle Systemkultur initialisiert wird. Weitere Informationen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>. Um eine Zeichenfolge mit den Formatierungsinformationen des einer bestimmten Kultur zu analysieren, verwenden die <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29> oder <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> Methode.  
  
 Normalerweise übergeben die <xref:System.Single.Parse%2A> Methode eine Zeichenfolge, die durch den Aufruf erstellt wird die <xref:System.Single.ToString%2A> -Methode, die ursprünglichen <xref:System.Single> Wert wird zurückgegeben. Jedoch können aufgrund einer Unterbrechung der Genauigkeit, die Werte sein nicht gleich.  
  
 Wenn Sie ein Trennzeichen gefunden wird die `s` Parameter bei einem Analysevorgang, und die geltenden Währung oder Zahl, Dezimalzahl und Gruppentrennzeichen sind identisch, die der Analysevorgang wird davon ausgegangen, dass das Trennzeichen ein Dezimaltrennzeichen anstelle einer Gruppe Trennzeichen. Weitere Informationen zu den Trennzeichen, finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Single.Parse%28System.String%29> Methode, um ein Array von Zeichenfolgen in entsprechende konvertieren <xref:System.Single> Werte.  
  
 [!code-csharp[System.Single.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse1.cs#2)]
 [!code-vb[System.Single.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> stellt keine Zahl in einem gültigen Format dar.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> stellt eine Zahl dar, die kleiner als <see cref="F:System.Single.MinValue" /> oder größer als <see cref="F:System.Single.MaxValue" /> ist.</exception>
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analysieren numerischer Zeichenfolgen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; single" Usage="System.single.Parse (s, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <param name="style">Eine bitweise Kombination von Enumerationswerten, die die Stilelemente angeben, die in <c>s</c> vorhanden sein können. Ein häufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Float" /> in Kombination mit <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil in die entsprechende Gleitkommazahl mit einfacher Genauigkeit.</summary>
        <returns>Eine Gleitkommazahl mit einfacher Genauigkeit, die dem numerischen Wert oder Symbol in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `style` Parameter definiert die Stilelemente (z. B. Leerzeichen, Tausende Trennzeichen und Währungssymbolen), sind zulässig, der `s` Parameter, damit der Analysevorgang erfolgreich ist. Es muss eine Kombination von Bitflags aus den <xref:System.Globalization.NumberStyles> Enumeration. Die folgenden <xref:System.Globalization.NumberStyles> Member werden nicht unterstützt:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 Die `s` Parameter kann der aktuellen Kultur enthalten <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>. Abhängig vom Wert `style`, es dauert auch die Form:  
  
 [*ws*] [*$*] [*anmelden*] [*ganzzahligen Ziffern*[*,*]]* Ganzzahl-Ziffern*[*.* [*Bruchziffern*]] [E [*anmelden*]*Exponenten-Ziffern*] [*ws*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
 *ws*  
 Eine Reihe von Leerzeichen. Leerzeichen am Anfang stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> Flag, und es können angezeigt werden, am Ende der `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> Flag.  
  
 $  
 Eine kulturspezifische Währungssymbol. Seine Position in der Zeichenfolge wird definiert, durch die <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> und <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> Eigenschaften der aktuellen Kultur. In der aktuellen Kultur Währungssymbol angezeigt werden kann `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> Flag.  
  
 *sign*  
 Ein Minuszeichen (-) oder ein Pluszeichen (+). Die Zeichen am Anfang stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> Flag, und es können angezeigt werden, am Ende der `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> Flag. Klammern können verwendet werden, `s` um einen negativen Wert anzugeben, ob `style` enthält die <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> Flag.  
  
 *Ganzzahl-Ziffern*  
 Eine Folge von Ziffern zwischen 0 und 9, die den ganzzahligen Teil der Zahl angeben. Die *ganzzahligen Ziffern* Element kann nicht vorhanden, wenn die Zeichenfolge enthält den *Bruchziffern* Element.  
  
 ,  
 Eine kulturspezifische Gruppentrennzeichen. In der aktuellen Kultur Gruppentrennzeichen angezeigt werden kann `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> Flag  
  
 sein.  
 Eine kulturspezifische Dezimaltrennzeichen. In der aktuellen Kultur Dezimaltrennzeichen angezeigt werden kann `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Flag.  
  
 *fractional-digits*  
 Eine Folge von Ziffern zwischen 0 und 9, die die Nachkommastellen der Zahl angeben. Bruchziffern können angezeigt werden, `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Flag.  
  
 E  
 Das "e" oder "E"-Zeichen, die angibt, dass der Wert in Exponentialschreibweise (wissenschaftlich) dargestellt wird. Die `value` Parameter kann eine Zahl in Exponentialschreibweise darstellen, wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> Flag.  
  
 *exponential-digits*  
 Eine Folge von Ziffern zwischen 0 und 9, die einen Exponenten angeben.  
  
> [!NOTE]
> Alle abschließenden NULL (U + 0000)-Zeichen im `s` werden ignoriert, durch den Analysevorgang, unabhängig vom Wert für die `style` Argument.

 Eine Zeichenfolge mit der nur Ziffern (Dies entspricht der <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> Stil) immer erfolgreich analysiert. Die verbleibenden <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Member steuern Elemente, die möglicherweise vorhanden, jedoch sind nicht erforderlich, in der Eingabezeichenfolge vorhanden sein. Die folgende Tabelle gibt an, wie einzelne <xref:System.Globalization.NumberStyles> Flags wirken sich auf die Elemente, die ggf. im `s`.  
  
|NumberStyles-Wert|Elemente in zulässig `s` neben Ziffern|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Die *ganzzahligen Ziffern* nur-Element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Das Dezimaltrennzeichen (*.*) und *Bruchziffern* Elemente.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Das "e" oder "E"-Zeichen, das Exponentialschreibweise angibt. Dieses Flag selbst unterstützt Werte im Formular *Ziffern*E*Ziffern*; zusätzliche Flags sind erforderlich, um die Zeichenfolgen mit Elementen wie die positiven und negativen Vorzeichen und Dezimaltrennzeichen erfolgreich analysiert.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Die *ws* Element am Anfang des `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Die *ws* Element am Ende der `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Die *anmelden* Element am Anfang des `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Die *anmelden* Element am Ende der `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Die *anmelden* Element in Form von Klammern, die den numerischen Wert einschließen.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|1.000er-Trennzeichen-Element.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Das Element, Currency ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Alle Elemente. Allerdings `s` keine hexadezimale Zahl oder eine Zahl in Exponentialschreibweise darstellen.|  
|<xref:System.Globalization.NumberStyles.Float>|Die *ws* Element am Anfang oder Ende des `s`, *anmelden* am Anfang des `s`, und das Dezimaltrennzeichen (.). Die `s` Parameter können Sie auch Exponentialschreibweise.|  
|<xref:System.Globalization.NumberStyles.Number>|Die `ws`, `sign`, Tausende Trennzeichen (,) und Dezimaltrennzeichen (.)-Elemente.|  
|<xref:System.Globalization.NumberStyles.Any>|Alle Elemente. Allerdings `s` eine hexadezimale Zahl nicht darstellen kann.|  
  
 Einige Beispiele für `s` sind "100", "123,456,789", "123. 45e + 6", "+ 500", "5e2", "3.1416", "600", "-. 123" und "-Infinity".  
  
 Die `s` -Parameter wird analysiert, die unter Verwendung der Formatierungsinformationen in eine <xref:System.Globalization.NumberFormatInfo> -Objekt, das für die aktuelle Systemkultur initialisiert wird. Rufen Sie zum Angeben der Kultur, deren Formatierungsinformationen, damit der Analysevorgang verwendet wird, der <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> überladen.  
  
 Normalerweise übergeben die <xref:System.Single.Parse%2A> Methode eine Zeichenfolge, die durch den Aufruf erstellt wird die <xref:System.Single.ToString%2A> -Methode, die ursprünglichen <xref:System.Single> Wert wird zurückgegeben. Jedoch können aufgrund einer Unterbrechung der Genauigkeit, die Werte sein nicht gleich.  
  
 Wenn Sie ein Trennzeichen gefunden wird die `s` Parameter bei einem Analysevorgang, und die geltenden Währung oder Zahl, Dezimalzahl und Gruppentrennzeichen sind identisch, die der Analysevorgang wird davon ausgegangen, dass das Trennzeichen ein Dezimaltrennzeichen anstelle einer Gruppe Trennzeichen. Weitere Informationen zu den Trennzeichen, finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> Methode, um die Zeichenfolgendarstellung von analysieren <xref:System.Single> Werte. Im Beispiel wird die Formatierungsinformationen für die Kultur En-US.  
  
 [!code-csharp[System.Single.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse2.cs#3)]
 [!code-vb[System.Single.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> stellt keine Zahl in einem gültigen Format dar.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> stellt eine Zahl dar, die kleiner als <see cref="F:System.Single.MinValue" /> oder größer als <see cref="F:System.Single.MaxValue" /> ist.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
- oder -  
 <paramref name="style" /> schließt den <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />-Wert ein.</exception>
        <altmember cref="M:System.Single.ToString" />
        <altmember cref="Overload:System.Single.TryParse" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analysieren numerischer Zeichenfolgen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; single" Usage="System.single.Parse (s, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu <c>s</c> bereitstellt.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem bestimmten kulturabhängigen Format in die entsprechende Gleitkommazahl mit einfacher Genauigkeit.</summary>
        <returns>Eine Gleitkommazahl mit einfacher Genauigkeit, die dem numerischen Wert oder Symbol in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung wird normalerweise verwendet, um Text zu konvertieren, die in einer Vielzahl von Möglichkeiten, formatiert werden, kann ein <xref:System.Single> Wert. Sie können z. B. verwendet werden, so konvertieren Sie den Text in einen numerischen Wert von einem Benutzer in einem HTML-Textfeld eingegeben.  
  
 Die `s` Parameter wird eine Kombination von interpretiert die <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> und <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> Flags. Die `s` kann Parameter enthalten <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, oder <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> für die Kultur, die anhand des `provider`, oder eine Zeichenfolge im Format enthalten:  
  
 [*ws*] [*anmelden*]*ganzzahligen Ziffern*[*.* [*Bruchziffern*]] [E [*anmelden*]*Exponenten-Ziffern*] [*ws*]  
  
 Optionale Elemente werden in eckige Klammern eingeschlossen ([und]). Elemente, die die Begriff "Ziffern" enthalten, bestehen aus einer Reihe von numerischen Zeichen, die im Bereich von 0 bis 9.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*ws*|Eine Reihe von Leerzeichen.|  
|*sign*|Ein Minuszeichen (-) oder ein Pluszeichen (+).|  
|*Ganzzahl-Ziffern*|Eine Folge von Ziffern zwischen 0 und 9, die den ganzzahligen Teil der Zahl angeben. Wird *ganzzahligen Ziffern* durch ein Gruppentrennzeichen partitioniert werden kann. In einigen Kulturen trennt ein Komma (,) z. B. Gruppen von Tausenden. Die *ganzzahligen Ziffern* Element kann nicht vorhanden, wenn die Zeichenfolge enthält den *Bruchziffern* Element.|  
|sein.|Eine kulturspezifische Dezimaltrennzeichen.|  
|*fractional-digits*|Eine Folge von Ziffern zwischen 0 und 9, die die Nachkommastellen der Zahl angeben.|  
|E|Das "e" oder "E"-Zeichen, die angibt, dass der Wert in Exponentialschreibweise (wissenschaftlich) dargestellt wird.|  
|*exponential-digits*|Eine Folge von Ziffern zwischen 0 und 9, die einen Exponenten angeben.|  
  
 Weitere Informationen über numerische Formate finden Sie unter den [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md) Thema.  
  
 Die `provider` -Parameter ist ein <xref:System.IFormatProvider> Implementierung, deren <xref:System.IFormatProvider.GetFormat%2A> Methode gibt eine <xref:System.Globalization.NumberFormatInfo> -Objekt, das kulturspezifische Formatierungsinformationen bereitstellt. Wenn die <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29> -Methode wird aufgerufen, ruft es die `provider` des Parameters <xref:System.IFormatProvider.GetFormat%2A> Methode und übergibt sie ein <xref:System.Type> Objekt, das darstellt der <xref:System.Globalization.NumberFormatInfo> Typ. Der <xref:System.IFormatProvider.GetFormat%2A> Methodenrückgabe klicken Sie dann die <xref:System.Globalization.NumberFormatInfo> -Objekt, das Informationen über das Format der `s` Parameter. Es gibt drei Möglichkeiten zum Verwenden der `provider` Parameter, um die benutzerdefinierte Formatierung Informationen, die der Analysevorgang angeben:  
  
-   Sie können übergeben eine <xref:System.Globalization.CultureInfo> -Objekt, das die Kultur darstellt, das Formatierungsinformationen bereitstellt. Die <xref:System.Globalization.CultureInfo.GetFormat%2A> Methode gibt die <xref:System.Globalization.NumberFormatInfo> -Objekt, das numerische Formatierungsinformationen für die jeweilige Kultur bereitstellt.  
  
-   Sie können die tatsächlichen übergeben <xref:System.Globalization.NumberFormatInfo> -Objekt, das numerische Formatierungsinformationen bereitstellt. (Eine Implementierung von <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> nur sich selbst zurückgibt.)  
  
-   Sie können ein benutzerdefiniertes Objekt, das implementiert übergeben <xref:System.IFormatProvider>. Die <xref:System.IFormatProvider.GetFormat%2A> -Methode instanziiert und gibt die <xref:System.Globalization.NumberFormatInfo> -Objekt, das Formatierungsinformationen bereitstellt.  
  
 Wenn `provider` ist `null` oder <xref:System.Globalization.NumberFormatInfo> kann nicht abgerufen werden, die Formatierungsinformationen für die aktuelle Systemkultur verwendet wird.  
  
 Wenn Sie ein Trennzeichen gefunden wird die `s` Parameter bei einem Analysevorgang, und die geltenden Währung oder Zahl, Dezimalzahl und Gruppentrennzeichen sind identisch, die der Analysevorgang wird davon ausgegangen, dass das Trennzeichen ein Dezimaltrennzeichen anstelle einer Gruppe Trennzeichen. Weitere Informationen zu den Trennzeichen, finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
 Einige Beispiele für `s` sind "100", "123,456,789", "123. 45e + 6", "+ 500", "5e2", "3.1416", "600", "-. 123" und "-Infinity".  
  
   
  
## Examples  
 Im folgende Beispiel wird-Ereignishandler von einem Web Form auf die Schaltfläche klicken. Er verwendet das von zurückgegebene Array die <xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType> -Eigenschaft können Sie das Gebietsschema des Benutzers zu bestimmen. Klicken Sie dann Instanziieren einer <xref:System.Globalization.CultureInfo> Objekt, das dieses Gebietsschema entspricht. Die <xref:System.Globalization.NumberFormatInfo> -Objekt, das mit dem gehört <xref:System.Globalization.CultureInfo> Objekt wird dann zum Übergeben der <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29> Methode zum Konvertieren des Benutzers die Eingabe für eine <xref:System.Single> Wert.  
  
 [!code-csharp[ParseMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR/ParseMethod/cs/Default.aspx.cs#1)]
 [!code-vb[ParseMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ParseMethod/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> stellt keine Zahl in einem gültigen Format dar.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> stellt eine Zahl dar, die kleiner als <see cref="F:System.Single.MinValue" /> oder größer als <see cref="F:System.Single.MaxValue" /> ist.</exception>
        <altmember cref="M:System.Single.ToString" />
        <altmember cref="Overload:System.Single.TryParse" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analysieren numerischer Zeichenfolgen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As Single" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; single" Usage="System.single.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; single" Usage="System.single.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <param name="style">Eine bitweise Kombination von Enumerationswerten, die die Stilelemente angeben, die in <c>s</c> vorhanden sein können. Ein häufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Float" /> in Kombination mit <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu <c>s</c> bereitstellt.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturabhängigen Format in die entsprechende Gleitkommazahl mit einfacher Genauigkeit.</summary>
        <returns>Eine Gleitkommazahl mit einfacher Genauigkeit, die dem numerischen Wert oder Symbol in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `style` Parameter definiert die Stilelemente (z. B. Leerzeichen, Tausende Trennzeichen und Währungssymbolen), sind zulässig, der `s` Parameter, damit der Analysevorgang erfolgreich ist. Es muss eine Kombination von Bitflags aus den <xref:System.Globalization.NumberStyles> Enumeration. Die folgenden <xref:System.Globalization.NumberStyles> Member werden nicht unterstützt:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 Die `s` kann Parameter enthalten <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, oder <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> für die Kultur, die anhand des `provider`. Abhängig vom Wert `style`, es dauert auch die Form:  
  
 [*ws*] [*$*] [*anmelden*] [*ganzzahligen Ziffern*,]*ganzzahligen Ziffern*[. [ *Bruchziffern*]] [E [*anmelden*]*Exponenten-Ziffern*] [*ws*]  
  
 Elemente müssen in eckigen Klammern ([und]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*ws*|Eine Reihe von Leerzeichen. Leerzeichen am Anfang stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> Flag, und es können angezeigt werden, am Ende der `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> Flag.|  
|$|Eine kulturspezifische Währungssymbol. Seine Position in der Zeichenfolge wird definiert, durch die <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> und <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> Eigenschaften der aktuellen Kultur. In der aktuellen Kultur Währungssymbol angezeigt werden kann `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> Flag.|  
|*sign*|Ein Minuszeichen (-) oder ein Pluszeichen (+). Die Zeichen am Anfang stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> Flag, und es können angezeigt werden, am Ende der `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> Flag. Klammern können verwendet werden, `s` um einen negativen Wert anzugeben, ob `style` enthält die <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> Flag.|  
|*Ganzzahl-Ziffern*|Eine Folge von Ziffern zwischen 0 und 9, die den ganzzahligen Teil der Zahl angeben. Die *ganzzahligen Ziffern* Element kann nicht vorhanden, wenn die Zeichenfolge enthält den *Bruchziffern* Element.|  
|,|Eine kulturspezifische Gruppentrennzeichen. In der aktuellen Kultur Gruppentrennzeichen angezeigt werden kann `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> Flag|  
|sein.|Eine kulturspezifische Dezimaltrennzeichen. In der aktuellen Kultur Dezimaltrennzeichen angezeigt werden kann `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Flag.|  
|*fractional-digits*|Eine Folge von Ziffern zwischen 0 und 9, die die Nachkommastellen der Zahl angeben. Bruchziffern können angezeigt werden, `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Flag.|  
|E|Das "e" oder "E"-Zeichen, die angibt, dass der Wert in Exponentialschreibweise (wissenschaftlich) dargestellt wird. Die `s` Parameter kann eine Zahl in Exponentialschreibweise darstellen, wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> Flag.|  
|*exponential-digits*|Eine Folge von Ziffern zwischen 0 und 9, die einen Exponenten angeben.|  
  
> [!NOTE]
> Alle abschließenden NULL (U + 0000)-Zeichen im `s` werden ignoriert, durch den Analysevorgang, unabhängig vom Wert für die `style` Argument.

 Eine Zeichenfolge mit der nur Ziffern (Dies entspricht der <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> Stil) immer erfolgreich analysiert. Die verbleibenden <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Member steuern Elemente, die möglicherweise vorhanden, jedoch sind nicht erforderlich, in der Eingabezeichenfolge vorhanden sein. Die folgende Tabelle gibt an, wie einzelne <xref:System.Globalization.NumberStyles> Flags wirken sich auf die Elemente, die ggf. im `s`.  
  
|NumberStyles-Wert|Elemente in zulässig `s` neben Ziffern|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Die *ganzzahligen Ziffern* nur-Element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Das Dezimaltrennzeichen (*.*) und *Bruchziffern* Elemente.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Das "e" oder "E"-Zeichen, das Exponentialschreibweise angibt. Dieses Flag selbst unterstützt Werte im Formular *Ziffern*E*Ziffern*; zusätzliche Flags sind erforderlich, um die Zeichenfolgen mit Elementen wie die positiven und negativen Vorzeichen und Dezimaltrennzeichen erfolgreich analysiert.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Die *ws* Element am Anfang des `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Die *ws* Element am Ende der `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Die *anmelden* Element am Anfang des `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Die *anmelden* Element am Ende der `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Die *anmelden* Element in Form von Klammern, die den numerischen Wert einschließen.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|1.000er-Trennzeichen-Element.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Das Element, Currency ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Alle Elemente. Allerdings `s` keine hexadezimale Zahl oder eine Zahl in Exponentialschreibweise darstellen.|  
|<xref:System.Globalization.NumberStyles.Float>|Die *ws* Element am Anfang oder Ende des `s`, *anmelden* am Anfang des `s`, und das Dezimaltrennzeichen (.). Die `s` Parameter können Sie auch Exponentialschreibweise.|  
|<xref:System.Globalization.NumberStyles.Number>|Die `ws`, `sign`, Tausende Trennzeichen (,) und Dezimaltrennzeichen (.)-Elemente.|  
|<xref:System.Globalization.NumberStyles.Any>|Alle Elemente. Allerdings `s` eine hexadezimale Zahl nicht darstellen kann.|  
  
 Die `provider` -Parameter ist ein <xref:System.IFormatProvider> Implementierung. Die <xref:System.IFormatProvider.GetFormat%2A> Methode gibt eine <xref:System.Globalization.NumberFormatInfo> -Objekt, das kulturspezifische Informationen zum Format von bietet `value`. In der Regel `provider` kann einer der folgenden sein:  
  
-   Ein <xref:System.Globalization.CultureInfo> -Objekt, das die Kultur darstellt, die numerische Formatierungsinformationen bereitstellt. Die <xref:System.Globalization.CultureInfo.GetFormat%2A> Methode gibt die <xref:System.Globalization.NumberFormatInfo> -Objekt, das numerische Formatierungsinformationen bereitstellt.  
  
-   Ein <xref:System.Globalization.NumberFormatInfo> -Objekt, das Formatierungsinformationen bereitstellt. (Eine Implementierung von <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> nur sich selbst zurückgibt.)  
  
-   Ein benutzerdefiniertes Objekt, das implementiert <xref:System.IFormatProvider> und verwendet die <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> Methode zum Instanziieren und Zurückgeben der <xref:System.Globalization.NumberFormatInfo> -Objekt, das Formatierungsinformationen bereitstellt.  
  
 Wenn `provider` ist `null`, <xref:System.Globalization.NumberFormatInfo> -Objekt für die aktuelle Kultur verwendet.  
  
 Wenn Sie ein Trennzeichen gefunden wird die `s` Parameter bei einem Analysevorgang, und die geltenden Währung oder Zahl, Dezimalzahl und Gruppentrennzeichen sind identisch, die der Analysevorgang wird davon ausgegangen, dass das Trennzeichen ein Dezimaltrennzeichen anstelle einer Gruppe Trennzeichen. Weitere Informationen zu den Trennzeichen, finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> Methode, um die Zeichenfolgendarstellung von analysieren <xref:System.Single> Werte. Jede Zeichenfolge in ein Array wird die Verwendung der Formatierungskonventionen der En-US, nl-NL und eine benutzerdefinierte Kultur analysiert. Die benutzerdefinierte Kultur definiert die Gruppentrennzeichen als der Unterstrich ("_") und die Gruppengröße als zwei.  
  
 [!code-csharp[System.Single.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse3.cs#4)]
 [!code-vb[System.Single.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> stellt keinen numerischen Wert dar.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
- oder -  
 <paramref name="style" /> ist der <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />-Wert.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> stellt eine Zahl dar, die kleiner als <see cref="F:System.Single.MinValue" /> oder größer als <see cref="F:System.Single.MaxValue" /> ist.</exception>
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analysieren numerischer Zeichenfolgen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="PositiveInfinity">
      <MemberSignature Language="C#" Value="public const float PositiveInfinity = Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 PositiveInfinity = float32(Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Single.PositiveInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const PositiveInfinity As Single  = Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: float PositiveInfinity = Infinity;" />
      <MemberSignature Language="F#" Value="val mutable PositiveInfinity : single" Usage="System.single.PositiveInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>Infinity</MemberValue>
      <Docs>
        <summary>Stellt plus unendlich dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Konstanten ist das Ergebnis der Division einer positiven Zahl durch 0 (null).  
  
 Diese Konstante wird zurückgegeben, wenn das Ergebnis eines Vorgangs übersteigt <xref:System.Single.MaxValue>.  
  
 Verwendung <xref:System.Single.IsPositiveInfinity%2A> zu bestimmen, ob ein Wert plus unendlich ergibt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die <xref:System.Single.PositiveInfinity> Konstanten.  
  
 [!code-cpp[System.Single#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#10)]
 [!code-csharp[System.Single#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#10)]
 [!code-vb[System.Single#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns>
          <see langword="true" />, wenn der Wert der aktuellen Instanz nicht 0 (null) ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToBoolean%28System.Single%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Byte" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToByte%28System.Single%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Diese Konvertierung wird nicht unterstützt. Bei dem Versuch der Verwendung dieser Methode wird eine <see cref="T:System.InvalidCastException" /> ausgelöst.</summary>
        <returns>Diese Konvertierung wird nicht unterstützt. Es wird kein Wert zurückgegeben.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">In allen Fällen.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Diese Konvertierung wird nicht unterstützt. Bei dem Versuch der Verwendung dieser Methode wird eine <see cref="T:System.InvalidCastException" /> ausgelöst.</summary>
        <returns>Diese Konvertierung wird nicht unterstützt. Es wird kein Wert zurückgegeben.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">In allen Fällen.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Decimal" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToDecimal%28System.Single%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Double" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToDouble%28System.Single%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Int16" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToInt16%28System.Single%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Int32" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToInt32%28System.Single%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Int64" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToInt64%28System.Single%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.SByte" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToSByte%28System.Single%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>Der unveränderte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ, in den dieser <see cref="T:System.Single" />-Wert konvertiert werden soll.</param>
        <param name="provider">Ein Objekt, das Informationen zum Format des zurückgegebenen Werts bereitstellt.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Der in <paramref name="type" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der `static` (`Shared` in Visual Basic) <xref:System.Convert.ChangeType%2A?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.UInt16" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToUInt16%28System.Single%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.UInt32" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToUInt32%28System.Single%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.UInt64" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Single>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToUInt64%28System.Single%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert den Wert dieser Instanz in die entsprechende Zeichenfolgendarstellung.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="single.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konvertiert den Wert dieser Instanz in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieser Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Single.ToString> -Methode formatiert einen <xref:System.Single> Wert in der Standardeinstellung ("G" oder Allgemein) Format der aktuellen Kultur. Wenn Sie ein anderes Format oder die Kultur angeben möchten, verwenden Sie alle anderen Überladungen der der <xref:System.Single.ToString%2A> -Methode wie folgt:  
  
|Format verwenden|Für die Kultur|Verwenden Sie die Überladung|  
|-------------------|-----------------|----------------------|  
|Standardformat ("G")|Eine bestimmte Kultur|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|Einem bestimmten format|(Aktueller) Standardkultur|<xref:System.Single.ToString%28System.String%29>|  
|Einem bestimmten format|Eine bestimmte Kultur|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Der Rückgabewert kann sein <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, oder eine Zeichenfolge der Form:  
  
 [Sign] Ganzzahl-Ziffern [. [ Bruchziffern]] [e [Sign] exponentiellen-Ziffern]  
  
 Optionale Elemente werden in eckige Klammern eingeschlossen ([und]). Elemente, die die Begriff "Ziffern" enthalten, bestehen aus einer Reihe von numerischen Zeichen, die im Bereich von 0 bis 9. In der folgende Tabelle wird jedes Element aufgeführt:  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*sign*|Ein negatives Vorzeichen oder das Pluszeichen.|  
|*Ganzzahl-Ziffern*|Eine Folge von Ziffern, die den ganzzahligen Teil der Zahl. Ganzzahl-Ziffern nicht vorhanden sein können Wenn Bruchziffern vorhanden sind.|  
|'.'|Eine kulturspezifische Dezimaltrennzeichen.|  
|*fractional-digits*|Eine Folge von Ziffern, die die Nachkommastellen der Zahl.|  
|'e'|Ein Kleinbuchstabe 'e', der angibt, exponential (wissenschaftlich)-Notation.|  
|*exponential-digits*|Eine Folge von Ziffern, die einen Exponenten angibt.|  
  
 Einige Beispiele des Rückgabewerts sind "100", "-123,456,789", "123. 45e + 6", "500", "3.1416", "600", "-0.123" und "-Infinity".  
  
 .NET Framework bietet umfangreiche formatierungsunterstützung, die in den folgenden Themen zur Formatierung ausführlicher beschrieben wird:  
  
-   Weitere Informationen über numerische Formatbezeichner finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Standardwert <xref:System.Single.ToString%2A?displayProperty=nameWithType> die Zeichenfolgendarstellung einer Zahl der anzuzeigenden Methode <xref:System.Single> Werte.  
  
 [!code-csharp[System.Single.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#1)]
 [!code-vb[System.Single.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#1)]  
  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Single.Parse%28System.String%29> Methode zusammen mit den <xref:System.Single.ToString> Methode.  
  
 [!code-cpp[System.Single#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#3)]
 [!code-csharp[System.Single#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#3)]
 [!code-vb[System.Single#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="single.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Konvertiert den numerischen Wert dieser Instanz unter Berücksichtigung der angegebenen kulturabhängigen Formatierungsinformationen in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieser Instanz entsprechend den Angaben von <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Single.ToString%28System.IFormatProvider%29> -Methode formatiert einen <xref:System.Single> Wert in der Standardeinstellung ("G" oder Allgemein) Format einer angegebenen Kultur. Wenn Sie ein anderes Format oder die aktuelle Kultur angeben möchten, verwenden Sie alle anderen Überladungen der der <xref:System.Single.ToString%2A> -Methode wie folgt:  
  
|Format verwenden|Für die Kultur|Verwenden Sie die Überladung|  
|-------------------|-----------------|----------------------|  
|Standardformat ("G")|(Aktueller) Standardkultur|<xref:System.Single.ToString>|  
|Einem bestimmten format|(Aktueller) Standardkultur|<xref:System.Single.ToString%28System.String%29>|  
|Einem bestimmten format|Eine bestimmte Kultur|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Der Rückgabewert kann sein <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, oder eine Zeichenfolge der Form:  
  
 [Sign] Ganzzahl-Ziffern [. [ Bruchziffern]] [e [Sign] exponentiellen-Ziffern]  
  
 Optionale Elemente werden in eckige Klammern eingeschlossen ([und]). Elemente, die den Begriff "Ziffern" bestehen aus einer Reihe von numerischen Zeichen, die im Bereich von 0 bis 9. Die folgende Tabelle enthält jedes Element.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|sign|Ein negatives Vorzeichen oder das Pluszeichen.|  
|Ganzzahl-Ziffern|Eine Folge von Ziffern, die den ganzzahligen Teil der Zahl. Ganzzahl-Ziffern nicht vorhanden sein können Wenn Bruchziffern vorhanden sind.|  
|'.'|Eine kulturspezifische Dezimaltrennzeichen.|  
|Dezimalstellen:|Eine Folge von Ziffern, die die Nachkommastellen der Zahl.|  
|'e'|Ein Kleinbuchstabe 'e', der angibt, exponential (wissenschaftlich)-Notation.|  
|exponentielle-Ziffern|Eine Folge von Ziffern, die einen Exponenten angibt.|  
  
 Einige Beispiele des Rückgabewerts sind "100", "-123,456,789", "123. 45e + 6", "500", "3.1416", "600", "-0.123" und "-Infinity".  
  
 .NET Framework bietet umfangreiche formatierungsunterstützung, die in den folgenden Themen zur Formatierung ausführlicher beschrieben wird:  
  
-   Weitere Informationen über numerische Formatbezeichner finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md).  
  
 Die `provider` -Parameter ist ein <xref:System.IFormatProvider> Implementierung, deren <xref:System.IFormatProvider.GetFormat%2A> Methode gibt eine <xref:System.Globalization.NumberFormatInfo> Objekt. In der Regel `provider` ist eine <xref:System.Globalization.CultureInfo> Objekt oder ein <xref:System.Globalization.NumberFormatInfo> Objekt. Die `provider` Parameter liefert kulturspezifische Informationen, die bei der Formatierung verwendete. Wenn `provider` ist `null`, der Rückgabewert formatiert wird, mit der <xref:System.Globalization.NumberFormatInfo> Daten für die aktuelle Kultur.  
  
 Konvertiert eine <xref:System.Single> Wert in seine Zeichenfolgendarstellung, die mit einer angegebenen Kultur und einem bestimmten Format String Aufruf der <xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine Zeichenfolgendarstellung von zwei <xref:System.Single> Werte mithilfe von <xref:System.Globalization.CultureInfo> Objekte, die verschiedene Kulturen darstellen.  
  
 [!code-csharp[System.Single.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#2)]
 [!code-vb[System.Single.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="single.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Eine numerische Formatierungszeichenfolge.</param>
        <summary>Konvertiert den numerischen Wert dieser Instanz in die entsprechende Zeichenfolgendarstellung unter Berücksichtigung des angegebenen Formats.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieser Instanz entsprechend den Angaben von <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Single.ToString%28System.String%29> -Methode formatiert einen <xref:System.Single> Wert in einem angegebenen Format mithilfe der Konventionen der aktuellen Kultur. Wenn Sie die Standardeinstellung ("G" oder allgemeine) verwenden möchten formatieren oder eine andere Kultur angeben, verwenden Sie die anderen Überladungen von der <xref:System.Single.ToString%2A> -Methode wie folgt:  
  
|Format verwenden|Für die Kultur|Verwenden Sie die Überladung|  
|-------------------|-----------------|----------------------|  
|Standardformat ("G")|(Aktueller) Standardkultur|<xref:System.Single.ToString>|  
|Standardformat ("G")|Eine bestimmte Kultur|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|Einem bestimmten format|Eine bestimmte Kultur|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Der Rückgabewert kann sein <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, oder der Zeichenfolgendarstellung des Werts der aktuellen Instanz gemäß `format`.  
  
 Die `format` Parameter kann eine beliebige gültige numerischer Standardformatbezeichner mit Ausnahme der Forschung und Entwicklung sowie X sowie eine beliebige Kombination aus benutzerdefinierten Zahlenformatbezeichner sein. Wenn das Format `null` oder eine leere Zeichenfolge, die den Rückgabewert mit dem allgemeinen numerische Formatbezeichner ("G") formatiert ist.  
  
 .NET Framework bietet umfangreiche formatierungsunterstützung, die in den folgenden Themen zur Formatierung ausführlicher beschrieben wird:  
  
-   Weitere Informationen über numerische Formatbezeichner finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md).  
  
 Standardmäßig enthält der Rückgabewert nur 7 Dezimalstellen, obwohl intern ein Maximum von 9 Ziffern gespeichert wird. Wenn der Wert dieser Instanz mehr als 7 Ziffern verfügt <xref:System.Single.ToString%28System.String%29> gibt <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> oder <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> anstelle der erwarteten Anzahl. Wenn Sie eine höhere Genauigkeit benötigen, geben Sie `format` der "G9" Format-Spezifikation, die immer 9 Ziffern, oder "R" zurückgibt, die 7 Ziffern zurückgibt, wenn die Anzahl mit Genauigkeit oder 9 Ziffern dargestellt werden kann, wenn die Zahl nur dargestellt werden kann mit maximaler Genauigkeit.  
  
   
  
## Examples  
 Im folgenden Beispiel definiert einen numerischen Wert und formatiert ihn als einen Währungswert unter Verwendung der standardmäßigen numerischen Formatierungszeichenfolge-Zeichenfolge "C" und als numerischer Wert mit drei Dezimalstellen mithilfe der standardmäßigen numerischen Formatierungszeichenfolge von "N". Die Ergebniszeichenfolgen werden mithilfe der Konventionen der Kultur En-US formatiert. Weitere Informationen zu numerischen Formatzeichenfolgen finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
 [!code-csharp[System.Single.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString7.cs#7)]
 [!code-vb[System.Single.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString7.vb#7)]  
  
 Das folgende Beispiel zeigt mehrere <xref:System.Single> Werte mit einer der unterstützten standardzahlen-Formatbezeichnern zusammen mit zwei benutzerdefinierte numerische Formatzeichenfolgen. Eines dieser benutzerdefinierten Formatzeichenfolgen veranschaulicht, wie eine <xref:System.Single> Wert mit führenden Nullen. Bei der Konvertierung die numerischen Werte in Zeichenfolgen, verwendet das Beispiel die Formatierungskonventionen der Kultur En-US.  
  
 [!code-csharp[System.Single.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#3)]
 [!code-vb[System.Single.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> ist ungültig.</exception>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-pad-a-number-with-leading-zeros.md">Gewusst wie: Auffüllen einer Zahl mit führenden Nullen</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="single.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Eine numerische Formatierungszeichenfolge.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Konvertiert den numerischen Wert dieser Instanz unter Verwendung des angegebenen Formats und der angegebenen kulturabhängigen Formatierungsinformationen in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieser Instanz entsprechend den Angaben von <paramref name="format" /> und <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29> -Methode formatiert einen <xref:System.Single> Wert in einem angegebenen Format einer angegebenen Kultur. Wenn Sie die Standardeinstellungen Format oder die Kultur verwenden möchten, verwenden Sie alle anderen Überladungen der der <xref:System.Single.ToString%2A> -Methode wie folgt:  
  
|Format verwenden|Für die Kultur|Verwenden Sie die Überladung|  
|-------------------|-----------------|----------------------|  
|Standardformat ("G")|(Aktueller) Standardkultur|<xref:System.Single.ToString>|  
|Standardformat ("G")|Eine bestimmte Kultur|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|Einem bestimmten format|(Aktueller) Standardkultur|<xref:System.Single.ToString%28System.String%29>|  
  
 Der Rückgabewert kann sein <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, oder der Zeichenfolgendarstellung des Werts der aktuellen Instanz gemäß `format`.  
  
 Die `format` Parameter kann eine beliebige gültige numerischer Standardformatbezeichner mit Ausnahme der Forschung und Entwicklung sowie X sowie eine beliebige Kombination aus benutzerdefinierten Zahlenformatbezeichner sein. Wenn `format` ist `null` oder eine leere Zeichenfolge und der Rückgabewert für diese Instanz mit dem allgemeinen numerische Formatbezeichner ("G") formatiert ist.  
  
 .NET Framework bietet umfangreiche formatierungsunterstützung, die in den folgenden Themen zur Formatierung ausführlicher beschrieben wird:  
  
-   Weitere Informationen über numerische Formatbezeichner finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md).  
  
 Die `provider` -Parameter ist ein <xref:System.IFormatProvider> Implementierung, deren <xref:System.IFormatProvider.GetFormat%2A> Methode gibt eine <xref:System.Globalization.NumberFormatInfo> Objekt. In der Regel `provider` ist eine <xref:System.Globalization.CultureInfo> Objekt oder ein <xref:System.Globalization.NumberFormatInfo> Objekt. Die `provider` Parameter liefert kulturspezifische Informationen, die bei der Formatierung verwendete. Wenn `provider` ist `null`, der Rückgabewert formatiert wird, mit der <xref:System.Globalization.NumberFormatInfo> Objekt für die aktuelle Kultur.  
  
 Standardmäßig enthält der Rückgabewert nur 7 Dezimalstellen, obwohl intern ein Maximum von 9 Ziffern gespeichert wird. Wenn der Wert dieser Instanz mehr als 7 Ziffern verfügt <xref:System.Single.ToString%2A> gibt <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> oder <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> anstelle der erwarteten Anzahl. Wenn Sie eine höhere Genauigkeit benötigen, geben Sie `format` der "G9" Format-Spezifikation, die immer 9 Ziffern, oder "R" zurückgibt, die 7 Ziffern zurückgibt, wenn die Anzahl mit Genauigkeit oder 9 Ziffern dargestellt werden kann, wenn die Zahl nur dargestellt werden kann mit maximaler Genauigkeit.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine <xref:System.Single> Wert mit einer der unterstützten standardzahlen-Formatbezeichnern für verschiedene Kulturen.  
  
 [!code-csharp[System.Single.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#4)]
 [!code-vb[System.Single.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-pad-a-number-with-leading-zeros.md">Gewusst wie: Auffüllen einer Zahl mit führenden Nullen</related>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; *  * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="single.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in die entsprechende Gleitkommazahl mit einfacher Genauigkeit. Ein Rückgabewert gibt an, ob die Konvertierung erfolgreich war oder nicht.</summary>
        <altmember cref="Overload:System.Single.Parse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.ReadOnlySpan{System.Char},System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.single.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Single" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.String,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.single.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="result" Type="System.Single" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die die zu konvertierende Zahl darstellt.</param>
        <param name="result">Diese Methode gibt bei erfolgreicher Konvertierung eine Gleitkommazahl mit einfacher Genauigkeit zurück, die dem numerischen Wert oder dem in <c>s</c> enthaltenen Symbol entspricht, und 0 (null), wenn die Konvertierung nicht durchgeführt werden konnte. Bei der Konvertierung tritt ein Fehler auf, wenn der <c>s</c>-Parameter <see langword="null" /> oder <see cref="F:System.String.Empty" /> ist, keine Zahl in einem gültigen Format ist oder eine Zahl kleiner als <see cref="F:System.Single.MinValue" /> oder größer als <see cref="F:System.Single.MaxValue" /> ist. Dieser Parameter wird nicht initialisiert übergeben. In <c>result</c> ursprünglich übergebene Werte werden ausnahmslos überschrieben.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in die entsprechende Gleitkommazahl mit einfacher Genauigkeit. Ein Rückgabewert gibt an, ob die Konvertierung erfolgreich war oder nicht.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="s" /> erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung unterscheidet sich von der <xref:System.Single.Parse%28System.String%29?displayProperty=nameWithType> Methode durch einen booleschen Wert, der angibt, ob der Analysevorgang erfolgreich war, anstatt den analysierten numerischen Wert zurückgeben. Es entfällt die Notwendigkeit, eine Ausnahmebehandlung verwendet wird, zum Prüfen auf eine <xref:System.FormatException> , `s` ist ungültig und kann nicht erfolgreich analysiert werden kann.  
  
 Die `s` kann Parameter enthalten <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> (beim Vergleich der Zeichenfolgen wird beachtet), oder eine Zeichenfolge der Form:  
  
 [ws] [SSO] [ganzzahligen Ziffern,] Ganzzahl-Ziffern [. [ Bruchziffern]] [e [Sign] exponentiellen-Ziffern] [ws]  
  
 Elemente in eckigen Klammern sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*ws*|Eine Reihe von Leerzeichen.|  
|*sign*|Ein negatives Vorzeichen oder das Pluszeichen.|  
|*Ganzzahl-Ziffern*|Eine Reihe von numerischen Zeichen, die im Bereich von 0 bis 9, die den ganzzahligen Teil der Zahl angeben. Ganzzahl-Ziffern nicht vorhanden sein können Wenn Bruchziffern vorhanden sind.|  
|*,*|Eine kulturspezifische Gruppentrennzeichen.|  
|*.*|Eine kulturspezifische Dezimaltrennzeichen.|  
|*fractional-digits*|Eine Reihe von numerischen Zeichen, die im Bereich von 0 bis 9, die die Nachkommastellen der Zahl angeben.|  
|*E*|Ein klein-oder Großbuchstaben und Zeichen 'e', der Exponentialschreibweise (wissenschaftlich) angibt.|  
|*exponential-digits*|Eine Reihe von numerischen Zeichen, die im Bereich von 0 bis 9, die einen Exponenten angeben.|  
  
 Die `s` Parameter wird eine Kombination von interpretiert die <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> und <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> Flags. Dies bedeutet, dass Leerraum und Tausende Trennzeichen zulässig sind Währungssymbole sind jedoch nicht. Die Elemente explizit zu definieren (wie Währungssymbole, Tausende Trennzeichen und Leerraum) in vorhanden sein können `s`, verwenden die <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29> -methodenüberladung.  
  
 Die `s` -Parameter wird analysiert, die unter Verwendung der Formatierungsinformationen in eine <xref:System.Globalization.NumberFormatInfo> -Objekt, das für die aktuelle Systemkultur initialisiert wird. Weitere Informationen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>. Analysieren eine Zeichenfolge unter Verwendung der Formatierungsinformationen in einer anderen Kultur angegeben, verwenden Sie die <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29> -methodenüberladung.  
  
 Normalerweise übergeben die <xref:System.Single.TryParse%2A?displayProperty=nameWithType> Methode eine Zeichenfolge, die durch den Aufruf erstellt wird die <xref:System.Single.ToString%2A?displayProperty=nameWithType> -Methode, die ursprünglichen <xref:System.Single> Wert wird zurückgegeben. Jedoch können aufgrund einer Unterbrechung der Genauigkeit, die Werte sein nicht gleich.  
  
 Wenn Sie ein Trennzeichen gefunden wird die `s` Parameter bei einem Analysevorgang, und die geltenden Währung oder Zahl, Dezimalzahl und Gruppentrennzeichen sind identisch, die der Analysevorgang wird davon ausgegangen, dass das Trennzeichen ein Dezimaltrennzeichen anstelle einer Gruppe Trennzeichen. Weitere Informationen zu den Trennzeichen, finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Single.TryParse%28System.String%2CSystem.Single%40%29> konvertiert die zeichenfolgendarstellungen von numerischen Werten für die Methode <xref:System.Single> Werte. Es wird davon ausgegangen, dass diese En-US, die aktuelle Kultur ist.  
  
 [!code-csharp[System.Single.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.tryparse/cs/tryparse1.cs#1)]
 [!code-vb[System.Single.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.tryparse/vb/tryparse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analysieren numerischer Zeichenfolgen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider provider, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.single.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Single" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.single.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Single" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die die zu konvertierende Zahl darstellt.</param>
        <param name="style">Eine bitweise Kombination von Enumerationswerten, die das zulässige Format von <c>s</c> angibt. Ein häufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Float" /> in Kombination mit <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu <c>s</c> bereitstellt.</param>
        <param name="result">Diese Methode gibt bei erfolgreicher Konvertierung eine Gleitkommazahl mit einfacher Genauigkeit zurück, die dem numerischen Wert oder dem in <c>s</c> enthaltenen Symbol entspricht, und 0 (null), wenn die Konvertierung nicht durchgeführt werden konnte. Die Konvertierung kann nicht durchgeführt werden, wenn der <c>s</c>-Parameter <see langword="null" /> oder <see cref="F:System.String.Empty" /> ist, kein mit <c>style</c> kompatibles Format aufweist, eine Zahl kleiner als <see cref="F:System.Single.MinValue" /> oder größer als <see cref="F:System.Single.MaxValue" /> darstellt oder wenn <c>style</c> keine gültige Kombination von <see cref="T:System.Globalization.NumberStyles" />-Enumerationskonstanten ist. Dieser Parameter wird nicht initialisiert übergeben. In <c>result</c> ursprünglich übergebene Werte werden ausnahmslos überschrieben.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturabhängigen Format in die entsprechende Gleitkommazahl mit einfacher Genauigkeit. Ein Rückgabewert gibt an, ob die Konvertierung erfolgreich war oder nicht.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="s" /> erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung unterscheidet sich von der <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> Methode durch einen booleschen Wert, der angibt, ob der Analysevorgang erfolgreich war, anstatt den analysierten numerischen Wert zurückgeben. Es entfällt die Notwendigkeit, eine Ausnahmebehandlung verwendet wird, zum Prüfen auf eine <xref:System.FormatException> , `s` ist ungültig und kann nicht erfolgreich analysiert werden kann.  
  
 Die `style` Parameter definiert das zulässige Format von der `s` Parameter, damit der Analysevorgang erfolgreich ist. Es muss eine Kombination von Bitflags aus den <xref:System.Globalization.NumberStyles> Enumeration. Die folgenden <xref:System.Globalization.NumberStyles> Member werden nicht unterstützt:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>  
  
 Die `s` kann Parameter enthalten <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> für die Kultur, angegeben durch `provider`. Darüber hinaus, abhängig vom Wert `style`, `s` Parameter die folgenden Elemente enthalten:  
  
 [ws] [$] [SSO] [ganzzahligen Ziffern,] [.fractional-Ziffern] [e [Sign] exponentiellen-Ziffern] Ganzzahl-Ziffern [ws]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*ws*|Optionalen Leerzeichen. Leerzeichen am Anfang stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> Flag. Es kann angezeigt werden, am Ende der `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> Flag.|  
|*$*|Eine kulturspezifische Währungssymbol. Seine Position in der Zeichenfolge wird definiert, durch die <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> oder <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> Eigenschaften der <xref:System.Globalization.NumberFormatInfo> zurückgegebenes Objekt der <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> -Methode der der `provider` Parameter. Das Währungssymbol angezeigt werden kann, im `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> Flag.|  
|*sign*|Einem optionalen Vorzeichen. Die Zeichen am Anfang stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> Flag, und es können angezeigt werden, am Ende der `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> Flag. Klammern können verwendet werden, `s` um einen negativen Wert anzugeben, ob `style` enthält die <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> Flag.|  
|*Ganzzahl-Ziffern*|Eine Folge von Ziffern zwischen 0 und 9, die den ganzzahligen Teil der Zahl angeben. Ganzzahl-Ziffern nicht vorhanden sein können Wenn Bruchziffern vorhanden sind.|  
|*,*|Ein Tausendertrennzeichen kulturspezifische Trennzeichen-Symbol. Tausende von der aktuellen Kultur als Trennzeichen kann angezeigt werden, `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> Flag.|  
|*.*|Eine kulturspezifische Dezimaltrennzeichen. In der aktuellen Kultur Dezimaltrennzeichen angezeigt werden kann `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Flag.|  
|*fractional-digits*|Eine Folge von Ziffern zwischen 0 und 9, die die Nachkommastellen der Zahl angeben. Bruchziffern können angezeigt werden, `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Flag.|  
|*e*|Das e oder E-Zeichen, der angibt, dass `s` kann eine Zahl, die mit der Exponentialschreibweise darstellen. Die `s` Parameter kann eine Zahl in Exponentialschreibweise darstellen, wenn Style enthält die <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> Flag.|  
|*exponential-digits*|Eine Folge von Ziffern zwischen 0 und 9, die einen Exponenten angeben.|  
  
> [!NOTE]
> Alle abschließenden NULL (U + 0000)-Zeichen im `s` werden ignoriert, durch den Analysevorgang, unabhängig vom Wert für die `style` Argument.

 Eine Zeichenfolge mit der nur Ziffern (Dies entspricht der <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> Stil) immer erfolgreich analysiert. Die verbleibenden <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Elemente steuern, Elemente, die möglicherweise sind jedoch nicht erforderlich, in der Eingabezeichenfolge vorhanden sein muss. Die folgende Tabelle gibt an, wie einzelne <xref:System.Globalization.NumberStyles> Flags wirken sich auf die Elemente, die ggf. im `s`.  
  
|NumberStyles-Wert|Elemente in s neben Ziffern zulässig|  
|------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Die *ganzzahligen Ziffern* nur-Element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Das Sprachelement *.* und *Bruchziffern* Elemente.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Die `s` Parameter können Sie auch Exponentialschreibweise. Dieses Flag selbst unterstützt Werte im Formular *ganzzahligen Ziffern*E*Exponenten-Ziffern*; zusätzliche Flags sind erforderlich, um die erfolgreichen Analysieren von Zeichenfolgen in Exponentialschreibweise mit Elementen wie positives oder negatives Vorzeichen und ein Dezimaltrennzeichen.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Die *ws* Element am Anfang des `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Die *ws* Element am Ende der `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Die *anmelden* Element am Anfang des `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Die *anmelden* Element am Ende der `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Die *anmelden* Element in Form von Klammern, die den numerischen Wert einschließen.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Die *,* Element.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Die * $ * Element.|  
|<xref:System.Globalization.NumberStyles.Currency>|Alle Die `s` -Parameter kann keine hexadezimale Zahl oder einer Zahl in Exponentialschreibweise darstellen.|  
|<xref:System.Globalization.NumberStyles.Float>|Die *ws* Element am Anfang oder Ende des `s`, *anmelden* am Anfang des `s`, und die *.* Symbol. Die `s` Parameter können Sie auch Exponentialschreibweise.|  
|<xref:System.Globalization.NumberStyles.Number>|Die `ws`, `sign`, Tausende Trennzeichen (*,),* und Dezimaltrennzeichen (*.*) Elemente.|  
|<xref:System.Globalization.NumberStyles.Any>|Alle Stile mit Ausnahme von `s` eine hexadezimale Zahl nicht darstellen kann.|  
  
 Die `provider` -Parameter ist ein <xref:System.IFormatProvider> Implementierung, deren <xref:System.IFormatProvider.GetFormat%2A> Methode gibt eine <xref:System.Globalization.NumberFormatInfo> -Objekt, das kulturspezifische Formatierungsinformationen bereitstellt. Wenn die <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29> -Methode wird aufgerufen, ruft es die `provider` des Parameters <xref:System.IFormatProvider.GetFormat%2A> Methode und übergibt sie ein <xref:System.Type> Objekt, das darstellt der <xref:System.Globalization.NumberFormatInfo> Typ. Der <xref:System.IFormatProvider.GetFormat%2A> Methodenrückgabe klicken Sie dann die <xref:System.Globalization.NumberFormatInfo> -Objekt, das Informationen über das Format der `s` Parameter. Es gibt drei Möglichkeiten zum Verwenden der `provider` Parameter, um die benutzerdefinierte Formatierung Informationen, die der Analysevorgang angeben:  
  
-   Sie können übergeben eine <xref:System.Globalization.CultureInfo> -Objekt, das die Kultur darstellt, das Formatierungsinformationen bereitstellt. Die <xref:System.Globalization.CultureInfo.GetFormat%2A> Methode gibt die <xref:System.Globalization.NumberFormatInfo> -Objekt, das numerische Formatierungsinformationen für die jeweilige Kultur bereitstellt.  
  
-   Sie können die tatsächlichen übergeben <xref:System.Globalization.NumberFormatInfo> -Objekt, das numerische Formatierungsinformationen bereitstellt. (Eine Implementierung von <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> nur sich selbst zurückgibt.)  
  
-   Sie können ein benutzerdefiniertes Objekt, das implementiert übergeben <xref:System.IFormatProvider>. Die <xref:System.IFormatProvider.GetFormat%2A> -Methode instanziiert und gibt die <xref:System.Globalization.NumberFormatInfo> -Objekt, das Formatierungsinformationen bereitstellt.  
  
 Wenn `provider` ist `null`, die Formatierung der `s` interpretiert basierend auf den <xref:System.Globalization.NumberFormatInfo> Objekt der aktuellen Kultur.  
  
 Wenn Sie ein Trennzeichen gefunden wird die `s` Parameter bei einem Analysevorgang, und die geltenden Währung oder Zahl, Dezimalzahl und Gruppentrennzeichen sind identisch, die der Analysevorgang wird davon ausgegangen, dass das Trennzeichen ein Dezimaltrennzeichen anstelle einer Gruppe Trennzeichen. Weitere Informationen zu den Trennzeichen, finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Verwendung der <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29?displayProperty=nameWithType> Methode, um die Zeichenfolgendarstellung von Zahlen zu analysieren, die einen bestimmten nachrichtenstil und mit den Konventionen einer bestimmten Kultur formatiert.  
  
 [!code-csharp[System.Single.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.tryparse/cs/tryparse1.cs#2)]
 [!code-vb[System.Single.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.tryparse/vb/tryparse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
- oder -  
 <paramref name="style" /> ist der <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />-Wert.</exception>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analysieren numerischer Zeichenfolgen in .NET</related>
      </Docs>
    </Member>
  </Members>
</Type>