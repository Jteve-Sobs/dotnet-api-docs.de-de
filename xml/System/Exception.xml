<Type Name="Exception" FullName="System.Exception">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4dc37d06070017412e2ccd0e886f62a2b70f6949" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48595307" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Exception : System.Runtime.InteropServices._Exception, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable beforefieldinit Exception extends System.Object implements class System.Runtime.InteropServices._Exception, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Exception" />
  <TypeSignature Language="VB.NET" Value="Public Class Exception&#xA;Implements _Exception, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Exception : System::Runtime::InteropServices::_Exception, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Exception = class&#xA;    interface ISerializable&#xA;    interface _Exception" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Exception</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Exception))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt Fehler dar, die beim Ausführen einer Anwendung auftreten.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Klasse ist die Basisklasse für alle Ausnahmen. Wenn ein Fehler auftritt, entweder das System oder der aktuell ausgeführten Anwendung wird gemeldet durch Auslösen einer Ausnahme, die Informationen zum Fehler enthält. Nachdem eine Ausnahme ausgelöst wird, wird sie von der Anwendung oder vom Standardausnahmehandler verarbeitet.  
  
 In diesem Abschnitt  
  
 [Fehler und Ausnahmen](#Errors)   
 [Try/Catch-Blöcke](#TryCatch)   
 [Features von Ausnahmetypen](#Features)   
 [Eigenschaften der Ausnahme-Klasse](#Properties)   
 [Überlegungen zur Leistung](#Performance)   
 [Erneutes Auslösen einer Ausnahme](#Rethrow)   
 [Standardausnahmen auswählen](#Standard)   
 [Implementieren benutzerdefinierte Ausnahmen](#Custom)  
  
<a name="Errors"></a>   
## <a name="errors-and-exceptions"></a>Fehler und Ausnahmen  
 Laufzeitfehler können eine Vielzahl von Gründen auftreten. Allerdings sollten nicht alle Fehler im Code als Ausnahmen behandelt werden. Hier sind einige Arten von Fehlern, die zur Laufzeit und die entsprechenden Methoden auf diese reagieren auftreten können.  
  
-   **Fehler.** Ein verwendungsfehlers stellt einen Fehler in der Programmlogik, die zu einer Ausnahme führen können. Der Fehler sollten jedoch nicht über die Behandlung von Ausnahmen aber ändern den fehlerhaften Code behandelt werden. Z. B. die Überschreibung der der <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> Methode im folgenden Beispiel wird vorausgesetzt, dass die `obj` Argument muss immer ungleich Null sein.  
  
     [!code-csharp[System.Exception.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/usageerrors1.cs#4)]
     [!code-vb[System.Exception.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/usageerrors1.vb#4)]  
  
     Die <xref:System.NullReferenceException> Ausnahme, die Ergebnisse bei `obj` ist `null` kann behoben werden, durch die Änderung des Quellcodes, um explizit auf Null vor dem Aufruf zu testen der <xref:System.Object.Equals%2A?displayProperty=nameWithType> "Override" und klicken Sie dann erneut kompiliert. Das folgende Beispiel enthält den korrigierten Quellcode, der verarbeitet eine `null` Argument.  
  
     [!code-csharp[System.Exception.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/usageerrors2.cs#5)]
     [!code-vb[System.Exception.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/usageerrors2.vb#5)]  
  
     Anstatt eine Ausnahmebehandlung für Fehler, können Sie die <xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType> Methode, um die Nutzung in Debugbuilds, fehleridentifizierung und <xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType> Methode zum Erkennen von Fehlern der Nutzung in Debug und Release-builds. Weitere Informationen finden Sie unter [Assertionen in verwaltetem Code](/visualstudio/debugger/assertions-in-managed-code).  
  
-   **Programmfehler.** Ein Programmfehler ist ein Laufzeitfehler auf, die unbedingt vermieden werden kann, indem fehlerfreien Code zu schreiben.  
  
     In einigen Fällen kann ein Programmfehler eine erwartete oder eines routineparameters fehlerbedingung. In diesem Fall empfiehlt es sich um zu vermeiden, befassen sich mit der Programmfehler, und versuchen Sie stattdessen eine Ausnahmebehandlung mit. Z. B. wenn der Benutzer zur Eingabe eines Datums in einem bestimmten Format erwartet wird, Sie können analysieren, die Datumszeichenfolge durch Aufrufen der <xref:System.DateTime.TryParseExact%2A?displayProperty=nameWithType> -Methode, die gibt eine <xref:System.Boolean> Wert, der angibt, ob der Analysevorgang erfolgreich war, anstatt die ,<xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType>-Methode, die löst eine <xref:System.FormatException> -Ausnahme aus, wenn die Datumszeichenfolge kann, um konvertiert werden eine <xref:System.DateTime> Wert. Auf ähnliche Weise, wenn ein Benutzer versucht, eine Datei zu öffnen, die nicht vorhanden ist, Sie können rufen Sie zuerst die <xref:System.IO.File.Exists%2A?displayProperty=nameWithType> -Methode überprüft, ob die Datei vorhanden ist, und, wenn er nicht der Fall ist der Benutzer aufgefordert, ob er wünscht, ihn zu erstellen.  
  
     In anderen Fällen gibt ein Programmfehler eine unerwartete fehlerbedingung, die in Ihrem Code behandelt werden können. Beispielsweise auch, wenn Sie sichergestellt haben, um sicherzustellen, dass eine Datei vorhanden ist, kann es gelöscht werden bevor können Sie es öffnen, oder sie ist möglicherweise beschädigt. In diesem Fall versuchen, zum Öffnen der Datei durch die Instanziierung einer <xref:System.IO.StreamReader> -Objekts oder das Aufrufen der <xref:System.IO.File.Open%2A> Methode Auslösen einer <xref:System.IO.FileNotFoundException> Ausnahme. In diesen Fällen sollten Sie zum Beheben des Fehlers für die Ausnahmebehandlung verwenden.  
  
-   **Systemfehler.** Ein Systemfehler auftritt ist, der programmgesteuert auf sinnvolle Weise behandelt werden, kann nicht zur Laufzeit Fehler aufgetreten. Beispielsweise kann eine beliebige Methode Auslösen einer <xref:System.OutOfMemoryException> -Ausnahme aus, wenn die common Language Runtime keinen zusätzlichen Arbeitsspeicher zuweisen kann. Systemfehler werden normalerweise nicht mit der Behandlung von Ausnahmen behandelt. Stattdessen möglicherweise ein Ereignis zu verwenden, z. B. <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> , und rufen Sie die <xref:System.Environment.FailFast%2A?displayProperty=nameWithType> Methode, um Informationen zur Ausnahme protokollieren und den Benutzer für den Fehler zu benachrichtigen, bevor die Anwendung beendet wird.  
  
<a name="TryCatch"></a>   
## <a name="trycatch-blocks"></a>Try/Catch-Blöcke  
 Die common Language Runtime bietet ein Modell zur Ausnahmebehandlung, die basierend auf der Darstellung von Ausnahmen als Objekte, und die Trennung von Programmcode und Code in die Ausnahmebehandlung `try` Blöcke und `catch` Blöcke. Es kann sein, eine oder mehrere `catch` blockiert, die einen bestimmten Typ von Ausnahme oder einem Block, eine spezifischere Ausnahme als einen anderen Block abgefangen werden soll.  
  
 Wenn eine Anwendung Ausnahmen, die während der Ausführung eines Codeblocks Anwendung auftreten behandelt, muss der Code platziert werden, in einem `try` Anweisung und wird aufgerufen, eine `try` Block. Anwendungscode, der ausgelöste Ausnahmen behandelt eine `try` Block befindet sich in einem `catch` Anweisung und wird aufgerufen, eine `catch` Block. 0 (null) oder mehr `catch` Blöcke zugeordnet sind eine `try` Block, und jedes `catch` -Block enthält einen Filter vom Typ, der bestimmt, die Arten von Ausnahmen behandelt.  
  
 Wenn eine Ausnahme auftritt, eine `try` blockieren, das System sucht die zugeordnete `catch` , freigegebene Blöcke in der Reihenfolge im Anwendungscode, bis er findet eine `catch` Block, der die Ausnahme behandelt. Ein `catch` -Block verarbeitet eine Ausnahme vom Typ `T` Wenn gibt an, der Filter des Catch-Blocks `T` oder ein Typ, der `T` abgeleitet. Das System beendet die Suche, nach der ersten gefundenen `catch` Block, der die Ausnahme behandelt. Aus diesem Grund im Anwendungscode eine `catch` Block, der einen Typ behandelt muss angegeben werden, bevor Sie eine `catch` Block, der Basistypen, behandelt, wie im Beispiel wird veranschaulicht, die in diesem Abschnitt folgt. Ein CatchBlock, behandelt `System.Exception` zuletzt angegeben ist.  
  
 Wenn keiner der der `catch` Blöcke, die die aktuelle zugeordnet `try` Block verarbeitet die Ausnahme und die aktuelle `try` innerhalb anderer Block geschachtelt ist `try` im aktuellen Aufruf blockiert die `catch` Blöcke, die nächste zugeordnet Einschließen von `try` Block durchsucht werden. Wenn kein `catch` Block für die Ausnahme gefunden wird, wird das System durchsucht Schachtelungsebenen im aktuellen Aufruf. Wenn kein `catch` -Block für die Ausnahme, die im aktuellen Aufruf gefunden wird, die Ausnahme der Aufrufliste nach oben weitergegeben wird und vorherigen Stapelrahmens gesucht wird eine `catch` Block, der die Ausnahme behandelt. Die Suche der Aufrufliste wird fortgesetzt, bis die Ausnahme behandelt wird oder keine Frames mehr in der Aufrufliste vorhanden sind. Wenn am Anfang der Aufrufliste, ohne suchen erreicht ist eine `catch` -Block die Behandlung der Ausnahme, die der Standardausnahmehandler verarbeitet sie und die Anwendung beendet wird.  
  
<a name="Features"></a>   
## <a name="exception-type-features"></a>Features von Ausnahmetypen  
 Ausnahmetypen unterstützt die folgenden Features:  
  
-   Benutzer lesbarer Text, der den Fehler beschreibt. Wenn eine Ausnahme auftritt, garantiert die Runtime eine Textnachricht verfügbar, um den Benutzer, der die Art des Fehlers zu informieren und Aktion wird empfohlen, um das Problem zu beheben. Diese Textnachricht wird, verbleibt in der <xref:System.Exception.Message%2A> -Eigenschaft des Ausnahmeobjekts. Während der Erstellung des Ausnahmeobjekts können Sie eine Textzeichenfolge an den Konstruktor, um die Details dieser bestimmten Ausnahme beschreiben übergeben. Wenn kein Fehler Message-Argument an den Konstruktor angegeben wird, wird die Standardfehlermeldung verwendet. Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Exception.Message%2A>-Eigenschaft.  
  
-   Der Zustand der Aufrufliste als die Ausnahme ausgelöst wurde. Die <xref:System.Exception.StackTrace%2A> Eigenschaft weist eine stapelüberwachung, die verwendet werden kann, um zu bestimmen, wo der Fehler im Code auftritt. Die stapelüberwachung Listet alle aufgerufenen Methoden und die Zeilennummern, in der Quelldatei, in dem die Aufrufe erfolgt sind.  
  
<a name="Properties"></a>   
## <a name="exception-class-properties"></a>Eigenschaften der Ausnahme-Klasse  
 Die <xref:System.Exception> -Klasse enthält eine Reihe von Eigenschaften, die der Code-Ort, den Typ, der Hilfedatei und die Ursache der Ausnahme zu ermitteln: <xref:System.Exception.StackTrace%2A>, <xref:System.Exception.InnerException%2A>, <xref:System.Exception.Message%2A>, <xref:System.Exception.HelpLink%2A>, <xref:System.Exception.HResult%2A>, <xref:System.Exception.Source%2A>, <xref:System.Exception.TargetSite%2A>, und <xref:System.Exception.Data%2A>.  
  
 Wenn eine kausale Beziehung zwischen zwei oder mehr Ausnahmen, ist die <xref:System.Exception.InnerException%2A> Eigenschaft behält diese Informationen. Die äußere Ausnahme wird als Reaktion auf diese innere Ausnahme ausgelöst. Der Code, der die äußere Ausnahme behandelt, kann die Informationen aus die innere Ausnahme verwenden, um den Fehler besser zu behandeln. Zusätzliche Informationen zur Ausnahme kann gespeichert werden, als eine Auflistung von Schlüssel/Wert-Paare in der <xref:System.Exception.Data%2A> Eigenschaft.  
  
 Die Zeichenfolge der Fehlermeldung, die während der Erstellung des Ausnahmeobjekts an den Konstruktor übergeben wird, sollte lokalisiert werden, und aus einer Ressourcendatei angegeben werden, mithilfe der <xref:System.Resources.ResourceManager> Klasse. Weitere Informationen zu lokalisierten Ressourcen finden Sie unter den [Erstellen von Satellitenassemblys](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md) und [Packaging and Deploying Resources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md) Themen.  
  
 Um ausführliche Informationen zur Ursache der Ausnahme, erhält der Benutzer die <xref:System.Exception.HelpLink%2A> Eigenschaft kann einen URL (oder URN) zu einer Hilfedatei enthalten.  
  
 Die <xref:System.Exception> Klasse verwendet die HRESULT COR_E_EXCEPTION mit den Wert 0 x 80131500.  
  
 Eine Liste der anfänglichen Eigenschaftswerte für eine Instanz der <xref:System.Exception> Klasse, finden Sie unter den <xref:System.Exception.%23ctor%2A> Konstruktoren.  
  
<a name="Performance"></a>   
## <a name="performance-considerations"></a>Überlegungen zur Leistung  
 Das Auslösen und Behandeln einer Ausnahme verwendet eine beträchtliche Menge an Systemressourcen und Zeitpunkt der Ausführung. Lösen Sie Ausnahmen nur um wirklich außergewöhnlichen Umständen nicht um vorhersagbare Ereignisse behandeln oder die flusssteuerung zu behandeln. In einigen Fällen, z. B. Wenn Sie eine Klassenbibliothek, entwickeln, ist es z. B. sinnvoll, eine Ausnahme ausgelöst, wenn ein Methodenargument ungültig ist, da Sie davon ausgehen können Ihre Methode, die mit gültigen Parametern aufgerufen werden. Ungültige Methodenargument, bedeutet ist dies nicht das Ergebnis eines verwendungsfehlers, dass es sich bei außergewöhnlicher etwas geschehen ist. Im Gegensatz dazu keine Ausnahme ausgelöst bei Benutzereingaben ungültig, da Sie die Benutzer gelegentlich ungültige Daten eingeben erwarten können. Stattdessen geben Sie einen Wiederholungsmechanismus, damit Benutzer eine gültige Eingabe eingeben können. Auch sollten Sie Ausnahmen verwenden, um Fehler zu behandeln. Verwenden Sie stattdessen [Assertionen](/visualstudio/debugger/assertions-in-managed-code) , identifizieren und beheben Sie Fehler.  
  
 Darüber hinaus keine Ausnahme ausgelöst, wenn ein Rückgabecode ausreichend ist; Konvertieren Sie einen Rückgabecode nicht auf eine Ausnahme; ist nicht routinemäßig Catch eine Ausnahme, ignorieren Sie ihn und klicken Sie dann die Verarbeitung fortgesetzt.  
  
<a name="Rethrow"></a>   
## <a name="re-throwing-an-exception"></a>Erneutes Auslösen einer Ausnahme  
 In vielen Fällen möchte ein Ausnahmehandler einfach die Ausnahme an den Aufrufer übergeben. Dieses Verfahren kommt besonders häufig:  
  
-   Eine Klassenbibliothek, die wiederum Aufrufen von Methoden in der .NET Framework-Klassenbibliothek oder andere Klassenbibliotheken umschließt.  
  
-   Eine Anwendung oder Bibliothek, die eine schwerwiegende Ausnahme auftritt. Der Ausnahmehandler kann die Ausnahme protokollieren, und klicken Sie dann die Ausnahme erneut auszulösen.  
  
 Die empfohlene Methode eine Ausnahme erneut ausgelöst wird, verwenden Sie einfach die [auslösen](~/docs/csharp/language-reference/keywords/throw.md) -Anweisung in c# und die [auslösen](~/docs/visual-basic/language-reference/statements/throw-statement.md) -Anweisung in Visual Basic, ohne dass einen Ausdruck. Dadurch wird sichergestellt, dass alle Informationen in der Aufrufliste beibehalten werden, wenn die Ausnahme an den Aufrufer weitergegeben wird. Dies wird anhand des folgenden Beispiels veranschaulicht. Eine Zeichenfolge-Erweiterungsmethode, `FindOccurrences`, dient als Wrapper für eine oder mehrere Aufrufe von <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> ohne Argumente im Voraus zu überprüfen.  
  
 [!code-csharp[System.Exception.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow1.cs#6)]
 [!code-vb[System.Exception.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow1.vb#6)]  
  
 Ein Aufrufer ruft dann `FindOccurrences` zweimal. Im zweiten Aufruf von `FindOccurrences`, der Aufrufer übergibt ein `null` der Suchzeichenfolge, welchen Fällen die <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> -Methode auslöst ein <xref:System.ArgumentNullException> Ausnahme. Diese Ausnahme wird behandelt, durch die `FindOccurrences` -Methode und an den Aufrufer. Da die Throw-Anweisung ohne Ausdruck verwendet wird, zeigt die Ausgabe des Beispiels an, dass die Aufrufliste beibehalten werden.  
  
 [!code-csharp[System.Exception.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow1.cs#7)]
 [!code-vb[System.Exception.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow1.vb#7)]  
  
 Im Gegensatz dazu sind, wenn die Ausnahme erneut mit ausgelöst wird die  
  
```csharp  
throw e  
```  
  
```vb  
Throw e  
```  
  
 die vollständige Aufrufliste-Anweisung wird nicht beibehalten, und im Beispiel würde die folgende Ausgabe generiert:  
  
```Output  
  
'a' occurs at the following character positions: 4, 7, 15  
  
An exception (ArgumentNullException) occurred.  
Message:  
   Value cannot be null.  
Parameter name: value  
  
Stack Trace:  
      at Library.FindOccurrences(String s, String f)  
   at Example.Main()  
  
```  
  
 Eine etwas umständlicher Alternative ist, um eine neue Ausnahme auszulösen und die ursprüngliche Ausnahme Aufruflisteninformationen in eine innere Ausnahme beibehalten. Der Aufrufer kann dann der neuen Ausnahme verwenden <xref:System.Exception.InnerException%2A> Stapelrahmen und andere Informationen über die ursprüngliche Ausnahme abzurufende Eigenschaft. In diesem Fall ist die Throw-Anweisung aus:  
  
 [!code-csharp[System.Exception.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow3.cs#8)]
 [!code-vb[System.Exception.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow3.vb#8)]  
  
 Der Code des Benutzer, die die Ausnahme behandelt wurde, zu wissen, dass die <xref:System.Exception.InnerException%2A> Eigenschaft enthält Informationen über die ursprüngliche Ausnahme aus, wie die folgenden Ausnahmehandler veranschaulicht.  
  
 [!code-csharp[System.Exception.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow3.cs#9)]
 [!code-vb[System.Exception.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow3.vb#9)]  
  
<a name="Standard"></a>   
## <a name="choosing-standard-exceptions"></a>Standardausnahmen auswählen  
 Wenn Sie eine Ausnahme ausgelöst haben, können Sie häufig einen vorhandenen Ausnahmetyp in .NET Framework statt eine benutzerdefinierte Ausnahme zu implementieren. Sie sollten einen standardmäßigen Ausnahmetyp unter diesen Bedingungen verwenden:  
  
-   Sie sind eine Ausnahme, die aufgrund eines verwendungsfehlers ist (d. h. aufgrund eines Fehlers in der Programmlogik, die von der Entwickler, die die Methode aufruft). In der Regel Sie eine Auslösung ausgeben würde z. B. <xref:System.ArgumentException>, <xref:System.ArgumentNullException>, <xref:System.InvalidOperationException>, oder <xref:System.NotSupportedException>. Die Zeichenfolge, die Sie für das Ausnahmeobjekt-Konstruktor angeben, wenn das Ausnahmeobjekt instanziieren den Fehler beschreiben, damit der Entwickler können Sie diesen Fehler beheben. Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Exception.Message%2A>-Eigenschaft.  
  
-   Sie sind einen Fehler behandeln, der an den Aufrufer mit einer vorhandenen .NET Framework-Ausnahme übermittelt werden kann. Sie sollten die am stärksten abgeleitete, mögliche Ausnahme auslösen. Z. B. wenn eine Methode ein Argument für ein gültiges Mitglied ein Enumerationstyp sein erforderlich ist, lösen Sie eine <xref:System.ComponentModel.InvalidEnumArgumentException> (am meisten abgeleitete Klasse) anstelle einer <xref:System.ArgumentException>.  
  
 Die folgende Tabelle enthält allgemeine Ausnahmetypen und die Bedingungen, unter denen Sie diese auslösen würde.  
  
|Ausnahme|Bedingung|  
|---------------|---------------|  
|<xref:System.ArgumentException>|Ein nicht-Null-Argument, das an eine Methode übergeben wird, ist ungültig.|  
|<xref:System.ArgumentNullException>|Ein Argument, das an eine Methode übergeben wird ist `null`.|  
|<xref:System.ArgumentOutOfRangeException>|Ein Argument liegt außerhalb des Bereichs der gültigen Werte.|  
|<xref:System.IO.DirectoryNotFoundException>|Teil einen Verzeichnispfad ist ungültig.|  
|<xref:System.DivideByZeroException>|Der Nenner in eine ganze Zahl oder <xref:System.Decimal> Divisionsvorgang ist 0 (null).|  
|<xref:System.IO.DriveNotFoundException>|Ein Laufwerk ist nicht verfügbar oder nicht vorhanden.|  
|<xref:System.IO.FileNotFoundException>|Eine Datei ist nicht vorhanden.|  
|<xref:System.FormatException>|Ein Wert ist nicht in ein geeignetes Format, das aus einer Zeichenfolge durch eine Konvertierungsmethode konvertiert werden z. B. `Parse`.|  
|<xref:System.IndexOutOfRangeException>|Ein Index ist außerhalb der Grenzen eines Arrays oder einer Auflistung.|  
|<xref:System.InvalidOperationException>|Ein Methodenaufruf ist im aktuellen Zustand des Objekts ungültig.|  
|<xref:System.Collections.Generic.KeyNotFoundException>|Der angegebene Schlüssel für den Zugriff auf ein Element in einer Auflistung kann nicht gefunden werden.|  
|<xref:System.NotImplementedException>|Eine Methode oder der Vorgang ist nicht implementiert.|  
|<xref:System.NotSupportedException>|Eine Methode oder der Vorgang wird nicht unterstützt.|  
|<xref:System.ObjectDisposedException>|Für ein Objekt, das verworfen wurde, wird ein Vorgang ausgeführt.|  
|<xref:System.OverflowException>|Ein Arithmetik-, Umwandlungs- oder Konvertierungsvorgang führt zu einem Überlauf.|  
|<xref:System.IO.PathTooLongException>|Ein Pfad oder Dateiname überschreitet die vom System definierte Maximallänge.|  
|<xref:System.PlatformNotSupportedException>|Der Vorgang wird auf der aktuellen Plattform nicht unterstützt.|  
|<xref:System.RankException>|Ein Array mit der falschen Anzahl von Dimensionen, die an eine Methode übergeben wird.|  
|<xref:System.TimeoutException>|Das Zeitintervall für einen Vorgang zugewiesene Zeitraum ist abgelaufen.|  
|<xref:System.UriFormatException>|Es wird ein ungültiger Uniform Resource Identifier (URI) verwendet.|  
  
<a name="Custom"></a>   
## <a name="implementing-custom-exceptions"></a>Implementieren benutzerdefinierte Ausnahmen  
 In den folgenden Fällen ist nicht mit einer vorhandenen .NET Framework-Ausnahme eine fehlerbedingung behandelt ausreichend:  
  
-   Wenn die Ausnahme einen Fehler für die eindeutige Programm spiegelt wider, der auf eine vorhandene .NET Framework-Ausnahme zugeordnet werden kann.  
  
-   Wenn die Ausnahme behandeln, die die Verarbeitung unterscheidet, die für eine vorhandene .NET Framework-Ausnahme oder die Ausnahme ist erfordert muss über eine ähnliche Ausnahme eindeutig bestimmt werden. Wenn Sie auslösen, z. B. eine <xref:System.ArgumentOutOfRangeException> Ausnahme bei der die numerische Darstellung einer Zeichenfolge zu analysieren, die außerhalb des gültigen Bereichs des ganzzahligen Zieltyps ist, Sie möchten nicht verwenden, die gleiche Ausnahme für einen Fehler aus der der Aufrufer keine Angabe der geeignete Werte beschränkt, beim Aufrufen der Methode.  
  
 Die <xref:System.Exception> Klasse ist die Basisklasse aller Ausnahmen in .NET Framework. Viele abgeleitete Klassen abhängig von der Member von das geerbte Verhalten der <xref:System.Exception> -Klasse überschreiben sie nicht die Mitglieder der <xref:System.Exception>, und definieren sie eine beliebige eindeutige Elemente.  
  
 So definieren Sie Ihre eigene Ausnahmeklasse:  
  
1.  Definieren Sie eine Klasse, die von erbt <xref:System.Exception>. Definieren Sie bei Bedarf alle eindeutigen Elemente, die von Ihrer Klasse erforderlich, um zusätzliche Informationen zur Ausnahme bereitzustellen. Z. B. die <xref:System.ArgumentException> Klasse enthält eine <xref:System.ArgumentException.ParamName%2A> -Eigenschaft, die den Namen des Parameters angibt, deren Argument der Ausnahme verursacht hat, und die <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> Eigenschaft enthält eine <xref:System.Text.RegularExpressions.RegexMatchTimeoutException.MatchTimeout%2A> Eigenschaft, die das Timeoutintervall angibt.  
  
2.  Bei Bedarf überschreiben Sie alle geerbten Member, deren Funktionalität, die Sie ändern möchten. Beachten Sie, dass die meisten vorhandenen Klassen von abgeleitete <xref:System.Exception> nicht das Verhalten des geerbten Member überschreiben.  
  
3.  Bestimmen Sie, ob Ihre benutzerdefinierten Ausnahme ein Objekt serialisierbar ist. Serialisierung ermöglicht Ihnen das Speichern von Informationen über die Ausnahme und lässt Informationen zur Ausnahme, die von einem Server und einen Clientproxy in einem Remoting-Kontext freigegeben werden. Um das Ausnahmeobjekt serialisierbar zu machen, markieren Sie sie mit der <xref:System.SerializableAttribute> Attribut.  
  
4.  Definieren Sie die Konstruktoren Ihrer Exception-Klasse. Ausnahmeklassen in der Regel haben, eine oder mehrere der folgenden Konstruktoren:  
  
    -   <xref:System.Exception.%23ctor>, der Standardwerte verwendet, um die Eigenschaften eines neuen Ausnahme Objekts initialisieren.  
  
    -   <xref:System.Exception.%23ctor%28System.String%29>, der Initialisiert eine neue Ausnahmeobjekt mit einer angegebenen Fehlermeldung.  
  
    -   <xref:System.Exception.%23ctor%28System.String%2CSystem.Exception%29>, der Initialisiert eine neue Ausnahmeobjekt mit einer angegebenen Fehlermeldung und einer inneren Ausnahme.  
  
    -   <xref:System.Exception.%23ctor%28System.Runtime.Serialization.SerializationInfo%2CSystem.Runtime.Serialization.StreamingContext%29>, die eine `protected` Konstruktor, initialisiert ein neues Ausnahmeobjekt aus, serialisierten Daten. Sie sollten diesen Konstruktor implementieren, wenn Sie entschieden haben, um Ihr Ausnahmeobjekt serialisierbar zu machen.  
  
 Das folgende Beispiel veranschaulicht die Verwendung einer benutzerdefinierten Ausnahme-Klasse. Definiert eine `NotPrimeException` Ausnahme wird ausgelöst, wenn ein Client, zum Abrufen einer Sequenz mit den Primzahlen versucht durch Angabe einer ab, die sich nicht um eine Primzahl handelt. Die Ausnahme definiert eine neue Eigenschaft `NonPrime`, gibt, die zurück, die nicht-Primzahl, die die Ausnahme verursacht hat. Neben der Implementierung ein geschützter parameterlosen Konstruktor und einen Konstruktor mit <xref:System.Runtime.Serialization.SerializationInfo> und <xref:System.Runtime.Serialization.StreamingContext> Parameter für die Serialisierung der `NotPrimeException` -Klasse definiert drei zusätzliche Konstruktoren zur Unterstützung der `NonPrime` Eigenschaft.  Jeder Konstruktor ruft einen Basisklassenkonstruktor zusätzlich zu den Wert von der nicht-Primzahl. Die `NotPrimeException` Klasse ist auch mit markiert die <xref:System.SerializableAttribute> Attribut.  
  
 [!code-csharp[System.Exception.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/notprimeexception.cs#1)]
 [!code-vb[System.Exception.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/notprimeexception.vb#1)]  
  
 Die `PrimeNumberGenerator` Klasse, die im folgenden Beispiel gezeigt das Sieb des Eratosthenes verwendet, um die Reihenfolge der Primzahlen von 2 auf einen Grenzwert angegeben, die vom Client im Aufruf ihres Klassenkonstruktors zu berechnen. Die `GetPrimesFrom` Methode gibt alle Primzahlen, die größer als oder gleich einem angegebenen unteren Grenzwert sind, löst aber eine `NotPrimeException` Wenn, untere Grenze nicht um eine Primzahl ist.  
  
 [!code-csharp[System.Exception.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/primenumbergenerator.cs#2)]
 [!code-vb[System.Exception.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/primenumbergenerator.vb#2)]  
  
 Im folgende Beispiel werden zwei Aufrufe der `GetPrimesFrom` Methode mit nichtprimzahlen, von denen Anwendungsdomänengrenzen überschreitet. In beiden Fällen wird die Ausnahme wird ausgelöst, und im Clientcode erfolgreich behandelt.  
  
 [!code-csharp[System.Exception.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/example.cs#3)]
 [!code-vb[System.Exception.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/example.vb#3)]  
  
## <a name="windows-runtime-and-includenetv451includesnet-v451-mdmd"></a>Windows-Runtime und [!INCLUDE[net_v451](~/includes/net-v451-md.md)]  
 In [!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)] für [!INCLUDE[win8](~/includes/win8-md.md)], einige Informationen zur Ausnahme ist in der Regel verloren, wenn eine Ausnahme über Stapelrahmen nicht-.NET Framework - weitergegeben wird. Beginnend mit der [!INCLUDE[net_v451](~/includes/net-v451-md.md)] und [!INCLUDE[win81](~/includes/win81-md.md)], die common Language Runtime verwendet weiterhin die ursprüngliche <xref:System.Exception> -Objekt, das ausgelöst wurde, es sei denn, diese Ausnahme in einem Stapelrahmen nicht-.NET Framework - geändert wurde.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine `catch` Block, der definiert ist, dass behandeln <xref:System.ArithmeticException> Fehler. Dies `catch` -Block fängt auch <xref:System.DivideByZeroException> Fehler, da <xref:System.DivideByZeroException> leitet sich von <xref:System.ArithmeticException> und es gibt keine `catch` Block für explizit definierte <xref:System.DivideByZeroException> Fehler.  
  
 [!code-cpp[CatchException#1](~/samples/snippets/cpp/VS_Snippets_CLR/CatchException/CPP/catchexception.cpp#1)]
 [!code-csharp[CatchException#1](~/samples/snippets/csharp/VS_Snippets_CLR/CatchException/CS/catchexception.cs#1)]
 [!code-vb[CatchException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CatchException/VB/catchexception.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/exceptions/index.md">Behandeln und Auslösen von Ausnahmen</related>
    <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Verpacken und Bereitstellen von Ressourcen in Desktop-Apps</related>
    <related type="Article" href="http://msdn.microsoft.com/library/70ab2522-6486-4076-a1a9-e0f11cd0f3a1">Assertionen in verwaltetem Code</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Exception" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Exception" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert die <xref:System.Exception.Message%2A>-Eigenschaft der neuen Instanz mit einer Systemmeldung, die den Fehler beschreibt und die aktuelle Systemkultur berücksichtigt.  
  
 Alle abgeleiteten Klassen sollten diese Standardkonstruktor bereitstellen. In der folgenden Tabelle werden die anfänglichen Eigenschaftenwerte für eine <xref:System.Exception>-Instanz aufgeführt.  
  
|Eigenschaft|Wert|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Ein NULL-Verweis (`Nothing` in Visual Basic).|  
|<xref:System.Exception.Message%2A>|Eine im System enthaltene lokalisierte Beschreibung.|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird abgeleitet wird ein `Exception` , verwendet eine vordefinierte Nachricht. Der Code veranschaulicht die Verwendung von dem parameterlosen Konstruktor für die abgeleitete Klasse und die Basis `Exception` Klasse.  
  
 [!code-cpp[System.Exception.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/new.cpp#1)]
 [!code-csharp[System.Exception.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/new.cs#1)]
 [!code-vb[System.Exception.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/new.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception(System::String ^ message);" />
      <MemberSignature Language="F#" Value="new Exception : string -&gt; Exception" Usage="new System.Exception message" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Die Meldung, in der der Fehler beschrieben wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Exception" />-Klasse mit einer angegebenen Fehlermeldung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert die <xref:System.Exception.Message%2A> Eigenschaft der neuen Instanz unter Verwendung der `message` Parameter. Wenn die `message` Parameter `null`, dies ist der gleiche wie das Aufrufen der <xref:System.Exception.%23ctor%2A> Konstruktor.  
  
 In der folgenden Tabelle werden die anfänglichen Eigenschaftenwerte für eine <xref:System.Exception>-Instanz aufgeführt.  
  
|Eigenschaft|Wert|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Ein NULL-Verweis (`Nothing` in Visual Basic).|  
|<xref:System.Exception.Message%2A>|Die Zeichenfolge der Fehlermeldung.|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird abgeleitet wird ein `Exception` für eine bestimmte Bedingung. Der Code veranschaulicht die Verwendung des Konstruktors, die eine vom Aufrufer angegebene Meldung als Parameter für die abgeleitete Klasse und die Basis akzeptiert `Exception` Klasse.  
  
 [!code-cpp[System.Exception.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/news.cpp#2)]
 [!code-csharp[System.Exception.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/news.cs#2)]
 [!code-vb[System.Exception.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/news.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Exception (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new Exception : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; Exception" Usage="new System.Exception (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Die <see cref="T:System.Runtime.Serialization.SerializationInfo" />, die die serialisierten Objektdaten für die ausgelöste Ausnahme enthält.</param>
        <param name="context">Der <see cref="T:System.Runtime.Serialization.StreamingContext" />, der die Kontextinformationen über die Quelle oder das Ziel enthält.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Exception" />-Klasse mit serialisierten Daten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor wird während der Deserialisierung aufgerufen, um das über einen Stream übertragene Ausnahmeobjekt wiederherzustellen. Weitere Informationen finden Sie unter [XML- und SOAP-Serialisierung](~/docs/standard/serialization/xml-and-soap-serialization.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel definiert eine abgeleitete serialisierbare `Exception` Klasse. Der Code wird ein Fehler aufgrund einer Division durch 0 erzwungen und erstellt dann eine Instanz der abgeleiteten Ausnahme unter Verwendung der (<xref:System.Runtime.Serialization.SerializationInfo>, <xref:System.Runtime.Serialization.StreamingContext>) Konstruktor. Der Code wird die Instanz in eine Datei serialisiert, deserialisiert Sie die Datei in eine neue Ausnahme ausgelöst und abgefangen werden Daten von der Ausnahme angezeigt.  
  
 [!code-cpp[System.Exception.GetObjectData#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CPP/getobjdata.cpp#1)]
 [!code-csharp[System.Exception.GetObjectData#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CS/getobjdata.cs#1)]
 [!code-vb[System.Exception.GetObjectData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetObjectData/VB/getobjdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="info" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.Serialization.SerializationException">Der Klassenname ist <see langword="null" />, oder <see cref="P:System.Exception.HResult" /> ist 0 (null).</exception>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">XML- und SOAP-Serialisierung</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception(System::String ^ message, Exception ^ innerException);" />
      <MemberSignature Language="F#" Value="new Exception : string * Exception -&gt; Exception" Usage="new System.Exception (message, innerException)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">Die Fehlermeldung, in der die Ursache der Ausnahme erklärt wird.</param>
        <param name="innerException">Die Ausnahme, die die aktuelle Ausnahme verursacht hat, oder ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn keine innere Ausnahme angegeben ist.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Exception" />-Klasse mit einer angegebenen Fehlermeldung und einem Verweis auf die innere Ausnahme, die diese Ausnahme ausgelöst hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Ausnahme, die als direktes Ergebnis einer vorhergehenden Ausnahme ausgelöst wird, muss in der <xref:System.Exception.InnerException%2A>-Eigenschaft über einen Verweis auf die vorhergehende Ausnahme verfügen. Die <xref:System.Exception.InnerException%2A>-Eigenschaft gibt denselben Wert zurück, der an den Konstruktor übergeben wurde, bzw. einen NULL-Verweis (`Nothing` in Visual Basic), wenn die <xref:System.Exception.InnerException%2A>-Eigenschaft nicht den Wert für die innere Ausnahme für den Konstruktor bereitstellt.  
  
 In der folgenden Tabelle werden die anfänglichen Eigenschaftenwerte für eine <xref:System.Exception>-Instanz aufgeführt.  
  
|Eigenschaft|Wert|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Der Verweis auf die interne Ausnahme.|  
|<xref:System.Exception.Message%2A>|Die Zeichenfolge der Fehlermeldung.|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird abgeleitet wird ein `Exception` für eine bestimmte Bedingung. Der Code veranschaulicht die Verwendung des Konstruktors, der eine Meldung eine innere Ausnahme als Parameter für die abgeleitete Klasse und die Basis und `Exception` Klasse.  
  
 [!code-cpp[System.Exception.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/newsi.cpp#3)]
 [!code-csharp[System.Exception.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/newsi.cs#3)]
 [!code-vb[System.Exception.Ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/newsi.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Data">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionary Data { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Data" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Data" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Data As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::IDictionary ^ Data { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Data : System.Collections.IDictionary" Usage="System.Exception.Data" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung von Schlüssel-Wert-Paaren ab, die zusätzliche benutzerdefinierte Informationen über die Ausnahme bereitstellen.</summary>
        <value>Ein Objekt, das die <see cref="T:System.Collections.IDictionary" />-Schnittstelle implementiert und eine Auflistung benutzerdefinierter Schlüssel-Wert-Paare enthält. Der Standard ist eine leere Auflistung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Collections.IDictionary?displayProperty=nameWithType> zurückgegebenes Objekt der <xref:System.Exception.Data%2A> Eigenschaft zum Speichern und Abrufen von zusätzlichen Informationen über die Ausnahme. Die Informationen sind in Form von einer beliebigen Anzahl von benutzerdefinierten Schlüssel/Wert-Paaren. Die wichtige Komponente jedes Schlüssel-Wert-Paars ist in der Regel eine identifizierende Zeichenfolge ist, während die Wertkomponente des Paars auf jede Art von Objekt sein kann.  
  
## <a name="keyvalue-pair-security"></a>Schlüssel/Wert-Paar-Sicherheit  
 Die Schlüssel-/Wertpaare gespeichert, in der Auflistung zurückgegeben werden, indem die <xref:System.Exception.Data%2A> Eigenschaft sind nicht sicher. Wenn die Anwendung, eine geschachtelte Reihe von Routinen aufruft, und jede Routine Ausnahmehandler enthält, enthält die daraus entstehende Aufrufliste eine Hierarchie der Ausnahmehandler. Wenn eine untergeordnete Routine eine Ausnahme auslöst, kann alle übergeordneten Ausnahmehandler in der Stack Aufrufhierarchie gelesen und/oder Ändern der Schlüssel-/Wertpaaren, die von jedem anderen Ausnahmehandler in der Auflistung gespeichert. Dies bedeutet, dass Sie sicherstellen müssen, dass die Informationen im Schlüssel/Wert-Paare nicht vertraulich sind und Ihre Anwendung ordnungsgemäß ausgeführt wird, wenn die Informationen in der Schlüssel-/Wertpaaren beschädigt ist.  
  
## <a name="key-conflicts"></a>ID-Konflikte  
 Ein Schlüssel Konflikt tritt bei der anderen Ausnahmehandler Schlüssel/Wert-Paar auf den gleichen Schlüssel. Vorsichtig, wenn Ihre Anwendung zu entwickeln, da die Folge von einem Konflikt mit Schlüssel ist, dass das Low-Level-Ausnahmehandler versehentlich mit Ausnahmehandler auf höherer Ebene kommunizieren können, und diese Kommunikation möglicherweise geringfügige Programmfehler. Jedoch wenn Sie vorsichtig sind können wichtige Konflikte Sie um Ihre Anwendung zu optimieren.  
  
## <a name="avoiding-key-conflicts"></a>Vermeiden von Konflikten mit Schlüssel  
 Vermeiden Sie durch die Einführung einer Benennungskonvention zum Generieren von eindeutigen Schlüssel für Schlüssel/Wert-Paaren. Beispielsweise könnte eine Benennungskonvention ergeben, einen Schlüssel, der den Punkt getrennte Namen der Anwendung besteht, die Methode, die zusätzliche Informationen für das Paar und einen eindeutigen Bezeichner enthält.  
  
 Angenommen, zwei Anwendungen, mit dem Namen Produkten und Lieferanten, besitzt jeder eine Methode mit dem Namen Sales. Die Sales-Methode in der Anwendung Produkte stellt die ID-Nummer (die Stock keeping Unit bzw. SKU) eines Produkts bereit. Die Sales-Methode in der Lieferanten-Anwendung enthält die ID-Nummer oder die SID, von einem Lieferanten. Die Namenskonvention für dieses Beispiel ergibt daher den Schlüssel, "Products.Sales.SKU" und "Suppliers.Sales.SID".  
  
## <a name="exploiting-key-conflicts"></a>Ausnutzen-Konflikte  
 Nutzen Sie aus, indem Sie mit der Steuerung der Verarbeitung durch das Vorhandensein von ein oder mehrere spezielle, vordefinierten Schlüssel. Nehmen wir an, in einem Szenario der höchsten Ebene Ausnahmehandler im Stapel Anrufhierarchie alle von Low-Level-Ausnahmehandler ausgelöste Ausnahmen abfängt. Wenn ein Schlüssel/Wert-Paar mit einem speziellen Schlüssel vorhanden ist, formatiert der hohen Ausnahmehandler verbleibenden Schlüssel/Wert-Paare in der <xref:System.Collections.IDictionary> Objekt nicht dem Standard entsprechende irgendwie; andernfalls werden die restlichen Schlüssel/Wert-Paare auf normale Weise formatiert.  
  
 Nehmen wir nun an, in einem anderen Szenario wird der Ausnahmehandler auf jeder Ebene der Hierarchie Stack Aufruf von der nächsten Ausnahmehandler von Low-Level-ausgelöste Ausnahme abfängt. Darüber hinaus jeden Ausnahmehandler von zurückgegebene Auflistung kennt die <xref:System.Exception.Data%2A> Eigenschaft enthält einen Satz von Schlüssel/Wert-Paaren, die zugegriffen werden kann, mit einem vordefinierten Satz von Schlüsseln.  
  
 Jeder Ausnahmehandler verwendet den vordefinierten Satz von Schlüsseln, um die Wertkomponente des entsprechenden Schlüssel/Wert-Paar mit Informationen, die nur für dieser Ausnahmehandler zu aktualisieren. Nachdem der Aktualisierungsvorgang abgeschlossen ist, löst die Ausnahme an den nächsten Ausnahmehandler auf höherer Ebene von der Ausnahmehandler aus. Abschließend wird der Ausnahmehandler auf höchste Ebene greift auf die Schlüssel/Wert-Paare und zeigt die konsolidierte Updateinformationen über die Low-Level-Ausnahmehandler.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt das Hinzufügen und Abrufen von Informationen mithilfe der <xref:System.Exception.Data%2A> Eigenschaft.  
  
 [!code-cpp[exception.data#1](~/samples/snippets/cpp/VS_Snippets_CLR/exception.data/CPP/data.cpp#1)]
 [!code-csharp[exception.data#1](~/samples/snippets/csharp/VS_Snippets_CLR/exception.data/CS/data.cs#1)]
 [!code-vb[exception.data#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/exception.data/VB/data.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.DictionaryEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetBaseException">
      <MemberSignature Language="C#" Value="public virtual Exception GetBaseException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Exception GetBaseException() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetBaseException" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBaseException () As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Exception ^ GetBaseException();" />
      <MemberSignature Language="F#" Value="abstract member GetBaseException : unit -&gt; Exception&#xA;override this.GetBaseException : unit -&gt; Exception" Usage="exception.GetBaseException " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetBaseException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt beim Überschreiben in einer abgeleiteten Klasse eine <see cref="T:System.Exception" /> zurück, die die ursprüngliche Ursache für eine oder mehrere nachfolgende Ausnahmen ist.</summary>
        <returns>Die erste Ausnahme, die in einer Kette von Ausnahmen ausgelöst wird. Wenn die <see cref="P:System.Exception.InnerException" />-Eigenschaft der aktuellen Ausnahme ein NULL-Verweis (<see langword="Nothing" /> in Visual Basic) ist, gibt diese Eigenschaft die aktuelle Ausnahme zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Kette von Ausnahmen besteht aus einem Satz von Ausnahmen so, dass jede Ausnahme in der Kette, als direktes Ergebnis der Ausnahme verwiesen wird ausgelöst wurde, dessen `InnerException` Eigenschaft. Für einer Kette kann genau eine Ausnahme, die Ursache für alle anderen Ausnahmen in der Kette vorhanden sein. Diese Ausnahme wird aufgerufen, die Basis-Ausnahme und die zugehörige `InnerException` Eigenschaft enthält immer einen null-Verweis.  
  
 Für alle Ausnahmen in einer Kette von Ausnahmen die `GetBaseException` Methode muss das gleiche Objekt (die Basisausnahme) zurückgeben.  
  
 Verwenden der `GetBaseException` Methode, wenn Sie die Ursache einer Ausnahme gesucht werden soll, jedoch Informationen zu Ausnahmen, die möglicherweise zwischen der aktuellen Ausnahme und die erste Ausnahme aufgetreten ist nicht erforderlich.  
  
   
  
## Examples  
 Das folgende Codebeispiel definiert zwei abgeleitete `Exception` Klassen. Es erzwingt, dass eine Ausnahme, und klicken Sie dann erneut mit der abgeleiteten Klassen ausgelöst. Der Code zeigt die Verwendung der `GetBaseException` Methode, um die ursprüngliche Ausnahme abzurufen.  
  
 [!code-cpp[System.Exception.GetBaseException#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetBaseException/CPP/getbaseexc.cpp#1)]
 [!code-csharp[System.Exception.GetBaseException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetBaseException/CS/getbaseexc.cs#1)]
 [!code-vb[System.Exception.GetBaseException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetBaseException/VB/getbaseexc.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Die <see langword="GetBaseException" /> Methode in Klassen, die Kontrolle über den Inhalt oder Format erfordern überschrieben wird.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="exception.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Die <see cref="T:System.Runtime.Serialization.SerializationInfo" />, die die serialisierten Objektdaten für die ausgelöste Ausnahme enthält.</param>
        <param name="context">Der <see cref="T:System.Runtime.Serialization.StreamingContext" />, der die Kontextinformationen über die Quelle oder das Ziel enthält.</param>
        <summary>Legt beim Überschreiben in einer abgeleiteten Klasse die <see cref="T:System.Runtime.Serialization.SerializationInfo" /> mit Informationen über die Ausnahme fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetObjectData` legt die <xref:System.Runtime.Serialization.SerializationInfo> mit allen Daten für das Ausnahmeobjekt fest, das für die Serialisierung vorgesehen ist. Während der Deserialisierung wird die Ausnahme aus der über den Stream übertragenen `SerializationInfo` wiederhergestellt.  
  
   
  
## Examples  
 Das folgende Codebeispiel definiert eine abgeleitete serialisierbare `Exception` Klasse, die implementiert `GetObjectData`, wodurch kleinere Änderungen auf zwei Eigenschaften, und klicken Sie dann Aufrufe der Basisklasse aus, führen Sie die Serialisierung. Im Beispiel wird ein Fehler aufgrund einer Division durch 0 erzwungen und erstellt dann eine Instanz der abgeleiteten Ausnahme. Der Code wird die Instanz in eine Datei serialisiert, deserialisiert Sie die Datei in eine neue Ausnahme ausgelöst und abgefangen werden Daten von der Ausnahme angezeigt.  
  
 [!code-cpp[System.Exception.GetObjectData#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CPP/getobjdata.cpp#1)]
 [!code-csharp[System.Exception.GetObjectData#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CS/getobjdata.cs#1)]
 [!code-vb[System.Exception.GetObjectData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetObjectData/VB/getobjdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="info" />-Parameter ist ein NULL-Verweis (<see langword="Nothing" /> in Visual Basic).</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="exception.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft den Laufzeittyp der aktuellen Instanz ab.</summary>
        <returns>Ein <see cref="T:System.Type" />-Objekt, das den exakten Laufzeittyp der aktuellen Instanz darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Exception.GetType%2A> Methode zur Unterstützung der .NET Framework-Infrastruktur vorhanden ist, und ruft intern die grundlegende Methode <xref:System.Object.GetType%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="HelpLink">
      <MemberSignature Language="C#" Value="public virtual string HelpLink { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HelpLink" />
      <MemberSignature Language="DocId" Value="P:System.Exception.HelpLink" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property HelpLink As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HelpLink { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.HelpLink : string with get, set" Usage="System.Exception.HelpLink" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.HelpLink</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Link zu der mit dieser Ausnahme verbundenen Hilfedatei ab oder legt diesen fest.</summary>
        <value>Der URN (Uniform Resource Name) oder die URL (Uniform Resource Locator).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rückgabewert, der eine Hilfedatei darstellt, ist ein URN oder ein URL. Z. B. die `HelpLink` Wert kann sein:  
  
 "file:///C:/Applications/Bazzal/help.html#ErrorNum42"  
  
   
  
## Examples  
 Der folgende code ausgelöst ein `Exception` festlegt, die die `HelpLink` Eigenschaft in den Konstruktor und fängt die Ausnahme und zeigt dann `HelpLink`.  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HResult">
      <MemberSignature Language="C#" Value="public int HResult { get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HResult" />
      <MemberSignature Language="DocId" Value="P:System.Exception.HResult" />
      <MemberSignature Language="VB.NET" Value="Public Property HResult As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:  property int HResult {  public:&#xA;int get(); protected:&#xA; void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.HResult : int with get, set" Usage="System.Exception.HResult" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft HRESULT ab oder legt HRESULT fest. Dies ist ein codierter Wert, der einer bestimmten Ausnahme zugeordnet ist.</summary>
        <value>Der HRESULT-Wert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HRESULT ist eine 32-Bit-Wert, der in drei separate Felder unterteilt: fehlergewichtung, Funktionscode und Fehlercode. Die fehlergewichtung gibt an, ob der Rückgabewert Informationen, Warnung oder Fehler darstellt. Der Funktionscode identifiziert den Bereich des Systems für den Fehler verantwortlich. Der Fehlercode ist eine eindeutige Zahl, die zum Darstellen der Ausnahme zugeordnet ist. Jede Ausnahme wird einem eindeutigen HRESULT zugeordnet. Bei verwalteter Code eine Ausnahme auslöst, übergibt die Laufzeit das HRESULT an COM-Client. Beim nicht verwalteter Code einen Fehler zurückgibt, wird der HRESULT-Wert auf eine Ausnahme, die dann von der Laufzeit ausgelöst wird, konvertiert. Weitere Informationen zu HRESULT-Werte und den entsprechenden .NET Framework-Ausnahmen, finden Sie unter [Vorgehensweise: Zuordnen von HRESULTs und Ausnahmen](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md). Finden Sie unter [Allgemeine HRESULT-Werte](http://msdn.microsoft.com/library/windows/desktop/aa378137.aspx) in der Windows-Dokumentation für eine Liste der Werte, die Ihnen voraussichtlich am häufigsten auftreten.  
  
 Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)], <xref:System.Exception.HResult%2A> des Eigenschaften-Setter geschützt werden, während die Getter-Methode öffentlich ist.  In früheren Versionen von .NET Framework werden sowohl Getter und Setter geschützt.  
  
   
  
## Examples  
 Das folgende Codebeispiel definiert eine abgeleitete `Exception` -Klasse, die legt die `HResult` Eigenschaft, um einen benutzerdefinierten Wert in seinem Konstruktor.  
  
 [!code-cpp[System.Exception.HResult#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.HResult/CPP/hresult.cpp#1)]
 [!code-csharp[System.Exception.HResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.HResult/CS/hresult.cs#1)]
 [!code-vb[System.Exception.HResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.HResult/VB/hresult.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/610b364b-2761-429d-9c4a-afbc3e66f1b9">Gewusst wie: Zuordnen von HRESULTs und Ausnahmen</related>
        <related type="ExternalDocumentation" href="http://msdn.microsoft.com/library/windows/desktop/aa378137.aspx">Allgemeine HRESULT-Werte</related>
      </Docs>
    </Member>
    <Member MemberName="InnerException">
      <MemberSignature Language="C#" Value="public Exception InnerException { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception InnerException" />
      <MemberSignature Language="DocId" Value="P:System.Exception.InnerException" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InnerException As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ InnerException { Exception ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InnerException : Exception" Usage="System.Exception.InnerException" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.InnerException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Exception" />-Instanz ab, die die aktuelle Ausnahme verursacht hat.</summary>
        <value>Eine Instanz, die den Fehler beschreibt, der die aktuelle Ausnahme verursacht hat. Die <see cref="P:System.Exception.InnerException" />-Eigenschaft gibt gleichen Wert zurück, der an den <see cref="M:System.Exception.#ctor(System.String,System.Exception)" />-Konstruktor übergeben wurde, oder <see langword="null" />, wenn der Wert der inneren Ausnahme nicht an den Konstruktor übergeben wurde. Diese Eigenschaft ist schreibgeschützt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine Ausnahme `X` wird als direktes Ergebnis einer vorhergehenden Ausnahme ausgelöst, `Y`, <xref:System.Exception.InnerException%2A> Eigenschaft `X` sollten enthalten einen Verweis auf `Y`.  
  
 Über die <xref:System.Exception.InnerException%2A>-Eigenschaft kann die Gruppe von Ausnahmen abgerufen werden, die zur aktuellen Ausnahme geführt hat.  
  
 Sie können eine neue Ausnahme erstellen, die eine früheren Ausnahme abfängt. Der Code, Handles, die die zweite Ausnahme vornehmen, kann die zusätzlichen Informationen aus der früheren Ausnahme zu verwenden, um den Fehler besser zu behandeln.  
  
 Nehmen wir an, dass eine Funktion, die eine Datei liest und formatiert die Daten aus dieser Datei vorhanden ist. In diesem Beispiel ist als der Code versucht, die Datei zu lesen eine <xref:System.IO.IOException> ausgelöst. Die Funktion fängt die <xref:System.IO.IOException> und löst eine <xref:System.IO.FileNotFoundException>. Die <xref:System.IO.IOException> konnten in gespeichert werden die <xref:System.Exception.InnerException%2A> Eigenschaft der <xref:System.IO.FileNotFoundException>, aktivieren den Code, der erfasst die <xref:System.IO.FileNotFoundException> um die Ursache für den ursprünglichen Fehler zu untersuchen.  
  
 Die <xref:System.Exception.InnerException%2A> -Eigenschaft, die einen Verweis auf die innere Ausnahme enthält, bei der Initialisierung des Ausnahmeobjekts festgelegt ist.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt das Auslösen und Abfangen einer Ausnahme, die auf eine innere Ausnahme verweist.  
  
 [!code-cpp[InnerEx#1](~/samples/snippets/cpp/VS_Snippets_CLR/InnerEx/CPP/innerex.cpp#1)]
 [!code-csharp[InnerEx#1](~/samples/snippets/csharp/VS_Snippets_CLR/InnerEx/CS/innerex.cs#1)]
 [!code-vb[InnerEx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InnerEx/VB/innerex.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Message">
      <MemberSignature Language="C#" Value="public virtual string Message { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Message" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Message" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Message As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Message { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Message : string" Usage="System.Exception.Message" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.Message</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Meldung ab, die die aktuelle Ausnahme beschreibt.</summary>
        <value>Die Fehlermeldung, die die Ursache der Ausnahme erklärt, bzw. eine leere Zeichenfolge ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Fehlermeldungen als Ziel den Entwickler, der die Ausnahme verarbeitet. Der Text, der die <xref:System.Exception.Message%2A> Eigenschaft sollte den Fehler vollständig beschreiben und, sofern möglich, sollte auch erläutert, wie Sie den Fehler zu beheben. Ausnahmehandler der obersten Ebene möglicherweise die Meldung angezeigt und für Endbenutzer, deshalb Sie sicherstellen sollten, dass sie grammatisch korrekten und jeden Satz der Nachricht mit einem Punkt endet. Verwenden Sie keine Fragezeichen oder Ausrufezeichen. Wenn Ihre Anwendung lokalisierte ausnahmemeldungen verwendet, sollten Sie sicherstellen, dass sie genau übersetzt werden.  
  
> [!IMPORTANT]
>  Legen Sie ohne eine Überprüfung auf die entsprechenden Berechtigungen keine offen Sie vertraulichen Informationen in der ausnahmemeldungen.  
  
 Der Wert des der <xref:System.Exception.Message%2A> Eigenschaft befindet sich im zurückgegebenen Informationen <xref:System.Exception.ToString%2A>. Die <xref:System.Exception.Message%2A> Eigenschaftensatz wird nur beim Erstellen einer <xref:System.Exception>. Wenn keine Nachricht an den Konstruktor für die aktuelle Instanz angegeben wurde, stellt das System eine Standardnachricht, die mit der aktuellen Systemkultur formatiert ist.  
  
## <a name="windows-runtime-and-includenetv451includesnet-v451-mdmd"></a>Windows-Runtime und [!INCLUDE[net_v451](~/includes/net-v451-md.md)]  
 Beginnend mit der [!INCLUDE[net_v451](~/includes/net-v451-md.md)] und [!INCLUDE[win81](~/includes/win81-md.md)], verbessert die Genauigkeit der Fehlermeldungen von Ausnahmen, die von Windows-Runtime-Typen und Member, die nicht Teil von .NET Framework sind weitergegeben werden. Insbesondere Ausnahme von Meldungen aus der Visual C++-komponentenerweiterungen (C++ / CX) werden jetzt wieder in .NET Framework weitergegeben <xref:System.Exception> Objekte.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ausgelöst, und klicken Sie dann fängt eine <xref:System.Exception> Ausnahme und zeigt den der Ausnahme Text unter Verwendung der <xref:System.Exception.Message%2A> Eigenschaft.
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn eine aus einer Eigenschaft Ausnahme, und Sie im Text des finden Sie unter müssen <see cref="P:System.Exception.Message" /> an das Eigenschaftsargument, die Sie festlegen oder abrufen, verwenden Sie "Value" als Namen für das Eigenschaftsargument.</para>
        </block>
        <block subset="none" type="overrides">
          <para>Die <see cref="P:System.Exception.Message" /> in Klassen, die Kontrolle über den Nachrichteninhalt oder das Format erfordern Eigenschaft überschrieben wird. Anwendungscode greift diese Eigenschaft in der Regel auf, wenn er benötigt, um Informationen zu einer Ausnahme anzuzeigen, die abgefangen wurde.  
  
Die Fehlermeldung sollte lokalisiert werden.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SerializeObjectState">
      <MemberSignature Language="C#" Value="protected event EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; SerializeObjectState;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.Serialization.SafeSerializationEventArgs&gt; SerializeObjectState" />
      <MemberSignature Language="DocId" Value="E:System.Exception.SerializeObjectState" />
      <MemberSignature Language="VB.NET" Value="Protected Custom Event SerializeObjectState As EventHandler(Of SafeSerializationEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; event EventHandler&lt;System::Runtime::Serialization::SafeSerializationEventArgs ^&gt; ^ SerializeObjectState;" />
      <MemberSignature Language="F#" Value="member this.SerializeObjectState : EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; " Usage="member this.SerializeObjectState : System.EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn eine Ausnahme serialisiert wird, um ein Ausnahmezustandsobjekt zu erstellen, das serialisierte Daten für die Ausnahme enthält.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementiert das Ausnahmeobjekt für den Status der <xref:System.Runtime.Serialization.ISafeSerializationData> Schnittstelle.  
  
 Wenn die <xref:System.Exception.SerializeObjectState> Ereignis abonniert ist, wird die Ausnahme deserialisiert und als leere Ausnahme erstellt. Der Konstruktor der Ausnahme nicht ausgeführt wird, und der Ausnahmezustand auch deserialisiert wird. Die <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A> Callback-Methode des Ausnahmeobjekts Zustand wird dann benachrichtigt, damit es die leere Ausnahme deserialisierte Daten weitergeben kann.  
  
 Die <xref:System.Exception.SerializeObjectState> Ereignis können transparent Ausnahmetypen, die zum Serialisieren und Deserialisieren der Ausnahmedaten. Transparenter Code kann führen Befehle innerhalb der Grenzen des Berechtigungssatzes, in denen es in Betrieb ist, aber kann nicht ausgeführt, aufrufen, abgeleitet oder wichtigen Code enthalten.  
  
 Wenn die <xref:System.Exception.SerializeObjectState> Ereignis nicht abonniert ist, tritt die Deserialisierung wie gewohnt mit der <xref:System.Exception.%23ctor%2A> Konstruktor.  
  
 In der Regel einen Handler für die <xref:System.Exception.SerializeObjectState> Ereignis hinzugefügt wird, in der Ausnahme-Konstruktor, um die Serialisierung bereit. Da der Konstruktor, nicht ist jedoch ausgeführt, wenn die <xref:System.Exception.SerializeObjectState> -Ereignishandler ausgeführt wird, serialisieren eine deserialisierte-Ausnahme auslösen kann eine <xref:System.Runtime.Serialization.SerializationException> Ausnahme aus, wenn Sie versuchen, die die Ausnahme zu deserialisieren. Um dies zu vermeiden, sollten Sie auch den Handler für Hinzufügen der <xref:System.Exception.SerializeObjectState> Ereignis in der <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType> Methode. Finden Sie im Abschnitt "Beispiele" veranschaulicht.  
  
   
  
## Examples  
 Das folgende Beispiel definiert eine `BadDivisionException` , behandelt der <xref:System.Exception.SerializeObjectState> Ereignis. Es enthält auch ein Zustandsobjekt, d.h. eine geschachtelte Struktur mit dem Namen `BadDivisionExceptionState` , implementiert die <xref:System.Runtime.Serialization.ISafeSerializationData> Schnittstelle.  
  
 [!code-csharp[System.Exception.SerializeObjectState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.serializeobjectstate/cs/example2.cs#1)]
 [!code-vb[System.Exception.SerializeObjectState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.serializeobjectstate/vb/example2.vb#1)]  
  
 Die `BadDivisionException` Ausnahme wird ausgelöst, wenn es sich bei eine Gleitkommadivision durch Null auftritt. Während der ersten Division durch 0 (null) wird das Beispiel instanziiert ein `BadDivisionException` Objekt, serialisiert und löst die Ausnahme aus. Bei nachfolgenden Bereiche von 0 (null) im Beispiel deserialisiert das zuvor serialisierte Objekt, serialisiert es dann erneut, und löst die Ausnahme. Um für die Serialisierung von Objekten, die Deserialisierung, Reserialization und Deserialisierung zu ermöglichen, sich das Beispiel fügt die <xref:System.Exception.SerializeObjectState> -Ereignishandler sowohl in der `BadDivisionException` Klassenkonstruktor und klicken Sie in der <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType> Implementierung.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn dieses Ereignis abonniert und verwendet wird, müssen alle abgeleitete Typen, die in der Vererbungshierarchie folgen den gleiche Serialisierungsmechanismus implementieren.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public virtual string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Source" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : string with get, set" Usage="System.Exception.Source" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.Source</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt den Namen der Anwendung oder des Objekts zurück, die bzw. das den Fehler verursacht hat, oder legt diesen fest.</summary>
        <value>Der Name der Anwendung oder des Objekts, die bzw. das den Fehler verursacht hat.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Exception.Source%2A> Eigenschaft nicht explizit festgelegt wurde, die Laufzeit automatisch wird auf den Namen der Assembly, in dem die Ausnahme stammt.  
  
   
  
## Examples  
 Das folgende Beispiel löst eine `Exception` festlegt, die die `Source` Eigenschaft in den Konstruktor und fängt die Ausnahme und zeigt dann `Source`.  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das Objekt muss ein <see cref="N:System.Reflection" />-Laufzeitobjekt sein.</exception>
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public virtual string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Exception.StackTrace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StackTrace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ StackTrace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StackTrace : string" Usage="System.Exception.StackTrace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.StackTrace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Zeichenfolgendarstellung der unmittelbaren Frames in der Aufrufliste ab.</summary>
        <value>Eine Zeichenfolge, die die unmittelbaren Frames der Aufrufliste beschreibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Ausführungsstapel verfolgt alle Methoden, die zu einem angegebenen Zeitpunkt gerade ausgeführt werden. Ein Überwachungsprotokoll der Methodenaufrufe wird als Stapelüberwachung bezeichnet. Die Stapel-Trace-Auflistung bietet eine Möglichkeit, befolgen die Aufrufliste die Nummer der Zeile in der Methode, wo die Ausnahme auftritt.  
  
 Die <xref:System.Exception.StackTrace%2A> Eigenschaft zurückgibt, die Frames der Aufrufliste, die am Speicherort stammen, in dem die Ausnahme ausgelöst wurde. Sie erhalten Informationen zu zusätzlichen Frames in der Aufrufliste, indem Sie erstellen eine neue Instanz der dem <xref:System.Diagnostics.StackTrace?displayProperty=nameWithType> -Klasse und verwenden dessen <xref:System.Diagnostics.StackTrace.ToString%2A?displayProperty=nameWithType> Methode.  
  
 Die common Language Runtime (CLR) aktualisiert die stapelüberwachung, wenn im Code eine Ausnahme ausgelöst wird (mithilfe der `throw` Schlüsselwort). Wenn die Ausnahme in einer Methode erneut, die unterscheidet sich von der Methode ausgelöst wurde, in dem sie ursprünglich ausgelöst wurde, enthält die stapelüberwachung auf, den Speicherort in der Methode, in dem die Ausnahme ursprünglich ausgelöst wurde, und den Speicherort in der Methode, in dem die Ausnahme war erneut ausgelöst. Wenn die Ausnahme ausgelöst wird, und später erneut ausgelöst, in der gleichen Methode enthält die stapelüberwachung nur den Speicherort, in dem die Ausnahme erneut ausgelöst wurde, und umfasst nicht den Speicherort, in dem die Ausnahme ursprünglich ausgelöst wurde.  
  
 Die <xref:System.Exception.StackTrace%2A> Eigenschaft melden möglicherweise nicht so viele Methodenaufrufe erwartungsgemäß da der Code, z. B. Inlining, dem Kompromiss, die auftreten, während der Optimierung.  
  
   
  
## Examples  
 Im folgenden Codebeispiel Beispiel löst eine `Exception` abgefangen und zeigt einen Stapel datenzugriffsablaufverfolgung unter Verwendung der `StackTrace` Eigenschaft.  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Die <see langword="StackTrace" /> in Klassen, die Kontrolle über den Stapel-Trace-Inhalt oder das Format erfordern Eigenschaft überschrieben wird.  
  
Standardmäßig wird die stapelüberwachung erfasst, unmittelbar bevor ein Ausnahmeobjekt ausgelöst wird. Verwendung <see cref="P:System.Environment.StackTrace" /> um Stapelüberwachungsinformationen zu erhalten, wenn keine Ausnahme ausgelöst wird.</para>
        </block>
        <altmember cref="P:System.Environment.StackTrace" />
      </Docs>
    </Member>
    <Member MemberName="TargetSite">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodBase TargetSite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase TargetSite" />
      <MemberSignature Language="DocId" Value="P:System.Exception.TargetSite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetSite As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodBase ^ TargetSite { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetSite : System.Reflection.MethodBase" Usage="System.Exception.TargetSite" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.TargetSite</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Methode ab, die die aktuelle Ausnahme auslöst.</summary>
        <value>Die <see cref="T:System.Reflection.MethodBase" />, die die aktuelle Ausnahme ausgelöst hat.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Methode, die diese Ausnahme auslöst, nicht verfügbar ist, und die stapelüberwachung kein null-Verweis ist (`Nothing` in Visual Basic), <xref:System.Exception.TargetSite%2A> erhält die Methode von der stapelüberwachung. Wenn die Stapelüberwachung ein NULL-Verweis ist, gibt <xref:System.Exception.TargetSite%2A> ebenfalls einen NULL-Verweis zurück.  
  
> [!NOTE]
>  Die <xref:System.Exception.TargetSite%2A> Eigenschaft eventuell nicht genau den Namen der Methode in der eine Ausnahme ausgelöst wurde, wenn der Ausnahmehandler eine Ausnahme über Anwendungsdomänengrenzen hinweg behandelt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel Beispiel löst eine `Exception` abgefangen und zeigt an, die ursprüngliche Methode mithilfe der `TargetSite` Eigenschaft.  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="exception.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine Zeichenfolgendarstellung der aktuellen Ausnahme und gibt diese zurück.</summary>
        <returns>Eine Zeichenfolgendarstellung der aktuellen Ausnahme.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Exception.ToString%2A> Gibt eine Darstellung der aktuellen Ausnahme, die Personen verständlich sein soll. Das die Ausnahme kulturabhängige Daten enthält, wird die Zeichenfolgendarstellung von zurückgegebenen `ToString` ist erforderlich, um die aktuelle Systemkultur berücksichtigt. Es gibt, zwar keine genauen Anforderungen für das Format der zurückgegebenen Zeichenfolge sollte es der Wert des Objekts als vom Benutzer wahrgenommene wider.  
  
 Die standardmäßige Implementierung des <xref:System.Exception.ToString%2A> erhält den Namen der Klasse, die ausgelöst wird, der die aktuelle Ausnahme, die die Nachricht, die das Ergebnis des Aufrufs <xref:System.Exception.ToString%2A> auf die innere Ausnahme und das Ergebnis des Aufrufs <xref:System.Environment.StackTrace%2A?displayProperty=nameWithType>. Wenn einer dieser Member ist `null`, dessen Wert nicht in der zurückgegebenen Zeichenfolge enthalten ist.  
  
 Wenn es keine Fehlermeldung angezeigt wird, oder wenn es sich um eine leere Zeichenfolge ist (""), wird keine Fehlermeldung zurückgegeben. Der Namen der inneren Ausnahme und stapelüberwachung werden nur zurückgegeben, wenn dies nicht der Fall `null`.  
  
 Diese Methode überschreibt <xref:System.Object.ToString%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Ausnahme und zeigt das Ergebnis des Aufrufs <xref:System.Exception.ToString%2A> für die Ausnahme ausgegeben. Beachten Sie, dass die <xref:System.Exception.ToString%2A?displayProperty=nameWithType> Methode wird implizit aufgerufen, wenn die Ausnahme-Klasseninstanz in der Argumentliste angezeigt wird der <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> Methode.  
  
 [!code-cpp[System.Exception.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.exception.tostring/cpp/ToStringEx1.cpp#1)]
 [!code-csharp[System.Exception.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.tostring/cs/ToStringEx1.cs#1)]
 [!code-vb[System.Exception.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.tostring/vb/ToStringEx1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>