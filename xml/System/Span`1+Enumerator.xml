<Type Name="Span&lt;T&gt;+Enumerator" FullName="System.Span&lt;T&gt;+Enumerator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="469ed8e0801c9371e32db2c9dbf6d628854d8825" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/13/2018" />
    <Meta Name="ms.locfileid" Value="35417120" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Span&lt;T&gt;.Enumerator" />
  <TypeSignature Language="ILAsm" Value=".class nested public sequential ansi sealed beforefieldinit Span`1/Enumerator&lt;T&gt; extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.Span`1.Enumerator" />
  <TypeSignature Language="VB.NET" Value="Public Structure Span(Of T).Enumerator" />
  <TypeSignature Language="C++ CLI" Value="public: value class Span&lt;T&gt;::Enumerator" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.IsByRefLike</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt einen Enumerator für diese Elemente eines <see cref="T:System.Span`1" />-Elements bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  

Die C#- [Foreach](~/docs/csharp/language-reference/keywords/foreach-in.md) der C#-Sprache und die [für jede... Nächste](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md) Konstrukt in Visual Basic verbirgt die Komplexität der Enumeratoren. Direkt und den Enumerator nicht, mit `foreach` oder `For Each...Next` wird empfohlen. 

Zu Beginn wird der Enumerator vor das erste Element in der <xref:System.Span%601>. An dieser Position ist <xref:System.Span%601.Enumerator.Current> nicht definiert. Rufen Sie <xref:System.Span%601.Enumerator.MoveNext%2A> um den Enumerator auf das erste Element in der <xref:System.Span%601> vor dem Lesen des Werts von <xref:System.Span%601.Enumerator.Current>.

<xref:System.Span%601.Enumerator.Current> Gibt den gleichen Wert bis <xref:System.Span%601.Enumerator.MoveNext%2A> aufgerufen wird. <xref:System.Span%601.Enumerator.MoveNext%2A> Legt <xref:System.Span%601.Enumerator.Current> zum nächsten Element in der <xref:System.Span%601>.

Wenn <xref:System.Span%601.Enumerator.MoveNext%2A> übergibt am Ende der <xref:System.Span%601>, <xref:System.Span%601.Enumerator.MoveNext%2A> gibt `false`. Wenn der Enumerator ist an diesem Status nachfolgende Aufrufe von <xref:System.Span%601.Enumerator.MoveNext%2A> auch zurückgeben `false` und <xref:System.Span%601.Enumerator.Current> ist nicht definiert. Sie können nicht festgelegt <xref:System.Span%601.Enumerator.Current> auf das erste Element in der <xref:System.Span%601> erneut; Sie müssen eine neue Enumeratorinstanz erstellen. 

Der Enumerator hat keinen exklusiven Zugriff auf die <xref:System.Span%601>. Darüber hinaus können auch die zugrunde liegenden Daten, die auf denen die Spanne basiert geändert werden. Aus diesem Grund ist die aufzählen durch eine Spanne systemintern kein threadsicheres Verfahren. Um während der Enumeration Threadsicherheit zu gewährleisten, müssen Sie eine eigene Synchronisierung implementieren. Der folgende Code wurde z. B. eine Racebedingung. Es wird nicht sichergestellt, dass die Spanne vor dem aufgezählt werden die `ClearContents` Methode ausgeführt wird. Daher wird das zugrunde liegende Array während der Enumeration der Spanne gelöscht:

[!code-csharp[System.Span<T>.Enumerator-no-synchronization](~/samples/snippets/csharp/api/system/span.enumerator/nosync/program.cs)]

Wenn der Zugriff auf das Array zu synchronisieren, bevor die Spanne, als die überarbeitete Version Auflisten der `EnumerateSpan` Methode im folgenden Beispiel wird die `ClearContents` Methode nicht ändern, die zugrunde liegende Spanne Daten während der Enumeration. Beachten Sie, dass im Beispiel wird das zugrunde liegende Array Sperren auf dem die Spanne basiert.  

[!code-csharp[System.Span<T>.Enumerator-no-synchronization](~/samples/snippets/csharp/api/system/span.enumerator/sync/program.cs#1)]

Im Gegensatz zu einigen anderen Enumerator Strukturen in .NET die <xref:System.Span%601.Enumerator>:

- Implementiert nicht die <xref:System.Collections.IEnumerator> oder <xref:System.Collections.Generic.IEnumerator%601> Schnittstelle. Grund hierfür ist, <xref:System.Span%601.Enumerator> ist ein [Verweisstruktur](~/docs/csharp/reference-semantics-with-value-types.md#ref-struct-type).

- Enthält keine `Reset` -Methode, die den Enumerator auf seine anfängliche Position vor dem ersten Element im Bereich festlegen kann. (Die <xref:System.Collections.IEnumerator.Reset?displayProperty=nameWithType> Methode muss als Teil der Schnittstelle implementiert werden, aber die meisten in einer Implementierung eine Ausnahme auslöst oder keine Implementierung bereitstellen.) 
 
      ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public T Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Current" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Enumerator.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T % Current { T % get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T@</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Verweis auf das Element an der aktuellen Position des Enumerators ab.</summary>
        <value>Das Element in der <see cref="T:System.Span`1" /> an der aktuellen Position des Enumerators.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

`Current` unter einem der folgenden Bedingungen ist nicht definiert werden: 

- Unmittelbar nach dem Erstellen des Enumerators wird der Enumerator vor das erste Element im Bereich positioniert. <xref:System.Span%601.Enumerator.MoveNext%2A> muss aufgerufen werden, um den Enumerator auf das erste Element der Spanne vor dem Lesen des Werts von `Current`.

- Der letzte Aufruf von <xref:System.Span%601.Enumerator.MoveNext%2A> zurückgegebene `false`, gibt das Ende der Spanne an. 

`Current` Gibt den gleichen Wert bis <xref:System.Span%601.Enumerator.MoveNext%2A> aufgerufen wird. <xref:System.Span%601.Enumerator.MoveNext%2A> Legt `Current` zum nächsten Element in der Spanne. 

      ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Enumerator.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool MoveNext();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legt den Enumerator auf das nächste Element von <see cref="System.Span`1" /> fest.</summary>
        <returns>TRUE, wenn der Enumerator erfolgreich auf das nächste Element festgelegt wurde; FALSE, wenn das Ende des Span-Elements überschritten wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Nach der Erstellung eines Enumerators vor das erste Element in die Spanne, und der erste Aufruf von positioniert `MoveNext` setzt den Enumerator auf das erste Element in der Spanne. 

Wenn `MoveNext` übergibt das Ende der Spanne `MoveNext` gibt `false`. Wenn der Enumerator ist an diesem Status nachfolgende Aufrufe von `MoveNext` auch zurückgeben `false`.

         ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>