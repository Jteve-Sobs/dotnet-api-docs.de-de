<Type Name="MathF" FullName="System.MathF">
  <Metadata><Meta Name="ms.openlocfilehash" Value="bf0fdf8276ae10620bad74c5b2f3bdc37fa9f2df" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75172634" /></Metadata><TypeSignature Language="C#" Value="public static class MathF" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit MathF extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.MathF" />
  <TypeSignature Language="VB.NET" Value="Public Class MathF" />
  <TypeSignature Language="C++ CLI" Value="public ref class MathF abstract sealed" />
  <TypeSignature Language="F#" Value="type MathF = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="50d2c-101">Stellt Konstanten und statische Methoden für trigonometrische, logarithmische und andere gebräuchliche mathematische Funktionen bereit.</span><span class="sxs-lookup"><span data-stu-id="50d2c-101">Provides constants and static methods for trigonometric, logarithmic, and other common mathematical functions.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  

<span data-ttu-id="50d2c-102">Die statischen Felder und Methoden der `MathF`-Klasse entsprechen denen der <xref:System.Math>-Klasse, mit dem Unterschied, dass Ihre Parameter vom Typ <xref:System.Single> und nicht von <xref:System.Double>sind und <xref:System.Single> nicht <xref:System.Double> Werte zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="50d2c-102">The static fields and methods of the `MathF` class correspond to those of the <xref:System.Math> class, except that their parameters are of type <xref:System.Single> rather than <xref:System.Double>, and they return <xref:System.Single> rather than <xref:System.Double> values.</span></span>

         ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static float Abs (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Abs(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Abs(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Abs(float x);" />
      <MemberSignature Language="F#" Value="static member Abs : single -&gt; single" Usage="System.MathF.Abs x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-103">Eine Zahl, die größer oder gleich <see cref="F:System.Single.MinValue" />, aber kleiner oder gleich <see cref="F:System.Single.MaxValue" /> ist.</span><span class="sxs-lookup"><span data-stu-id="50d2c-103">A number that is greater than or equal to <see cref="F:System.Single.MinValue" />, but less than or equal to <see cref="F:System.Single.MaxValue" />.</span></span></param>
        <summary><span data-ttu-id="50d2c-104">Gibt den absoluten Wert einer Gleitkommazahl mit einfacher Genauigkeit zurück.</span><span class="sxs-lookup"><span data-stu-id="50d2c-104">Returns the absolute value of a single-precision floating-point number.</span></span></summary>
        <returns><span data-ttu-id="50d2c-105">Eine Gleitkommazahl x mit einfacher Genauigkeit im Bereich 0 ≤ x ≤ <see cref="F:System.Single.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="50d2c-105">A single-precision floating-point number, x, such that 0 ≤ x ≤ <see cref="F:System.Single.MaxValue" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50d2c-106">Der absolute Wert eines <xref:System.Single> ist sein numerischer Wert ohne Vorzeichen.</span><span class="sxs-lookup"><span data-stu-id="50d2c-106">The absolute value of a <xref:System.Single> is its numeric value without its sign.</span></span> <span data-ttu-id="50d2c-107">Beispielsweise ist der absolute Wert von 1.2 e-03 und-1.2 E03 1.2 E03.</span><span class="sxs-lookup"><span data-stu-id="50d2c-107">For example, the absolute value of both 1.2e-03 and -1.2e03 is 1.2e03.</span></span>  
  
 <span data-ttu-id="50d2c-108">Wenn `x` gleich <xref:System.Single.NegativeInfinity> oder <xref:System.Single.PositiveInfinity>ist, wird der Rückgabewert <xref:System.Single.PositiveInfinity>.</span><span class="sxs-lookup"><span data-stu-id="50d2c-108">If `x` is equal to <xref:System.Single.NegativeInfinity> or <xref:System.Single.PositiveInfinity>, the return value is <xref:System.Single.PositiveInfinity>.</span></span> <span data-ttu-id="50d2c-109">Wenn `x` gleich <xref:System.Single.NaN>ist, wird der Rückgabewert <xref:System.Single.NaN>.</span><span class="sxs-lookup"><span data-stu-id="50d2c-109">If `x` is equal to <xref:System.Single.NaN>, the return value is <xref:System.Single.NaN>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Acos">
      <MemberSignature Language="C#" Value="public static float Acos (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Acos(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Acos(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acos (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Acos(float x);" />
      <MemberSignature Language="F#" Value="static member Acos : single -&gt; single" Usage="System.MathF.Acos x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-110">Eine Zahl, die einen Kosinus darstellt, wobei <paramref name="x" /> größer oder gleich -1, aber kleiner oder gleich 1 sein muss.</span><span class="sxs-lookup"><span data-stu-id="50d2c-110">A number representing a cosine, where <paramref name="x" /> must be greater than or equal to -1, but less than or equal to 1.</span></span></param>
        <summary><span data-ttu-id="50d2c-111">Gibt einen Winkel zurück, dessen Kosinus die angegebene Zahl ist.</span><span class="sxs-lookup"><span data-stu-id="50d2c-111">Returns the angle whose cosine is the specified number.</span></span></summary>
        <returns><span data-ttu-id="50d2c-112">Ein Winkel (θ) im Bogenmaß im Bereich 0 ≤ θ ≤ π.</span><span class="sxs-lookup"><span data-stu-id="50d2c-112">An angle, θ, measured in radians, such that 0 ≤ θ ≤ π.</span></span>
  
<span data-ttu-id="50d2c-113">- oder -</span><span class="sxs-lookup"><span data-stu-id="50d2c-113">-or-</span></span> 
 <span data-ttu-id="50d2c-114"><see cref="F:System.Single.NaN" />, wenn <paramref name="x" /> &lt; –1 oder <paramref name="x" /> &gt; 1 oder <paramref name="x" /> gleich <see cref="F:System.Single.NaN" /> ist.</span><span class="sxs-lookup"><span data-stu-id="50d2c-114"><see cref="F:System.Single.NaN" /> if <paramref name="x" /> &lt; -1 or <paramref name="x" /> &gt; 1 or <paramref name="x" /> equals <see cref="F:System.Single.NaN" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50d2c-115">Multiplizieren Sie den Rückgabewert mit 180/<xref:System.MathF.PI?displayProperty=nameWithType>, um von Bogenmaß in Grad zu konvertieren.</span><span class="sxs-lookup"><span data-stu-id="50d2c-115">Multiply the return value by 180/<xref:System.MathF.PI?displayProperty=nameWithType> to convert from radians to degrees.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Acosh">
      <MemberSignature Language="C#" Value="public static float Acosh (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Acosh(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Acosh(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acosh (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Acosh(float x);" />
      <MemberSignature Language="F#" Value="static member Acosh : single -&gt; single" Usage="System.MathF.Acosh x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-116">Eine Zahl, die einen hyperbolischen Kosinus darstellt, wobei <paramref name="x" /> größer oder gleich 1, aber kleiner oder gleich <see cref="F:System.Single.PositiveInfinity" /> sein muss.</span><span class="sxs-lookup"><span data-stu-id="50d2c-116">A number representing a hyperbolic cosine, where <paramref name="x" /> must be greater than or equal to 1, but less than or equal to <see cref="F:System.Single.PositiveInfinity" />.</span></span></param>
        <summary><span data-ttu-id="50d2c-117">Gibt den Winkel zurück, dessen hyperbolischer Kosinus die angegebene Zahl ist.</span><span class="sxs-lookup"><span data-stu-id="50d2c-117">Returns the angle whose hyperbolic cosine is the specified number.</span></span></summary>
        <returns><span data-ttu-id="50d2c-118">Ein Winkel (θ) im Bogenmaß im Bereich 0 ≤ θ ≤ ∞.</span><span class="sxs-lookup"><span data-stu-id="50d2c-118">An angle, θ, measured in radians, such that 0 ≤ θ ≤ ∞.</span></span>
  
<span data-ttu-id="50d2c-119">- oder -</span><span class="sxs-lookup"><span data-stu-id="50d2c-119">-or-</span></span> 
 <span data-ttu-id="50d2c-120"><see cref="F:System.Single.NaN" /> wenn <paramref name="x" /> &lt; 1 oder <paramref name="x" /> gleich <see cref="F:System.Single.NaN" />.</span><span class="sxs-lookup"><span data-stu-id="50d2c-120"><see cref="F:System.Single.NaN" /> if <paramref name="x" /> &lt; 1 or <paramref name="x" /> equals <see cref="F:System.Single.NaN" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50d2c-121">Multiplizieren Sie den Rückgabewert mit 180/<xref:System.MathF.PI?displayProperty=nameWithType>, um von Bogenmaß in Grad zu konvertieren.</span><span class="sxs-lookup"><span data-stu-id="50d2c-121">Multiply the return value by 180/<xref:System.MathF.PI?displayProperty=nameWithType> to convert from radians to degrees.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Asin">
      <MemberSignature Language="C#" Value="public static float Asin (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Asin(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Asin(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asin (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Asin(float x);" />
      <MemberSignature Language="F#" Value="static member Asin : single -&gt; single" Usage="System.MathF.Asin x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-122">Eine Zahl, die einen Sinus darstellt, wobei <paramref name="x" /> größer oder gleich -1, aber kleiner oder gleich 1 sein muss.</span><span class="sxs-lookup"><span data-stu-id="50d2c-122">A number representing a sine, where <paramref name="x" /> must be greater than or equal to -1, but less than or equal to 1.</span></span></param>
        <summary><span data-ttu-id="50d2c-123">Gibt einen Winkel zurück, dessen Sinus die angegebene Zahl ist.</span><span class="sxs-lookup"><span data-stu-id="50d2c-123">Returns the angle whose sine is the specified number.</span></span></summary>
        <returns><span data-ttu-id="50d2c-124">Ein Winkel (θ) im Bogenmaß im Bereich -π/2 ≤ θ ≤ π/2.</span><span class="sxs-lookup"><span data-stu-id="50d2c-124">An angle, θ, measured in radians, such that -π/2 ≤ θ ≤ π/2.</span></span>
  
<span data-ttu-id="50d2c-125">- oder -</span><span class="sxs-lookup"><span data-stu-id="50d2c-125">-or-</span></span> 
 <span data-ttu-id="50d2c-126"><see cref="F:System.Single.NaN" />, wenn <paramref name="x" /> &lt; –1 oder <paramref name="x" /> &gt; 1 oder <paramref name="x" /> gleich <see cref="F:System.Single.NaN" /> ist.</span><span class="sxs-lookup"><span data-stu-id="50d2c-126"><see cref="F:System.Single.NaN" /> if <paramref name="x" /> &lt; -1 or <paramref name="x" /> &gt; 1 or <paramref name="x" /> equals <see cref="F:System.Single.NaN" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50d2c-127">Ein positiver Rückgabewert stellt einen Winkel gegen den Uhrzeigersinn von der x-Achse aus dar. ein negativer Rückgabewert stellt einen Winkel im Uhrzeigersinn dar.</span><span class="sxs-lookup"><span data-stu-id="50d2c-127">A positive return value represents a counterclockwise angle from the x-axis; a negative return value represents a clockwise angle.</span></span>  
  
 <span data-ttu-id="50d2c-128">Multiplizieren Sie den Rückgabewert mit 180/<xref:System.MathF.PI?displayProperty=nameWithType>, um von Bogenmaß in Grad zu konvertieren.</span><span class="sxs-lookup"><span data-stu-id="50d2c-128">Multiply the return value by 180/<xref:System.MathF.PI?displayProperty=nameWithType> to convert from radians to degrees.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Asinh">
      <MemberSignature Language="C#" Value="public static float Asinh (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Asinh(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Asinh(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asinh (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Asinh(float x);" />
      <MemberSignature Language="F#" Value="static member Asinh : single -&gt; single" Usage="System.MathF.Asinh x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-129">Eine Zahl, die einen hyperbolischen Sinus darstellt, wobei <paramref name="x" /> größer oder gleich <see cref="F:System.Single.NegativeInfinity" />, aber kleiner oder gleich <see cref="F:System.Single.PositiveInfinity" /> sein muss.</span><span class="sxs-lookup"><span data-stu-id="50d2c-129">A number representing a hyperbolic sine, where <paramref name="x" /> must be greater than or equal to <see cref="F:System.Single.NegativeInfinity" />, but less than or equal to <see cref="F:System.Single.PositiveInfinity" />.</span></span></param>
        <summary><span data-ttu-id="50d2c-130">Gibt den Winkel zurück, dessen hyperbolischer Sinus die angegebene Zahl ist.</span><span class="sxs-lookup"><span data-stu-id="50d2c-130">Returns the angle whose hyperbolic sine is the specified number.</span></span></summary>
        <returns><span data-ttu-id="50d2c-131">Ein Winkel (θ) im Bogenmaß sodass -∞ &lt; θ ≤ -1, oder 1 ≤ θ &lt; ∞.</span><span class="sxs-lookup"><span data-stu-id="50d2c-131">An angle, θ, measured in radians, such that -∞ &lt; θ ≤ -1, or 1 ≤ θ &lt; ∞.</span></span> 
  
<span data-ttu-id="50d2c-132">- oder -</span><span class="sxs-lookup"><span data-stu-id="50d2c-132">-or-</span></span> 
 <span data-ttu-id="50d2c-133"><see cref="F:System.Single.NaN" /> wenn <paramref name="x" /> gleich <see cref="F:System.Single.NaN" />.</span><span class="sxs-lookup"><span data-stu-id="50d2c-133"><see cref="F:System.Single.NaN" /> if <paramref name="x" /> equals <see cref="F:System.Single.NaN" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50d2c-134">Multiplizieren Sie den Rückgabewert mit 180/<xref:System.MathF.PI?displayProperty=nameWithType>, um von Bogenmaß in Grad zu konvertieren.</span><span class="sxs-lookup"><span data-stu-id="50d2c-134">Multiply the return value by 180/<xref:System.MathF.PI?displayProperty=nameWithType> to convert from radians to degrees.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan">
      <MemberSignature Language="C#" Value="public static float Atan (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Atan(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Atan(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Atan(float x);" />
      <MemberSignature Language="F#" Value="static member Atan : single -&gt; single" Usage="System.MathF.Atan x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-135">Eine Zahl, die einen Tangens darstellt.</span><span class="sxs-lookup"><span data-stu-id="50d2c-135">A number representing a tangent.</span></span></param>
        <summary><span data-ttu-id="50d2c-136">Gibt einen Winkel zurück, dessen Tangens die angegebene Zahl ist.</span><span class="sxs-lookup"><span data-stu-id="50d2c-136">Returns the angle whose tangent is the specified number.</span></span></summary>
        <returns><span data-ttu-id="50d2c-137">Ein Winkel (θ) im Bogenmaß im Bereich -π/2 ≤ θ ≤ π/2.</span><span class="sxs-lookup"><span data-stu-id="50d2c-137">An angle, θ, measured in radians, such that -π/2 ≤ θ ≤ π/2.</span></span>  
  
<span data-ttu-id="50d2c-138">- oder -</span><span class="sxs-lookup"><span data-stu-id="50d2c-138">-or-</span></span> 
 <span data-ttu-id="50d2c-139"><see cref="F:System.Single.NaN" />, wenn <paramref name="x" /> gleich <see cref="F:System.Single.NaN" /> ist, –π/2 auf doppelte Genauigkeit gerundet (–1,5707963267949), wenn <paramref name="x" /> gleich <see cref="F:System.Single.NegativeInfinity" /> ist oder π/2 auf doppelte Genauigkeit gerundet (1,5707963267949), wenn <paramref name="x" /> gleich <see cref="F:System.Single.PositiveInfinity" /> ist.</span><span class="sxs-lookup"><span data-stu-id="50d2c-139"><see cref="F:System.Single.NaN" /> if <paramref name="x" /> equals <see cref="F:System.Single.NaN" />, -π/2 rounded to double precision (-1.5707963267949) if <paramref name="x" /> equals <see cref="F:System.Single.NegativeInfinity" />, or π/2 rounded to double precision (1.5707963267949) if <paramref name="x" /> equals <see cref="F:System.Single.PositiveInfinity" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50d2c-140">Ein positiver Rückgabewert stellt einen Winkel gegen den Uhrzeigersinn von der x-Achse aus dar. ein negativer Rückgabewert stellt einen Winkel im Uhrzeigersinn dar.</span><span class="sxs-lookup"><span data-stu-id="50d2c-140">A positive return value represents a counterclockwise angle from the x-axis; a negative return value represents a clockwise angle.</span></span>  
  
 <span data-ttu-id="50d2c-141">Multiplizieren Sie den Rückgabewert mit 180/<xref:System.MathF.PI?displayProperty=nameWithType>, um von Bogenmaß in Grad zu konvertieren.</span><span class="sxs-lookup"><span data-stu-id="50d2c-141">Multiply the return value by 180/<xref:System.MathF.PI?displayProperty=nameWithType> to convert from radians to degrees.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan2">
      <MemberSignature Language="C#" Value="public static float Atan2 (float y, float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Atan2(float32 y, float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Atan2(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan2 (y As Single, x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Atan2(float y, float x);" />
      <MemberSignature Language="F#" Value="static member Atan2 : single * single -&gt; single" Usage="System.MathF.Atan2 (y, x)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="y"><span data-ttu-id="50d2c-142">Die y-Koordinate eines Punkts.</span><span class="sxs-lookup"><span data-stu-id="50d2c-142">The y coordinate of a point.</span></span></param>
        <param name="x"><span data-ttu-id="50d2c-143">Die x-Koordinate eines Punkts.</span><span class="sxs-lookup"><span data-stu-id="50d2c-143">The x coordinate of a point.</span></span></param>
        <summary><span data-ttu-id="50d2c-144">Gibt einen Winkel zurück, dessen Tangens der Quotient zweier angegebener Zahlen ist.</span><span class="sxs-lookup"><span data-stu-id="50d2c-144">Returns the angle whose tangent is the quotient of two specified numbers.</span></span></summary>
        <returns><span data-ttu-id="50d2c-145">Ein Winkel (θ) im Bogenmaß im Bereich –π ≤ θ ≤ π, und tan(θ) = <paramref name="y" /> / <paramref name="x" />, wobei (<paramref name="x" />, <paramref name="y" />) einen Punkt in der kartesischen Ebene darstellt.</span><span class="sxs-lookup"><span data-stu-id="50d2c-145">An angle, θ, measured in radians, such that -π ≤ θ ≤ π, and tan(θ) = <paramref name="y" /> / <paramref name="x" />, where (<paramref name="x" />, <paramref name="y" />) is a point in the Cartesian plane.</span></span> <span data-ttu-id="50d2c-146">Beachten Sie dabei:</span><span class="sxs-lookup"><span data-stu-id="50d2c-146">Observe the following:</span></span> 
<span data-ttu-id="50d2c-147">–   Wenn (<paramref name="x" />, <paramref name="y" />) im 1. Quadranten liegt, gilt 0 &lt; θ &lt; π/2.</span><span class="sxs-lookup"><span data-stu-id="50d2c-147">-   For (<paramref name="x" />, <paramref name="y" />) in quadrant 1, 0 &lt; θ &lt; π/2.</span></span>  
  
<span data-ttu-id="50d2c-148">–   Wenn (<paramref name="x" />, <paramref name="y" />) im 2. Quadranten liegt, gilt π/2 &lt; θ ≤ π.</span><span class="sxs-lookup"><span data-stu-id="50d2c-148">-   For (<paramref name="x" />, <paramref name="y" />) in quadrant 2, π/2 &lt; θ ≤ π.</span></span>  
  
<span data-ttu-id="50d2c-149">–   Wenn (<paramref name="x" />, <paramref name="y" />) im 3. Quadranten liegt, gilt –π &lt; θ &lt; –π/2.</span><span class="sxs-lookup"><span data-stu-id="50d2c-149">-   For (<paramref name="x" />, <paramref name="y" />) in quadrant 3, -π &lt; θ &lt; -π/2.</span></span>  
  
<span data-ttu-id="50d2c-150">–   Wenn (<paramref name="x" />, <paramref name="y" />) im 4. Quadranten liegt, gilt –π/2 &lt; θ &lt; 0.</span><span class="sxs-lookup"><span data-stu-id="50d2c-150">-   For (<paramref name="x" />, <paramref name="y" />) in quadrant 4, -π/2 &lt; θ &lt; 0.</span></span>  
  
<span data-ttu-id="50d2c-151">Für Punkte an den Begrenzungen der Quadranten wird der folgende Rückgabewert zurückgegeben:</span><span class="sxs-lookup"><span data-stu-id="50d2c-151">For points on the boundaries of the quadrants, the return value is the following:</span></span> 
<span data-ttu-id="50d2c-152">–   Wenn y gleich 0 und x nicht negativ ist, gilt θ = 0.</span><span class="sxs-lookup"><span data-stu-id="50d2c-152">-   If y is 0 and x is not negative, θ = 0.</span></span>  
  
<span data-ttu-id="50d2c-153">–   Wenn y gleich 0 und x negativ ist, gilt θ = π.</span><span class="sxs-lookup"><span data-stu-id="50d2c-153">-   If y is 0 and x is negative, θ = π.</span></span>  
  
<span data-ttu-id="50d2c-154">–   Wenn y positiv und x gleich 0 ist, gilt θ = π/2.</span><span class="sxs-lookup"><span data-stu-id="50d2c-154">-   If y is positive and x is 0, θ = π/2.</span></span>  
  
<span data-ttu-id="50d2c-155">–   Wenn y negativ ist und x gleich 0 ist, gilt θ = -π/2.</span><span class="sxs-lookup"><span data-stu-id="50d2c-155">-   If y is negative and x is 0, θ = -π/2.</span></span>  
  
<span data-ttu-id="50d2c-156">–   Wenn y gleich 0 ist und x gleich 0 ist, gilt θ = 0.</span><span class="sxs-lookup"><span data-stu-id="50d2c-156">-   If y is 0 and x is 0, θ = 0.</span></span>  
  
<span data-ttu-id="50d2c-157">Wenn <paramref name="x" /> oder <paramref name="y" /> gleich <see cref="F:System.Single.NaN" /> ist oder wenn <paramref name="x" /> und <paramref name="y" /> entweder gleich <see cref="F:System.Single.PositiveInfinity" /> oder gleich <see cref="F:System.Single.NegativeInfinity" /> sind, gibt die Methode <see cref="F:System.Single.NaN" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="50d2c-157">If <paramref name="x" /> or <paramref name="y" /> is <see cref="F:System.Single.NaN" />, or if <paramref name="x" /> and <paramref name="y" /> are either <see cref="F:System.Single.PositiveInfinity" /> or <see cref="F:System.Single.NegativeInfinity" />, the method returns <see cref="F:System.Single.NaN" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50d2c-158">Der Rückgabewert ist der Winkel in der kartesischen Ebene, der durch die x-Achse gebildet wird, und ein Vektor, der mit dem Ursprung beginnt (0,0) und am Punkt endet (x, y).</span><span class="sxs-lookup"><span data-stu-id="50d2c-158">The return value is the angle in the Cartesian plane formed by the x-axis, and a vector starting from the origin, (0,0), and terminating at the point, (x,y).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Atanh">
      <MemberSignature Language="C#" Value="public static float Atanh (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Atanh(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Atanh(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atanh (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Atanh(float x);" />
      <MemberSignature Language="F#" Value="static member Atanh : single -&gt; single" Usage="System.MathF.Atanh x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-159">Eine Zahl, die einen hyperbolischen Tangens darstellt, wobei <paramref name="x" /> größer oder gleich -1, aber kleiner oder gleich 1 sein muss.</span><span class="sxs-lookup"><span data-stu-id="50d2c-159">A number representing a hyperbolic tangent, where <paramref name="x" /> must be greater than or equal to -1, but less than or equal to 1.</span></span></param>
        <summary><span data-ttu-id="50d2c-160">Gibt den Winkel zurück, dessen hyperbolischer Tangens die angegebene Zahl ist.</span><span class="sxs-lookup"><span data-stu-id="50d2c-160">Returns the angle whose hyperbolic tangent is the specified number.</span></span></summary>
        <returns><span data-ttu-id="50d2c-161">Ein Winkel (θ) im Bogenmaß im Bereich -∞ &lt; θ &lt;-1, oder 1 &lt; θ &lt; ∞.</span><span class="sxs-lookup"><span data-stu-id="50d2c-161">An angle, θ, measured in radians, such that -∞ &lt; θ &lt;-1, or 1 &lt; θ &lt; ∞.</span></span>  
  
<span data-ttu-id="50d2c-162">- oder -</span><span class="sxs-lookup"><span data-stu-id="50d2c-162">-or-</span></span> 
 <span data-ttu-id="50d2c-163"><see cref="F:System.Single.NaN" />, wenn <paramref name="x" /> &lt; –1 oder <paramref name="x" /> &gt; 1 oder <paramref name="x" /> gleich <see cref="F:System.Single.NaN" /> ist.</span><span class="sxs-lookup"><span data-stu-id="50d2c-163"><see cref="F:System.Single.NaN" /> if <paramref name="x" /> &lt; -1 or <paramref name="x" /> &gt; 1 or <paramref name="x" /> equals <see cref="F:System.Single.NaN" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50d2c-164">Multiplizieren Sie den Rückgabewert mit 180/<xref:System.MathF.PI?displayProperty=nameWithType>, um von Bogenmaß in Grad zu konvertieren.</span><span class="sxs-lookup"><span data-stu-id="50d2c-164">Multiply the return value by 180/<xref:System.MathF.PI?displayProperty=nameWithType> to convert from radians to degrees.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BitDecrement">
      <MemberSignature Language="C#" Value="public static float BitDecrement (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 BitDecrement(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.BitDecrement(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BitDecrement (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float BitDecrement(float x);" />
      <MemberSignature Language="F#" Value="static member BitDecrement : single -&gt; single" Usage="System.MathF.BitDecrement x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-165">Der zu dekrementierende Wert.</span><span class="sxs-lookup"><span data-stu-id="50d2c-165">The value to decrement.</span></span></param>
        <summary><span data-ttu-id="50d2c-166">Gibt den nächsten kleinsten Wert zurück, der weniger als <paramref name="x" /> vergleicht.</span><span class="sxs-lookup"><span data-stu-id="50d2c-166">Returns the next smallest value that compares less than <paramref name="x" />.</span></span></summary>
        <returns><span data-ttu-id="50d2c-167">Der nächste kleinste Wert, der weniger als <paramref name="x" /> vergleicht.</span><span class="sxs-lookup"><span data-stu-id="50d2c-167">The next smallest value that compares less than <paramref name="x" />.</span></span>
  
<span data-ttu-id="50d2c-168">- oder -</span><span class="sxs-lookup"><span data-stu-id="50d2c-168">-or-</span></span> 
 <span data-ttu-id="50d2c-169"><see cref="F:System.Single.NegativeInfinity" /> wenn <paramref name="x" /> ist gleich <see cref="F:System.Single.NegativeInfinity" />.</span><span class="sxs-lookup"><span data-stu-id="50d2c-169"><see cref="F:System.Single.NegativeInfinity" /> if <paramref name="x" /> is equals <see cref="F:System.Single.NegativeInfinity" />.</span></span>
  
<span data-ttu-id="50d2c-170">- oder -</span><span class="sxs-lookup"><span data-stu-id="50d2c-170">-or-</span></span> 
 <span data-ttu-id="50d2c-171"><see cref="F:System.Single.NaN" /> wenn <paramref name="x" /> gleich <see cref="F:System.Single.NaN" />.</span><span class="sxs-lookup"><span data-stu-id="50d2c-171"><see cref="F:System.Single.NaN" /> if <paramref name="x" /> equals <see cref="F:System.Single.NaN" />.</span></span></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="BitIncrement">
      <MemberSignature Language="C#" Value="public static float BitIncrement (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 BitIncrement(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.BitIncrement(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BitIncrement (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float BitIncrement(float x);" />
      <MemberSignature Language="F#" Value="static member BitIncrement : single -&gt; single" Usage="System.MathF.BitIncrement x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-172">Der zu inkrementierende Wert.</span><span class="sxs-lookup"><span data-stu-id="50d2c-172">The value to increment.</span></span></param>
        <summary><span data-ttu-id="50d2c-173">Gibt den nächsten größten Wert zurück, der größer als <paramref name="x" /> ist.</span><span class="sxs-lookup"><span data-stu-id="50d2c-173">Returns the next largest value that is greater than <paramref name="x" />.</span></span></summary>
        <returns><span data-ttu-id="50d2c-174">Der nächste größte Wert, der größer als <paramref name="x" /> ist.</span><span class="sxs-lookup"><span data-stu-id="50d2c-174">The next largest value that is greater than <paramref name="x" />.</span></span>
  
<span data-ttu-id="50d2c-175">- oder -</span><span class="sxs-lookup"><span data-stu-id="50d2c-175">-or-</span></span> 
 <span data-ttu-id="50d2c-176"><see cref="F:System.Single.PositiveInfinity" /> wenn <paramref name="x" /> gleich <see cref="F:System.Single.PositiveInfinity" />.</span><span class="sxs-lookup"><span data-stu-id="50d2c-176"><see cref="F:System.Single.PositiveInfinity" /> if <paramref name="x" /> equals <see cref="F:System.Single.PositiveInfinity" />.</span></span>
  
<span data-ttu-id="50d2c-177">- oder -</span><span class="sxs-lookup"><span data-stu-id="50d2c-177">-or-</span></span> 
 <span data-ttu-id="50d2c-178"><see cref="F:System.Single.NaN" /> wenn <paramref name="x" /> ist gleich <see cref="F:System.Single.NaN" />.</span><span class="sxs-lookup"><span data-stu-id="50d2c-178"><see cref="F:System.Single.NaN" /> if <paramref name="x" /> is equals <see cref="F:System.Single.NaN" />.</span></span></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Cbrt">
      <MemberSignature Language="C#" Value="public static float Cbrt (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Cbrt(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Cbrt(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cbrt (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Cbrt(float x);" />
      <MemberSignature Language="F#" Value="static member Cbrt : single -&gt; single" Usage="System.MathF.Cbrt x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-179">Die Zahl, deren Kubikwurzel bestimmt werden soll.</span><span class="sxs-lookup"><span data-stu-id="50d2c-179">The number whose cube root is to be found.</span></span></param>
        <summary><span data-ttu-id="50d2c-180">Gibt die Kubikwurzel einer angegebenen Zahl zurück.</span><span class="sxs-lookup"><span data-stu-id="50d2c-180">Returns the cube root of a specified number.</span></span></summary>
        <returns><span data-ttu-id="50d2c-181">Die Kubikwurzel von <paramref name="x" />.</span><span class="sxs-lookup"><span data-stu-id="50d2c-181">The cube root of <paramref name="x" />.</span></span>
  
<span data-ttu-id="50d2c-182">- oder -</span><span class="sxs-lookup"><span data-stu-id="50d2c-182">-or-</span></span> 
 <span data-ttu-id="50d2c-183"><see cref="F:System.Single.NaN" /> wenn <paramref name="x" /> ist gleich <see cref="F:System.Single.NaN" />.</span><span class="sxs-lookup"><span data-stu-id="50d2c-183"><see cref="F:System.Single.NaN" /> if <paramref name="x" /> is equals <see cref="F:System.Single.NaN" />.</span></span></returns>
        <remarks></remarks>
        <altmember cref="M:System.MathF.Pow(System.Single,System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Ceiling">
      <MemberSignature Language="C#" Value="public static float Ceiling (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Ceiling(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Ceiling(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Ceiling (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Ceiling(float x);" />
      <MemberSignature Language="F#" Value="static member Ceiling : single -&gt; single" Usage="System.MathF.Ceiling x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-184">Eine Gleitkommazahl mit einfacher Genauigkeit.</span><span class="sxs-lookup"><span data-stu-id="50d2c-184">A single-precision floating-point number.</span></span></param>
        <summary><span data-ttu-id="50d2c-185">Gibt den kleinsten ganzzahligen Wert zurück, der größer oder gleich der angegebenen Gleitkommazahl mit einfacher Genauigkeit ist.</span><span class="sxs-lookup"><span data-stu-id="50d2c-185">Returns the smallest integral value that is greater than or equal to the specified single-precision floating-point number.</span></span></summary>
        <returns><span data-ttu-id="50d2c-186">Der kleinste ganzzahlige Wert, der größer oder gleich <paramref name="x" /> ist.</span><span class="sxs-lookup"><span data-stu-id="50d2c-186">The smallest integral value that is greater than or equal to <paramref name="x" />.</span></span> <span data-ttu-id="50d2c-187">Wenn <paramref name="x" /> gleich <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" /> oder <see cref="F:System.Single.PositiveInfinity" /> ist, wird dieser Wert zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="50d2c-187">If <paramref name="x" /> is equal to <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" />, or <see cref="F:System.Single.PositiveInfinity" />, that value is returned.</span></span> <span data-ttu-id="50d2c-188">Beachten Sie, dass diese Methode einen <see cref="T:System.Single" /> anstelle eines ganzzahligen Typs zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="50d2c-188">Note that this method returns a <see cref="T:System.Single" /> instead of an integral type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50d2c-189">Das Verhalten dieser Methode folgt IEEE Standard 754, Abschnitt 4.</span><span class="sxs-lookup"><span data-stu-id="50d2c-189">The behavior of this method follows IEEE Standard 754, section 4.</span></span> <span data-ttu-id="50d2c-190">Diese Art der Rundung wird manchmal als Rundung in Richtung positiv unendlich bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="50d2c-190">This kind of rounding is sometimes called rounding toward positive infinity.</span></span> <span data-ttu-id="50d2c-191">Anders ausgedrückt: Wenn `x` positiv ist, bewirkt das vorhanden sein einer Bruchteil-Komponente, dass `x` auf die nächsthöhere Ganzzahl gerundet wird.</span><span class="sxs-lookup"><span data-stu-id="50d2c-191">In other words, if `x` is positive, the presence of any fractional component causes `x` to be rounded to the next highest integer.</span></span> <span data-ttu-id="50d2c-192">Wenn `x` negativ ist, bewirkt der Rundungs Vorgang, dass alle Bruchteile von `x` verworfen werden.</span><span class="sxs-lookup"><span data-stu-id="50d2c-192">If `x` is negative, the rounding operation causes any fractional component of `x` to be discarded.</span></span> <span data-ttu-id="50d2c-193">Der Vorgang dieser Methode unterscheidet sich von der <xref:System.MathF.Floor%28System.Single%29>-Methode, die das Runden in Richtung minus unendlich unterstützt.</span><span class="sxs-lookup"><span data-stu-id="50d2c-193">The operation of this method differs from the <xref:System.MathF.Floor%28System.Single%29> method, which supports rounding toward negative infinity.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.MathF.Round" />
        <altmember cref="M:System.MathF.Floor(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="CopySign">
      <MemberSignature Language="C#" Value="public static float CopySign (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 CopySign(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.CopySign(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CopySign (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float CopySign(float x, float y);" />
      <MemberSignature Language="F#" Value="static member CopySign : single * single -&gt; single" Usage="System.MathF.CopySign (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="y" Type="System.Single" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-194">Eine Zahl, deren Betrag im Ergebnis verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="50d2c-194">A number whose magnitude is used in the result.</span></span></param>
        <param name="y"><span data-ttu-id="50d2c-195">Eine Zahl, deren Vorzeichen im Ergebnis verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="50d2c-195">A number whose sign is the used in the result.</span></span></param>
        <summary><span data-ttu-id="50d2c-196">Gibt einen Wert mit dem Betrag <paramref name="x" /> und dem Vorzeichen <paramref name="y" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="50d2c-196">Returns a value with the magnitude of <paramref name="x" /> and the sign of <paramref name="y" />.</span></span></summary>
        <returns><span data-ttu-id="50d2c-197">Ein Wert mit dem Betrag <paramref name="x" /> und dem Vorzeichen <paramref name="y" />.</span><span class="sxs-lookup"><span data-stu-id="50d2c-197">A value with the magnitude of <paramref name="x" /> and the sign of <paramref name="y" />.</span></span></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos">
      <MemberSignature Language="C#" Value="public static float Cos (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Cos(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Cos(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cos (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Cos(float x);" />
      <MemberSignature Language="F#" Value="static member Cos : single -&gt; single" Usage="System.MathF.Cos x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-198">Ein im Bogenmaß angegebener Winkel.</span><span class="sxs-lookup"><span data-stu-id="50d2c-198">An angle, measured in radians.</span></span></param>
        <summary><span data-ttu-id="50d2c-199">Gibt den Kosinus des angegebenen Winkels zurück.</span><span class="sxs-lookup"><span data-stu-id="50d2c-199">Returns the cosine of the specified angle.</span></span></summary>
        <returns><span data-ttu-id="50d2c-200">Der Kosinus von <paramref name="x" />.</span><span class="sxs-lookup"><span data-stu-id="50d2c-200">The cosine of <paramref name="x" />.</span></span> <span data-ttu-id="50d2c-201">Wenn <paramref name="x" /> gleich <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" /> oder <see cref="F:System.Single.PositiveInfinity" /> ist, wird <see cref="F:System.Single.NaN" /> von dieser Methode zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="50d2c-201">If <paramref name="x" /> is equal to <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" />, or <see cref="F:System.Single.PositiveInfinity" />, this method returns <see cref="F:System.Single.NaN" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50d2c-202">Der Winkel, der `x`, muss im Bogenmaße liegen.</span><span class="sxs-lookup"><span data-stu-id="50d2c-202">The angle, `x`, must be in radians.</span></span> <span data-ttu-id="50d2c-203">Multiplizieren Sie <xref:System.MathF.PI?displayProperty=nameWithType>/180, um Grad in Bogenmaß zu konvertieren.</span><span class="sxs-lookup"><span data-stu-id="50d2c-203">Multiply by <xref:System.MathF.PI?displayProperty=nameWithType>/180 to convert degrees to radians.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static float Cosh (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Cosh(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Cosh(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cosh (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Cosh(float x);" />
      <MemberSignature Language="F#" Value="static member Cosh : single -&gt; single" Usage="System.MathF.Cosh x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-204">Ein im Bogenmaß angegebener Winkel.</span><span class="sxs-lookup"><span data-stu-id="50d2c-204">An angle, measured in radians.</span></span></param>
        <summary><span data-ttu-id="50d2c-205">Gibt den Hyperbelkosinus des angegebenen Winkels zurück.</span><span class="sxs-lookup"><span data-stu-id="50d2c-205">Returns the hyperbolic cosine of the specified angle.</span></span></summary>
        <returns><span data-ttu-id="50d2c-206">Der Hyperbelkosinus von <paramref name="x" />.</span><span class="sxs-lookup"><span data-stu-id="50d2c-206">The hyperbolic cosine of <paramref name="x" />.</span></span> <span data-ttu-id="50d2c-207">Wenn <paramref name="x" /> gleich <see cref="F:System.Single.NegativeInfinity" /> oder <see cref="F:System.Single.PositiveInfinity" /> ist, wird <see cref="F:System.Single.PositiveInfinity" /> zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="50d2c-207">If <paramref name="x" /> is equal to <see cref="F:System.Single.NegativeInfinity" /> or <see cref="F:System.Single.PositiveInfinity" />, <see cref="F:System.Single.PositiveInfinity" /> is returned.</span></span> <span data-ttu-id="50d2c-208">Wenn <paramref name="x" /> gleich <see cref="F:System.Single.NaN" /> ist, wird <see cref="F:System.Single.NaN" /> zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="50d2c-208">If <paramref name="x" /> is equal to <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50d2c-209">Der Winkel, der `x`, muss im Bogenmaße liegen.</span><span class="sxs-lookup"><span data-stu-id="50d2c-209">The angle, `x`, must be in radians.</span></span> <span data-ttu-id="50d2c-210">Multiplizieren Sie <xref:System.MathF.PI?displayProperty=nameWithType>/180, um Grad in Bogenmaß zu konvertieren.</span><span class="sxs-lookup"><span data-stu-id="50d2c-210">Multiply by <xref:System.MathF.PI?displayProperty=nameWithType>/180 to convert degrees to radians.</span></span>    
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="E">
      <MemberSignature Language="C#" Value="public const float E = 2.718282;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 E = (2.718282)" />
      <MemberSignature Language="DocId" Value="F:System.MathF.E" />
      <MemberSignature Language="VB.NET" Value="Public Const E As Single  = 2.718282" />
      <MemberSignature Language="C++ CLI" Value="public: float E = 2.718282;" />
      <MemberSignature Language="F#" Value="val mutable E : single" Usage="System.MathF.E" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>2.718282</MemberValue>
      <Docs>
        <summary><span data-ttu-id="50d2c-211">Stellt die Basis des natürlichen Logarithmus durch die Konstante <see langword="e" /> dar.</span><span class="sxs-lookup"><span data-stu-id="50d2c-211">Represents the natural logarithmic base, specified by the constant, <see langword="e" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="50d2c-212">Der Wert dieser Konstante ist 2,71828175.</span><span class="sxs-lookup"><span data-stu-id="50d2c-212">The value of this constant is 2.71828175.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static float Exp (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Exp(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Exp(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Exp(float x);" />
      <MemberSignature Language="F#" Value="static member Exp : single -&gt; single" Usage="System.MathF.Exp x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-213">Eine Zahl, die einen Exponenten angibt.</span><span class="sxs-lookup"><span data-stu-id="50d2c-213">A number specifying a power.</span></span></param>
        <summary><span data-ttu-id="50d2c-214">Gibt den Wert von <see langword="e" /> hoch angegebenem Exponenten zurück.</span><span class="sxs-lookup"><span data-stu-id="50d2c-214">Returns <see langword="e" /> raised to the specified power.</span></span></summary>
        <returns><span data-ttu-id="50d2c-215">Die Zahl <see langword="e" /> hoch <paramref name="x" />.</span><span class="sxs-lookup"><span data-stu-id="50d2c-215">The number <see langword="e" /> raised to the power <paramref name="x" />.</span></span> <span data-ttu-id="50d2c-216">Wenn <paramref name="x" /> gleich <see cref="F:System.Single.NaN" /> oder <see cref="F:System.Single.PositiveInfinity" /> ist, wird dieser Wert zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="50d2c-216">If <paramref name="x" /> equals <see cref="F:System.Single.NaN" /> or <see cref="F:System.Single.PositiveInfinity" />, that value is returned.</span></span> <span data-ttu-id="50d2c-217">Wenn <paramref name="x" /> gleich <see cref="F:System.Single.NegativeInfinity" /> ist, wird 0 zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="50d2c-217">If <paramref name="x" /> equals <see cref="F:System.Single.NegativeInfinity" />, 0 is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50d2c-218">`e` ist eine mathematische Konstante, deren Wert ungefähr 2,71828 ist.</span><span class="sxs-lookup"><span data-stu-id="50d2c-218">`e` is a mathematical constant whose value is approximately 2.71828.</span></span>  
  
 <span data-ttu-id="50d2c-219">Verwenden Sie die <xref:System.MathF.Pow%2A>-Methode, um die Fähigkeiten anderer Basen zu berechnen.</span><span class="sxs-lookup"><span data-stu-id="50d2c-219">Use the <xref:System.MathF.Pow%2A> method to calculate powers of other bases.</span></span>  
  
 <span data-ttu-id="50d2c-220"><xref:System.MathF.Exp%2A> ist die Umkehrung von <xref:System.MathF.Log%2A>.</span><span class="sxs-lookup"><span data-stu-id="50d2c-220"><xref:System.MathF.Exp%2A> is the inverse of <xref:System.MathF.Log%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.MathF.E" />
        <altmember cref="M:System.MathF.Pow(System.Single,System.Single)" />
        <altmember cref="M:System.MathF.Log(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Floor">
      <MemberSignature Language="C#" Value="public static float Floor (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Floor(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Floor(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Floor (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Floor(float x);" />
      <MemberSignature Language="F#" Value="static member Floor : single -&gt; single" Usage="System.MathF.Floor x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-221">Eine Gleitkommazahl mit einfacher Genauigkeit.</span><span class="sxs-lookup"><span data-stu-id="50d2c-221">A single-precision floating-point number.</span></span></param>
        <summary><span data-ttu-id="50d2c-222">Gibt die größte Ganzzahl zurück, die kleiner oder gleich der angegebenen Gleitkommazahl mit einfacher Genauigkeit ist.</span><span class="sxs-lookup"><span data-stu-id="50d2c-222">Returns the largest integral value less than or equal to the specified single-precision floating-point number.</span></span></summary>
        <returns><span data-ttu-id="50d2c-223">Die größte Ganzzahl, die kleiner oder gleich <paramref name="x" /> ist.</span><span class="sxs-lookup"><span data-stu-id="50d2c-223">The largest integral value less than or equal to <paramref name="x" />.</span></span> <span data-ttu-id="50d2c-224">Wenn <paramref name="x" /> gleich <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" /> oder <see cref="F:System.Single.PositiveInfinity" /> ist, wird dieser Wert zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="50d2c-224">If <paramref name="x" /> is equal to <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" />, or <see cref="F:System.Single.PositiveInfinity" />, that value is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50d2c-225">Das Verhalten dieser Methode folgt IEEE Standard 754, Abschnitt 4.</span><span class="sxs-lookup"><span data-stu-id="50d2c-225">The behavior of this method follows IEEE Standard 754, section 4.</span></span> <span data-ttu-id="50d2c-226">Diese Art der Rundung wird manchmal als Rundung in Bezug auf minus unendlich bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="50d2c-226">This kind of rounding is sometimes called rounding toward negative infinity.</span></span> <span data-ttu-id="50d2c-227">Anders ausgedrückt: Wenn `x` positiv ist, wird jede beliebige Bruch Komponente abgeschnitten.</span><span class="sxs-lookup"><span data-stu-id="50d2c-227">In other words, if `x` is positive, any fractional component is truncated.</span></span> <span data-ttu-id="50d2c-228">Wenn `x` negativ ist, bewirkt das vorhanden sein einer Bruchteil-Komponente, dass Sie auf die kleinere ganze Zahl gerundet wird.</span><span class="sxs-lookup"><span data-stu-id="50d2c-228">If `x` is negative, the presence of any fractional component causes it to be rounded to the smaller integer.</span></span> <span data-ttu-id="50d2c-229">Der Vorgang dieser Methode unterscheidet sich von der <xref:System.MathF.Ceiling%2A>-Methode, die das Runden in Richtung positiv unendlich unterstützt.</span><span class="sxs-lookup"><span data-stu-id="50d2c-229">The operation of this method differs from the <xref:System.MathF.Ceiling%2A> method, which supports rounding toward positive infinity.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.MathF.Round" />
        <altmember cref="M:System.MathF.Ceiling(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="FusedMultiplyAdd">
      <MemberSignature Language="C#" Value="public static float FusedMultiplyAdd (float x, float y, float z);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 FusedMultiplyAdd(float32 x, float32 y, float32 z) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.FusedMultiplyAdd(System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FusedMultiplyAdd (x As Single, y As Single, z As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float FusedMultiplyAdd(float x, float y, float z);" />
      <MemberSignature Language="F#" Value="static member FusedMultiplyAdd : single * single * single -&gt; single" Usage="System.MathF.FusedMultiplyAdd (x, y, z)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="y" Type="System.Single" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="z" Type="System.Single" Index="2" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-230">Die Zahl, die mit <paramref name="y" /> multipliziert werden soll.</span><span class="sxs-lookup"><span data-stu-id="50d2c-230">The number to be multiplied with <paramref name="y" />.</span></span></param>
        <param name="y"><span data-ttu-id="50d2c-231">Die Zahl, die mit <paramref name="x" /> multipliziert werden soll.</span><span class="sxs-lookup"><span data-stu-id="50d2c-231">The number to be multiplied with <paramref name="x" />.</span></span></param>
        <param name="z"><span data-ttu-id="50d2c-232">Die Zahl, die zum Ergebnis von <paramref name="x" /> multipliziert mit <paramref name="y" /> addiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="50d2c-232">The number to be added to the result of <paramref name="x" /> multiplied by <paramref name="y" />.</span></span></param>
        <summary><span data-ttu-id="50d2c-233">Gibt (x \* y) + z, gerundet als ternärer Vorgang, zurück.</span><span class="sxs-lookup"><span data-stu-id="50d2c-233">Returns (x \* y) + z, rounded as one ternary operation.</span></span></summary>
        <returns><span data-ttu-id="50d2c-234">(x \* y) + z, gerundet als ternärer Vorgang.</span><span class="sxs-lookup"><span data-stu-id="50d2c-234">(x \* y) + z, rounded as one ternary operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50d2c-235">Dadurch wird `(x * y)` berechnet, als ob die Genauigkeit unbegrenzt ist, `z` zu diesem Ergebnis hinzufügt, wie bei einer unendlichen Genauigkeit, und schließlich auf den nächsten darstellbaren Wert gerundet.</span><span class="sxs-lookup"><span data-stu-id="50d2c-235">This computes `(x * y)` as if to infinite precision, adds `z` to that result as if to infinite precision, and finally rounds to the nearest representable value.</span></span>
  
 <span data-ttu-id="50d2c-236">Dies unterscheidet sich von der nicht-Fused-Sequenz, die `(x * y)` wie eine unendliche Vorversion berechnen würde, das Ergebnis auf den nächstgelegenen darstellbaren Wert gerundet, dem gerundeten Ergebnis "z" hinzufügt, als wäre es zu einer unendlichen Genauigkeit und schließlich auf den nächsten darstellbaren Wert gerundet.</span><span class="sxs-lookup"><span data-stu-id="50d2c-236">This differs from the non-fused sequence which would compute `(x * y)` as if to infinite preicision, round the result to the nearest representable value, add 'z' to the rounded result as if to infinite precision, and finally round to the nearest representable value.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IEEERemainder">
      <MemberSignature Language="C#" Value="public static float IEEERemainder (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 IEEERemainder(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.IEEERemainder(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IEEERemainder (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float IEEERemainder(float x, float y);" />
      <MemberSignature Language="F#" Value="static member IEEERemainder : single * single -&gt; single" Usage="System.MathF.IEEERemainder (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-237">Ein Dividend.</span><span class="sxs-lookup"><span data-stu-id="50d2c-237">A dividend.</span></span></param>
        <param name="y"><span data-ttu-id="50d2c-238">Ein Divisor.</span><span class="sxs-lookup"><span data-stu-id="50d2c-238">A divisor.</span></span></param>
        <summary><span data-ttu-id="50d2c-239">Gibt den Rest der Division zweier angegebener Zahlen zurück.</span><span class="sxs-lookup"><span data-stu-id="50d2c-239">Returns the remainder resulting from the division of a specified number by another specified number.</span></span></summary>
        <returns><span data-ttu-id="50d2c-240">Eine Zahl gleich <paramref name="x" /> – (<paramref name="y" /> Q), wobei Q der auf die nächste ganze Zahl gerundete Quotient von <paramref name="x" /> / <paramref name="y" /> ist (wenn <paramref name="x" /> / <paramref name="y" /> genau in der Mitte zwischen zwei ganzen Zahlen liegt, wird die gerade ganze Zahl zurückgegeben).</span><span class="sxs-lookup"><span data-stu-id="50d2c-240">A number equal to <paramref name="x" /> - (<paramref name="y" /> Q), where Q is the quotient of <paramref name="x" /> / <paramref name="y" /> rounded to the nearest integer (if <paramref name="x" /> / <paramref name="y" /> falls halfway between two integers, the even integer is returned).</span></span>  
  
<span data-ttu-id="50d2c-241">Wenn <paramref name="x" /> - (<paramref name="y" />Q) gleich 0 ist, wird bei positivem <paramref name="x" /> +0 und bei negativem <paramref name="x" /> -0 zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="50d2c-241">If <paramref name="x" /> - (<paramref name="y" /> Q) is zero, the value +0 is returned if <paramref name="x" /> is positive, or -0 if <paramref name="x" /> is negative.</span></span>  
  
<span data-ttu-id="50d2c-242">Wenn <paramref name="y" /> = 0 ist, wird <see cref="F:System.Single.NaN" /> zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="50d2c-242">If <paramref name="y" /> = 0, <see cref="F:System.Single.NaN" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50d2c-243">Dieser Vorgang entspricht dem Rest-Vorgang, der im Abschnitt 5,1 von ANSI/IEEE Std 754-1985 definiert ist. IEEE-Standard für binäre Gleit Komma Arithmetik; Institute of Electrical and Electronics Engineers, Inc. 1985.</span><span class="sxs-lookup"><span data-stu-id="50d2c-243">This operation complies with the remainder operation defined in Section 5.1 of ANSI/IEEE Std 754-1985; IEEE Standard for Binary Floating-Point Arithmetic; Institute of Electrical and Electronics Engineers, Inc; 1985.</span></span>  
  
 <span data-ttu-id="50d2c-244">Die <xref:System.MathF.IEEERemainder%2A>-Methode ist nicht identisch mit dem [Rest-Operator](~/docs/csharp/language-reference/operators/remainder-operator.md).</span><span class="sxs-lookup"><span data-stu-id="50d2c-244">The <xref:System.MathF.IEEERemainder%2A> method is not the same as the [remainder operator](~/docs/csharp/language-reference/operators/remainder-operator.md).</span></span> <span data-ttu-id="50d2c-245">Obwohl beide den Rest nach der Division zurückgeben, unterscheiden sich die von Ihnen verwendeten Formeln.</span><span class="sxs-lookup"><span data-stu-id="50d2c-245">Although both return the remainder after division, the formulas they use are different.</span></span> <span data-ttu-id="50d2c-246">Die Formel für die <xref:System.MathF.IEEERemainder%2A>-Methode lautet wie folgt:</span><span class="sxs-lookup"><span data-stu-id="50d2c-246">The formula for the <xref:System.MathF.IEEERemainder%2A> method is:</span></span>  
  
```  
IEEERemainder = dividend - (divisor * MathF.Round(dividend / divisor))  
```  
  
 <span data-ttu-id="50d2c-247">Im Gegensatz dazu ist die Formel für den Rest-Operator:</span><span class="sxs-lookup"><span data-stu-id="50d2c-247">In contrast, the formula for the remainder operator is:</span></span>  
  
```  
Remainder = (MathF.Abs(dividend) - (MathF.Abs(divisor) *   
            (MathF.Floor(MathF.Abs(dividend) / MathF.Abs(divisor))))) *   
            MathF.Sign(dividend)  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ILogB">
      <MemberSignature Language="C#" Value="public static int ILogB (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ILogB(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.ILogB(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ILogB (x As Single) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ILogB(float x);" />
      <MemberSignature Language="F#" Value="static member ILogB : single -&gt; int" Usage="System.MathF.ILogB x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-248">Die Zahl, deren Logarithmus bestimmt werden soll.</span><span class="sxs-lookup"><span data-stu-id="50d2c-248">The number whose logarithm is to be found.</span></span></param>
        <summary><span data-ttu-id="50d2c-249">Gibt den Logarithmus einer angegebenen ganzen Zahl zur Basis 2 zurück.</span><span class="sxs-lookup"><span data-stu-id="50d2c-249">Returns the base 2 integer logarithm of a specified number.</span></span></summary>
        <returns><span data-ttu-id="50d2c-250">Einer der Werte aus der folgenden Tabelle.</span><span class="sxs-lookup"><span data-stu-id="50d2c-250">One of the values in the following table.</span></span>  
  
 <list type="table"><listheader><term><span data-ttu-id="50d2c-251"><paramref name="x" />-Parameter</span><span class="sxs-lookup"><span data-stu-id="50d2c-251"><paramref name="x" /> parameter</span></span> 
 </term><description> <span data-ttu-id="50d2c-252">Rückgabewert</span><span class="sxs-lookup"><span data-stu-id="50d2c-252">Return value</span></span> 
 </description></listheader><item><term> <span data-ttu-id="50d2c-253">Standard</span><span class="sxs-lookup"><span data-stu-id="50d2c-253">Default</span></span> 
 </term><description> <span data-ttu-id="50d2c-254">Der Logarithmus einer ganzen Zahl zur Basis 2 von <paramref name="x" />; d.h. (int)log2(<paramref name="x" />).</span><span class="sxs-lookup"><span data-stu-id="50d2c-254">The base 2 integer log of <paramref name="x" />; that is, (int)log2(<paramref name="x" />).</span></span>  
  
 </description></item><item><term> <span data-ttu-id="50d2c-255">Zero</span><span class="sxs-lookup"><span data-stu-id="50d2c-255">Zero</span></span> 
 </term><description><see cref="F:System.Int32.MinValue" /></description></item><item><term> <span data-ttu-id="50d2c-256">Gleich <see cref="F:System.Single.NaN" /> oder <see cref="F:System.Single.PositiveInfinity" /> oder <see cref="F:System.Single.NegativeInfinity" /></span><span class="sxs-lookup"><span data-stu-id="50d2c-256">Equal to <see cref="F:System.Single.NaN" /> or <see cref="F:System.Single.PositiveInfinity" /> or <see cref="F:System.Single.NegativeInfinity" /></span></span></term><description><see cref="F:System.Int32.MaxValue" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50d2c-257">Der Parameter `x` wird als Basis 10 angegeben.</span><span class="sxs-lookup"><span data-stu-id="50d2c-257">Parameter `x` is specified as a base 10 number.</span></span>   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static float Log (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Log(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Log(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Log(float x);" />
      <MemberSignature Language="F#" Value="static member Log : single -&gt; single" Usage="System.MathF.Log x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-258">Die Zahl, deren Logarithmus bestimmt werden soll.</span><span class="sxs-lookup"><span data-stu-id="50d2c-258">The number whose logarithm is to be found.</span></span></param>
        <summary><span data-ttu-id="50d2c-259">Gibt den natürlichen Logarithmus (zur Basis <see langword="e" />) der angegebenen Zahl zurück.</span><span class="sxs-lookup"><span data-stu-id="50d2c-259">Returns the natural (base <see langword="e" />) logarithm of a specified number.</span></span></summary>
        <returns><span data-ttu-id="50d2c-260">Einer der Werte aus der folgenden Tabelle.</span><span class="sxs-lookup"><span data-stu-id="50d2c-260">One of the values in the following table.</span></span>  
  
 <list type="table"><listheader><term><span data-ttu-id="50d2c-261"><paramref name="x" />-Parameter</span><span class="sxs-lookup"><span data-stu-id="50d2c-261"><paramref name="x" /> parameter</span></span> 
 </term><description> <span data-ttu-id="50d2c-262">Rückgabewert</span><span class="sxs-lookup"><span data-stu-id="50d2c-262">Return value</span></span> 
 </description></listheader><item><term> <span data-ttu-id="50d2c-263">Positiv</span><span class="sxs-lookup"><span data-stu-id="50d2c-263">Positive</span></span> 
 </term><description> <span data-ttu-id="50d2c-264">Der natürliche Logarithmus von <paramref name="x" />, d.h. ln <paramref name="x" /> oder log e <paramref name="x" /></span><span class="sxs-lookup"><span data-stu-id="50d2c-264">The natural logarithm of <paramref name="x" />; that is, ln <paramref name="x" />, or log e <paramref name="x" /></span></span></description></item><item><term> <span data-ttu-id="50d2c-265">Zero</span><span class="sxs-lookup"><span data-stu-id="50d2c-265">Zero</span></span> 
 </term><description><see cref="F:System.Single.NegativeInfinity" /></description></item><item><term> <span data-ttu-id="50d2c-266">Negativ</span><span class="sxs-lookup"><span data-stu-id="50d2c-266">Negative</span></span> 
 </term><description><see cref="F:System.Single.NaN" /></description></item><item><term> <span data-ttu-id="50d2c-267">Gleich <see cref="F:System.Single.NaN" /></span><span class="sxs-lookup"><span data-stu-id="50d2c-267">Equal to <see cref="F:System.Single.NaN" /></span></span></term><description><see cref="F:System.Single.NaN" /></description></item><item><term> <span data-ttu-id="50d2c-268">Gleich <see cref="F:System.Single.PositiveInfinity" /></span><span class="sxs-lookup"><span data-stu-id="50d2c-268">Equal to <see cref="F:System.Single.PositiveInfinity" /></span></span></term><description><see cref="F:System.Single.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50d2c-269">Der Parameter `x` wird als Basis 10 angegeben.</span><span class="sxs-lookup"><span data-stu-id="50d2c-269">Parameter `x` is specified as a base 10 number.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.MathF.E" />
        <altmember cref="M:System.MathF.Exp(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static float Log (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Log(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Log(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Log(float x, float y);" />
      <MemberSignature Language="F#" Value="static member Log : single * single -&gt; single" Usage="System.MathF.Log (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-270">Die Zahl, deren Logarithmus bestimmt werden soll.</span><span class="sxs-lookup"><span data-stu-id="50d2c-270">The number whose logarithm is to be found.</span></span></param>
        <param name="y"><span data-ttu-id="50d2c-271">Die Basis</span><span class="sxs-lookup"><span data-stu-id="50d2c-271">The base.</span></span></param>
        <summary><span data-ttu-id="50d2c-272">Gibt den Logarithmus einer angegebenen Zahl bezüglich einer angegebenen Basis zurück.</span><span class="sxs-lookup"><span data-stu-id="50d2c-272">Returns the logarithm of a specified number in a specified base.</span></span></summary>
        <returns><span data-ttu-id="50d2c-273">Einer der Werte aus der folgenden Tabelle.</span><span class="sxs-lookup"><span data-stu-id="50d2c-273">One of the values in the following table.</span></span> <span data-ttu-id="50d2c-274">(Plus unendlich steht für <see cref="F:System.Single.PositiveInfinity" />, minus unendlich für <see cref="F:System.Single.NegativeInfinity" /> und NaN für <see cref="F:System.Single.NaN" />.)</span><span class="sxs-lookup"><span data-stu-id="50d2c-274">(+Infinity denotes <see cref="F:System.Single.PositiveInfinity" />, -Infinity denotes <see cref="F:System.Single.NegativeInfinity" />, and NaN denotes <see cref="F:System.Single.NaN" />.)</span></span> 
 <list type="table"><listheader><term><paramref name="x" /></term><description><paramref name="newBase" /></description><description> <span data-ttu-id="50d2c-275">Rückgabewert</span><span class="sxs-lookup"><span data-stu-id="50d2c-275">Return value</span></span> 
 </description></listheader><item><term><span data-ttu-id="50d2c-276"><paramref name="x" />&gt; 0</span><span class="sxs-lookup"><span data-stu-id="50d2c-276"><paramref name="x" />&gt; 0</span></span> 
 </term><description> <span data-ttu-id="50d2c-277">(0 &lt;<paramref name="newBase" />&lt; 1) – oder – (<paramref name="newBase" />&gt; 1)</span><span class="sxs-lookup"><span data-stu-id="50d2c-277">(0 &lt;<paramref name="newBase" />&lt; 1) -or-(<paramref name="newBase" />&gt; 1)</span></span> 
 </description><description> <span data-ttu-id="50d2c-278">lognewBase(a)</span><span class="sxs-lookup"><span data-stu-id="50d2c-278">lognewBase(a)</span></span> 
 </description></item><item><term><span data-ttu-id="50d2c-279"><paramref name="x" />&lt; 0</span><span class="sxs-lookup"><span data-stu-id="50d2c-279"><paramref name="x" />&lt; 0</span></span> 
 </term><description> <span data-ttu-id="50d2c-280">(beliebiger Wert)</span><span class="sxs-lookup"><span data-stu-id="50d2c-280">(any value)</span></span> 
 </description><description> <span data-ttu-id="50d2c-281">NaN</span><span class="sxs-lookup"><span data-stu-id="50d2c-281">NaN</span></span> 
 </description></item><item><term> <span data-ttu-id="50d2c-282">(beliebiger Wert)</span><span class="sxs-lookup"><span data-stu-id="50d2c-282">(any value)</span></span> 
 </term><description><span data-ttu-id="50d2c-283"><paramref name="newBase" />&lt; 0</span><span class="sxs-lookup"><span data-stu-id="50d2c-283"><paramref name="newBase" />&lt; 0</span></span> 
 </description><description> <span data-ttu-id="50d2c-284">NaN</span><span class="sxs-lookup"><span data-stu-id="50d2c-284">NaN</span></span> 
 </description></item><item><term><span data-ttu-id="50d2c-285"><paramref name="x" /> != 1</span><span class="sxs-lookup"><span data-stu-id="50d2c-285"><paramref name="x" /> != 1</span></span> 
 </term><description><span data-ttu-id="50d2c-286"><paramref name="newBase" /> = 0</span><span class="sxs-lookup"><span data-stu-id="50d2c-286"><paramref name="newBase" /> = 0</span></span> 
 </description><description> <span data-ttu-id="50d2c-287">NaN</span><span class="sxs-lookup"><span data-stu-id="50d2c-287">NaN</span></span> 
 </description></item><item><term><span data-ttu-id="50d2c-288"><paramref name="x" /> != 1</span><span class="sxs-lookup"><span data-stu-id="50d2c-288"><paramref name="x" /> != 1</span></span> 
 </term><description><span data-ttu-id="50d2c-289"><paramref name="newBase" /> = plus unendlich</span><span class="sxs-lookup"><span data-stu-id="50d2c-289"><paramref name="newBase" /> = +Infinity</span></span> 
 </description><description> <span data-ttu-id="50d2c-290">NaN</span><span class="sxs-lookup"><span data-stu-id="50d2c-290">NaN</span></span> 
 </description></item><item><term><span data-ttu-id="50d2c-291"><paramref name="x" /> = NaN</span><span class="sxs-lookup"><span data-stu-id="50d2c-291"><paramref name="x" /> = NaN</span></span> 
 </term><description> <span data-ttu-id="50d2c-292">(beliebiger Wert)</span><span class="sxs-lookup"><span data-stu-id="50d2c-292">(any value)</span></span> 
 </description><description> <span data-ttu-id="50d2c-293">NaN</span><span class="sxs-lookup"><span data-stu-id="50d2c-293">NaN</span></span> 
 </description></item><item><term> <span data-ttu-id="50d2c-294">(beliebiger Wert)</span><span class="sxs-lookup"><span data-stu-id="50d2c-294">(any value)</span></span> 
 </term><description><span data-ttu-id="50d2c-295"><paramref name="newBase" /> = NaN</span><span class="sxs-lookup"><span data-stu-id="50d2c-295"><paramref name="newBase" /> = NaN</span></span> 
 </description><description> <span data-ttu-id="50d2c-296">NaN</span><span class="sxs-lookup"><span data-stu-id="50d2c-296">NaN</span></span> 
 </description></item><item><term> <span data-ttu-id="50d2c-297">(beliebiger Wert)</span><span class="sxs-lookup"><span data-stu-id="50d2c-297">(any value)</span></span> 
 </term><description><span data-ttu-id="50d2c-298"><paramref name="newBase" /> = 1</span><span class="sxs-lookup"><span data-stu-id="50d2c-298"><paramref name="newBase" /> = 1</span></span> 
 </description><description> <span data-ttu-id="50d2c-299">NaN</span><span class="sxs-lookup"><span data-stu-id="50d2c-299">NaN</span></span> 
 </description></item><item><term><span data-ttu-id="50d2c-300"><paramref name="x" /> = 0</span><span class="sxs-lookup"><span data-stu-id="50d2c-300"><paramref name="x" /> = 0</span></span> 
 </term><description> <span data-ttu-id="50d2c-301">0 &lt;<paramref name="newBase" />&lt; 1</span><span class="sxs-lookup"><span data-stu-id="50d2c-301">0 &lt;<paramref name="newBase" />&lt; 1</span></span> 
 </description><description> <span data-ttu-id="50d2c-302">plus unendlich</span><span class="sxs-lookup"><span data-stu-id="50d2c-302">+Infinity</span></span> 
 </description></item><item><term><span data-ttu-id="50d2c-303"><paramref name="x" /> = 0</span><span class="sxs-lookup"><span data-stu-id="50d2c-303"><paramref name="x" /> = 0</span></span> 
 </term><description><span data-ttu-id="50d2c-304"><paramref name="newBase" />&gt; 1</span><span class="sxs-lookup"><span data-stu-id="50d2c-304"><paramref name="newBase" />&gt; 1</span></span> 
 </description><description> <span data-ttu-id="50d2c-305">minus unendlich</span><span class="sxs-lookup"><span data-stu-id="50d2c-305">-Infinity</span></span> 
 </description></item><item><term><span data-ttu-id="50d2c-306"><paramref name="x" /> =  +unendlich</span><span class="sxs-lookup"><span data-stu-id="50d2c-306"><paramref name="x" /> =  +Infinity</span></span> 
 </term><description> <span data-ttu-id="50d2c-307">0 &lt;<paramref name="newBase" />&lt; 1</span><span class="sxs-lookup"><span data-stu-id="50d2c-307">0 &lt;<paramref name="newBase" />&lt; 1</span></span> 
 </description><description> <span data-ttu-id="50d2c-308">minus unendlich</span><span class="sxs-lookup"><span data-stu-id="50d2c-308">-Infinity</span></span> 
 </description></item><item><term><span data-ttu-id="50d2c-309"><paramref name="x" /> =  +unendlich</span><span class="sxs-lookup"><span data-stu-id="50d2c-309"><paramref name="x" /> =  +Infinity</span></span> 
 </term><description><span data-ttu-id="50d2c-310"><paramref name="newBase" />&gt; 1</span><span class="sxs-lookup"><span data-stu-id="50d2c-310"><paramref name="newBase" />&gt; 1</span></span> 
 </description><description> <span data-ttu-id="50d2c-311">plus unendlich</span><span class="sxs-lookup"><span data-stu-id="50d2c-311">+Infinity</span></span> 
 </description></item><item><term><span data-ttu-id="50d2c-312"><paramref name="x" /> = 1</span><span class="sxs-lookup"><span data-stu-id="50d2c-312"><paramref name="x" /> = 1</span></span> 
 </term><description><span data-ttu-id="50d2c-313"><paramref name="newBase" /> = 0</span><span class="sxs-lookup"><span data-stu-id="50d2c-313"><paramref name="newBase" /> = 0</span></span> 
 </description><description> <span data-ttu-id="50d2c-314">0</span><span class="sxs-lookup"><span data-stu-id="50d2c-314">0</span></span> 
 </description></item><item><term><span data-ttu-id="50d2c-315"><paramref name="x" /> = 1</span><span class="sxs-lookup"><span data-stu-id="50d2c-315"><paramref name="x" /> = 1</span></span> 
 </term><description><span data-ttu-id="50d2c-316"><paramref name="newBase" /> = plus unendlich</span><span class="sxs-lookup"><span data-stu-id="50d2c-316"><paramref name="newBase" /> = +Infinity</span></span> 
 </description><description> <span data-ttu-id="50d2c-317">0</span><span class="sxs-lookup"><span data-stu-id="50d2c-317">0</span></span> 
 </description></item></list></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static float Log10 (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Log10(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Log10(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Log10(float x);" />
      <MemberSignature Language="F#" Value="static member Log10 : single -&gt; single" Usage="System.MathF.Log10 x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-318">Eine Zahl, deren Logarithmus gesucht wird.</span><span class="sxs-lookup"><span data-stu-id="50d2c-318">A number whose logarithm is to be found.</span></span></param>
        <summary><span data-ttu-id="50d2c-319">Gibt den Logarithmus einer angegebenen Zahl zur Basis 10 zurück.</span><span class="sxs-lookup"><span data-stu-id="50d2c-319">Returns the base 10 logarithm of a specified number.</span></span></summary>
        <returns><span data-ttu-id="50d2c-320">Einer der Werte aus der folgenden Tabelle.</span><span class="sxs-lookup"><span data-stu-id="50d2c-320">One of the values in the following table.</span></span>  
  
 <list type="table"><listheader><term><span data-ttu-id="50d2c-321"><paramref name="x" />-Parameter</span><span class="sxs-lookup"><span data-stu-id="50d2c-321"><paramref name="x" /> parameter</span></span> 
 </term><description> <span data-ttu-id="50d2c-322">Rückgabewert</span><span class="sxs-lookup"><span data-stu-id="50d2c-322">Return value</span></span> 
 </description></listheader><item><term> <span data-ttu-id="50d2c-323">Positiv</span><span class="sxs-lookup"><span data-stu-id="50d2c-323">Positive</span></span> 
 </term><description> <span data-ttu-id="50d2c-324">Der Logarithmus von <paramref name="x" /> zur Basis 10, d.h. log 10<paramref name="x" />.</span><span class="sxs-lookup"><span data-stu-id="50d2c-324">The base 10 log of <paramref name="x" />; that is, log 10<paramref name="x" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="50d2c-325">Zero</span><span class="sxs-lookup"><span data-stu-id="50d2c-325">Zero</span></span> 
 </term><description><see cref="F:System.Single.NegativeInfinity" /></description></item><item><term> <span data-ttu-id="50d2c-326">Negativ</span><span class="sxs-lookup"><span data-stu-id="50d2c-326">Negative</span></span> 
 </term><description><see cref="F:System.Single.NaN" /></description></item><item><term> <span data-ttu-id="50d2c-327">Gleich <see cref="F:System.Single.NaN" /></span><span class="sxs-lookup"><span data-stu-id="50d2c-327">Equal to <see cref="F:System.Single.NaN" /></span></span></term><description><see cref="F:System.Single.NaN" /></description></item><item><term> <span data-ttu-id="50d2c-328">Gleich <see cref="F:System.Single.PositiveInfinity" /></span><span class="sxs-lookup"><span data-stu-id="50d2c-328">Equal to <see cref="F:System.Single.PositiveInfinity" /></span></span></term><description><see cref="F:System.Single.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50d2c-329">Der Parameter `x` wird als Basis 10 angegeben.</span><span class="sxs-lookup"><span data-stu-id="50d2c-329">Parameter `x` is specified as a base 10 number.</span></span>   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log2">
      <MemberSignature Language="C#" Value="public static float Log2 (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Log2(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Log2(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log2 (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Log2(float x);" />
      <MemberSignature Language="F#" Value="static member Log2 : single -&gt; single" Usage="System.MathF.Log2 x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-330">Eine Zahl, deren Logarithmus gesucht wird.</span><span class="sxs-lookup"><span data-stu-id="50d2c-330">A number whose logarithm is to be found.</span></span></param>
        <summary><span data-ttu-id="50d2c-331">Gibt den Logarithmus einer angegebenen Zahl zur Basis 2 zurück.</span><span class="sxs-lookup"><span data-stu-id="50d2c-331">Returns the base 2 logarithm of a specified number.</span></span></summary>
        <returns><span data-ttu-id="50d2c-332">Einer der Werte aus der folgenden Tabelle.</span><span class="sxs-lookup"><span data-stu-id="50d2c-332">One of the values in the following table.</span></span>  
  
 <list type="table"><listheader><term><span data-ttu-id="50d2c-333"><paramref name="x" />-Parameter</span><span class="sxs-lookup"><span data-stu-id="50d2c-333"><paramref name="x" /> parameter</span></span> 
 </term><description> <span data-ttu-id="50d2c-334">Rückgabewert</span><span class="sxs-lookup"><span data-stu-id="50d2c-334">Return value</span></span> 
 </description></listheader><item><term> <span data-ttu-id="50d2c-335">Positiv</span><span class="sxs-lookup"><span data-stu-id="50d2c-335">Positive</span></span> 
 </term><description> <span data-ttu-id="50d2c-336">Der Logarithmus von <paramref name="x" /> zur Basis 2, d.h. log 2<paramref name="x" />.</span><span class="sxs-lookup"><span data-stu-id="50d2c-336">The base 2 log of <paramref name="x" />; that is, log 2<paramref name="x" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="50d2c-337">Zero</span><span class="sxs-lookup"><span data-stu-id="50d2c-337">Zero</span></span> 
 </term><description><see cref="F:System.Single.NegativeInfinity" /></description></item><item><term> <span data-ttu-id="50d2c-338">Negativ</span><span class="sxs-lookup"><span data-stu-id="50d2c-338">Negative</span></span> 
 </term><description><see cref="F:System.Single.NaN" /></description></item><item><term> <span data-ttu-id="50d2c-339">Gleich <see cref="F:System.Single.NaN" /></span><span class="sxs-lookup"><span data-stu-id="50d2c-339">Equal to <see cref="F:System.Single.NaN" /></span></span></term><description><see cref="F:System.Single.NaN" /></description></item><item><term> <span data-ttu-id="50d2c-340">Gleich <see cref="F:System.Single.PositiveInfinity" /></span><span class="sxs-lookup"><span data-stu-id="50d2c-340">Equal to <see cref="F:System.Single.PositiveInfinity" /></span></span></term><description><see cref="F:System.Single.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50d2c-341">Der Parameter `x` wird als Basis 10 angegeben.</span><span class="sxs-lookup"><span data-stu-id="50d2c-341">Parameter `x` is specified as a base 10 number.</span></span>   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static float Max (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Max(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Max(float x, float y);" />
      <MemberSignature Language="F#" Value="static member Max : single * single -&gt; single" Usage="System.MathF.Max (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-342">Die erste von zwei zu vergleichenden Gleitkommazahlen mit einfacher Genauigkeit.</span><span class="sxs-lookup"><span data-stu-id="50d2c-342">The first of two single-precision floating-point numbers to compare.</span></span></param>
        <param name="y"><span data-ttu-id="50d2c-343">Die zweite von zwei zu vergleichenden Gleitkommazahlen mit einfacher Genauigkeit.</span><span class="sxs-lookup"><span data-stu-id="50d2c-343">The second of two single-precision floating-point numbers to compare.</span></span></param>
        <summary><span data-ttu-id="50d2c-344">Gibt die größere von zwei Gleitkommazahlen mit einfacher Genauigkeit zurück.</span><span class="sxs-lookup"><span data-stu-id="50d2c-344">Returns the larger of two single-precision floating-point numbers.</span></span></summary>
        <returns><span data-ttu-id="50d2c-345">Der größere der Parameter <paramref name="x" /> und <paramref name="y" />.</span><span class="sxs-lookup"><span data-stu-id="50d2c-345">Parameter <paramref name="x" /> or <paramref name="y" />, whichever is larger.</span></span> <span data-ttu-id="50d2c-346">Wenn entweder <paramref name="x" /> oder <paramref name="y" /> oder sowohl <paramref name="x" /> als auch <paramref name="y" /> gleich <see cref="F:System.Single.NaN" /> ist, wird <see cref="F:System.Single.NaN" /> zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="50d2c-346">If <paramref name="x" />, or <paramref name="y" />, or both <paramref name="x" /> and <paramref name="y" /> are equal to <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> is returned.</span></span></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitude">
      <MemberSignature Language="C#" Value="public static float MaxMagnitude (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 MaxMagnitude(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.MaxMagnitude(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MaxMagnitude (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float MaxMagnitude(float x, float y);" />
      <MemberSignature Language="F#" Value="static member MaxMagnitude : single * single -&gt; single" Usage="System.MathF.MaxMagnitude (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="y" Type="System.Single" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-347">Die erste von zwei zu vergleichenden Gleitkommazahlen mit einfacher Genauigkeit.</span><span class="sxs-lookup"><span data-stu-id="50d2c-347">The first of two single-precision floating-point numbers to compare.</span></span></param>
        <param name="y"><span data-ttu-id="50d2c-348">Die zweite von zwei zu vergleichenden Gleitkommazahlen mit einfacher Genauigkeit.</span><span class="sxs-lookup"><span data-stu-id="50d2c-348">The second of two single-precision floating-point numbers to compare.</span></span></param>
        <summary><span data-ttu-id="50d2c-349">Gibt den größeren Betrag von zwei Gleitkommazahlen mit einfacher Genauigkeit zurück.</span><span class="sxs-lookup"><span data-stu-id="50d2c-349">Returns the larger magnitude of two single-precision floating-point numbers.</span></span></summary>
        <returns><span data-ttu-id="50d2c-350">Parameter <paramref name="x" /> oder <paramref name="y" />, je nachdem, welche den größeren Betrag hat.</span><span class="sxs-lookup"><span data-stu-id="50d2c-350">Parameter <paramref name="x" /> or <paramref name="y" />, whichever has the larger magnitude.</span></span> <span data-ttu-id="50d2c-351">Wenn entweder <paramref name="x" /> oder <paramref name="y" /> oder sowohl <paramref name="x" /> als auch <paramref name="y" /> gleich <see cref="F:System.Single.NaN" /> ist, wird <see cref="F:System.Single.NaN" /> zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="50d2c-351">If <paramref name="x" />, or <paramref name="y" />, or both <paramref name="x" /> and <paramref name="y" /> are equal to <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> is returned.</span></span></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static float Min (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Min(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Min(float x, float y);" />
      <MemberSignature Language="F#" Value="static member Min : single * single -&gt; single" Usage="System.MathF.Min (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-352">Die erste von zwei zu vergleichenden Gleitkommazahlen mit einfacher Genauigkeit.</span><span class="sxs-lookup"><span data-stu-id="50d2c-352">The first of two single-precision floating-point numbers to compare.</span></span></param>
        <param name="y"><span data-ttu-id="50d2c-353">Die zweite von zwei zu vergleichenden Gleitkommazahlen mit einfacher Genauigkeit.</span><span class="sxs-lookup"><span data-stu-id="50d2c-353">The second of two single-precision floating-point numbers to compare.</span></span></param>
        <summary><span data-ttu-id="50d2c-354">Gibt die kleinere von zwei Gleitkommazahlen mit einfacher Genauigkeit zurück.</span><span class="sxs-lookup"><span data-stu-id="50d2c-354">Returns the smaller of two single-precision floating-point numbers.</span></span></summary>
        <returns><span data-ttu-id="50d2c-355">Der kleinere der Parameter <paramref name="x" /> und <paramref name="y" />.</span><span class="sxs-lookup"><span data-stu-id="50d2c-355">Parameter <paramref name="x" /> or <paramref name="y" />, whichever is smaller.</span></span> <span data-ttu-id="50d2c-356">Wenn entweder <paramref name="x" /> oder <paramref name="y" /> oder sowohl <paramref name="x" /> als auch <paramref name="y" /> gleich <see cref="F:System.Single.NaN" /> ist, wird <see cref="F:System.Single.NaN" /> zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="50d2c-356">If <paramref name="x" />, <paramref name="y" />, or both <paramref name="x" /> and <paramref name="y" /> are equal to <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> is returned.</span></span></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitude">
      <MemberSignature Language="C#" Value="public static float MinMagnitude (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 MinMagnitude(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.MinMagnitude(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MinMagnitude (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float MinMagnitude(float x, float y);" />
      <MemberSignature Language="F#" Value="static member MinMagnitude : single * single -&gt; single" Usage="System.MathF.MinMagnitude (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="y" Type="System.Single" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-357">Die erste von zwei zu vergleichenden Gleitkommazahlen mit einfacher Genauigkeit.</span><span class="sxs-lookup"><span data-stu-id="50d2c-357">The first of two single-precision floating-point numbers to compare.</span></span></param>
        <param name="y"><span data-ttu-id="50d2c-358">Die zweite von zwei zu vergleichenden Gleitkommazahlen mit einfacher Genauigkeit.</span><span class="sxs-lookup"><span data-stu-id="50d2c-358">The second of two single-precision floating-point numbers to compare.</span></span></param>
        <summary><span data-ttu-id="50d2c-359">Gibt den kleineren Betrag von zwei Gleitkommazahlen mit einfacher Genauigkeit zurück.</span><span class="sxs-lookup"><span data-stu-id="50d2c-359">Returns the smaller magnitude of two single-precision floating-point numbers.</span></span></summary>
        <returns><span data-ttu-id="50d2c-360">Parameter <paramref name="x" /> oder <paramref name="y" />, je nachdem, welche den kleineren Betrag hat.</span><span class="sxs-lookup"><span data-stu-id="50d2c-360">Parameter <paramref name="x" /> or <paramref name="y" />, whichever has the smaller magnitude.</span></span> <span data-ttu-id="50d2c-361">Wenn entweder <paramref name="x" /> oder <paramref name="y" /> oder sowohl <paramref name="x" /> als auch <paramref name="y" /> gleich <see cref="F:System.Single.NaN" /> ist, wird <see cref="F:System.Single.NaN" /> zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="50d2c-361">If <paramref name="x" />, or <paramref name="y" />, or both <paramref name="x" /> and <paramref name="y" /> are equal to <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> is returned.</span></span></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="PI">
      <MemberSignature Language="C#" Value="public const float PI = 3.141593;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 PI = (3.141593)" />
      <MemberSignature Language="DocId" Value="F:System.MathF.PI" />
      <MemberSignature Language="VB.NET" Value="Public Const PI As Single  = 3.141593" />
      <MemberSignature Language="C++ CLI" Value="public: float PI = 3.141593;" />
      <MemberSignature Language="F#" Value="val mutable PI : single" Usage="System.MathF.PI" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>3.141593</MemberValue>
      <Docs>
        <summary><span data-ttu-id="50d2c-362">Stellt das Verhältnis eines Kreisumfangs zum Kreisdurchmesser durch die Konstante π dar.</span><span class="sxs-lookup"><span data-stu-id="50d2c-362">Represents the ratio of the circumference of a circle to its diameter, specified by the constant, π.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="50d2c-363">Der Wert dieses Felds ist 3,14159274.</span><span class="sxs-lookup"><span data-stu-id="50d2c-363">The value of this field is 3.14159274.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static float Pow (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Pow(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Pow(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Pow(float x, float y);" />
      <MemberSignature Language="F#" Value="static member Pow : single * single -&gt; single" Usage="System.MathF.Pow (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-364">Eine Gleitkommazahl mit einfacher Genauigkeit, die potenziert werden soll.</span><span class="sxs-lookup"><span data-stu-id="50d2c-364">A single-precision floating-point number to be raised to a power.</span></span></param>
        <param name="y"><span data-ttu-id="50d2c-365">Eine Gleitkommazahl mit einfacher Genauigkeit, die einen Exponenten darstellt.</span><span class="sxs-lookup"><span data-stu-id="50d2c-365">A single-precision floating-point number that specifies a power.</span></span></param>
        <summary><span data-ttu-id="50d2c-366">Potenziert eine angegebene Zahl mit dem angegebenen Exponenten.</span><span class="sxs-lookup"><span data-stu-id="50d2c-366">Returns a specified number raised to the specified power.</span></span></summary>
        <returns><span data-ttu-id="50d2c-367">Die Zahl <paramref name="x" /> hoch <paramref name="y" />.</span><span class="sxs-lookup"><span data-stu-id="50d2c-367">The number <paramref name="x" /> raised to the power <paramref name="y" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50d2c-368">In der folgenden Tabelle wird der Rückgabewert angegeben, wenn für die Parameter `x` und `y` verschiedene Werte oder Wertebereiche angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="50d2c-368">The following table indicates the return value when various values or ranges of values are specified for the `x` and `y` parameters.</span></span> <span data-ttu-id="50d2c-369">Weitere Informationen finden Sie unter <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> und <xref:System.Single.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="50d2c-369">For more information, see <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, and <xref:System.Single.NaN?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="50d2c-370">Parameter</span><span class="sxs-lookup"><span data-stu-id="50d2c-370">Parameters</span></span>|<span data-ttu-id="50d2c-371">Rückgabewert</span><span class="sxs-lookup"><span data-stu-id="50d2c-371">Return value</span></span>|  
|----------------|------------------|  
|<span data-ttu-id="50d2c-372">`x` oder `y` = `NaN`.</span><span class="sxs-lookup"><span data-stu-id="50d2c-372">`x` or `y` = `NaN`.</span></span>|`NaN`|  
|<span data-ttu-id="50d2c-373">`x` = beliebiger Wert außer `NaN`; `y` = 0.</span><span class="sxs-lookup"><span data-stu-id="50d2c-373">`x` = Any value except `NaN`; `y` = 0.</span></span>|<span data-ttu-id="50d2c-374">1</span><span class="sxs-lookup"><span data-stu-id="50d2c-374">1</span></span>|  
|<span data-ttu-id="50d2c-375">`x` = `NegativeInfinity`; `y` < 0.</span><span class="sxs-lookup"><span data-stu-id="50d2c-375">`x` = `NegativeInfinity`; `y` < 0.</span></span>|<span data-ttu-id="50d2c-376">0</span><span class="sxs-lookup"><span data-stu-id="50d2c-376">0</span></span>|  
|<span data-ttu-id="50d2c-377">`x` = `NegativeInfinity`; `y` ist eine positive ungerade ganze Zahl.</span><span class="sxs-lookup"><span data-stu-id="50d2c-377">`x` = `NegativeInfinity`; `y` is a positive odd integer.</span></span>|`NegativeInfinity`|  
|<span data-ttu-id="50d2c-378">`x` = `NegativeInfinity`; `y` ist positiv, aber keine ungerade ganze Zahl.</span><span class="sxs-lookup"><span data-stu-id="50d2c-378">`x` = `NegativeInfinity`; `y` is positive but not an odd integer.</span></span>|`PositiveInfinity`|  
|<span data-ttu-id="50d2c-379">`x` < 0, aber nicht `NegativeInfinity`; `y` ist keine Ganzzahl, `NegativeInfinity`oder `PositiveInfinity`.</span><span class="sxs-lookup"><span data-stu-id="50d2c-379">`x` < 0 but not `NegativeInfinity`; `y` is not an integer, `NegativeInfinity`, or `PositiveInfinity`.</span></span>|`NaN`|  
|<span data-ttu-id="50d2c-380">`x` =-1; `y` = `NegativeInfinity` oder `PositiveInfinity`.</span><span class="sxs-lookup"><span data-stu-id="50d2c-380">`x` = -1; `y` = `NegativeInfinity` or `PositiveInfinity`.</span></span>|`NaN`|  
|<span data-ttu-id="50d2c-381">-1 < `x` < 1; `y` = `NegativeInfinity`.</span><span class="sxs-lookup"><span data-stu-id="50d2c-381">-1 < `x` < 1; `y` = `NegativeInfinity`.</span></span>|`PositiveInfinity`|  
|<span data-ttu-id="50d2c-382">-1 < `x` < 1; `y` = `PositiveInfinity`.</span><span class="sxs-lookup"><span data-stu-id="50d2c-382">-1 < `x` < 1; `y` = `PositiveInfinity`.</span></span>|<span data-ttu-id="50d2c-383">0</span><span class="sxs-lookup"><span data-stu-id="50d2c-383">0</span></span>|  
|<span data-ttu-id="50d2c-384">`x` <-1 oder `x` > 1; `y` = `NegativeInfinity`.</span><span class="sxs-lookup"><span data-stu-id="50d2c-384">`x` < -1 or `x` > 1; `y` = `NegativeInfinity`.</span></span>|<span data-ttu-id="50d2c-385">0</span><span class="sxs-lookup"><span data-stu-id="50d2c-385">0</span></span>|  
|<span data-ttu-id="50d2c-386">`x` <-1 oder `x` > 1; `y` = `PositiveInfinity`.</span><span class="sxs-lookup"><span data-stu-id="50d2c-386">`x` < -1 or `x` > 1; `y` = `PositiveInfinity`.</span></span>|`PositiveInfinity`|  
|<span data-ttu-id="50d2c-387">`x` = 0; `y` < 0.</span><span class="sxs-lookup"><span data-stu-id="50d2c-387">`x` = 0; `y` < 0.</span></span>|`PositiveInfinity`|  
|<span data-ttu-id="50d2c-388">`x` = 0; `y` > 0.</span><span class="sxs-lookup"><span data-stu-id="50d2c-388">`x` = 0; `y` > 0.</span></span>|<span data-ttu-id="50d2c-389">0</span><span class="sxs-lookup"><span data-stu-id="50d2c-389">0</span></span>|  
|<span data-ttu-id="50d2c-390">`x` = 1; `y` ist ein beliebiger Wert außer `NaN`.</span><span class="sxs-lookup"><span data-stu-id="50d2c-390">`x` = 1; `y` is any value except `NaN`.</span></span>|<span data-ttu-id="50d2c-391">1</span><span class="sxs-lookup"><span data-stu-id="50d2c-391">1</span></span>|  
|<span data-ttu-id="50d2c-392">`x` = `PositiveInfinity`; `y` < 0.</span><span class="sxs-lookup"><span data-stu-id="50d2c-392">`x` = `PositiveInfinity`; `y` < 0.</span></span>|<span data-ttu-id="50d2c-393">0</span><span class="sxs-lookup"><span data-stu-id="50d2c-393">0</span></span>|  
|<span data-ttu-id="50d2c-394">`x` = `PositiveInfinity`; `y` > 0.</span><span class="sxs-lookup"><span data-stu-id="50d2c-394">`x` = `PositiveInfinity`; `y` > 0.</span></span>|`PositiveInfinity`|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.MathF.Sqrt(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static float Round (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Round(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Round(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Round(float x);" />
      <MemberSignature Language="F#" Value="static member Round : single -&gt; single" Usage="System.MathF.Round x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-395">Eine zu rundende Gleitkommazahl mit einfacher Genauigkeit.</span><span class="sxs-lookup"><span data-stu-id="50d2c-395">A single-precision floating-point number to be rounded.</span></span></param>
        <summary><span data-ttu-id="50d2c-396">Rundet einen Gleitkommawert mit einfacher Genauigkeit auf den nächstgelegenen ganzzahligen Wert und Mittelpunktwerte auf die nächstgelegene gerade Zahl.</span><span class="sxs-lookup"><span data-stu-id="50d2c-396">Rounds a single-precision floating-point value to the nearest integral value, and rounds midpoint values to the nearest even number.</span></span></summary>
        <returns><span data-ttu-id="50d2c-397">Die zu <paramref name="x" /> nächste Ganzzahl.</span><span class="sxs-lookup"><span data-stu-id="50d2c-397">The integer nearest <paramref name="x" />.</span></span> <span data-ttu-id="50d2c-398">Wenn der Nachkommawert von <paramref name="x" /> genau in der Mitte zwischen zwei Ganzzahlen liegt, von denen eine gerade und die andere ungerade ist, wird die gerade Zahl zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="50d2c-398">If the fractional component of <paramref name="x" /> is halfway between two integers, one of which is even and the other odd, then the even number is returned.</span></span> <span data-ttu-id="50d2c-399">Beachten Sie, dass diese Methode einen <see cref="T:System.Single" /> anstelle eines ganzzahligen Typs zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="50d2c-399">Note that this method returns a <see cref="T:System.Single" /> instead of an integral type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="50d2c-400">Diese Methode verwendet die Standard Rundungs Konvention <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="50d2c-400">This method uses the default rounding convention of <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType>.</span></span>

[!INCLUDE[midpoint-rounding](~/includes/floating-point-equality.md)]

<span data-ttu-id="50d2c-401">Wenn der Wert des `x` Arguments <xref:System.Single.NaN?displayProperty=nameWithType>ist, gibt die Methode <xref:System.Single.NaN?displayProperty=nameWithType>zurück.</span><span class="sxs-lookup"><span data-stu-id="50d2c-401">If the value of the `x` argument is <xref:System.Single.NaN?displayProperty=nameWithType>, the method returns <xref:System.Single.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="50d2c-402">Wenn `x` ist <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, gibt die Methode zurück <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>bzw.</span><span class="sxs-lookup"><span data-stu-id="50d2c-402">If `x` is <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, the method returns <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, respectively.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="50d2c-403">Aufgrund des Genauigkeits Verlusts, der sich aus der Darstellung von Dezimalwerten als Gleit Komma Zahlen oder der Durchführung arithmetischer Operationen für Gleit Komma Werte ergeben kann, scheint die <see cref="M:System.MathF.Round(System.Single)" />-Methode in manchen Fällen keine Mittelpunkt Werte auf die nächste gerade ganze Zahl zu runden.</span><span class="sxs-lookup"><span data-stu-id="50d2c-403">Because of the loss of precision that can result from representing decimal values as floating-point numbers or performing arithmetic operations on floating-point values, in some cases the <see cref="M:System.MathF.Round(System.Single)" /> method may not appear to round midpoint values to the nearest even integer.</span></span></para></block>
        <altmember cref="M:System.MathF.Ceiling(System.Single)" />
        <altmember cref="M:System.MathF.Floor(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static float Round (float x, int digits);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Round(float32 x, int32 digits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Round(System.Single,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (x As Single, digits As Integer) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Round(float x, int digits);" />
      <MemberSignature Language="F#" Value="static member Round : single * int -&gt; single" Usage="System.MathF.Round (x, digits)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="digits" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-404">Eine zu rundende Gleitkommazahl mit einfacher Genauigkeit.</span><span class="sxs-lookup"><span data-stu-id="50d2c-404">A single-precision floating-point number to be rounded.</span></span></param>
        <param name="digits"><span data-ttu-id="50d2c-405">Die Anzahl von Dezimalstellen im Rückgabewert.</span><span class="sxs-lookup"><span data-stu-id="50d2c-405">The number of fractional digits in the return value.</span></span></param>
        <summary><span data-ttu-id="50d2c-406">Rundet einen Gleitkommawert mit einfacher Genauigkeit auf eine angegebene Anzahl Dezimalstellen und Mittelpunktwerte auf die nächstgelegene gerade Zahl.</span><span class="sxs-lookup"><span data-stu-id="50d2c-406">Rounds a single-precision floating-point value to a specified number of fractional digits, and rounds midpoint values to the nearest even number.</span></span></summary>
        <returns><span data-ttu-id="50d2c-407">Die Zahl, die <paramref name="x" /> am nächsten liegt und deren Anzahl von Nachkommastellen gleich <paramref name="digits" /> ist.</span><span class="sxs-lookup"><span data-stu-id="50d2c-407">The number nearest to <paramref name="x" /> that contains a number of fractional digits equal to <paramref name="digits" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<span data-ttu-id="50d2c-408">Der Wert des `digits` Arguments kann zwischen 0 und 6 liegen.</span><span class="sxs-lookup"><span data-stu-id="50d2c-408">The value of the `digits` argument can range from 0 to 6.</span></span> <span data-ttu-id="50d2c-409">Beachten Sie, dass 6 die maximale Anzahl von ganzzahligen und Bruch Ziffern ist, die vom <xref:System.Single> Typ unterstützt werden.</span><span class="sxs-lookup"><span data-stu-id="50d2c-409">Note that 6 is the maximum number of integral and fractional digits supported by the <xref:System.Single> type.</span></span>

<span data-ttu-id="50d2c-410">Diese Methode verwendet die Standard Rundungs Konvention <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="50d2c-410">This method uses the default rounding convention of <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType>.</span></span> 

[!INCLUDE[midpoint-rounding](~/includes/floating-point-equality.md)]

<span data-ttu-id="50d2c-411">Wenn der Wert des `x` Arguments <xref:System.Single.NaN?displayProperty=nameWithType>ist, gibt die Methode <xref:System.Single.NaN?displayProperty=nameWithType>zurück.</span><span class="sxs-lookup"><span data-stu-id="50d2c-411">If the value of the `x` argument is <xref:System.Single.NaN?displayProperty=nameWithType>, the method returns <xref:System.Single.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="50d2c-412">Wenn `x` ist <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, gibt die Methode zurück <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>bzw.</span><span class="sxs-lookup"><span data-stu-id="50d2c-412">If `x` is <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, the method returns <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, respectively.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="50d2c-413"><paramref name="digits" /> ist kleiner als 0 (null) oder größer als 6.</span><span class="sxs-lookup"><span data-stu-id="50d2c-413"><paramref name="digits" /> is less than 0 or greater than 6.</span></span></exception>
        <altmember cref="M:System.MathF.Ceiling(System.Single)" />
        <altmember cref="M:System.MathF.Floor(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static float Round (float x, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Round(float32 x, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Round(System.Single,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (x As Single, mode As MidpointRounding) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Round(float x, MidpointRounding mode);" />
      <MemberSignature Language="F#" Value="static member Round : single * MidpointRounding -&gt; single" Usage="System.MathF.Round (x, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-414">Eine zu rundende Gleitkommazahl mit einfacher Genauigkeit.</span><span class="sxs-lookup"><span data-stu-id="50d2c-414">A single-precision floating-point number to be rounded.</span></span></param>
        <param name="mode"><span data-ttu-id="50d2c-415">Angabe, wie <paramref name="x" /> gerundet werden soll, wenn der Wert genau in der Mitte zwischen zwei anderen Zahlen liegt.</span><span class="sxs-lookup"><span data-stu-id="50d2c-415">Specification for how to round <paramref name="x" /> if it is midway between two other numbers.</span></span></param>
        <summary><span data-ttu-id="50d2c-416">Rundet einen Gleitkommawert mit einfacher Genauigkeit auf die nächstgelegene ganze Zahl und verwendet den angegebenen Rundungsmodus für Mittelpunktwerte.</span><span class="sxs-lookup"><span data-stu-id="50d2c-416">Rounds a single-precision floating-point value to the nearest integer, and uses the specified rounding convention for midpoint values.</span></span></summary>
        <returns><span data-ttu-id="50d2c-417">Die zu <paramref name="x" /> nächste Ganzzahl.</span><span class="sxs-lookup"><span data-stu-id="50d2c-417">The integer nearest <paramref name="x" />.</span></span> <span data-ttu-id="50d2c-418">Wenn <paramref name="x" /> genau in der Mitte zwischen zwei Ganzzahlen liegt, von denen eine gerade und die andere ungerade ist, bestimmt <paramref name="mode" />, welche der beiden Zahlen zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="50d2c-418">If <paramref name="x" /> is halfway between two integers, one of which is even and the other odd, then <paramref name="mode" /> determines which of the two is returned.</span></span> <span data-ttu-id="50d2c-419">Beachten Sie, dass diese Methode einen <see cref="T:System.Single" /> anstelle eines ganzzahligen Typs zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="50d2c-419">Note that this method returns a <see cref="T:System.Single" /> instead of an integral type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  


[!INCLUDE[midpoint-rounding](~/includes/floating-point-equality.md)]

<span data-ttu-id="50d2c-420">Wenn der Wert des `x` Arguments <xref:System.Single.NaN?displayProperty=nameWithType>ist, gibt die Methode <xref:System.Single.NaN?displayProperty=nameWithType>zurück.</span><span class="sxs-lookup"><span data-stu-id="50d2c-420">If the value of the `x` argument is <xref:System.Single.NaN?displayProperty=nameWithType>, the method returns <xref:System.Single.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="50d2c-421">Wenn `x` ist <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, gibt die Methode zurück <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>bzw.</span><span class="sxs-lookup"><span data-stu-id="50d2c-421">If `x` is <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, the method returns <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, respectively.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="50d2c-422"><paramref name="mode" /> ist kein gültiger Wert von <see cref="T:System.MidpointRounding" />.</span><span class="sxs-lookup"><span data-stu-id="50d2c-422"><paramref name="mode" /> is not a valid value of <see cref="T:System.MidpointRounding" />.</span></span></exception>
        <altmember cref="M:System.MathF.Ceiling(System.Single)" />
        <altmember cref="M:System.MathF.Floor(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static float Round (float x, int digits, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Round(float32 x, int32 digits, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Round(System.Single,System.Int32,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (x As Single, digits As Integer, mode As MidpointRounding) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Round(float x, int digits, MidpointRounding mode);" />
      <MemberSignature Language="F#" Value="static member Round : single * int * MidpointRounding -&gt; single" Usage="System.MathF.Round (x, digits, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="digits" Type="System.Int32" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-423">Eine zu rundende Gleitkommazahl mit einfacher Genauigkeit.</span><span class="sxs-lookup"><span data-stu-id="50d2c-423">A single-precision floating-point number to be rounded.</span></span></param>
        <param name="digits"><span data-ttu-id="50d2c-424">Die Anzahl von Dezimalstellen im Rückgabewert.</span><span class="sxs-lookup"><span data-stu-id="50d2c-424">The number of fractional digits in the return value.</span></span></param>
        <param name="mode"><span data-ttu-id="50d2c-425">Angabe, wie <paramref name="x" /> gerundet werden soll, wenn der Wert genau in der Mitte zwischen zwei anderen Zahlen liegt.</span><span class="sxs-lookup"><span data-stu-id="50d2c-425">Specification for how to round <paramref name="x" /> if it is midway between two other numbers.</span></span></param>
        <summary><span data-ttu-id="50d2c-426">Rundet einen Gleitkommawert mit einfacher Genauigkeit auf die angegebene Anzahl Dezimalstellen und verwendet den angegebenen Rundungsmodus für Mittelpunktwerte.</span><span class="sxs-lookup"><span data-stu-id="50d2c-426">Rounds a single-precision floating-point value to a specified number of fractional digits, and uses the specified rounding convention for midpoint values.</span></span></summary>
        <returns><span data-ttu-id="50d2c-427">Die Zahl, die <paramref name="x" /> am nächsten liegt und deren Anzahl von Dezimalstellen gleich <paramref name="digits" /> ist.</span><span class="sxs-lookup"><span data-stu-id="50d2c-427">The number nearest to <paramref name="x" /> that has a number of fractional digits equal to <paramref name="digits" />.</span></span> <span data-ttu-id="50d2c-428">Wenn <paramref name="x" /> weniger Dezimalstellen als <paramref name="digits" /> hat, wird <paramref name="x" /> unverändert zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="50d2c-428">If <paramref name="x" /> has fewer fractional digits than <paramref name="digits" />, <paramref name="x" /> is returned unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="50d2c-429">Der Wert des `digits` Arguments kann zwischen 0 und 6 liegen.</span><span class="sxs-lookup"><span data-stu-id="50d2c-429">The value of the `digits` argument can range from 0 to 6.</span></span> <span data-ttu-id="50d2c-430">Beachten Sie, dass 6 die maximale Anzahl von ganzzahligen und Bruch Ziffern ist, die vom <xref:System.Single> Typ unterstützt werden.</span><span class="sxs-lookup"><span data-stu-id="50d2c-430">Note that 6 is the maximum number of integral and fractional digits supported by the <xref:System.Single> type.</span></span>


[!INCLUDE[midpoint-rounding](~/includes/floating-point-equality.md)]

<span data-ttu-id="50d2c-431">Wenn der Wert des `x` Arguments <xref:System.Single.NaN?displayProperty=nameWithType>ist, gibt die Methode <xref:System.Single.NaN?displayProperty=nameWithType>zurück.</span><span class="sxs-lookup"><span data-stu-id="50d2c-431">If the value of the `x` argument is <xref:System.Single.NaN?displayProperty=nameWithType>, the method returns <xref:System.Single.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="50d2c-432">Wenn `x` ist <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, gibt die Methode zurück <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>bzw.</span><span class="sxs-lookup"><span data-stu-id="50d2c-432">If `x` is <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, the method returns <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, respectively.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="50d2c-433"><paramref name="digits" /> ist kleiner als 0 (null) oder größer als 6.</span><span class="sxs-lookup"><span data-stu-id="50d2c-433"><paramref name="digits" /> is less than 0 or greater than 6.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="50d2c-434"><paramref name="mode" /> ist kein gültiger Wert von <see cref="T:System.MidpointRounding" />.</span><span class="sxs-lookup"><span data-stu-id="50d2c-434"><paramref name="mode" /> is not a valid value of <see cref="T:System.MidpointRounding" />.</span></span></exception>
        <altmember cref="M:System.MathF.Ceiling(System.Single)" />
        <altmember cref="M:System.MathF.Floor(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="ScaleB">
      <MemberSignature Language="C#" Value="public static float ScaleB (float x, int n);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ScaleB(float32 x, int32 n) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.ScaleB(System.Single,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ScaleB (x As Single, n As Integer) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float ScaleB(float x, int n);" />
      <MemberSignature Language="F#" Value="static member ScaleB : single * int -&gt; single" Usage="System.MathF.ScaleB (x, n)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="n" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-435">Eine Gleitkommazahl mit einfacher Genauigkeit, die den Basiswert darstellt.</span><span class="sxs-lookup"><span data-stu-id="50d2c-435">A single-precision floating-point number that specifies the base value.</span></span></param>
        <param name="n"><span data-ttu-id="50d2c-436">Eine Gleitkommazahl mit einfacher Genauigkeit, die den Exponenten darstellt.</span><span class="sxs-lookup"><span data-stu-id="50d2c-436">A single-precision floating-point number that specifies the power.</span></span></param>
        <summary><span data-ttu-id="50d2c-437">Gibt x \* 2^n effizient berechnet zurück.</span><span class="sxs-lookup"><span data-stu-id="50d2c-437">Returns x \* 2^n computed efficiently.</span></span></summary>
        <returns><span data-ttu-id="50d2c-438">x \* 2^n effizient berechnet.</span><span class="sxs-lookup"><span data-stu-id="50d2c-438">x \* 2^n computed efficiently.</span></span></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Sign(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (x As Single) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(float x);" />
      <MemberSignature Language="F#" Value="static member Sign : single -&gt; int" Usage="System.MathF.Sign x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-439">Eine Zahl mit Vorzeichen.</span><span class="sxs-lookup"><span data-stu-id="50d2c-439">A signed number.</span></span></param>
        <summary><span data-ttu-id="50d2c-440">Gibt eine ganze Zahl zurück, die das Vorzeichen einer Gleitkommazahl mit einfacher Genauigkeit angibt.</span><span class="sxs-lookup"><span data-stu-id="50d2c-440">Returns an integer that indicates the sign of a single-precision floating-point number.</span></span></summary>
        <returns><span data-ttu-id="50d2c-441">Eine Zahl, die das Vorzeichen von <paramref name="x" /> angibt, wie in der folgenden Tabelle veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="50d2c-441">A number that indicates the sign of <paramref name="x" />, as shown in the following table.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="50d2c-442">Rückgabewert</span><span class="sxs-lookup"><span data-stu-id="50d2c-442">Return value</span></span> 
 </term><description> <span data-ttu-id="50d2c-443">Bedeutung</span><span class="sxs-lookup"><span data-stu-id="50d2c-443">Meaning</span></span> 
 </description></listheader><item><term> <span data-ttu-id="50d2c-444">-1</span><span class="sxs-lookup"><span data-stu-id="50d2c-444">-1</span></span> 
 </term><description><span data-ttu-id="50d2c-445"><paramref name="x" /> ist kleiner als Null.</span><span class="sxs-lookup"><span data-stu-id="50d2c-445"><paramref name="x" /> is less than zero.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="50d2c-446">0</span><span class="sxs-lookup"><span data-stu-id="50d2c-446">0</span></span> 
 </term><description><span data-ttu-id="50d2c-447"><paramref name="x" /> ist gleich 0 (null).</span><span class="sxs-lookup"><span data-stu-id="50d2c-447"><paramref name="x" /> is equal to zero.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="50d2c-448">1</span><span class="sxs-lookup"><span data-stu-id="50d2c-448">1</span></span> 
 </term><description><span data-ttu-id="50d2c-449"><paramref name="x" /> ist größer als 0 (null).</span><span class="sxs-lookup"><span data-stu-id="50d2c-449"><paramref name="x" /> is greater than zero.</span></span>  
  
 </description></item></list></returns>
        <remarks></remarks>
        <exception cref="T:System.ArithmeticException"><span data-ttu-id="50d2c-450"><paramref name="x" /> ist gleich <see cref="F:System.Single.NaN" />.</span><span class="sxs-lookup"><span data-stu-id="50d2c-450"><paramref name="x" /> is equal to <see cref="F:System.Single.NaN" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Sin">
      <MemberSignature Language="C#" Value="public static float Sin (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sin(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Sin(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sin (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Sin(float x);" />
      <MemberSignature Language="F#" Value="static member Sin : single -&gt; single" Usage="System.MathF.Sin x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-451">Ein im Bogenmaß angegebener Winkel.</span><span class="sxs-lookup"><span data-stu-id="50d2c-451">An angle, measured in radians.</span></span></param>
        <summary><span data-ttu-id="50d2c-452">Gibt den Sinus des angegebenen Winkels zurück.</span><span class="sxs-lookup"><span data-stu-id="50d2c-452">Returns the sine of the specified angle.</span></span></summary>
        <returns><span data-ttu-id="50d2c-453">Der Sinus von <paramref name="x" />.</span><span class="sxs-lookup"><span data-stu-id="50d2c-453">The sine of <paramref name="x" />.</span></span> <span data-ttu-id="50d2c-454">Wenn <paramref name="x" /> gleich <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" /> oder <see cref="F:System.Single.PositiveInfinity" /> ist, wird <see cref="F:System.Single.NaN" /> von dieser Methode zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="50d2c-454">If <paramref name="x" /> is equal to <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" />, or <see cref="F:System.Single.PositiveInfinity" />, this method returns <see cref="F:System.Single.NaN" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50d2c-455">Der Winkel, der `x`, muss im Bogenmaße liegen.</span><span class="sxs-lookup"><span data-stu-id="50d2c-455">The angle, `x`, must be in radians.</span></span> <span data-ttu-id="50d2c-456">Multiplizieren Sie <xref:System.MathF.PI?displayProperty=nameWithType>/180, um Grad in Bogenmaß zu konvertieren.</span><span class="sxs-lookup"><span data-stu-id="50d2c-456">Multiply by <xref:System.MathF.PI?displayProperty=nameWithType>/180 to convert degrees to radians.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static float Sinh (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sinh(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Sinh(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sinh (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Sinh(float x);" />
      <MemberSignature Language="F#" Value="static member Sinh : single -&gt; single" Usage="System.MathF.Sinh x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-457">Ein im Bogenmaß angegebener Winkel.</span><span class="sxs-lookup"><span data-stu-id="50d2c-457">An angle, measured in radians.</span></span></param>
        <summary><span data-ttu-id="50d2c-458">Gibt den Hyperbelsinus des angegebenen Winkels zurück.</span><span class="sxs-lookup"><span data-stu-id="50d2c-458">Returns the hyperbolic sine of the specified angle.</span></span></summary>
        <returns><span data-ttu-id="50d2c-459">Der Hyperbelsinus von <paramref name="x" />.</span><span class="sxs-lookup"><span data-stu-id="50d2c-459">The hyperbolic sine of <paramref name="x" />.</span></span> <span data-ttu-id="50d2c-460">Wenn <paramref name="x" /> gleich <see cref="F:System.Single.NegativeInfinity" />, <see cref="F:System.Single.PositiveInfinity" /> oder <see cref="F:System.Single.NaN" /> ist, gibt diese Methode einen <see cref="T:System.Single" /> mit dem Wert <paramref name="x" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="50d2c-460">If <paramref name="x" /> is equal to <see cref="F:System.Single.NegativeInfinity" />, <see cref="F:System.Single.PositiveInfinity" />, or <see cref="F:System.Single.NaN" />, this method returns a <see cref="T:System.Single" /> equal to <paramref name="x" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50d2c-461">Der Winkel, der `x`, muss im Bogenmaße liegen.</span><span class="sxs-lookup"><span data-stu-id="50d2c-461">The angle, `x`, must be in radians.</span></span> <span data-ttu-id="50d2c-462">Multiplizieren Sie <xref:System.MathF.PI?displayProperty=nameWithType>/180, um Grad in Bogenmaß zu konvertieren.</span><span class="sxs-lookup"><span data-stu-id="50d2c-462">Multiply by <xref:System.MathF.PI?displayProperty=nameWithType>/180 to convert degrees to radians.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sqrt">
      <MemberSignature Language="C#" Value="public static float Sqrt (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sqrt(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Sqrt(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sqrt (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Sqrt(float x);" />
      <MemberSignature Language="F#" Value="static member Sqrt : single -&gt; single" Usage="System.MathF.Sqrt x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-463">Die Zahl, deren Quadratwurzel bestimmt werden soll.</span><span class="sxs-lookup"><span data-stu-id="50d2c-463">The number whose square root is to be found.</span></span></param>
        <summary><span data-ttu-id="50d2c-464">Gibt die Quadratwurzel einer angegebenen Zahl zurück.</span><span class="sxs-lookup"><span data-stu-id="50d2c-464">Returns the square root of a specified number.</span></span></summary>
        <returns><span data-ttu-id="50d2c-465">Einer der Werte aus der folgenden Tabelle.</span><span class="sxs-lookup"><span data-stu-id="50d2c-465">One of the values in the following table.</span></span>  
  
 <list type="table"><listheader><term><span data-ttu-id="50d2c-466"><paramref name="x" />-Parameter</span><span class="sxs-lookup"><span data-stu-id="50d2c-466"><paramref name="x" /> parameter</span></span> 
 </term><description> <span data-ttu-id="50d2c-467">Rückgabewert</span><span class="sxs-lookup"><span data-stu-id="50d2c-467">Return value</span></span> 
 </description></listheader><item><term> <span data-ttu-id="50d2c-468">0 oder positiv</span><span class="sxs-lookup"><span data-stu-id="50d2c-468">Zero or positive</span></span> 
 </term><description> <span data-ttu-id="50d2c-469">Die positive Quadratwurzel von <paramref name="x" />.</span><span class="sxs-lookup"><span data-stu-id="50d2c-469">The positive square root of <paramref name="x" />.</span></span>  
  
 </description></item><item><term> <span data-ttu-id="50d2c-470">Negativ</span><span class="sxs-lookup"><span data-stu-id="50d2c-470">Negative</span></span> 
 </term><description><see cref="F:System.Single.NaN" /></description></item><item><term> <span data-ttu-id="50d2c-471">Entspricht <see cref="F:System.Single.NaN" />.</span><span class="sxs-lookup"><span data-stu-id="50d2c-471">Equals <see cref="F:System.Single.NaN" /></span></span></term><description><see cref="F:System.Single.NaN" /></description></item><item><term> <span data-ttu-id="50d2c-472">Entspricht <see cref="F:System.Single.PositiveInfinity" />.</span><span class="sxs-lookup"><span data-stu-id="50d2c-472">Equals <see cref="F:System.Single.PositiveInfinity" /></span></span></term><description><see cref="F:System.Single.PositiveInfinity" /></description></item></list></returns>
        <remarks></remarks>
        <altmember cref="M:System.MathF.Pow(System.Single,System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Tan">
      <MemberSignature Language="C#" Value="public static float Tan (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Tan(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Tan(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tan (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Tan(float x);" />
      <MemberSignature Language="F#" Value="static member Tan : single -&gt; single" Usage="System.MathF.Tan x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-473">Ein im Bogenmaß angegebener Winkel.</span><span class="sxs-lookup"><span data-stu-id="50d2c-473">An angle, measured in radians.</span></span></param>
        <summary><span data-ttu-id="50d2c-474">Gibt den Tangens des angegebenen Winkels zurück.</span><span class="sxs-lookup"><span data-stu-id="50d2c-474">Returns the tangent of the specified angle.</span></span></summary>
        <returns><span data-ttu-id="50d2c-475">Der Tangens von <paramref name="x" />.</span><span class="sxs-lookup"><span data-stu-id="50d2c-475">The tangent of <paramref name="x" />.</span></span> <span data-ttu-id="50d2c-476">Wenn <paramref name="x" /> gleich <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" /> oder <see cref="F:System.Single.PositiveInfinity" /> ist, wird <see cref="F:System.Single.NaN" /> von dieser Methode zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="50d2c-476">If <paramref name="x" /> is equal to <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" />, or <see cref="F:System.Single.PositiveInfinity" />, this method returns <see cref="F:System.Single.NaN" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50d2c-477">Der Winkel, der `x`, muss im Bogenmaße liegen.</span><span class="sxs-lookup"><span data-stu-id="50d2c-477">The angle, `x`, must be in radians.</span></span> <span data-ttu-id="50d2c-478">Multiplizieren Sie <xref:System.MathF.PI?displayProperty=nameWithType>/180, um Grad in Bogenmaß zu konvertieren.</span><span class="sxs-lookup"><span data-stu-id="50d2c-478">Multiply by <xref:System.MathF.PI?displayProperty=nameWithType>/180 to convert degrees to radians.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static float Tanh (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Tanh(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Tanh(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tanh (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Tanh(float x);" />
      <MemberSignature Language="F#" Value="static member Tanh : single -&gt; single" Usage="System.MathF.Tanh x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-479">Ein im Bogenmaß angegebener Winkel.</span><span class="sxs-lookup"><span data-stu-id="50d2c-479">An angle, measured in radians.</span></span></param>
        <summary><span data-ttu-id="50d2c-480">Gibt den Hyperbeltangens des angegebenen Winkels zurück.</span><span class="sxs-lookup"><span data-stu-id="50d2c-480">Returns the hyperbolic tangent of the specified angle.</span></span></summary>
        <returns><span data-ttu-id="50d2c-481">Der Hyperbeltangens von <paramref name="x" />.</span><span class="sxs-lookup"><span data-stu-id="50d2c-481">The hyperbolic tangent of <paramref name="x" />.</span></span> <span data-ttu-id="50d2c-482">Wenn <paramref name="x" /> gleich <see cref="F:System.Single.NegativeInfinity" /> ist, gibt diese Methode -1 zurück.</span><span class="sxs-lookup"><span data-stu-id="50d2c-482">If <paramref name="x" /> is equal to <see cref="F:System.Single.NegativeInfinity" />, this method returns -1.</span></span> <span data-ttu-id="50d2c-483">Wenn "value" gleich <see cref="F:System.Single.PositiveInfinity" /> ist, gibt diese Methode 1 zurück.</span><span class="sxs-lookup"><span data-stu-id="50d2c-483">If value is equal to <see cref="F:System.Single.PositiveInfinity" />, this method returns 1.</span></span> <span data-ttu-id="50d2c-484">Wenn <paramref name="x" /> gleich <see cref="F:System.Single.NaN" /> ist, gibt diese Methode <see cref="F:System.Single.NaN" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="50d2c-484">If <paramref name="x" /> is equal to <see cref="F:System.Single.NaN" />, this method returns <see cref="F:System.Single.NaN" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="50d2c-485">Der Winkel, der `x`, muss im Bogenmaße liegen.</span><span class="sxs-lookup"><span data-stu-id="50d2c-485">The angle, `x`, must be in radians.</span></span> <span data-ttu-id="50d2c-486">Multiplizieren Sie <xref:System.MathF.PI?displayProperty=nameWithType>/180, um Grad in Bogenmaß zu konvertieren.</span><span class="sxs-lookup"><span data-stu-id="50d2c-486">Multiply by <xref:System.MathF.PI?displayProperty=nameWithType>/180 to convert degrees to radians.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Truncate">
      <MemberSignature Language="C#" Value="public static float Truncate (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Truncate(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Truncate(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Truncate (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Truncate(float x);" />
      <MemberSignature Language="F#" Value="static member Truncate : single -&gt; single" Usage="System.MathF.Truncate x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="50d2c-487">Eine abzuschneidende Zahl.</span><span class="sxs-lookup"><span data-stu-id="50d2c-487">A number to truncate.</span></span></param>
        <summary><span data-ttu-id="50d2c-488">Berechnet den ganzzahligen Teil einer angegebenen Gleitkommazahl mit einfacher Genauigkeit.</span><span class="sxs-lookup"><span data-stu-id="50d2c-488">Calculates the integral part of a specified single-precision floating-point number.</span></span></summary>
        <returns><span data-ttu-id="50d2c-489">Der ganzzahlige Teil von <paramref name="x" />, d. h. die Zahl, die übrig bleibt, wenn alle Dezimalstellen verworfen wurden, oder einer der Werte in der folgenden Tabelle.</span><span class="sxs-lookup"><span data-stu-id="50d2c-489">The integral part of <paramref name="x" />; that is, the number that remains after any fractional digits have been discarded, or one of the values listed in the following table.</span></span>  
  
 <list type="table"><listheader><term><paramref name="x" /></term><description> <span data-ttu-id="50d2c-490">Rückgabewert</span><span class="sxs-lookup"><span data-stu-id="50d2c-490">Return value</span></span> 
 </description></listheader><item><term><see cref="F:System.Single.NaN" /></term><description><see cref="F:System.Single.NaN" /></description></item><item><term><see cref="F:System.Single.NegativeInfinity" /></term><description><see cref="F:System.Single.NegativeInfinity" /></description></item><item><term><see cref="F:System.Single.PositiveInfinity" /></term><description><see cref="F:System.Single.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="50d2c-491"><xref:System.MathF.Truncate%2A> rundet `x` auf die nächste ganze Zahl in Richtung 0 (null).</span><span class="sxs-lookup"><span data-stu-id="50d2c-491"><xref:System.MathF.Truncate%2A> rounds `x` to the nearest integer towards zero.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.MathF.Round" />
        <altmember cref="M:System.MathF.Ceiling(System.Single)" />
        <altmember cref="M:System.MathF.Floor(System.Single)" />
      </Docs>
    </Member>
  </Members>
</Type>
