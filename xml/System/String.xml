<Type Name="String" FullName="System.String">
  <Metadata><Meta Name="ms.openlocfilehash" Value="19deeefaf1553b2ecb7fd8839a8a7f26159bb5ba" /><Meta Name="ms.sourcegitcommit" Value="05b28af3128fd8a2fe51178c9a1cc798d4601bf7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/12/2020" /><Meta Name="ms.locfileid" Value="83230776" /></Metadata><TypeSignature Language="C#" Value="public sealed class String : IComparable, IComparable&lt;string&gt;, IConvertible, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="DocId" Value="T:System.String" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements IComparable, IComparable(Of String), IConvertible, IEnumerable(Of Char), IEquatable(Of String)" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : IComparable, IComparable&lt;System::String ^&gt;, IConvertible, IEquatable&lt;System::String ^&gt;, System::Collections::Generic::IEnumerable&lt;char&gt;" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface seq&lt;char&gt;&#xA;    interface IEnumerable&#xA;    interface IComparable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface IConvertible&#xA;    interface IEquatable&lt;string&gt;" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C#" Value="public sealed class String : ICloneable, IComparable, IComparable&lt;string&gt;, IConvertible, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements ICloneable, IComparable, IComparable(Of String), IConvertible, IEnumerable(Of Char), IEquatable(Of String)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : ICloneable, IComparable, IComparable&lt;System::String ^&gt;, IConvertible, IEquatable&lt;System::String ^&gt;, System::Collections::Generic::IEnumerable&lt;char&gt;" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface seq&lt;char&gt;&#xA;    interface IEnumerable&#xA;    interface ICloneable&#xA;    interface IComparable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface IConvertible&#xA;    interface IEquatable&lt;string&gt;" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface seq&lt;char&gt;&#xA;    interface IEnumerable&#xA;    interface IComparable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface IConvertible&#xA;    interface IEquatable&lt;string&gt;&#xA;    interface ICloneable" FrameworkAlternate="netcore-2.0" />
  <TypeSignature Language="C#" Value="public sealed class String : ICloneable, IComparable, IConvertible, System.Collections.IEnumerable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit string extends System.Object implements class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IConvertible" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements ICloneable, IComparable, IConvertible, IEnumerable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : ICloneable, IComparable, IConvertible, System::Collections::IEnumerable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface IComparable&#xA;    interface ICloneable&#xA;    interface IConvertible&#xA;    interface IEnumerable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface IComparable&#xA;    interface ICloneable&#xA;    interface IConvertible&#xA;    interface IComparable&lt;string&gt;&#xA;    interface seq&lt;char&gt;&#xA;    interface IEnumerable&#xA;    interface IEquatable&lt;string&gt;" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface IComparable&#xA;    interface ICloneable&#xA;    interface IConvertible&#xA;    interface IEnumerable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface seq&lt;char&gt;&#xA;    interface IEquatable&lt;string&gt;" FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C#" Value="public sealed class String : IComparable, IComparable&lt;string&gt;, IEquatable&lt;string&gt;, System.Collections.IEnumerable" FrameworkAlternate="netstandard-1.0;netstandard-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit string extends System.Object implements class System.Collections.IEnumerable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IEquatable`1&lt;string&gt;" FrameworkAlternate="netstandard-1.0;netstandard-1.1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements IComparable, IComparable(Of String), IEnumerable, IEquatable(Of String)" FrameworkAlternate="netstandard-1.0;netstandard-1.1" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : IComparable, IComparable&lt;System::String ^&gt;, IEquatable&lt;System::String ^&gt;, System::Collections::IEnumerable" FrameworkAlternate="netstandard-1.0;netstandard-1.1" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface IEnumerable&#xA;    interface IComparable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface IEquatable&lt;string&gt;" FrameworkAlternate="netstandard-1.0;netstandard-1.1" />
  <TypeSignature Language="C#" Value="public sealed class String : IComparable, IComparable&lt;string&gt;, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" FrameworkAlternate="netstandard-1.2" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IEquatable`1&lt;string&gt;" FrameworkAlternate="netstandard-1.2" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements IComparable, IComparable(Of String), IEnumerable(Of Char), IEquatable(Of String)" FrameworkAlternate="netstandard-1.2" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : IComparable, IComparable&lt;System::String ^&gt;, IEquatable&lt;System::String ^&gt;, System::Collections::Generic::IEnumerable&lt;char&gt;" FrameworkAlternate="netstandard-1.2" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface IComparable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface IEquatable&lt;string&gt;&#xA;    interface seq&lt;char&gt;&#xA;    interface IEnumerable" FrameworkAlternate="netstandard-1.2" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.String&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="8b8da-101">Stellt Text als Sequenz von UTF-16-Codeeinheiten dar.</span><span class="sxs-lookup"><span data-stu-id="8b8da-101">Represents text as a sequence of UTF-16 code units.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks

 <span data-ttu-id="8b8da-102">Eine Zeichenfolge ist eine sequenzielle Auflistung von Zeichen, die zum Darstellen von Text verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-102">A string is a sequential collection of characters that is used to represent text.</span></span> <span data-ttu-id="8b8da-103">Ein <xref:System.String>-Objekt ist eine sequenzielle Auflistung von <xref:System.Char?displayProperty=nameWithType> Objekten, die eine Zeichenfolge darstellen. ein <xref:System.Char?displayProperty=nameWithType>-Objekt entspricht einer UTF-16-Code Einheit.</span><span class="sxs-lookup"><span data-stu-id="8b8da-103">A <xref:System.String> object is a sequential collection of <xref:System.Char?displayProperty=nameWithType> objects that represent a string; a <xref:System.Char?displayProperty=nameWithType> object corresponds to a UTF-16 code unit.</span></span> <span data-ttu-id="8b8da-104">Der Wert des <xref:System.String> Objekts ist der Inhalt der sequenziellen Auflistung von <xref:System.Char?displayProperty=nameWithType> Objekten, und dieser Wert ist unveränderlich (d. h., er ist schreibgeschützt).</span><span class="sxs-lookup"><span data-stu-id="8b8da-104">The value of the <xref:System.String> object is the content of the sequential collection of <xref:System.Char?displayProperty=nameWithType> objects, and that value is immutable (that is, it is read-only).</span></span> <span data-ttu-id="8b8da-105">Weitere Informationen zur Unveränderlichkeit von Zeichen folgen finden Sie im Abschnitt [Unveränderlichkeit und StringBuilder-Klasse](#Immutability) weiter unten in diesem Thema.</span><span class="sxs-lookup"><span data-stu-id="8b8da-105">For more information about the immutability of strings, see the [Immutability and the StringBuilder class](#Immutability) section later in this topic.</span></span> <span data-ttu-id="8b8da-106">Die maximale Größe eines <xref:System.String> Objekts im Arbeitsspeicher beträgt 2 GB oder ungefähr 1 Milliarde Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-106">The maximum size of a <xref:System.String> object in memory is 2GB, or about 1 billion characters.</span></span>

<span data-ttu-id="8b8da-107">Weitere Informationen zu Unicode, UTF-16, Code Einheiten, Code Punkten und den <xref:System.Char>-und <xref:System.Text.Rune> Typen finden Sie unter [Einführung in die Zeichencodierung in .net](~/docs/dotnet/standard/base-types/character-encoding-introduction.md).</span><span class="sxs-lookup"><span data-stu-id="8b8da-107">For more information about Unicode, UTF-16, code units, code points, and the <xref:System.Char> and <xref:System.Text.Rune> types, see [Introduction to character encoding in .NET](~/docs/dotnet/standard/base-types/character-encoding-introduction.md).</span></span>

 <span data-ttu-id="8b8da-108">In diesem Abschnitt</span><span class="sxs-lookup"><span data-stu-id="8b8da-108">In this section:</span></span>

 <span data-ttu-id="8b8da-109">[Instanziieren eines String-Objekts](#Instantiation)</span><span class="sxs-lookup"><span data-stu-id="8b8da-109">[Instantiate a String object](#Instantiation)</span></span>\
 <span data-ttu-id="8b8da-110">[Char-Objekte und Unicode-Zeichen](#Characters)</span><span class="sxs-lookup"><span data-stu-id="8b8da-110">[Char objects and Unicode characters](#Characters)</span></span>\
 <span data-ttu-id="8b8da-111">Zeichen folgen [und Unicode-Standard](#Unicode)</span><span class="sxs-lookup"><span data-stu-id="8b8da-111">[Strings and The Unicode Standard](#Unicode)</span></span>\
 <span data-ttu-id="8b8da-112">[Zeichen folgen und eingebettete NULL-Zeichen](#EmbeddedNulls)</span><span class="sxs-lookup"><span data-stu-id="8b8da-112">[Strings and embedded null characters](#EmbeddedNulls)</span></span>\
 <span data-ttu-id="8b8da-113">\ von Zeichen folgen [und Indizes](#Indexes)</span><span class="sxs-lookup"><span data-stu-id="8b8da-113">[Strings and indexes](#Indexes)\</span></span>
 <span data-ttu-id="8b8da-114">[NULL-Zeichen folgen und leere](#Nulls) Zeichen folgen</span><span class="sxs-lookup"><span data-stu-id="8b8da-114">[Null strings and empty strings](#Nulls)</span></span>\
 <span data-ttu-id="8b8da-115">[Unveränderlichkeit und die StringBuilder-Klasse](#Immutability)</span><span class="sxs-lookup"><span data-stu-id="8b8da-115">[Immutability and the StringBuilder class](#Immutability)</span></span>\
 <span data-ttu-id="8b8da-116">[Ordinalzahl im Vergleich zu Kultur abhängigen Vorgängen](#CultureSensitive)</span><span class="sxs-lookup"><span data-stu-id="8b8da-116">[Ordinal vs. culture-sensitive operations](#CultureSensitive)</span></span>\
 <span data-ttu-id="8b8da-117">[Normalisierung](#Normalization)</span><span class="sxs-lookup"><span data-stu-id="8b8da-117">[Normalization](#Normalization)</span></span>\
 [<span data-ttu-id="8b8da-118">Zeichen folgen Vorgänge nach Kategorie</span><span class="sxs-lookup"><span data-stu-id="8b8da-118">String operations by category</span></span>](#ByCategory)

<a name="Instantiation"></a>
## <a name="instantiate-a-string-object"></a><span data-ttu-id="8b8da-119">Instanziieren eines String-Objekts</span><span class="sxs-lookup"><span data-stu-id="8b8da-119">Instantiate a String object</span></span>
 <span data-ttu-id="8b8da-120">Sie können ein <xref:System.String> Objekt auf folgende Weise instanziieren:</span><span class="sxs-lookup"><span data-stu-id="8b8da-120">You can instantiate a <xref:System.String> object in the following ways:</span></span>

-   <span data-ttu-id="8b8da-121">Durch Zuweisen eines Zeichenfolgenliterals zu einer <xref:System.String> Variable.</span><span class="sxs-lookup"><span data-stu-id="8b8da-121">By assigning a string literal to a <xref:System.String> variable.</span></span> <span data-ttu-id="8b8da-122">Dies ist die am häufigsten verwendete Methode zum Erstellen einer Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-122">This is the most commonly used method for creating a string.</span></span> <span data-ttu-id="8b8da-123">Im folgenden Beispiel wird die Zuweisung verwendet, um mehrere Zeichen folgen zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-123">The following example uses assignment to create several strings.</span></span> <span data-ttu-id="8b8da-124">Beachten Sie, C#dass in, da der umgekehrte Schrägstrich (\\) ein Escapezeichen ist, literale umgekehrte Schrägstriche in einer Zeichenfolge mit Escapezeichen versehen oder die gesamte Zeichenfolge @-quotedwerden muss.</span><span class="sxs-lookup"><span data-stu-id="8b8da-124">Note that in C#, because the backslash (\\) is an escape character, literal backslashes in a string must be escaped or the entire string must be @-quoted.</span></span>

     [!code-cpp[System.String.Class.Instantiate#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate1.cpp#1)]
     [!code-csharp-interactive[System.String.Class.Instantiate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#1)]
     [!code-vb[System.String.Class.Instantiate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#1)]

-   <span data-ttu-id="8b8da-125">Durch Aufrufen eines <xref:System.String>-Klassenkonstruktors.</span><span class="sxs-lookup"><span data-stu-id="8b8da-125">By calling a <xref:System.String> class constructor.</span></span> <span data-ttu-id="8b8da-126">Im folgenden Beispiel werden Zeichen folgen durch Aufrufen mehrerer Klassenkonstruktoren instanziiert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-126">The following example instantiates strings by calling several class constructors.</span></span> <span data-ttu-id="8b8da-127">Beachten Sie, dass einige der Konstruktoren Zeiger auf Zeichen Arrays oder signierte Byte Arrays als Parameter enthalten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-127">Note that some of the constructors include pointers to character arrays or signed byte arrays as parameters.</span></span> <span data-ttu-id="8b8da-128">Der Visual Basic unterstützt keine Aufrufe dieser Konstruktoren.</span><span class="sxs-lookup"><span data-stu-id="8b8da-128">Visual Basic does not support calls to these constructors.</span></span> <span data-ttu-id="8b8da-129">Ausführliche Informationen zu <xref:System.String>-Konstruktoren finden Sie in der <xref:System.String.%23ctor%2A>-konstruktorzusammenfassung.</span><span class="sxs-lookup"><span data-stu-id="8b8da-129">For detailed information about <xref:System.String> constructors, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>

     [!code-cpp[System.String.Class.Instantiate#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate2.cpp#2)]
     [!code-csharp[System.String.Class.Instantiate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#2)]
     [!code-vb[System.String.Class.Instantiate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#2)]

-   <span data-ttu-id="8b8da-130">Verwenden Sie den Operator für die Zeichen folgen Verkettung ( C# + in und & oder + in Visual Basic), um eine einzelne Zeichenfolge aus einer beliebigen Kombination von <xref:System.String>-Instanzen und Zeichenfolgenliteralen zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-130">By using the string concatenation operator (+ in C# and & or + in Visual Basic) to create a single string from any combination of <xref:System.String> instances and string literals.</span></span> <span data-ttu-id="8b8da-131">Das folgende Beispiel veranschaulicht die Verwendung des Operators Operator für Zeichen folgen Verkettung.</span><span class="sxs-lookup"><span data-stu-id="8b8da-131">The following example illustrates the use of the string concatenation operator.</span></span>

     [!code-cpp[System.String.Class.Instantiate#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#3)]
     [!code-csharp-interactive[System.String.Class.Instantiate#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#3)]
     [!code-vb[System.String.Class.Instantiate#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#3)]

-   <span data-ttu-id="8b8da-132">Durch Abrufen einer Eigenschaft oder Aufrufen einer Methode, die eine Zeichenfolge zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-132">By retrieving a property or calling a method that returns a string.</span></span> <span data-ttu-id="8b8da-133">Im folgenden Beispiel wird die-Methode der <xref:System.String>-Klasse verwendet, um eine Teil Zeichenfolge aus einer größeren Zeichenfolge zu extrahieren.</span><span class="sxs-lookup"><span data-stu-id="8b8da-133">The following example uses the methods of the <xref:System.String> class to extract a substring from a larger string.</span></span>

     [!code-cpp[System.String.Class.Instantiate#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#4)]
     [!code-csharp-interactive[System.String.Class.Instantiate#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#4)]
     [!code-vb[System.String.Class.Instantiate#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#4)]

-   <span data-ttu-id="8b8da-134">Durch Aufrufen einer Formatierungs Methode, um einen Wert oder ein Objekt in seine Zeichen folgen Darstellung zu konvertieren.</span><span class="sxs-lookup"><span data-stu-id="8b8da-134">By calling a formatting method to convert a value or object to its string representation.</span></span> <span data-ttu-id="8b8da-135">Im folgenden Beispiel wird die Funktion für die [kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) verwendet, um die Zeichen folgen Darstellung von zwei-Objekten in eine Zeichenfolge einzubetten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-135">The following example uses the [composite formatting](~/docs/standard/base-types/composite-formatting.md) feature to embed the string representation of two objects into a string.</span></span>

     [!code-cpp[System.String.Class.Instantiate#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#5)]
     [!code-csharp[System.String.Class.Instantiate#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#5)]
     [!code-vb[System.String.Class.Instantiate#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#5)]

<a name="Characters"></a>
## <a name="char-objects-and-unicode-characters"></a><span data-ttu-id="8b8da-136">Char-Objekte und Unicode-Zeichen</span><span class="sxs-lookup"><span data-stu-id="8b8da-136">Char objects and Unicode characters</span></span>
 <span data-ttu-id="8b8da-137">Jedes Zeichen in einer Zeichenfolge wird durch einen Unicode-Skalarwert definiert, auch als Unicode-Codepunkt oder als Ordnungszahl (numerisch) des Unicode-Zeichens bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-137">Each character in a string is defined by a Unicode scalar value, also called a Unicode code point or the ordinal (numeric) value of the Unicode character.</span></span> <span data-ttu-id="8b8da-138">Jeder Codepunkt wird mithilfe der UTF-16-Codierung codiert, und der numerische Wert jedes Elements der Codierung wird durch ein <xref:System.Char> Objekt dargestellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-138">Each code point is encoded by using UTF-16 encoding, and the numeric value of each element of the encoding is represented by a <xref:System.Char> object.</span></span>

> [!NOTE]
>  <span data-ttu-id="8b8da-139">Beachten Sie Folgendes: da eine <xref:System.String>-Instanz aus einer sequenziellen Auflistung von UTF-16-Code Einheiten besteht, ist es möglich, ein <xref:System.String> Objekt zu erstellen, das keine wohlgeformte Unicode-Zeichenfolge ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-139">Note that, because a <xref:System.String> instance consists of a sequential collection of UTF-16 code units, it is possible to create a <xref:System.String> object that is not a well-formed Unicode string.</span></span> <span data-ttu-id="8b8da-140">Beispielsweise ist es möglich, eine Zeichenfolge zu erstellen, die ein niedriges Ersatz Zeichen ohne entsprechendes hohes Ersatz Zeichen enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-140">For example, it is possible to create a string that has a low surrogate without a corresponding high surrogate.</span></span> <span data-ttu-id="8b8da-141">Obwohl einige Methoden, z. b. die Methoden zum Codieren und Decodieren von Objekten im <xref:System.Text>-Namespace, möglicherweise Prüfungen durchführen, um sicherzustellen, dass Zeichen folgen wohl geformt sind, <xref:System.String> Klassenmember nicht sicherstellen, dass eine Zeichenfolge wohl geformt ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-141">Although some methods, such as the methods of encoding and decoding objects in the <xref:System.Text> namespace, may performs checks to ensure that strings are well-formed, <xref:System.String> class members don't ensure that a string is well-formed.</span></span>

 <span data-ttu-id="8b8da-142">Ein einzelnes <xref:System.Char> Objekt stellt normalerweise einen einzelnen Codepunkt dar. Dies bedeutet, dass der numerische Wert des <xref:System.Char> dem Codepunkt entspricht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-142">A single <xref:System.Char> object usually represents a single code point; that is, the numeric value of the <xref:System.Char> equals the code point.</span></span> <span data-ttu-id="8b8da-143">Beispielsweise ist der Codepunkt für das Zeichen "a" U + 0061.</span><span class="sxs-lookup"><span data-stu-id="8b8da-143">For example, the code point for the character "a" is U+0061.</span></span> <span data-ttu-id="8b8da-144">Ein Codepunkt benötigt jedoch möglicherweise mehr als ein codiertes Element (mehr als ein <xref:System.Char> Objekt).</span><span class="sxs-lookup"><span data-stu-id="8b8da-144">However, a code point might require more than one encoded element (more than one <xref:System.Char> object).</span></span> <span data-ttu-id="8b8da-145">Der Unicode-Standard definiert zwei Typen von Zeichen, die mehreren <xref:System.Char> Objekten entsprechen: graphemes und zusätzliche Unicode-Code Punkte, die Zeichen in den zusätzlichen Unicode-Ebenen entsprechen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-145">The Unicode standard defines two types of characters that correspond to multiple <xref:System.Char> objects: graphemes, and Unicode supplementary code points that correspond to characters in the Unicode supplementary planes.</span></span>

-   <span data-ttu-id="8b8da-146">Ein graphemgruppen wird durch ein Basiszeichen gefolgt von einem oder mehreren kombinierten Zeichen dargestellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-146">A grapheme is represented by a base character followed by one or more combining characters.</span></span> <span data-ttu-id="8b8da-147">Beispielsweise wird das Zeichen ä durch ein <xref:System.Char> Objekt dargestellt, dessen Codepunkt u + 0061 ist, gefolgt von einem <xref:System.Char> Objekt, dessen Codepunkt u + 0308 ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-147">For example, the character ä is represented by a <xref:System.Char> object whose code point is U+0061 followed by a <xref:System.Char> object whose code point is U+0308.</span></span> <span data-ttu-id="8b8da-148">Dieses Zeichen kann auch durch ein einzelnes <xref:System.Char> Objekt mit dem Codepunkt U + 00E4 definiert werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-148">This character can also be defined by a single <xref:System.Char> object that has a code point of U+00E4.</span></span> <span data-ttu-id="8b8da-149">Wie im folgenden Beispiel gezeigt, gibt ein Kultur abhängiger Vergleich auf Gleichheit an, dass diese beiden Darstellungen gleich sind, obwohl es sich bei einem normalen Ordinalvergleich nicht um handelt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-149">As the following example shows, a culture-sensitive comparison for equality indicates that these two representations are equal, although an ordinary ordinal comparison does not.</span></span> <span data-ttu-id="8b8da-150">Wenn die beiden Zeichen folgen jedoch normalisiert werden, gibt ein Ordinalvergleich auch an, dass Sie gleich sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-150">However, if the two strings are normalized, an ordinal comparison also indicates that they are equal.</span></span> <span data-ttu-id="8b8da-151">(Weitere Informationen zum Normalisieren von Zeichen folgen finden Sie im Abschnitt zur [Normalisierung](#Normalization) .)</span><span class="sxs-lookup"><span data-stu-id="8b8da-151">(For more information on normalizing strings, see the [Normalization](#Normalization) section.)</span></span>

     [!code-cpp[System.String.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char1.cpp#2)]
     [!code-csharp[System.String.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/grapheme1.cs#2)]
     [!code-vb[System.String.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/grapheme1.vb#2)]

-   <span data-ttu-id="8b8da-152">Ein zusätzlicher Unicode-Codepunkt (ein Ersatz Zeichenpaar) wird durch ein <xref:System.Char> Objekt dargestellt, dessen Codepunkt ein hohes Ersatz Zeichen gefolgt von einem <xref:System.Char> Objekt ist, dessen Codepunkt ein niedriges Ersatz Zeichen ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-152">A Unicode supplementary code point (a surrogate pair) is represented by a <xref:System.Char> object whose code point is a high surrogate followed by a <xref:System.Char> object whose code point is a low surrogate.</span></span> <span data-ttu-id="8b8da-153">Die Code Einheiten der hohen Surrogates reichen von u + D800 und bis u + DBFF.</span><span class="sxs-lookup"><span data-stu-id="8b8da-153">The code units of high surrogates range from U+D800 to U+DBFF.</span></span> <span data-ttu-id="8b8da-154">Die Code Einheiten von niedrigen Surrogates reichen von u + DC00 und bis u + DFFF.</span><span class="sxs-lookup"><span data-stu-id="8b8da-154">The code units of low surrogates range from U+DC00 to U+DFFF.</span></span> <span data-ttu-id="8b8da-155">Ersatzpaare werden verwendet, um Zeichen in den zusätzlichen 16-Unicode-Ebenen darzustellen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-155">Surrogate pairs are used to represent characters in the 16 Unicode supplementary planes.</span></span> <span data-ttu-id="8b8da-156">Das folgende Beispiel erstellt ein Ersatz Zeichen und übergibt es an die <xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType>-Methode, um zu bestimmen, ob es sich um ein Ersatz Zeichenpaar handelt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-156">The following example creates a surrogate character and passes it to the <xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType> method to determine whether it is a surrogate pair.</span></span>

     [!code-cpp[System.String.Class#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char2.cpp#3)]
     [!code-csharp-interactive[System.String.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/surrogate1.cs#3)]
     [!code-vb[System.String.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/surrogate1.vb#3)]

<a name="Unicode"></a>
## <a name="strings-and-the-unicode-standard"></a><span data-ttu-id="8b8da-157">Zeichen folgen und der Unicode-Standard</span><span class="sxs-lookup"><span data-stu-id="8b8da-157">Strings and the Unicode Standard</span></span>
 <span data-ttu-id="8b8da-158">Zeichen in einer Zeichenfolge werden durch UTF-16-codierte Code Einheiten dargestellt, die <xref:System.Char> Werten entsprechen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-158">Characters in a string are represented by UTF-16 encoded code units, which correspond to <xref:System.Char> values.</span></span>

 <span data-ttu-id="8b8da-159">Jedes Zeichen in einer Zeichenfolge verfügt über eine zugeordnete Unicode-Zeichen Kategorie, die von der <xref:System.Globalization.UnicodeCategory> Enumeration in .net dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-159">Each character in a string has an associated Unicode character category, which is represented in .NET by the <xref:System.Globalization.UnicodeCategory> enumeration.</span></span> <span data-ttu-id="8b8da-160">Die Kategorie eines Zeichens oder Ersatz Zeichen Paars kann durch Aufrufen der <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType>-Methode bestimmt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-160">The category of a character or a surrogate pair can be determined by calling the <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType> method.</span></span>

[!INCLUDE[character-categories](~/includes/unicode-categories.md)]

 <span data-ttu-id="8b8da-161">Außerdem unterstützt .NET den Zeichen folgen Vergleich und die Sortierung basierend auf dem Unicode-Standard.</span><span class="sxs-lookup"><span data-stu-id="8b8da-161">In addition, .NET supports string comparison and sorting based on the Unicode standard.</span></span> <span data-ttu-id="8b8da-162">In Versionen der .NET Framework über die [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]verwaltet der .NET Framework eine eigene Tabelle mit Zeichen folgen Daten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-162">In versions of the .NET Framework through the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the .NET Framework maintains its own table of string data.</span></span> <span data-ttu-id="8b8da-163">Dies gilt auch für Versionen der .NET Framework, die mit dem in Windows 7 laufenden [!INCLUDE[net_v45](~/includes/net-v45-md.md)] beginnen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-163">This is also true of versions of the .NET Framework starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] running on Windows 7.</span></span> <span data-ttu-id="8b8da-164">Beginnend mit dem [!INCLUDE[net_v45](~/includes/net-v45-md.md)], das unter Windows 8 und höheren Versionen des Windows-Betriebssystems ausgeführt wird, delegiert die Runtime Zeichen folgen Vergleichs-und Sortierungs Vorgänge an das Betriebssystem.</span><span class="sxs-lookup"><span data-stu-id="8b8da-164">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] running on Window 8 and later versions of the Windows operating system, the runtime delegates string comparison and sorting operations to the operating system.</span></span> <span data-ttu-id="8b8da-165">In .net Core werden Zeichen folgen Vergleich und Sortier Informationen von [internationalen Komponenten für Unicode](http://site.icu-project.org/) -Bibliotheken bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-165">On .NET Core, string comparison and sorting information is provided by [International Components for Unicode](http://site.icu-project.org/) libraries.</span></span> <span data-ttu-id="8b8da-166">In der folgenden Tabelle sind die Versionen von .net und die Versionen des Unicode-Standards aufgeführt, auf denen der Zeichen Vergleich und die Sortierung basieren.</span><span class="sxs-lookup"><span data-stu-id="8b8da-166">The following table lists the versions of .NET and the versions of the Unicode Standard on which character comparison and sorting are based.</span></span>

|<span data-ttu-id="8b8da-167">.NET-Version</span><span class="sxs-lookup"><span data-stu-id="8b8da-167">.NET version</span></span>|<span data-ttu-id="8b8da-168">Version des Unicode-Standards</span><span class="sxs-lookup"><span data-stu-id="8b8da-168">Version of the Unicode Standard</span></span>|
|----------------------------|-------------------------------------|
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[<span data-ttu-id="8b8da-169">The Unicode Standard, Version 4.0.0 (Der Unicode-Standard, Version 4.0.0)</span><span class="sxs-lookup"><span data-stu-id="8b8da-169">The Unicode Standard, Version 4.0.0</span></span>](https://www.unicode.org/versions/Unicode4.0.0/)|
|<span data-ttu-id="8b8da-170">.NET Framework 2.0</span><span class="sxs-lookup"><span data-stu-id="8b8da-170">.NET Framework 2.0</span></span>|[<span data-ttu-id="8b8da-171">The Unicode Standard, Version 5.0.0 (Der Unicode-Standard, Version 5.0.0)</span><span class="sxs-lookup"><span data-stu-id="8b8da-171">The Unicode Standard, Version 5.0.0</span></span>](https://www.unicode.org/versions/Unicode5.0.0)|
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[<span data-ttu-id="8b8da-172">The Unicode Standard, Version 5.0.0 (Der Unicode-Standard, Version 5.0.0)</span><span class="sxs-lookup"><span data-stu-id="8b8da-172">The Unicode Standard, Version 5.0.0</span></span>](https://www.unicode.org/versions/Unicode5.0.0)|
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[<span data-ttu-id="8b8da-173">The Unicode Standard, Version 5.0.0 (Der Unicode-Standard, Version 5.0.0)</span><span class="sxs-lookup"><span data-stu-id="8b8da-173">The Unicode Standard, Version 5.0.0</span></span>](https://www.unicode.org/versions/Unicode5.0.0)|
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] <span data-ttu-id="8b8da-174">und höher unter Windows 7</span><span class="sxs-lookup"><span data-stu-id="8b8da-174">and later on Windows 7</span></span>|[<span data-ttu-id="8b8da-175">The Unicode Standard, Version 5.0.0 (Der Unicode-Standard, Version 5.0.0)</span><span class="sxs-lookup"><span data-stu-id="8b8da-175">The Unicode Standard, Version 5.0.0</span></span>](https://www.unicode.org/versions/Unicode5.0.0)|
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] <span data-ttu-id="8b8da-176">und höher unter Windows 8 und höheren Windows-Betriebssystemen</span><span class="sxs-lookup"><span data-stu-id="8b8da-176">and later on Windows 8 and later Windows operating systems</span></span>|[<span data-ttu-id="8b8da-177">The Unicode Standard, Version 6.3.0 (Der Unicode-Standard, Version 6.3.0)</span><span class="sxs-lookup"><span data-stu-id="8b8da-177">The Unicode Standard, Version 6.3.0</span></span>](https://www.unicode.org/versions/Unicode6.3.0/)|
|<span data-ttu-id="8b8da-178">.NET Core (alle Versionen)</span><span class="sxs-lookup"><span data-stu-id="8b8da-178">.NET Core (all versions)</span></span>|<span data-ttu-id="8b8da-179">Hängt von der Version des Unicode-Standards ab, die vom zugrunde liegenden Betriebssystem unterstützt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-179">Depends on the version of the Unicode Standard supported by the underlying operating system.</span></span>|

<a name="EmbeddedNulls"></a>
## <a name="strings-and-embedded-null-characters"></a><span data-ttu-id="8b8da-180">Zeichen folgen und eingebettete NULL-Zeichen</span><span class="sxs-lookup"><span data-stu-id="8b8da-180">Strings and embedded null characters</span></span>
 <span data-ttu-id="8b8da-181">In .net kann ein <xref:System.String> Objekt eingebettete NULL-Zeichen enthalten, die als Teil der Länge der Zeichenfolge gezählt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-181">In .NET, a <xref:System.String> object can include embedded null characters, which count as a part of the string's length.</span></span> <span data-ttu-id="8b8da-182">In einigen Sprachen, wie z. b. C++C und, gibt ein NULL-Zeichen jedoch das Ende einer Zeichenfolge an. Er wird nicht als Teil der Zeichenfolge betrachtet und nicht als Teil der Länge der Zeichenfolge gezählt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-182">However, in some languages such as C and C++, a null character indicates the end of a string; it is not considered a part of the string and is not counted as part of the string's length.</span></span> <span data-ttu-id="8b8da-183">Dies bedeutet, dass die folgenden allgemeinen Annahmen, die C++ c und Programmierer oder Bibliotheken, die C++ in c geschrieben wurden, nicht unbedingt gültig sind, wenn Sie auf <xref:System.String> Objekte angewendet werden:</span><span class="sxs-lookup"><span data-stu-id="8b8da-183">This means that the following common assumptions that C and C++ programmers or libraries written in C or C++ might make about strings are not necessarily valid when applied to <xref:System.String> objects:</span></span>

-   <span data-ttu-id="8b8da-184">Der Wert, der von den Funktionen `strlen` oder `wcslen` zurückgegeben wird, ist nicht notwendigerweise gleich <xref:System.String.Length%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-184">The value returned by the `strlen` or `wcslen` functions does not necessarily equal <xref:System.String.Length%2A?displayProperty=nameWithType>.</span></span>

-   <span data-ttu-id="8b8da-185">Die durch die `strcpy_s`-oder `wcscpy_s`-Funktion erstellte Zeichenfolge ist nicht notwendigerweise identisch mit der Zeichenfolge, die von der <xref:System.String.Copy%2A?displayProperty=nameWithType>-Methode erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="8b8da-185">The string created by the `strcpy_s` or `wcscpy_s` functions is not necessarily identical to the string created by the <xref:System.String.Copy%2A?displayProperty=nameWithType> method.</span></span>

 <span data-ttu-id="8b8da-186">Stellen Sie sicher, dass System eigener C++ C-Code und Code, der <xref:System.String> Objekte instanziiert, und Code, der <xref:System.String> Objekten über Platt Form Aufrufe weitergeleitet wird, nicht davon ausgehen, dass ein eingebettetes NULL-Zeichen das Ende der Zeichenfolge markiert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-186">You should ensure that native C and C++ code that instantiates <xref:System.String> objects, and code that is passed <xref:System.String> objects through platform invoke, don't assume that an embedded null character marks the end of the string.</span></span>

 <span data-ttu-id="8b8da-187">Eingebettete NULL-Zeichen in einer Zeichenfolge werden auch anders behandelt, wenn eine Zeichenfolge sortiert (oder verglichen) wird und wenn eine Zeichenfolge durchsucht wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-187">Embedded null characters in a string are also treated differently when a string is sorted (or compared) and when a string is searched.</span></span> <span data-ttu-id="8b8da-188">NULL-Zeichen werden ignoriert, wenn Kultur abhängige Vergleiche zwischen zwei Zeichen folgen durchgeführt werden, einschließlich Vergleiche mit der invarianten Kultur.</span><span class="sxs-lookup"><span data-stu-id="8b8da-188">Null characters are ignored when performing culture-sensitive comparisons between two strings, including comparisons using the invariant culture.</span></span> <span data-ttu-id="8b8da-189">Sie werden nur bei ordinalvergleichen ohne Berücksichtigung der Groß-/Kleinschreibung berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-189">They are considered only for ordinal or case-insensitive ordinal comparisons.</span></span> <span data-ttu-id="8b8da-190">Auf der anderen Seite werden eingebettete NULL-Zeichen immer berücksichtigt, wenn eine Zeichenfolge mit Methoden wie <xref:System.String.Contains%2A>, <xref:System.String.StartsWith%2A>und <xref:System.String.IndexOf%2A>durchsucht wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-190">On the other hand, embedded null characters are always considered when searching a string with methods such as <xref:System.String.Contains%2A>, <xref:System.String.StartsWith%2A>, and <xref:System.String.IndexOf%2A>.</span></span>

<a name="Indexes"></a>
## <a name="strings-and-indexes"></a><span data-ttu-id="8b8da-191">Zeichen folgen und Indizes</span><span class="sxs-lookup"><span data-stu-id="8b8da-191">Strings and indexes</span></span>
 <span data-ttu-id="8b8da-192">Ein Index ist die Position eines <xref:System.Char> Objekts (kein Unicode-Zeichen) in einem <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-192">An index is the position of a <xref:System.Char> object (not a Unicode character) in a <xref:System.String>.</span></span> <span data-ttu-id="8b8da-193">Ein Index ist eine Null basierte, nicht negative Zahl, die von der ersten Position in der Zeichenfolge beginnt, die Indexposition 0 (null) ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-193">An index is a zero-based, nonnegative number that starts from the first position in the string, which is index position zero.</span></span> <span data-ttu-id="8b8da-194">Eine Reihe von Suchmethoden, z. b. <xref:System.String.IndexOf%2A> und <xref:System.String.LastIndexOf%2A>, geben den Index eines Zeichens oder einer Teil Zeichenfolge in der Zeichen folgen Instanz zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-194">A number of search methods, such as <xref:System.String.IndexOf%2A> and <xref:System.String.LastIndexOf%2A>, return the index of a character or substring in the string instance.</span></span>

 <span data-ttu-id="8b8da-195">Mit der <xref:System.String.Chars%2A>-Eigenschaft können Sie über die Indexposition in der Zeichenfolge auf einzelne <xref:System.Char> Objekte zugreifen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-195">The <xref:System.String.Chars%2A> property lets you access individual <xref:System.Char> objects by their index position in the string.</span></span> <span data-ttu-id="8b8da-196">Da die <xref:System.String.Chars%2A>-Eigenschaft die Standard Eigenschaft (in Visual Basic) oder der Indexer (in C#) ist, können Sie mithilfe von Code wie dem folgenden auf die einzelnen <xref:System.Char> Objekte in einer Zeichenfolge zugreifen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-196">Because the <xref:System.String.Chars%2A> property is the default property (in Visual Basic) or the indexer (in C#), you can access the individual <xref:System.Char> objects in a string by using code such as the following.</span></span> <span data-ttu-id="8b8da-197">Dieser Code sucht nach Leerzeichen oder Interpunktions Zeichen in einer Zeichenfolge, um zu bestimmen, wie viele Wörter in der Zeichenfolge enthalten sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-197">This code looks for white space or punctuation characters in a string to determine how many words the string contains.</span></span>

 [!code-cpp[System.String.Class#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index1.cpp#4)]
 [!code-csharp-interactive[System.String.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index1.cs#4)]
 [!code-vb[System.String.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index1.vb#4)]

 <span data-ttu-id="8b8da-198">Da die <xref:System.String>-Klasse die <xref:System.Collections.IEnumerable>-Schnittstelle implementiert, können Sie die <xref:System.Char> Objekte in einer Zeichenfolge auch durchlaufen, indem Sie ein `foreach` Konstrukt verwenden, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-198">Because the <xref:System.String> class implements the <xref:System.Collections.IEnumerable> interface, you can also iterate through the <xref:System.Char> objects in a string by using a `foreach` construct, as the following example shows.</span></span>

 [!code-cpp[System.String.Class#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index2.cpp#5)]
 [!code-csharp-interactive[System.String.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index2.cs#5)]
 [!code-vb[System.String.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index2.vb#5)]

 <span data-ttu-id="8b8da-199">Aufeinanderfolgende Indexwerte entsprechen möglicherweise nicht aufeinander folgenden Unicode-Zeichen, da ein Unicode-Zeichen möglicherweise als mehr als ein <xref:System.Char> Objekt codiert wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-199">Consecutive index values might not correspond to consecutive Unicode characters, because a Unicode character might be encoded as more than one <xref:System.Char> object.</span></span> <span data-ttu-id="8b8da-200">Vor allem kann eine Zeichenfolge mehrstufige Text Einheiten enthalten, die durch ein Basiszeichen, gefolgt von einem oder mehreren kombinierten Zeichen oder Ersatz Zeichen Paaren, gebildet werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-200">In particular, a string may contain multi-character units of text that are formed by a base character followed by one or more combining characters or by surrogate pairs.</span></span> <span data-ttu-id="8b8da-201">Verwenden Sie die Klassen <xref:System.Globalization.StringInfo?displayProperty=nameWithType> und <xref:System.Globalization.TextElementEnumerator> oder die <xref:System.String.EnumerateRunes%2A?displayProperty=nameWithType>-Methode und die <xref:System.Text.Rune>-Struktur, um mit Unicode-Zeichen anstelle von <xref:System.Char>-Objekten zu arbeiten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-201">To work with Unicode characters instead of <xref:System.Char> objects, use the <xref:System.Globalization.StringInfo?displayProperty=nameWithType> and <xref:System.Globalization.TextElementEnumerator> classes, or the <xref:System.String.EnumerateRunes%2A?displayProperty=nameWithType> method and the <xref:System.Text.Rune> struct.</span></span> <span data-ttu-id="8b8da-202">Das folgende Beispiel veranschaulicht den Unterschied zwischen Code, der mit <xref:System.Char> Objekten und Code funktioniert, der mit Unicode-Zeichen verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="8b8da-202">The following example illustrates the difference between code that works with <xref:System.Char> objects and code that works with Unicode characters.</span></span> <span data-ttu-id="8b8da-203">Er vergleicht die Anzahl der Zeichen oder Textelemente in jedem Wort eines Satzes.</span><span class="sxs-lookup"><span data-stu-id="8b8da-203">It compares the number of characters or text elements in each word of a sentence.</span></span> <span data-ttu-id="8b8da-204">Die Zeichenfolge enthält zwei Sequenzen eines Basis Zeichens gefolgt von einem kombinierten Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-204">The string includes two sequences of a base character followed by a combining character.</span></span>

 [!code-cpp[System.String.Class#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index3.cpp#6)]
 [!code-csharp-interactive[System.String.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index3.cs#6)]
 [!code-vb[System.String.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index3.vb#6)]

 <span data-ttu-id="8b8da-205">In diesem Beispiel werden Textelemente verwendet, indem die <xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType>-Methode und die <xref:System.Globalization.TextElementEnumerator>-Klasse verwendet werden, um alle Textelemente in einer Zeichenfolge aufzuzählen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-205">This example works with text elements by using the <xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType> method and the <xref:System.Globalization.TextElementEnumerator> class to enumerate all the text elements in a string.</span></span> <span data-ttu-id="8b8da-206">Sie können auch ein Array mit dem Start Index der einzelnen Textelemente abrufen, indem Sie die <xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType>-Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-206">You can also retrieve an array that contains the starting index of each text element by calling the <xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType> method.</span></span>

 <span data-ttu-id="8b8da-207">Weitere Informationen zum Arbeiten mit Text Einheiten anstelle einzelner <xref:System.Char> Werte finden Sie unter Einführung in [die Zeichencodierung in .net](~/docs/dotnet/standard/base-types/character-encoding-introduction.md).</span><span class="sxs-lookup"><span data-stu-id="8b8da-207">For more information about working with units of text rather than individual <xref:System.Char> values, see [Introduction to character encoding in .NET](~/docs/dotnet/standard/base-types/character-encoding-introduction.md).</span></span>

<a name="Nulls"></a>
## <a name="null-strings-and-empty-strings"></a><span data-ttu-id="8b8da-208">NULL-Zeichen folgen und leere Zeichen folgen</span><span class="sxs-lookup"><span data-stu-id="8b8da-208">Null strings and empty strings</span></span>
 <span data-ttu-id="8b8da-209">Eine Zeichenfolge, die deklariert wurde, aber keinem Wert zugewiesen wurde, ist `null`.</span><span class="sxs-lookup"><span data-stu-id="8b8da-209">A string that has been declared but has not been assigned a value is `null`.</span></span> <span data-ttu-id="8b8da-210">Der Versuch, Methoden für diese Zeichenfolge aufzurufen, löst eine <xref:System.NullReferenceException>aus.</span><span class="sxs-lookup"><span data-stu-id="8b8da-210">Attempting to call methods on that string throws a <xref:System.NullReferenceException>.</span></span> <span data-ttu-id="8b8da-211">Eine NULL-Zeichenfolge unterscheidet sich von einer leeren Zeichenfolge. Dies ist eine Zeichenfolge, deren Wert "" oder <xref:System.String.Empty?displayProperty=nameWithType>ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-211">A null string is different from an empty string, which is a string whose value is "" or <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8b8da-212">In einigen Fällen wird eine Ausnahme ausgelöst, wenn entweder eine NULL-Zeichenfolge oder eine leere Zeichenfolge als Argument in einem Methoden Befehl übergeben wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-212">In some cases, passing either a null string or an empty string as an argument in a method call throws an exception.</span></span> <span data-ttu-id="8b8da-213">Wenn Sie z. b. eine NULL-Zeichenfolge an die <xref:System.Int32.Parse%2A?displayProperty=nameWithType>-Methode übergeben, wird eine <xref:System.ArgumentNullException>ausgelöst. durch das Übergeben einer leeren Zeichenfolge wird eine <xref:System.FormatException></span><span class="sxs-lookup"><span data-stu-id="8b8da-213">For example, passing a null string to the <xref:System.Int32.Parse%2A?displayProperty=nameWithType> method throws an <xref:System.ArgumentNullException>, and passing an empty string throws a <xref:System.FormatException>.</span></span> <span data-ttu-id="8b8da-214">In anderen Fällen kann ein Methoden Argument entweder eine NULL-Zeichenfolge oder eine leere Zeichenfolge sein.</span><span class="sxs-lookup"><span data-stu-id="8b8da-214">In other cases, a method argument can be either a null string or an empty string.</span></span> <span data-ttu-id="8b8da-215">Wenn Sie z. b. eine <xref:System.IFormattable>-Implementierung für eine-Klasse bereitstellen, möchten Sie sowohl eine NULL-Zeichenfolge als auch eine leere Zeichenfolge mit dem allgemeinen Format Bezeichner "G" gleichsetzen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-215">For example, if you are providing an <xref:System.IFormattable> implementation for a class, you want to equate both a null string and an empty string with the general ("G") format specifier.</span></span>

 <span data-ttu-id="8b8da-216">Die <xref:System.String>-Klasse enthält die folgenden zwei Hilfsmethoden, mit denen Sie überprüfen können, ob eine Zeichenfolge `null` oder leer ist:</span><span class="sxs-lookup"><span data-stu-id="8b8da-216">The <xref:System.String> class includes the following two convenience methods that enable you to test whether a string is `null` or empty:</span></span>

-   <span data-ttu-id="8b8da-217"><xref:System.String.IsNullOrEmpty%2A>, das angibt, ob eine Zeichenfolge entweder `null` oder gleich <xref:System.String.Empty?displayProperty=nameWithType>ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-217"><xref:System.String.IsNullOrEmpty%2A>, which indicates whether a string is either `null` or is equal to  <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8b8da-218">Mit dieser Methode entfällt die Notwendigkeit, Code wie den folgenden zu verwenden:</span><span class="sxs-lookup"><span data-stu-id="8b8da-218">This method eliminates the need to use code such as the following:</span></span>

     [!code-cpp[System.String.Class.Null#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#1)]
     [!code-csharp[System.String.Class.Null#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#1)]
     [!code-vb[System.String.Class.Null#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#1)]

-   <span data-ttu-id="8b8da-219"><xref:System.String.IsNullOrWhiteSpace%2A>, das angibt, ob eine Zeichenfolge `null`ist, <xref:System.String.Empty?displayProperty=nameWithType>entspricht oder ausschließlich aus Leerzeichen besteht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-219"><xref:System.String.IsNullOrWhiteSpace%2A>, which indicates whether a string is `null`, equals <xref:System.String.Empty?displayProperty=nameWithType>, or consists exclusively of white-space characters.</span></span> <span data-ttu-id="8b8da-220">Mit dieser Methode entfällt die Notwendigkeit, Code wie den folgenden zu verwenden:</span><span class="sxs-lookup"><span data-stu-id="8b8da-220">This method eliminates the need to use code such as the following:</span></span>

     [!code-cpp[System.String.Class.Null#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#2)]
     [!code-csharp[System.String.Class.Null#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#2)]
     [!code-vb[System.String.Class.Null#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#2)]

 <span data-ttu-id="8b8da-221">Im folgenden Beispiel wird die <xref:System.String.IsNullOrEmpty%2A>-Methode in der <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> Implementierung einer benutzerdefinierten `Temperature`-Klasse verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-221">The following example uses the <xref:System.String.IsNullOrEmpty%2A> method in the <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> implementation of a custom `Temperature` class.</span></span> <span data-ttu-id="8b8da-222">Die-Methode unterstützt die Format Zeichenfolgen "G", "C", "F" und "K".</span><span class="sxs-lookup"><span data-stu-id="8b8da-222">The method supports the "G", "C", "F", and "K" format strings.</span></span> <span data-ttu-id="8b8da-223">Wenn eine leere Format Zeichenfolge oder eine Format Zeichenfolge, deren Wert `null` ist, an die-Methode übermittelt wird, wird der Wert in die Format Zeichenfolge "G" geändert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-223">If an empty format string or a format string whose value is `null` is passed to the method, its value is changed to the "G" format string.</span></span>

 [!code-cpp[System.String.Class.Null#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#3)]
 [!code-csharp[System.String.Class.Null#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#3)]
 [!code-vb[System.String.Class.Null#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#3)]

<a name="Immutability"></a>
## <a name="immutability-and-the-stringbuilder-class"></a><span data-ttu-id="8b8da-224">Unveränderlichkeit und die StringBuilder-Klasse</span><span class="sxs-lookup"><span data-stu-id="8b8da-224">Immutability and the StringBuilder class</span></span>
 <span data-ttu-id="8b8da-225">Ein <xref:System.String> Objekt wird als unveränderlich (schreibgeschützt) bezeichnet, da der Wert nicht geändert werden kann, nachdem er erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="8b8da-225">A <xref:System.String> object is called immutable (read-only), because its value cannot be modified after it has been created.</span></span> <span data-ttu-id="8b8da-226">Methoden, die anscheinend eine <xref:System.String> Objekt ändern, geben tatsächlich ein neues <xref:System.String> Objekt zurück, das die Änderung enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-226">Methods that appear to modify a <xref:System.String> object actually return a new <xref:System.String> object that contains the modification.</span></span>

 <span data-ttu-id="8b8da-227">Da Zeichen folgen unveränderlich sind, kann es bei Routinen zur Zeichen folgen Bearbeitung, die wiederholte Ergänzungen oder Löschungen für eine einzelne Zeichenfolge ausführen, zu einer erheblichen Leistungs Einbuße kommen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-227">Because strings are immutable, string manipulation routines that perform repeated additions or deletions to what appears to be a single string can exact a significant performance penalty.</span></span> <span data-ttu-id="8b8da-228">Im folgenden Code wird z. b. ein Zufallszahlengenerator verwendet, um eine Zeichenfolge mit 1000 Zeichen im Bereich 0x0001 bis 0x052f zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-228">For example, the following code uses a random number generator to create a string with 1000 characters in the range 0x0001 to 0x052F.</span></span> <span data-ttu-id="8b8da-229">Obwohl im Code die Zeichen folgen Verkettung verwendet wird, um ein neues Zeichen an die vorhandene Zeichenfolge mit dem Namen `str`anzufügen, wird für jeden Verkettungs Vorgang tatsächlich ein neues <xref:System.String>-Objekt erstellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-229">Although the code appears to use string concatenation to append a new character to the existing string named `str`, it actually creates a new <xref:System.String> object for each concatenation operation.</span></span>

 [!code-cpp[System.String.Class#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder1.cpp#15)]
 [!code-csharp[System.String.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable.cs#15)]
 [!code-vb[System.String.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable.vb#15)]

 <span data-ttu-id="8b8da-230">Sie können die <xref:System.Text.StringBuilder>-Klasse anstelle der <xref:System.String>-Klasse für Vorgänge verwenden, die mehrere Änderungen am Wert einer Zeichenfolge vornehmen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-230">You can use the <xref:System.Text.StringBuilder> class instead of the <xref:System.String> class for operations that make multiple changes to the value of a string.</span></span> <span data-ttu-id="8b8da-231">Im Gegensatz zu Instanzen der <xref:System.String>-Klasse sind <xref:System.Text.StringBuilder> Objekte änderbar. Wenn Sie Teil Zeichenfolgen in einer Zeichenfolge verketten, anfügen oder löschen, werden die Vorgänge für eine einzelne Zeichenfolge ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-231">Unlike instances of the <xref:System.String> class, <xref:System.Text.StringBuilder> objects are mutable; when you concatenate, append, or delete substrings from a string, the operations are performed on a single string.</span></span> <span data-ttu-id="8b8da-232">Wenn Sie die Änderung des Werts eines <xref:System.Text.StringBuilder> Objekts abgeschlossen haben, können Sie dessen <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType>-Methode zum Konvertieren in eine Zeichenfolge aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-232">When you have finished modifying the value of a <xref:System.Text.StringBuilder> object, you can call its <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> method to convert it to a string.</span></span> <span data-ttu-id="8b8da-233">Im folgenden Beispiel werden die im vorherigen Beispiel verwendeten <xref:System.String> zum Verketten von 1000 zufälligen Zeichen im Bereich mit 0x0001 bis 0x052f mit einem <xref:System.Text.StringBuilder>-Objekt ersetzt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-233">The following example replaces the <xref:System.String> used in the previous example to concatenate 1000 random characters in the range to  0x0001 to 0x052F with a <xref:System.Text.StringBuilder> object.</span></span>

 [!code-cpp[System.String.Class#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder2.cpp#16)]
 [!code-csharp[System.String.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable1.cs#16)]
 [!code-vb[System.String.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable1.vb#16)]

<a name="CultureSensitive"></a>
## <a name="ordinal-vs-culture-sensitive-operations"></a><span data-ttu-id="8b8da-234">Ordinal im Vergleich zu Kultur abhängigen Vorgängen</span><span class="sxs-lookup"><span data-stu-id="8b8da-234">Ordinal vs. culture-sensitive operations</span></span>
 <span data-ttu-id="8b8da-235">Member der <xref:System.String>-Klasse führen entweder Ordnungszahl-oder Kultur abhängige (linguistische) Vorgänge für ein <xref:System.String> Objekt aus.</span><span class="sxs-lookup"><span data-stu-id="8b8da-235">Members of the <xref:System.String> class perform either ordinal or culture-sensitive (linguistic) operations on a <xref:System.String> object.</span></span> <span data-ttu-id="8b8da-236">Ein ordinalvorgang wirkt sich auf den numerischen Wert jedes <xref:System.Char> Objekts aus.</span><span class="sxs-lookup"><span data-stu-id="8b8da-236">An ordinal operation acts on the numeric value of each <xref:System.Char> object.</span></span> <span data-ttu-id="8b8da-237">Ein Kultur abhängiger Vorgang wirkt sich auf den Wert des <xref:System.String> Objekts aus und berücksichtigt kulturspezifische Regeln für Groß-und Kleinschreibung, Sortierung, Formatierung und-Verarbeitung.</span><span class="sxs-lookup"><span data-stu-id="8b8da-237">A culture-sensitive operation acts on the value of the <xref:System.String> object, and takes culture-specific casing, sorting, formatting, and parsing rules into account.</span></span> <span data-ttu-id="8b8da-238">Kultur abhängige Vorgänge werden im Kontext einer explizit deklarierten Kultur oder der impliziten aktuellen Kultur ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-238">Culture-sensitive operations execute in the context of an explicitly declared culture or the implicit current culture.</span></span> <span data-ttu-id="8b8da-239">Die zwei Arten von Vorgängen können sehr unterschiedliche Ergebnisse liefern, wenn Sie für dieselbe Zeichenfolge ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-239">The two kinds of operations can produce very different results when they are performed on the same string.</span></span>

<span data-ttu-id="8b8da-240">.NET unterstützt auch Kultur unabhängige linguistische Zeichen folgen Operationen mit der invarianten Kultur (<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>), die auf den Kultur Einstellungen der englischen Sprache unabhängig von der Region locker basiert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-240">.NET also supports culture-insensitive linguistic string operations by using the invariant culture (<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>), which is loosely based on the culture settings of the English language independent of region.</span></span> <span data-ttu-id="8b8da-241">Im Gegensatz zu anderen <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> Einstellungen bleiben die Einstellungen der invarianten Kultur garantiert auf einem einzelnen Computer, von System zu System und über Versionen von .net konsistent.</span><span class="sxs-lookup"><span data-stu-id="8b8da-241">Unlike other <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> settings, the settings of the invariant culture are guaranteed to remain consistent on a single computer, from system to system, and across versions of .NET.</span></span> <span data-ttu-id="8b8da-242">Die invariante Kultur kann als eine Art schwarzes Feld angesehen werden, das die Stabilität von Zeichen folgen vergleichen und Reihenfolge in allen Kulturen gewährleistet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-242">The invariant culture can be seen as a kind of black box that ensures stability of string comparisons and ordering across all cultures.</span></span>

> [!IMPORTANT]
>  <span data-ttu-id="8b8da-243">Wenn Ihre Anwendung eine Sicherheits Entscheidung über einen symbolischen Bezeichner, z. b. einen Dateinamen oder eine Named Pipe, oder über persistente Daten, z. b. die textbasierten Daten in einer XML-Datei, trifft, sollte der Vorgang anstelle eines Kultur abhängigen Vergleichs einen Ordinalvergleich verwenden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-243">If your application makes a security decision about a symbolic identifier such as a file name or named pipe, or about persisted data such as the text-based data in an XML file, the operation should use an ordinal comparison instead of a culture-sensitive comparison.</span></span> <span data-ttu-id="8b8da-244">Der Grund hierfür ist, dass ein Kultur abhängiger Vergleich abhängig von der geltenden Kultur zu unterschiedlichen Ergebnissen führen kann, während ein Ordinalvergleich nur von dem binären Wert der verglichenen Zeichen abhängig ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-244">This is because a culture-sensitive comparison can yield different results depending on the culture in effect, whereas an ordinal comparison depends solely on the binary value of the compared characters.</span></span>

> [!IMPORTANT]
>  <span data-ttu-id="8b8da-245">Die meisten Methoden, die Zeichen folgen Operationen ausführen, beinhalten eine-Überladung mit einem Parameter vom Typ <xref:System.StringComparison>, mit dem Sie angeben können, ob die Methode einen Ordinalwert oder Kultur abhängigen Vorgang ausführt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-245">Most methods that perform string operations include an overload that has a parameter of type <xref:System.StringComparison>, which enables you to specify whether the method performs an ordinal or culture-sensitive operation.</span></span> <span data-ttu-id="8b8da-246">Im Allgemeinen sollten Sie diese Überladung aufrufen, um den Zweck des Methoden Aufrufes zu löschen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-246">In general, you should call this overload to make the intent of your method call clear.</span></span> <span data-ttu-id="8b8da-247">Bewährte Methoden und Anleitungen zur Verwendung von Ordinalzahl-und Kultur abhängigen Operationen für Zeichen folgen finden [Sie unter Bewährte Methoden für die Verwendung](~/docs/standard/base-types/best-practices-strings.md)von Zeichen folgen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-247">For best practices and guidance for using ordinal and culture-sensitive operations on strings, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>

 <span data-ttu-id="8b8da-248">Vorgänge für [die](#casing)Groß-/Kleinschreibung, das Auswerten [und formatieren](#parsing), das [vergleichen und Sortieren](#comparison)sowie das [Testen auf Gleichheit](#equality) können entweder Ordnungszahl oder Kultur abhängig sein.</span><span class="sxs-lookup"><span data-stu-id="8b8da-248">Operations for [casing](#casing), [parsing and formatting](#parsing), [comparison and sorting](#comparison), and [testing for equality](#equality) can be either ordinal or culture-sensitive.</span></span> <span data-ttu-id="8b8da-249">In den folgenden Abschnitten wird jede Kategorie des Vorgangs erläutert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-249">The following sections discuss each category of operation.</span></span>

> [!TIP]
>  <span data-ttu-id="8b8da-250">Sie sollten immer eine-Methoden Überladung aufrufen, die den Zweck des Methoden Aufrufes als Klartext macht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-250">You should always call a method overload that makes the intent of your method call clear.</span></span> <span data-ttu-id="8b8da-251">Anstatt z. b. die <xref:System.String.Compare%28System.String%2CSystem.String%29>-Methode aufzurufen, um einen Kultur abhängigen Vergleich zweier Zeichen folgen mithilfe der Konventionen der aktuellen Kultur auszuführen, sollten Sie die <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>-Methode mit dem Wert <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> für das `comparisonType`-Argument aufrufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-251">For example, instead of calling the <xref:System.String.Compare%28System.String%2CSystem.String%29> method to perform a culture-sensitive comparison of two strings by using the conventions of the current culture, you should call the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method with a value of <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> for the `comparisonType` argument.</span></span> <span data-ttu-id="8b8da-252">Weitere Informationen finden Sie unter [Empfohlene Vorgehensweisen für die Verwendung von Zeichenfolgen in .NET Framework](~/docs/standard/base-types/best-practices-strings.md).</span><span class="sxs-lookup"><span data-stu-id="8b8da-252">For more information, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>

<span data-ttu-id="8b8da-253">Sie können die aus mehreren Textdateien bestehenden [Sorting Weight Tables](https://www.microsoft.com/download/details.aspx?id=10921) herunterladen. Diese Textdateien enthalten Informationen zur Gewichtung der Zeichen, die bei Sortier- und Vergleichsvorgängen unter Windows-Betriebssystemen verwendet werden, sowie die [Default Unicode Collation Element Table](https://www.unicode.org/Public/UCA/latest/allkeys.txt), die Sortiergewichtungstabelle für Linux und macOS.</span><span class="sxs-lookup"><span data-stu-id="8b8da-253">You can download the [Sorting Weight Tables](https://www.microsoft.com/download/details.aspx?id=10921), a set of text files that contain information on the character weights used in sorting and comparison operations for Windows operating systems, and the [Default Unicode Collation Element Table](https://www.unicode.org/Public/UCA/latest/allkeys.txt), the sort weight table for Linux and macOS.</span></span>

<a name="casing"></a>
### <a name="casing"></a><span data-ttu-id="8b8da-254">Schreibweise</span><span class="sxs-lookup"><span data-stu-id="8b8da-254">Casing</span></span>
 <span data-ttu-id="8b8da-255">Regeln für die Groß-und Kleinschreibung bestimmen, wie die Groß Schreibung eines Unicode-Zeichens geändert beispielsweise von Kleinbuchstaben in Großbuchstaben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-255">Casing rules determine how to change the capitalization of a Unicode character; for example, from lowercase to uppercase.</span></span> <span data-ttu-id="8b8da-256">Häufig wird ein Schreibvorgang vor einem Zeichen folgen Vergleich durchgeführt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-256">Often, a casing operation is performed before a string comparison.</span></span> <span data-ttu-id="8b8da-257">Beispielsweise kann eine Zeichenfolge in einen Großbuchstaben konvertiert werden, damit Sie mit einer anderen Großbuchstaben-Zeichenfolge verglichen werden kann.</span><span class="sxs-lookup"><span data-stu-id="8b8da-257">For example, a string might be converted to uppercase so that it can be compared with another uppercase string.</span></span> <span data-ttu-id="8b8da-258">Sie können die Zeichen in einer Zeichenfolge in Kleinbuchstaben konvertieren, indem Sie die <xref:System.String.ToLower%2A>-oder <xref:System.String.ToLowerInvariant%2A>-Methode aufrufen, und Sie können Sie in Großbuchstaben konvertieren, indem Sie die <xref:System.String.ToUpper%2A>-oder <xref:System.String.ToUpperInvariant%2A>-Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-258">You can convert the characters in a string to lowercase by calling the <xref:System.String.ToLower%2A> or <xref:System.String.ToLowerInvariant%2A> method, and you can convert them to uppercase by calling the <xref:System.String.ToUpper%2A> or <xref:System.String.ToUpperInvariant%2A> method.</span></span> <span data-ttu-id="8b8da-259">Außerdem können Sie die <xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType>-Methode verwenden, um eine Zeichenfolge in einen titelfall zu konvertieren.</span><span class="sxs-lookup"><span data-stu-id="8b8da-259">In addition, you can use the <xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType> method to convert a string to title case.</span></span>

[!INCLUDE[platform-note](~/includes/c-and-posix-cultures.md)]

 <span data-ttu-id="8b8da-260">Schreibvorgänge können auf den Regeln der aktuellen Kultur, einer angegebenen Kultur oder der invarianten Kultur basieren.</span><span class="sxs-lookup"><span data-stu-id="8b8da-260">Casing operations can be based on the rules of the current culture, a specified culture, or the invariant culture.</span></span> <span data-ttu-id="8b8da-261">Da Fall Zuordnungen je nach verwendeter Kultur variieren können, kann das Ergebnis von Schreibvorgängen je nach Kultur variieren.</span><span class="sxs-lookup"><span data-stu-id="8b8da-261">Because case mappings can vary depending on the culture used, the result of casing operations can vary based on culture.</span></span> <span data-ttu-id="8b8da-262">Die tatsächlichen Unterschiede bei der Groß-/Kleinschreibung sind drei Arten:</span><span class="sxs-lookup"><span data-stu-id="8b8da-262">The actual differences in casing are of three kinds:</span></span>

-   <span data-ttu-id="8b8da-263">Unterschiede bei der Groß-/Kleinschreibung von lateinischen Großbuchstaben i (u + 0049), Latin Small Letter i (u + 0069), Latin Capital Letter i (u + 0130) und Latin Small Letter DOTLESS i (u + 0131).</span><span class="sxs-lookup"><span data-stu-id="8b8da-263">Differences in the case mapping of LATIN CAPITAL LETTER I (U+0049), LATIN SMALL LETTER I (U+0069), LATIN CAPITAL LETTER I WITH DOT ABOVE (U+0130), and LATIN SMALL LETTER DOTLESS I (U+0131).</span></span> <span data-ttu-id="8b8da-264">In den neutralen Kulturen tr-tr (Türkisch (Türkei)) und AZ-Latn-AZ (Aserbaidschan, Latin) und in den neutralen Kulturen tr, AZ und AZ-Latn ist die Entsprechung von lateinischen Großbuchstaben i "lateinisch Kleinbuchstabe i" und "Großbuchstabe i" der lateinische Großbuchstabe i mit dem Punkt oben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-264">In the tr-TR (Turkish (Turkey)) and az-Latn-AZ (Azerbaijan, Latin) cultures, and in the tr, az, and az-Latn neutral cultures, the lowercase equivalent of LATIN CAPITAL LETTER I is LATIN SMALL LETTER DOTLESS I, and the uppercase equivalent of LATIN SMALL LETTER I is LATIN CAPITAL LETTER I WITH DOT ABOVE.</span></span> <span data-ttu-id="8b8da-265">In allen anderen Kulturen, einschließlich der invarianten Kultur, lateinisch kleiner Buchstabe i und lateinischen Großbuchstaben, verwende ich Kleinbuchstaben und Entsprechungen in Großbuchstaben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-265">In all other cultures, including the invariant culture, LATIN SMALL LETTER I and LATIN CAPITAL LETTER I are lowercase and uppercase equivalents.</span></span>

     <span data-ttu-id="8b8da-266">Das folgende Beispiel veranschaulicht, wie ein Zeichen folgen Vergleich, der zum Verhindern des Dateisystem Zugriffs entworfen wurde, fehlschlagen kann, wenn er auf einen Kultur abhängigen Groß-/Kleinschreibung</span><span class="sxs-lookup"><span data-stu-id="8b8da-266">The following example demonstrates how a string comparison designed to prevent file system access can fail if it relies on a culture-sensitive casing comparison.</span></span> <span data-ttu-id="8b8da-267">(Die Konventionen für die Groß-und Kleinschreibung der invarianten Kultur sollten verwendet werden.)</span><span class="sxs-lookup"><span data-stu-id="8b8da-267">(The casing conventions of the invariant culture should have been used.)</span></span>

     [!code-csharp[System.String.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case2.cs#17)]
     [!code-vb[System.String.Class#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case2.vb#17)]

-   <span data-ttu-id="8b8da-268">Unterschiede in den Fall Zuordnungen zwischen der invarianten Kultur und allen anderen Kulturen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-268">Differences in case mappings between the invariant culture and all other cultures.</span></span> <span data-ttu-id="8b8da-269">In diesen Fällen wird mit den Regeln für die Groß-/Kleinschreibung der invarianten Kultur ein Zeichen in groß-oder Kleinbuchstaben geändert, um das gleiche Zeichen zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-269">In these cases, using the casing rules of the invariant culture to change a character to uppercase or lowercase returns the same character.</span></span> <span data-ttu-id="8b8da-270">Für alle anderen Kulturen wird ein anderes Zeichen zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-270">For all other cultures, it returns a different character.</span></span> <span data-ttu-id="8b8da-271">Einige der betroffenen Zeichen sind in der folgenden Tabelle aufgeführt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-271">Some of the affected characters are listed in the following table.</span></span>

    |<span data-ttu-id="8b8da-272">Zeichen</span><span class="sxs-lookup"><span data-stu-id="8b8da-272">Character</span></span>|<span data-ttu-id="8b8da-273">Bei Änderung in</span><span class="sxs-lookup"><span data-stu-id="8b8da-273">If changed to</span></span>|<span data-ttu-id="8b8da-274">Rückgabe</span><span class="sxs-lookup"><span data-stu-id="8b8da-274">Returns</span></span>|
    |---------------|-------------------|-------------|
    |<span data-ttu-id="8b8da-275">Micron-Zeichen (U + 00b5)</span><span class="sxs-lookup"><span data-stu-id="8b8da-275">MICRON SIGN (U+00B5)</span></span>|<span data-ttu-id="8b8da-276">Großbuchstaben</span><span class="sxs-lookup"><span data-stu-id="8b8da-276">Uppercase</span></span>|<span data-ttu-id="8b8da-277">Griechischer Großbuchstabe Mu (U +-39c)</span><span class="sxs-lookup"><span data-stu-id="8b8da-277">GREEK CAPITAL LETTER MU (U+-39C)</span></span>|
    |<span data-ttu-id="8b8da-278">Lateinischer Großbuchstabe I mit einem vorangehenden Punkt (U + 0130)</span><span class="sxs-lookup"><span data-stu-id="8b8da-278">LATIN CAPITAL LETTER I WITH DOT ABOVE (U+0130)</span></span>|<span data-ttu-id="8b8da-279">Kleinbuchstaben</span><span class="sxs-lookup"><span data-stu-id="8b8da-279">Lowercase</span></span>|<span data-ttu-id="8b8da-280">Lateinisch kleiner Buchstabe I (U + 0069)</span><span class="sxs-lookup"><span data-stu-id="8b8da-280">LATIN SMALL LETTER I (U+0069)</span></span>|
    |<span data-ttu-id="8b8da-281">Latin Small Letter DOTLESS I (U + 0131)</span><span class="sxs-lookup"><span data-stu-id="8b8da-281">LATIN SMALL LETTER DOTLESS I (U+0131)</span></span>|<span data-ttu-id="8b8da-282">Großbuchstaben</span><span class="sxs-lookup"><span data-stu-id="8b8da-282">Uppercase</span></span>|<span data-ttu-id="8b8da-283">Lateinisch Großbuchstabe I (U + 0049)</span><span class="sxs-lookup"><span data-stu-id="8b8da-283">LATIN CAPITAL LETTER I (U+0049)</span></span>|
    |<span data-ttu-id="8b8da-284">Latin Small Letter Long S (U + 017f)</span><span class="sxs-lookup"><span data-stu-id="8b8da-284">LATIN SMALL LETTER LONG S (U+017F)</span></span>|<span data-ttu-id="8b8da-285">Großbuchstaben</span><span class="sxs-lookup"><span data-stu-id="8b8da-285">Uppercase</span></span>|<span data-ttu-id="8b8da-286">Lateinische Großbuchstaben S (U + 0053)</span><span class="sxs-lookup"><span data-stu-id="8b8da-286">LATIN CAPITAL LETTER S (U+0053)</span></span>|
    |<span data-ttu-id="8b8da-287">Lateinisch Großbuchstabe D mit kleinem Buchstaben Z mit Caron (U + 01c5)</span><span class="sxs-lookup"><span data-stu-id="8b8da-287">LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON (U+01C5)</span></span>|<span data-ttu-id="8b8da-288">Kleinbuchstaben</span><span class="sxs-lookup"><span data-stu-id="8b8da-288">Lowercase</span></span>|<span data-ttu-id="8b8da-289">Latin Small Letter DZ with Caron (U + 01c6)</span><span class="sxs-lookup"><span data-stu-id="8b8da-289">LATIN SMALL LETTER DZ WITH CARON (U+01C6)</span></span>|
    |<span data-ttu-id="8b8da-290">Kombinieren von Greek ypogegrammeni (U + 0345)</span><span class="sxs-lookup"><span data-stu-id="8b8da-290">COMBINING GREEK YPOGEGRAMMENI (U+0345)</span></span>|<span data-ttu-id="8b8da-291">Großbuchstaben</span><span class="sxs-lookup"><span data-stu-id="8b8da-291">Uppercase</span></span>|<span data-ttu-id="8b8da-292">Griechischer Großbuchstabe Iota (U + 0399)</span><span class="sxs-lookup"><span data-stu-id="8b8da-292">GREEK CAPITAL LETTER IOTA (U+0399)</span></span>|

-   <span data-ttu-id="8b8da-293">Unterschiede bei den Zuordnungen von Groß-/Kleinschreibung aus zwei Buchstaben im ASCII-Zeichenbereich.</span><span class="sxs-lookup"><span data-stu-id="8b8da-293">Differences in case mappings of two-letter mixed-case pairs in the ASCII character range.</span></span> <span data-ttu-id="8b8da-294">In den meisten Kulturen ist ein aus zwei Buchstaben gemischtes Paar aus Groß-oder Kleinbuchstaben gleichwertig.</span><span class="sxs-lookup"><span data-stu-id="8b8da-294">In most cultures, a two-letter mixed-case pair is equal to the equivalent two-letter uppercase or lowercase pair.</span></span> <span data-ttu-id="8b8da-295">Dies gilt nicht für die folgenden zwei buchstabenden Paare in den folgenden Kulturen, da Sie in jedem Fall mit einem Digraph verglichen werden:</span><span class="sxs-lookup"><span data-stu-id="8b8da-295">This is not true for the following two-letter pairs in the following cultures, because in each case they are compared to a digraph:</span></span>

    -   <span data-ttu-id="8b8da-296">"LJ" und "NJ" in der HR-HR-Kultur (Kroatisch (Kroatien)).</span><span class="sxs-lookup"><span data-stu-id="8b8da-296">"lJ" and "nJ" in the hr-HR (Croatian (Croatia)) culture.</span></span>

    -   <span data-ttu-id="8b8da-297">"ch" in den Kulturen "CS-CZ (Tschechisch (Tschechische Republik)" und "SK-SK" (Slowakisch (Slowakei)).</span><span class="sxs-lookup"><span data-stu-id="8b8da-297">"cH" in the cs-CZ (Czech (Czech Republic)) and sk-SK (Slovak (Slovakia)) cultures.</span></span>

    -   <span data-ttu-id="8b8da-298">"AA" in der Kultur "da-DK (Dänisch (Dänemark)").</span><span class="sxs-lookup"><span data-stu-id="8b8da-298">"aA" in the da-DK (Danish (Denmark)) culture.</span></span>

    -   <span data-ttu-id="8b8da-299">"CS", "DZ", "dzs", "NY", "SZ", "tY" und "zS" in der Kultur "hu-hu (ungarisch)".</span><span class="sxs-lookup"><span data-stu-id="8b8da-299">"cS", "dZ", "dZS", "nY", "sZ", "tY", and "zS" in the hu-HU (Hungarian (Hungary)) culture.</span></span>

    -   <span data-ttu-id="8b8da-300">"ch" und "ll" in der Kultur "es-ES_tradnl (Spanisch (Spanien, Traditionelle Sortierung)").</span><span class="sxs-lookup"><span data-stu-id="8b8da-300">"cH" and "lL" in the es-ES_tradnl (Spanish (Spain, Traditional Sort)) culture.</span></span>

    -   <span data-ttu-id="8b8da-301">"ch", "GI", "KH", "ng" "NH", "pH", "qU", "th" und "tr" in der Kultur vi-VN (Vietnamese (Vietnam)).</span><span class="sxs-lookup"><span data-stu-id="8b8da-301">"cH", "gI", "kH", "nG" "nH", "pH", "qU', "tH", and "tR" in the vi-VN (Vietnamese (Vietnam)) culture.</span></span>

     <span data-ttu-id="8b8da-302">Es ist jedoch ungewöhnlich, dass eine Situation auftritt, in der ein Kultur abhängiger Vergleich dieser Paare Probleme verursacht, da diese Paare in festgelegten Zeichen folgen oder bezeichnerfällen nicht üblich sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-302">However, it is unusual to encounter a situation in which a culture-sensitive comparison of these pairs creates problems, because these pairs are uncommon in fixed strings or identifiers.</span></span>

 <span data-ttu-id="8b8da-303">Im folgenden Beispiel werden einige der Unterschiede zwischen den Regeln für die Groß-und Kleinschreibung beim Umwandeln von Zeichen folgen in Großbuchstaben veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-303">The following example illustrates some of the differences in casing rules between cultures when converting strings to uppercase.</span></span>

 [!code-cpp[System.String.Class#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.casing.cpp#7)]
 [!code-csharp[System.String.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case1.cs#7)]
 [!code-vb[System.String.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case1.vb#7)]

<a name="parsing"></a>
### <a name="parsing-and-formatting"></a><span data-ttu-id="8b8da-304">Auswerten und formatieren</span><span class="sxs-lookup"><span data-stu-id="8b8da-304">Parsing and formatting</span></span>
 <span data-ttu-id="8b8da-305">Formatierung und Verarbeitung sind umgekehrte Vorgänge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-305">Formatting and parsing are inverse operations.</span></span> <span data-ttu-id="8b8da-306">Formatierungs Regeln legen fest, wie ein Wert (z. b. ein Datum und eine Uhrzeit oder eine Zahl) in seine Zeichen folgen Darstellung konvertiert werden, wohingegen durch die durch das Durchsetzen von Regeln festgelegt wird, wie eine Zeichen folgen Darstellung in einen-Wert konvertiert werden soll</span><span class="sxs-lookup"><span data-stu-id="8b8da-306">Formatting rules determine how to convert a value, such as a date and time or a number, to its string representation, whereas parsing rules determine how to convert a string representation to a value such as a date and time.</span></span> <span data-ttu-id="8b8da-307">Sowohl Formatierungs-als auch Erteilungs Regeln sind von kulturellen Konventionen abhängig.</span><span class="sxs-lookup"><span data-stu-id="8b8da-307">Both formatting and parsing rules are dependent on cultural conventions.</span></span> <span data-ttu-id="8b8da-308">Im folgenden Beispiel wird die Mehrdeutigkeit veranschaulicht, die bei der Interpretation einer kulturspezifischen Datums Zeichenfolge auftreten kann.</span><span class="sxs-lookup"><span data-stu-id="8b8da-308">The following example illustrates the ambiguity that can arise when interpreting a culture-specific date string.</span></span> <span data-ttu-id="8b8da-309">Ohne die Konventionen der Kultur zu kennen, die zum Entwickeln einer Datums Zeichenfolge verwendet wurde, ist es nicht möglich zu wissen, ob 03/01/2011, 3/1/2011 und 01/03/2011 den 3. Januar 2011 oder den 1. März 2011 darstellen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-309">Without knowing the conventions of the culture that was used to produce a date string, it is not possible to know whether 03/01/2011, 3/1/2011, and 01/03/2011 represent January 3, 2011 or March 1, 2011.</span></span>

 [!code-cpp[System.String.Class#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.format1.cpp#8)]
 [!code-csharp[System.String.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/format1.cs#8)]
 [!code-vb[System.String.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/format1.vb#8)]

 <span data-ttu-id="8b8da-310">Wie im folgenden Beispiel gezeigt, kann eine einzelne Zeichenfolge abhängig von der Kultur, deren Konventionen im Analyse-Vorgang verwendet werden, unterschiedliche Datumsangaben liefern.</span><span class="sxs-lookup"><span data-stu-id="8b8da-310">Similarly, as the following example shows, a single string can produce different dates depending on the culture whose conventions are used in the parsing operation.</span></span>

 [!code-cpp[System.String.Class#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.parse1.cpp#9)]
 [!code-csharp[System.String.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/parse1.cs#9)]
 [!code-vb[System.String.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/parse1.vb#9)]

<a name="comparison"></a>
### <a name="string-comparison-and-sorting"></a><span data-ttu-id="8b8da-311">Zeichen folgen Vergleich und Sortierung</span><span class="sxs-lookup"><span data-stu-id="8b8da-311">String comparison and sorting</span></span>
 <span data-ttu-id="8b8da-312">Konventionen zum Vergleichen und Sortieren von Zeichen folgen variieren von Kultur zu Kultur.</span><span class="sxs-lookup"><span data-stu-id="8b8da-312">Conventions for comparing and sorting strings vary from culture to culture.</span></span> <span data-ttu-id="8b8da-313">Die Sortierreihenfolge kann z. b. auf der Phonetik oder der visuellen Darstellung von Zeichen basieren.</span><span class="sxs-lookup"><span data-stu-id="8b8da-313">For example, the sort order may be based on phonetics or on the visual representation of characters.</span></span> <span data-ttu-id="8b8da-314">In ostasiatischen Sprachen werden Zeichen anhand der Anzahl der Striche und der Radikale der Ideogramme sortiert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-314">In East Asian languages, characters are sorted by the stroke and radical of ideographs.</span></span> <span data-ttu-id="8b8da-315">Die Sortierung hängt außerdem von der Reihenfolge ab, die das Alphabet der jeweiligen Sprache bzw. Kultur aufweist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-315">Sorting also depends on the order languages and cultures use for the alphabet.</span></span> <span data-ttu-id="8b8da-316">Im Dänischen gibt es beispielsweise das Zeichen "Æ", das im Alphabet nach dem Zeichen "Z" einsortiert ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-316">For example, the Danish language has an "Æ" character that it sorts after "Z" in the alphabet.</span></span> <span data-ttu-id="8b8da-317">Außerdem kann bei vergleichen die Groß-/Kleinschreibung beachtet werden, und die Groß-/Kleinschreibung unterscheidet sich in manchen Fällen von der Kultur.</span><span class="sxs-lookup"><span data-stu-id="8b8da-317">In addition, comparisons can be case-sensitive or case-insensitive, and in some cases casing rules also differ by culture.</span></span> <span data-ttu-id="8b8da-318">Beim Ordinalvergleich werden dagegen die Unicode-Code Punkte von einzelnen Zeichen in einer Zeichenfolge beim Vergleichen und Sortieren von Zeichen folgen verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-318">Ordinal comparison, on the other hand, uses the Unicode code points of individual characters in a string when comparing and sorting strings.</span></span>

 <span data-ttu-id="8b8da-319">Sortierregeln bestimmen die alphabetische Reihenfolge von Unicode-Zeichen und die Art und Weise, wie zwei Zeichen folgen miteinander verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-319">Sort rules determine the alphabetic order of Unicode characters and how two strings compare to each other.</span></span> <span data-ttu-id="8b8da-320">Die <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType>-Methode vergleicht z. b. zwei Zeichen folgen auf der Grundlage des <xref:System.StringComparison>-Parameters.</span><span class="sxs-lookup"><span data-stu-id="8b8da-320">For example, the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> method compares two strings based on the <xref:System.StringComparison> parameter.</span></span> <span data-ttu-id="8b8da-321">Wenn der Parameterwert <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>ist, führt die Methode einen linguistischen Vergleich durch, der die Konventionen der aktuellen Kultur verwendet. Wenn der Parameterwert <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>ist, führt die Methode einen Ordinalvergleich durch.</span><span class="sxs-lookup"><span data-stu-id="8b8da-321">If the parameter value is <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, the method performs a linguistic comparison that uses the conventions of the current culture; if the parameter value is <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>, the method performs an ordinal comparison.</span></span> <span data-ttu-id="8b8da-322">Daher wird wie im folgenden Beispiel gezeigt, wenn die aktuelle Kultur US-Englisch ist, der erste Aufrufe der <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType>-Methode (mit Kultur sensiblem Vergleich) "a" kleiner als "a", aber der zweite Aufrufe derselben Methode (mit Ordinalvergleich) berücksichtigt "a" größer als "a".</span><span class="sxs-lookup"><span data-stu-id="8b8da-322">Consequently, as the following example shows, if the current culture is U.S. English, the first call to the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> method (using culture-sensitive comparison) considers "a" less than "A", but the second call to the same method (using ordinal comparison) considers "a" greater than "A".</span></span>

 [!code-cpp[System.String.Class#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare1.cpp#10)]
 [!code-csharp[System.String.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare1.cs#10)]
 [!code-vb[System.String.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare1.vb#10)]

 <span data-ttu-id="8b8da-323">.NET unterstützt Wort-, Zeichen folgen-und ordinalsortier Regeln:</span><span class="sxs-lookup"><span data-stu-id="8b8da-323">.NET supports word, string, and ordinal sort rules:</span></span>

-   <span data-ttu-id="8b8da-324">Bei einer Wortsortierung wird ein kulturabhängiger Vergleich von Zeichenfolgen durchgeführt, bei dem bestimmten nicht alphanumerischen Unicode-Zeichen u. U. bestimmte Gewichtungen zugeordnet sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-324">A word sort performs a culture-sensitive comparison of strings in which certain nonalphanumeric Unicode characters might have special weights assigned to them.</span></span> <span data-ttu-id="8b8da-325">Dem Bindestrich (-) kann z. b. eine sehr geringe Gewichtung zugewiesen werden, sodass "Coop" und "Co-op" in einer sortierten Liste nebeneinander angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-325">For example, the hyphen (-) might have a very small weight assigned to it so that "coop" and "co-op" appear next to each other in a sorted list.</span></span> <span data-ttu-id="8b8da-326">Eine Liste der <xref:System.String> Methoden, die zwei Zeichen folgen mithilfe von Wort Sortierregeln vergleichen, finden Sie im Abschnitt [Zeichen folgen Vorgänge nach Kategorie](#ByCategory) .</span><span class="sxs-lookup"><span data-stu-id="8b8da-326">For a list of the <xref:System.String> methods that compare two strings using word sort rules, see the [String operations by category](#ByCategory) section.</span></span>

-   <span data-ttu-id="8b8da-327">Eine Zeichen folgen Sortierung führt auch einen Kultur abhängigen Vergleich durch.</span><span class="sxs-lookup"><span data-stu-id="8b8da-327">A string sort also performs a culture-sensitive comparison.</span></span> <span data-ttu-id="8b8da-328">Sie ähnelt einem Wort Sort, mit dem Unterschied, dass es keine besonderen Fälle gibt und alle nicht alphanumerischen Symbole vor allen alphanumerischen Unicode-Zeichen stehen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-328">It is similar to a word sort, except that there are no special cases, and all nonalphanumeric symbols come before all alphanumeric Unicode characters.</span></span> <span data-ttu-id="8b8da-329">Zwei Zeichen folgen können mithilfe von Zeichen folgen Sortierregeln verglichen werden, indem die <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType> Methoden Überladungen aufgerufen werden, die über einen `options` Parameter verfügen, dem der Wert <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-329">Two strings can be compared using string sort rules by calling the <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType> method overloads that have an `options` parameter that is supplied a value of <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8b8da-330">Beachten Sie, dass dies die einzige Methode ist, die .net zum Vergleichen von zwei Zeichen folgen mithilfe von Zeichen folgen Sortierregeln bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-330">Note that this is the only method that .NET provides to compare two strings using string sort rules.</span></span>

-   <span data-ttu-id="8b8da-331">Eine Ordinalsortierung vergleicht Zeichenfolgen anhand des numerischen Werts jedes <xref:System.Char>-Objekts in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-331">An ordinal sort compares strings based on the numeric value of each <xref:System.Char> object in the string.</span></span> <span data-ttu-id="8b8da-332">Bei einem Ordinalvergleich wird die Groß-/Kleinschreibung nicht beachtet, da die Kleinbuchstaben-und Großbuchstaben Versionen eines Zeichens verschiedene Code Punkte aufweisen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-332">An ordinal comparison is automatically case-sensitive because the lowercase and uppercase versions of a character have different code points.</span></span> <span data-ttu-id="8b8da-333">Wenn die Groß-/Kleinschreibung jedoch nicht wichtig ist, können Sie einen Ordinalvergleich angeben, der Case ignoriert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-333">However, if case is not important, you can specify an ordinal comparison that ignores case.</span></span> <span data-ttu-id="8b8da-334">Dies entspricht dem Umwandeln der Zeichenfolge in Großbuchstaben unter Verwendung der invarianten Kultur und der anschließenden Durchführung eines Ordinalvergleichs für das Ergebnis.</span><span class="sxs-lookup"><span data-stu-id="8b8da-334">This is equivalent to converting the string to uppercase by using the invariant culture and then performing an ordinal comparison on the result.</span></span> <span data-ttu-id="8b8da-335">Eine Liste der <xref:System.String> Methoden, die zwei Zeichen folgen mithilfe von ordinalen Sortierregeln vergleichen, finden Sie im Abschnitt [Zeichen folgen Vorgänge nach Kategorie](#ByCategory) .</span><span class="sxs-lookup"><span data-stu-id="8b8da-335">For a list of the <xref:System.String> methods that compare two strings using ordinal sort rules, see the [String operations by category](#ByCategory) section.</span></span>

 <span data-ttu-id="8b8da-336">Ein Kultur abhängiger Vergleich ist ein beliebiger Vergleich, der explizit oder implizit ein <xref:System.Globalization.CultureInfo> Objekt verwendet, einschließlich der invarianten Kultur, die durch die <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>-Eigenschaft angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-336">A culture-sensitive comparison is any comparison that explicitly or implicitly uses a <xref:System.Globalization.CultureInfo> object, including the invariant culture that is specified by the <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="8b8da-337">Die implizite Kultur ist die aktuelle Kultur, die durch die Eigenschaften <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> und <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-337">The implicit culture is the current culture, which is specified by the <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> properties.</span></span> <span data-ttu-id="8b8da-338">Es gibt beträchtliche Abweichungen in der Sortierreihenfolge von alphabetischen Zeichen (d. h. Zeichen, für die die <xref:System.Char.IsLetter%2A?displayProperty=nameWithType>-Eigenschaft `true`) über Kulturen hinweg zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-338">There is considerable variation in the sort order of alphabetic characters (that is, characters for which the <xref:System.Char.IsLetter%2A?displayProperty=nameWithType> property returns `true`) across cultures.</span></span> <span data-ttu-id="8b8da-339">Sie können einen Kultur abhängigen Vergleich angeben, der die Konventionen einer bestimmten Kultur verwendet, indem Sie ein <xref:System.Globalization.CultureInfo>-Objekt für eine Zeichen folgen Vergleichsmethode wie <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-339">You can specify a culture-sensitive comparison that uses the conventions of a specific culture by supplying a <xref:System.Globalization.CultureInfo> object to a string comparison method such as <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>.</span></span> <span data-ttu-id="8b8da-340">Sie können einen Kultur abhängigen Vergleich angeben, der die Konventionen der aktuellen Kultur verwendet, indem Sie <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>oder einen beliebigen Member der <xref:System.Globalization.CompareOptions> Enumeration außer <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> oder <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> an eine entsprechende Überladung der <xref:System.String.Compare%2A>-Methode bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-340">You can specify a culture-sensitive comparison that uses the conventions of the current culture by supplying <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, or any member of the <xref:System.Globalization.CompareOptions> enumeration other than <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> or <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> to an appropriate overload of the <xref:System.String.Compare%2A> method.</span></span> <span data-ttu-id="8b8da-341">Ein Kultur abhängiger Vergleich ist in der Regel für die Sortierung geeignet, während ein Ordinalvergleich nicht erfolgt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-341">A culture-sensitive comparison is generally appropriate for sorting whereas an ordinal comparison is not.</span></span> <span data-ttu-id="8b8da-342">Ein Ordinalvergleich ist im allgemeinen geeignet, um zu bestimmen, ob zwei Zeichen folgen gleich sind (d. h. zum Bestimmen der Identität), während ein Kultur abhängiger Vergleich nicht ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-342">An ordinal comparison is generally appropriate for determining whether two strings are equal (that is, for determining identity) whereas a culture-sensitive comparison is not.</span></span>

 <span data-ttu-id="8b8da-343">Im folgenden Beispiel wird der Unterschied zwischen Kultur sensitiven und ordinalen Vergleichen veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-343">The following example illustrates the difference between culture-sensitive and ordinal comparison.</span></span> <span data-ttu-id="8b8da-344">Im Beispiel werden die drei Zeichen folgen "Apple", "Æble" und "aeble" mithilfe von ordinalvergleichen und den Konventionen der Kulturen "da-DK" und "en-US" ausgewertet (bei denen es sich um die Standard Kultur handelt, wenn die <xref:System.String.Compare%2A>-Methode aufgerufen wird).</span><span class="sxs-lookup"><span data-stu-id="8b8da-344">The example evaluates three strings, "Apple", "Æble", and "AEble", using ordinal comparison and the conventions of the da-DK and en-US cultures (each of which is the default culture at the time the <xref:System.String.Compare%2A> method is called).</span></span> <span data-ttu-id="8b8da-345">Da die dänische Sprache das Zeichen "Æ" als einzelnen Buchstaben behandelt und Sie nach "Z" im Alphabet sortiert, ist die Zeichenfolge "Æble" größer als "Apple".</span><span class="sxs-lookup"><span data-stu-id="8b8da-345">Because the Danish language treats the character "Æ" as an individual letter and sorts it after "Z" in the alphabet, the string "Æble" is greater than "Apple".</span></span> <span data-ttu-id="8b8da-346">"Æble" gilt jedoch nicht als äquivalent zu "aeble", sodass "Æble" auch größer als "aeble" ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-346">However, "Æble" is not considered equivalent to "AEble", so "Æble" is also greater than "AEble".</span></span> <span data-ttu-id="8b8da-347">Die Kultur "en-US" enthält nicht den Buchstaben "Æ", sondern behandelt Sie als äquivalent zu "AE", in dem erläutert wird, warum "Æble" kleiner als "Apple", aber gleich "aeble" ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-347">The en-US culture doesn't include the letter"Æ" but treats it as equivalent to "AE", which explains why  "Æble" is less than "Apple" but equal to "AEble".</span></span> <span data-ttu-id="8b8da-348">Bei einem Ordinalvergleich wird "Apple" als "Æble" und "Æble" als "aeble" betrachtet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-348">Ordinal comparison, on the other hand, considers "Apple" to be less than "Æble", and "Æble" to be greater than "AEble".</span></span>

 [!code-csharp[System.String.Class#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare4.cs#21)]
 [!code-vb[System.String.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare4.vb#21)]

 <span data-ttu-id="8b8da-349">Verwenden Sie die folgenden allgemeinen Richtlinien, um eine geeignete Sortier-oder Zeichen folgen Vergleichsmethode auszuwählen:</span><span class="sxs-lookup"><span data-stu-id="8b8da-349">Use the following general guidelines to choose an appropriate sorting or string comparison method:</span></span>

-   <span data-ttu-id="8b8da-350">Wenn Sie möchten, dass die Zeichen folgen anhand der Kultur des Benutzers sortiert werden, sollten Sie Sie nach den Konventionen der aktuellen Kultur sortieren.</span><span class="sxs-lookup"><span data-stu-id="8b8da-350">If you want the strings to be ordered based on the user's culture, you should order them based on the conventions of the current culture.</span></span> <span data-ttu-id="8b8da-351">Wenn sich die Kultur des Benutzers ändert, ändert sich auch die Reihenfolge der sortierten Zeichen folgen entsprechend.</span><span class="sxs-lookup"><span data-stu-id="8b8da-351">If the user's culture changes, the order of sorted strings will also change accordingly.</span></span> <span data-ttu-id="8b8da-352">Beispielsweise sollte eine thesaurusanwendung die Wörter immer basierend auf der Kultur des Benutzers sortieren.</span><span class="sxs-lookup"><span data-stu-id="8b8da-352">For example, a thesaurus application should always sort words based on the user's culture.</span></span>

-   <span data-ttu-id="8b8da-353">Wenn Sie möchten, dass die Zeichen folgen basierend auf den Konventionen einer bestimmten Kultur sortiert werden, sollten Sie diese sortieren, indem Sie ein <xref:System.Globalization.CultureInfo> Objekt, das diese Kultur darstellt, einer Vergleichsmethode bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-353">If you want the strings to be ordered based on the conventions of a specific culture, you should order them by supplying a <xref:System.Globalization.CultureInfo> object that represents that culture to a comparison method.</span></span> <span data-ttu-id="8b8da-354">Beispielsweise möchten Sie in einer Anwendung, die Studenten eine bestimmte Sprache vermitteln soll, Zeichen folgen basierend auf den Konventionen einer der Kulturen, die diese Sprache sprechen, geordnet werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-354">For example, in an application designed to teach students a particular language, you want strings to be ordered based on the conventions of one of the cultures that speaks that language.</span></span>

-   <span data-ttu-id="8b8da-355">Wenn Sie möchten, dass die Reihenfolge der Zeichen folgen zwischen Kulturen unverändert bleibt, sollten Sie Sie nach den Konventionen der invarianten Kultur sortieren oder einen Ordinalvergleich verwenden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-355">If you want the order of strings to remain unchanged across cultures, you should order them based on the conventions of the invariant culture or use an ordinal comparison.</span></span> <span data-ttu-id="8b8da-356">Beispielsweise verwenden Sie eine Ordinalsortierung, um die Namen von Dateien, Prozessen, Mutexen oder Named Pipes zu organisieren.</span><span class="sxs-lookup"><span data-stu-id="8b8da-356">For example, you would use an ordinal sort to organize the names of files, processes, mutexes, or named pipes.</span></span>

-   <span data-ttu-id="8b8da-357">Bei einem Vergleich, bei dem eine Sicherheits Entscheidung besteht (z. b., ob ein Benutzername gültig ist), sollten Sie immer einen ordinaltest auf Gleichheit durchführen, indem Sie eine Überladung der <xref:System.String.Equals%2A>-Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-357">For a comparison that involves a security decision (such as whether a username is valid), you should always perform an ordinal test for equality by calling an overload of the <xref:System.String.Equals%2A> method.</span></span>

> [!NOTE]
>  <span data-ttu-id="8b8da-358">Die für den Zeichen folgen Vergleich verwendeten Kultur abhängigen Sortier-und Schreibregeln sind von der .NET-Version abhängig.</span><span class="sxs-lookup"><span data-stu-id="8b8da-358">The culture-sensitive sorting and casing rules used in string comparison depend on the version of the .NET.</span></span> <span data-ttu-id="8b8da-359">In den .NET Framework 4,5 und höheren Versionen, die auf dem [!INCLUDE[win8](~/includes/win8-md.md)] Betriebssystem ausgeführt werden, entsprechen Sortierung, Groß-/Kleinschreibung, Normalisierung und Unicode-Zeichen Informationen dem Unicode 6,0-Standard.</span><span class="sxs-lookup"><span data-stu-id="8b8da-359">In the .NET Framework 4.5 and later versions running on the [!INCLUDE[win8](~/includes/win8-md.md)] operating system, sorting, casing, normalization, and Unicode character information conforms to the Unicode 6.0 standard.</span></span> <span data-ttu-id="8b8da-360">Unter anderen Windows-Betriebssystemen entspricht Sie dem Unicode-Standard 5,0.</span><span class="sxs-lookup"><span data-stu-id="8b8da-360">On other Windows operating systems, it conforms to the Unicode 5.0 standard.</span></span> <span data-ttu-id="8b8da-361">Unter .net Core hängt dies von der Version des Unicode-Standards ab, der vom zugrunde liegenden Betriebssystem unterstützt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-361">On .NET Core, it depends on the version of the Unicode Standard supported by the underlying operating system.</span></span>

 <span data-ttu-id="8b8da-362">Weitere Informationen zu Wort-, Zeichen folgen-und ordinalsortier Regeln finden Sie im <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> Thema.</span><span class="sxs-lookup"><span data-stu-id="8b8da-362">For more information about word, string, and ordinal sort rules, see the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> topic.</span></span> <span data-ttu-id="8b8da-363">Weitere Empfehlungen zur Verwendung der einzelnen Regeln finden Sie unter [bewährte Methoden für die Verwendung](~/docs/standard/base-types/best-practices-strings.md)von Zeichen folgen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-363">For additional recommendations on when to use each rule, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>

 <span data-ttu-id="8b8da-364">Normalerweise werden keine Zeichen folgen Vergleichsmethoden wie <xref:System.String.Compare%2A> direkt aufgerufen, um die Sortierreihenfolge von Zeichen folgen zu bestimmen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-364">Ordinarily, you don't call string comparison methods such as <xref:System.String.Compare%2A> directly to determine the sort order of strings.</span></span> <span data-ttu-id="8b8da-365">Stattdessen werden Vergleichsmethoden durch Sortiermethoden wie <xref:System.Array.Sort%2A?displayProperty=nameWithType> oder <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-365">Instead, comparison methods are called by sorting methods such as <xref:System.Array.Sort%2A?displayProperty=nameWithType> or <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8b8da-366">Im folgenden Beispiel werden vier verschiedene Sortiervorgänge durchführen (Wort Sortierung mit der aktuellen Kultur, Wort Sortierung mithilfe der invarianten Kultur, Ordinalsortierung und Zeichen folgen Sortierung mithilfe der invarianten Kultur), ohne explizit eine Zeichen folgen Vergleichsmethode aufzurufende, obwohl Sie den zu verwendenden Vergleichstyp angeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-366">The following example performs four different sorting operations (word sort using the current culture, word sort using the invariant culture, ordinal sort, and string sort using the invariant culture) without explicitly calling a string comparison method, although they do specify the type of comparison to use.</span></span> <span data-ttu-id="8b8da-367">Beachten Sie, dass jeder Sortiertyp eine eindeutige Reihenfolge von Zeichen folgen im Array erzeugt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-367">Note that each type of sort produces a unique ordering of strings in its array.</span></span>

 [!code-cpp[System.String.Class#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare2.cpp#12)]
 [!code-csharp[System.String.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare2.cs#12)]
 [!code-vb[System.String.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare2.vb#12)]

> [!TIP]
>  <span data-ttu-id="8b8da-368">Intern verwendet .net Sortierschlüssel, um einen Kultur abhängigen Zeichen folgen Vergleich zu unterstützen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-368">Internally, .NET uses sort keys to support culturally sensitive string comparison.</span></span> <span data-ttu-id="8b8da-369">Jedem Zeichen in einer Zeichenfolge sind mehrere Sortiergewichtungskategorien zugeordnet, darunter nach Skript, alphabetischer Folge, Groß-/Kleinschreibung und diakritischer Gewichtung.</span><span class="sxs-lookup"><span data-stu-id="8b8da-369">Each character in a string is given several categories of sort weights, including alphabetic, case, and diacritic.</span></span> <span data-ttu-id="8b8da-370">Ein Sortierschlüssel, der durch die <xref:System.Globalization.SortKey>-Klasse dargestellt wird, stellt ein Repository dieser Gewichtungen für eine bestimmte Zeichenfolge bereit.</span><span class="sxs-lookup"><span data-stu-id="8b8da-370">A sort key, represented by the <xref:System.Globalization.SortKey> class, provides a repository of these weights for a particular string.</span></span> <span data-ttu-id="8b8da-371">Wenn Ihre APP eine große Anzahl von Such-oder Sortiervorgängen für denselben Satz von Zeichen folgen ausführt, können Sie die Leistung verbessern, indem Sie Sortierschlüssel für alle verwendeten Zeichen folgen erstellen und speichern.</span><span class="sxs-lookup"><span data-stu-id="8b8da-371">If your app performs a large number of searching or sorting operations on the same set of strings, you can improve its performance by generating and storing sort keys for all the strings that it uses.</span></span> <span data-ttu-id="8b8da-372">Wenn eine Sortier-oder Vergleichsoperation erforderlich ist, verwenden Sie die Sortierschlüssel anstelle der Zeichen folgen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-372">When a sort or comparison operation is required, you use the sort keys instead of the strings.</span></span> <span data-ttu-id="8b8da-373">Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Globalization.SortKey>-Klasse.</span><span class="sxs-lookup"><span data-stu-id="8b8da-373">For more information, see the <xref:System.Globalization.SortKey> class.</span></span>

 <span data-ttu-id="8b8da-374">Wenn Sie keine Zeichen folgen Vergleichs Konvention angeben, werden beim Sortieren von Methoden wie <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> eine Kultur abhängige Sortierung für Zeichen folgen unter Beachtung der Groß-/Kleinschreibung durchgeführt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-374">If you don't specify a string comparison convention, sorting methods such as <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> perform a culture-sensitive, case-sensitive sort on strings.</span></span> <span data-ttu-id="8b8da-375">Im folgenden Beispiel wird veranschaulicht, wie sich das Ändern der aktuellen Kultur auf die Reihenfolge sortierter Zeichen folgen in einem Array auswirkt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-375">The following example illustrates how changing the current culture affects the order of sorted strings in an array.</span></span> <span data-ttu-id="8b8da-376">Es wird ein Array mit drei Zeichen folgen erstellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-376">It creates an array of three strings.</span></span> <span data-ttu-id="8b8da-377">Zuerst wird die `System.Threading.Thread.CurrentThread.CurrentCulture`-Eigenschaft auf "en-US" festgelegt, und die <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType>-Methode wird aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-377">First, it sets the `System.Threading.Thread.CurrentThread.CurrentCulture` property to en-US and calls the <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="8b8da-378">Die sich daraus ergebende Sortierreihenfolge basiert auf den Sortierkonventionen für die Kultur Englisch (USA).</span><span class="sxs-lookup"><span data-stu-id="8b8da-378">The resulting sort order is based on sorting conventions for the English (United States) culture.</span></span> <span data-ttu-id="8b8da-379">Als Nächstes wird die `System.Threading.Thread.CurrentThread.CurrentCulture`-Eigenschaft auf "da-DK" festgelegt und die <xref:System.Array.Sort%2A?displayProperty=nameWithType>-Methode erneut aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-379">Next, the example sets the `System.Threading.Thread.CurrentThread.CurrentCulture` property to da-DK and calls the <xref:System.Array.Sort%2A?displayProperty=nameWithType> method again.</span></span> <span data-ttu-id="8b8da-380">Die sich daraus ergebende Sortierreihenfolge unterscheidet sich von den Ergebnissen für "en-US", da die Sortierkonventionen für "Dänisch (Dänemark)" verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-380">Notice how the resulting sort order differs from the en-US results because it uses the sorting conventions for Danish (Denmark).</span></span>

 [!code-csharp[Conceptual.Strings.Comparing#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.comparing/cs/sort1.cs#3)]
 [!code-vb[Conceptual.Strings.Comparing#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.comparing/vb/sort1.vb#3)]

> [!WARNING]
>  <span data-ttu-id="8b8da-381">Wenn Sie den Hauptzweck beim Vergleichen von Zeichen folgen bestimmen, ob Sie gleich sind, sollten Sie die <xref:System.String.Equals%2A?displayProperty=nameWithType>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-381">If your primary purpose in comparing strings is to determine whether they are equal, you should call the <xref:System.String.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="8b8da-382">In der Regel sollten Sie <xref:System.String.Equals%2A> verwenden, um einen Ordinalvergleich durchzuführen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-382">Typically, you should use <xref:System.String.Equals%2A> to perform an ordinal comparison.</span></span> <span data-ttu-id="8b8da-383">Die <xref:System.String.Compare%2A?displayProperty=nameWithType>-Methode dient hauptsächlich zum Sortieren von Zeichen folgen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-383">The <xref:System.String.Compare%2A?displayProperty=nameWithType> method is intended primarily to sort strings.</span></span>

 <span data-ttu-id="8b8da-384">Zeichen folgen Suchmethoden, z. b. <xref:System.String.StartsWith%2A?displayProperty=nameWithType> und <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, können auch Kultur abhängige oder ordinale Zeichen folgen Vergleiche durchführen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-384">String search methods, such as <xref:System.String.StartsWith%2A?displayProperty=nameWithType> and <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, also can perform culture-sensitive or ordinal string comparisons.</span></span> <span data-ttu-id="8b8da-385">Im folgenden Beispiel werden die Unterschiede zwischen Ordinalzahl-und Kultur abhängigen vergleichen mithilfe der <xref:System.String.IndexOf%2A>-Methode veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-385">The following example illustrates the differences between ordinal and culture-sensitive comparisons using the <xref:System.String.IndexOf%2A> method.</span></span> <span data-ttu-id="8b8da-386">Bei einer Kultur abhängigen Suche, bei der es sich bei der aktuellen Kultur um Englisch (USA) handelt, wird die Teil Zeichenfolge "OE" als mit der Ligaturen "." betrachtet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-386">A culture-sensitive search in which the current culture is English (United States) considers the substring "oe" to match the ligature "œ".</span></span> <span data-ttu-id="8b8da-387">Da ein weicher Bindestrich (U + 00ad) ein Zeichen mit einer Breite von NULL ist, behandelt die Suche den weichen Bindestrich als äquivalent zu <xref:System.String.Empty?displayProperty=nameWithtype> und findet eine Übereinstimmung am Anfang der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-387">Because a soft hyphen (U+00AD) is a zero-width character, the search treats the soft hyphen as equivalent to <xref:System.String.Empty?displayProperty=nameWithtype> and finds a match at the beginning of the string.</span></span> <span data-ttu-id="8b8da-388">Eine Ordinalsuche findet dagegen in keinem Fall eine Entsprechung.</span><span class="sxs-lookup"><span data-stu-id="8b8da-388">An ordinal search, on the other hand, does not find a match in either case.</span></span>

 [!code-cpp[System.String.Class#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare3.cpp#13)]
 [!code-csharp[System.String.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare3.cs#13)]
 [!code-vb[System.String.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare3.vb#13)]

### <a name="searching-strings"></a><span data-ttu-id="8b8da-389">Suchen von Zeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="8b8da-389">Searching Strings</span></span>
 <span data-ttu-id="8b8da-390">Zeichen folgen Suchmethoden, z. b. <xref:System.String.StartsWith%2A?displayProperty=nameWithType> und <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, können auch Kultur abhängige oder ordinale Zeichen folgen Vergleiche durchführen, um zu bestimmen, ob ein Zeichen oder eine Teil Zeichenfolge in einer angegebenen Zeichenfolge gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-390">String search methods, such as <xref:System.String.StartsWith%2A?displayProperty=nameWithType> and <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, also can perform culture-sensitive or ordinal string comparisons to determine whether a character or substring is found in a specified string.</span></span>

 <span data-ttu-id="8b8da-391">Die Suchmethoden in der <xref:System.String>-Klasse, die nach einem einzelnen Zeichen suchen, z. b. die <xref:System.String.IndexOf%2A>-Methode, oder eine Zeichenfolge, z. b. die <xref:System.String.IndexOfAny%2A>-Methode, führen eine Ordinalsuche durch.</span><span class="sxs-lookup"><span data-stu-id="8b8da-391">The search methods in the <xref:System.String> class that search for an individual character, such as the <xref:System.String.IndexOf%2A> method, or one of a set of characters,   such as the <xref:System.String.IndexOfAny%2A> method, all perform an ordinal search.</span></span> <span data-ttu-id="8b8da-392">Um eine Kultur abhängige Suche nach einem Zeichen durchzuführen, müssen Sie eine <xref:System.Globalization.CompareInfo> Methode (z. b. <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> oder <xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>) aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-392">To perform a culture-sensitive search for a character, you must call a <xref:System.Globalization.CompareInfo> method such as <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> or <xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8b8da-393">Beachten Sie, dass die Ergebnisse der Suche nach einem Zeichen mit Ordinalzahl und Kultur sensiblem Vergleich sehr unterschiedlich sein können.</span><span class="sxs-lookup"><span data-stu-id="8b8da-393">Note that the results of searching for a character using ordinal and culture-sensitive comparison can be very different.</span></span> <span data-ttu-id="8b8da-394">Beispielsweise kann eine Suche nach einem vorzusammen gesetzten Unicode-Zeichen, wie z. b. die Ligaturen "Æ" (u + 00c6), jedes Vorkommen der zugehörigen Komponenten in der richtigen Reihenfolge, z. b. "AE" (u + 041u + 0045), abhängig von der Kultur entsprechen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-394">For example, a search for a precomposed Unicode character such as the ligature "Æ" (U+00C6) might match any occurrence of its components in the correct sequence, such as "AE" (U+041U+0045), depending on the culture.</span></span> <span data-ttu-id="8b8da-395">Das folgende Beispiel veranschaulicht den Unterschied zwischen den Methoden <xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType> und <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> bei der Suche nach einem einzelnen Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-395">The following example illustrates the difference between the <xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType> and <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> methods when searching for an individual character.</span></span> <span data-ttu-id="8b8da-396">Die Ligaturen "æ" (U + 00e6) wurde in der Zeichenfolge "Luftbild" gefunden, wenn die Konventionen der Kultur "en-US" verwendet werden, aber nicht, wenn die Konventionen der da-DK-Kultur verwendet werden oder wenn ein Ordinalvergleich durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-396">The ligature "æ" (U+00E6) is found in the string "aerial" when using the conventions of the en-US culture, but not when using the conventions of the da-DK culture or when performing an ordinal comparison.</span></span>

 [!code-csharp[System.String.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/search1.cs#22)]
 [!code-vb[System.String.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/search1.vb#22)]

 <span data-ttu-id="8b8da-397">Auf der anderen Seite führen <xref:System.String> Klassen Methoden, die anstelle eines Zeichens nach einer Zeichenfolge suchen, eine Kultur abhängige Suche durch, wenn die Suchoptionen nicht explizit durch einen Parameter vom Typ <xref:System.StringComparison>angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-397">On the other hand, <xref:System.String> class methods that search for a string rather than a character perform a culture-sensitive search if search options are not explicitly specified by a parameter of type <xref:System.StringComparison>.</span></span> <span data-ttu-id="8b8da-398">Die einzige Ausnahme ist <xref:System.String.Contains%2A>, die eine Ordinalsuche durchführt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-398">The sole exception is <xref:System.String.Contains%2A>, which performs an ordinal search.</span></span>

<a name="equality"></a>
### <a name="testing-for-equality"></a><span data-ttu-id="8b8da-399">Testen auf Gleichheit</span><span class="sxs-lookup"><span data-stu-id="8b8da-399">Testing for equality</span></span>
 <span data-ttu-id="8b8da-400">Verwenden Sie die <xref:System.String.Compare%2A?displayProperty=nameWithType>-Methode, um die Beziehung zweier Zeichen folgen in der Sortierreihenfolge zu bestimmen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-400">Use the <xref:System.String.Compare%2A?displayProperty=nameWithType> method to determine the relationship of two strings in the sort order.</span></span> <span data-ttu-id="8b8da-401">In der Regel handelt es sich hierbei um einen Kultur abhängigen Vorgang.</span><span class="sxs-lookup"><span data-stu-id="8b8da-401">Typically, this is a culture-sensitive operation.</span></span> <span data-ttu-id="8b8da-402">Im Gegensatz dazu wird die <xref:System.String.Equals%2A?displayProperty=nameWithType>-Methode aufgerufen, um auf Gleichheit zu prüfen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-402">In contrast, call the <xref:System.String.Equals%2A?displayProperty=nameWithType> method to test for equality.</span></span> <span data-ttu-id="8b8da-403">Da der Test auf Gleichheit normalerweise die Benutzereingaben mit einer bekannten Zeichenfolge vergleicht (z. b. ein gültiger Benutzername, ein Kennwort oder ein Dateisystempfad), handelt es sich in der Regel um einen ordinalvorgang.</span><span class="sxs-lookup"><span data-stu-id="8b8da-403">Because the test for equality usually compares user input with some known string, such as a valid user name, a password, or a file system path, it is typically an ordinal operation.</span></span>

> [!WARNING]
>  <span data-ttu-id="8b8da-404">Es ist möglich, auf Gleichheit zu testen, indem Sie die <xref:System.String.Compare%2A?displayProperty=nameWithType>-Methode aufrufen und ermitteln, ob der Rückgabewert 0 (null) ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-404">It is possible to test for equality by calling the <xref:System.String.Compare%2A?displayProperty=nameWithType> method and determining whether the return value is zero.</span></span> <span data-ttu-id="8b8da-405">Diese Vorgehensweise wird jedoch nicht empfohlen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-405">However, this practice is not recommended.</span></span> <span data-ttu-id="8b8da-406">Um zu ermitteln, ob zwei Zeichen folgen gleich sind, sollten Sie eine der über Ladungen der <xref:System.String.Equals%2A?displayProperty=nameWithType>-Methode abrufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-406">To determine whether two strings are equal, you should call one of the overloads of the <xref:System.String.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="8b8da-407">Die bevorzugte Überladung, die aufgerufen werden soll, ist entweder die Instanz <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29>-Methode oder die statische <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29>-Methode, da beide Methoden einen <xref:System.StringComparison?displayProperty=nameWithType>-Parameter enthalten, der den Typ des Vergleichs explizit angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-407">The preferred overload to call is either the instance <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> method or the static <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, because both methods include a <xref:System.StringComparison?displayProperty=nameWithType> parameter that explicitly specifies the type of comparison.</span></span>

 <span data-ttu-id="8b8da-408">Das folgende Beispiel veranschaulicht die Gefahr der Durchführung eines Kultur abhängigen Vergleichs auf Gleichheit, wenn stattdessen eine Ordinalzahl verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-408">The following example illustrates the danger of performing a culture-sensitive comparison for equality when an ordinal one should be used instead.</span></span> <span data-ttu-id="8b8da-409">In diesem Fall besteht der Zweck des Codes darin, den Dateisystem Zugriff über URLs zu verweigern, die mit "file://" oder "file://" beginnen, indem Sie einen Vergleich des Anfangs einer URL mit der Zeichenfolge "file://" ohne Beachtung der Groß-/Kleinschreibung durchführen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-409">In this case, the intent of the code is to prohibit file system access from URLs that begin with "FILE://" or "file://" by performing a case-insensitive comparison of the beginning of a URL with the string "FILE://".</span></span> <span data-ttu-id="8b8da-410">Wenn jedoch ein Kultur abhängiger Vergleich mithilfe der türkischen Kultur (Türkei) für eine URL durchgeführt wird, die mit "file://" beginnt, schlägt der Vergleich der Gleichheit fehl, da die Entsprechung von "i" in Großbuchstaben "i" anstelle von "i" lautet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-410">However, if a culture-sensitive comparison is performed using the Turkish (Turkey) culture on a URL that begins with "file://", the comparison for equality fails, because the Turkish uppercase equivalent of the lowercase "i" is "İ" instead of "I".</span></span> <span data-ttu-id="8b8da-411">Folglich ist der Zugriff auf Dateisysteme versehentlich zulässig.</span><span class="sxs-lookup"><span data-stu-id="8b8da-411">As a result, file system access is inadvertently permitted.</span></span> <span data-ttu-id="8b8da-412">Wenn dagegen ein Ordinalvergleich durchgeführt wird, ist der Vergleich der Gleichheit erfolgreich, und der Dateisystem Zugriff wird verweigert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-412">On the other hand, if an ordinal comparison is performed, the comparison for equality succeeds, and file system access is denied.</span></span>

 [!code-cpp[System.String.Class#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.equals.cpp#11)]
 [!code-csharp[System.String.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/equality1.cs#11)]
 [!code-vb[System.String.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/equality1.vb#11)]

<a name="Normalization"></a>
## <a name="normalization"></a><span data-ttu-id="8b8da-413">Normalisierung</span><span class="sxs-lookup"><span data-stu-id="8b8da-413">Normalization</span></span>
 <span data-ttu-id="8b8da-414">Einige Unicode-Zeichen verfügen über mehrere Darstellungen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-414">Some Unicode characters have multiple representations.</span></span> <span data-ttu-id="8b8da-415">Beispielsweise kann jeder der folgenden Code Punkte den Buchstaben "ắ" darstellen:</span><span class="sxs-lookup"><span data-stu-id="8b8da-415">For example, any of the following code points can represent the letter "ắ":</span></span>

-   <span data-ttu-id="8b8da-416">U + 1eaf</span><span class="sxs-lookup"><span data-stu-id="8b8da-416">U+1EAF</span></span>

-   <span data-ttu-id="8b8da-417">U+0103 U+0301</span><span class="sxs-lookup"><span data-stu-id="8b8da-417">U+0103 U+0301</span></span>

-   <span data-ttu-id="8b8da-418">U+0061 U+0306 U+0301</span><span class="sxs-lookup"><span data-stu-id="8b8da-418">U+0061 U+0306 U+0301</span></span>

 <span data-ttu-id="8b8da-419">Mehrere Darstellungen eines einzelnen Zeichens erschweren das suchen, sortieren, vergleichen und andere Zeichen folgen Operationen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-419">Multiple representations for a single character complicate searching, sorting, matching, and other string operations.</span></span>

 <span data-ttu-id="8b8da-420">Der Unicode-Standard definiert einen Prozess, der als Normalisierung bezeichnet wird und eine binäre Darstellung eines Unicode-Zeichens für eine der entsprechenden binären Darstellungen zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-420">The Unicode standard defines a process called normalization that returns one binary representation of a Unicode character for any of its equivalent binary representations.</span></span> <span data-ttu-id="8b8da-421">Bei der Normalisierung können mehrere Algorithmen verwendet werden, die als normalisierungs Formulare bezeichnet werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-421">Normalization can use several algorithms, called normalization forms, that follow different rules.</span></span> <span data-ttu-id="8b8da-422">.NET unterstützt Unicode-Normalisierungsformen C, D, KC und KD.</span><span class="sxs-lookup"><span data-stu-id="8b8da-422">.NET supports Unicode normalization forms C, D, KC, and KD.</span></span> <span data-ttu-id="8b8da-423">Wenn Zeichen folgen in dieselbe normalisierungs Form normalisiert wurden, können Sie mithilfe eines Ordinalvergleichs verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-423">When strings have been normalized to the same normalization form, they can be compared by using ordinal comparison.</span></span>

 <span data-ttu-id="8b8da-424">Ein Ordinalvergleich ist ein binärer Vergleich des Unicode-skalarwerts der entsprechenden <xref:System.Char>-Objekte in den einzelnen Zeichen folgen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-424">An ordinal comparison is a binary comparison of the Unicode scalar value of corresponding <xref:System.Char> objects in each string.</span></span> <span data-ttu-id="8b8da-425">Die <xref:System.String>-Klasse enthält eine Reihe von Methoden, die einen Ordinalvergleich durchführen können, einschließlich der folgenden:</span><span class="sxs-lookup"><span data-stu-id="8b8da-425">The <xref:System.String> class includes a number of methods that can perform an ordinal comparison, including the following:</span></span>

-   <span data-ttu-id="8b8da-426">Jede Überladung der Methoden <xref:System.String.Compare%2A>, <xref:System.String.Equals%2A>, <xref:System.String.StartsWith%2A>, <xref:System.String.EndsWith%2A>, <xref:System.String.IndexOf%2A>und <xref:System.String.LastIndexOf%2A>, die einen <xref:System.StringComparison>-Parameter enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-426">Any overload of the <xref:System.String.Compare%2A>, <xref:System.String.Equals%2A>, <xref:System.String.StartsWith%2A>,  <xref:System.String.EndsWith%2A>, <xref:System.String.IndexOf%2A>, and <xref:System.String.LastIndexOf%2A> methods that includes a <xref:System.StringComparison> parameter.</span></span> <span data-ttu-id="8b8da-427">Die-Methode führt einen Ordinalvergleich durch, wenn Sie für diesen Parameter den Wert <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> oder <xref:System.StringComparison.OrdinalIgnoreCase> angeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-427">The method performs an ordinal comparison if you supply a value of <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase> for this parameter.</span></span>

-   <span data-ttu-id="8b8da-428">Die über Ladungen der <xref:System.String.CompareOrdinal%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="8b8da-428">The overloads of the <xref:System.String.CompareOrdinal%2A> method.</span></span>

-   <span data-ttu-id="8b8da-429">Methoden, die standardmäßig einen Ordinalvergleich verwenden, z. b. <xref:System.String.Contains%2A>, <xref:System.String.Replace%2A>und <xref:System.String.Split%2A>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-429">Methods that use ordinal comparison by default, such as <xref:System.String.Contains%2A>, <xref:System.String.Replace%2A>, and <xref:System.String.Split%2A>.</span></span>

-   <span data-ttu-id="8b8da-430">Methoden, die nach einem <xref:System.Char> Wert oder nach den Elementen in einem <xref:System.Char> Array in einer Zeichen folgen Instanz suchen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-430">Methods that search for a <xref:System.Char> value or for the elements in a <xref:System.Char> array in a string instance.</span></span> <span data-ttu-id="8b8da-431">Zu diesen Methoden gehören <xref:System.String.IndexOf%28System.Char%29> und <xref:System.String.Split%28System.Char%5B%5D%29>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-431">Such methods include <xref:System.String.IndexOf%28System.Char%29> and <xref:System.String.Split%28System.Char%5B%5D%29>.</span></span>

 <span data-ttu-id="8b8da-432">Sie können bestimmen, ob eine Zeichenfolge in die normalisierungs Form C normalisiert wird, indem Sie die <xref:System.String.IsNormalized?displayProperty=nameWithType>-Methode aufrufen, oder Sie können die <xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType>-Methode aufrufen, um zu bestimmen, ob eine Zeichenfolge in eine angegebene normalisierungs Form normalisiert wird</span><span class="sxs-lookup"><span data-stu-id="8b8da-432">You can determine whether a string is normalized to normalization form C by calling the <xref:System.String.IsNormalized?displayProperty=nameWithType> method, or you can call the <xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType> method to determine whether a string is normalized to a specified normalization form.</span></span> <span data-ttu-id="8b8da-433">Sie können auch die <xref:System.String.Normalize?displayProperty=nameWithType>-Methode zum Konvertieren einer Zeichenfolge in eine normalisierungs Form C oder die <xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType>-Methode zum Konvertieren einer Zeichenfolge in eine angegebene normalisierungs Form aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-433">You can also call the <xref:System.String.Normalize?displayProperty=nameWithType> method to convert a string to normalization form C, or you can call the <xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType> method to convert a string to a specified normalization form.</span></span> <span data-ttu-id="8b8da-434">Schritt-für-Schritt-Informationen zum normalisieren und Vergleichen von Zeichen folgen finden Sie in den Methoden <xref:System.String.Normalize> und <xref:System.String.Normalize%28System.Text.NormalizationForm%29>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-434">For step-by-step information about normalizing and comparing strings, see the <xref:System.String.Normalize> and <xref:System.String.Normalize%28System.Text.NormalizationForm%29> methods.</span></span>

 <span data-ttu-id="8b8da-435">Das folgende einfache Beispiel veranschaulicht die Normalisierung von Zeichen folgen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-435">The following simple example illustrates string normalization.</span></span> <span data-ttu-id="8b8da-436">Er definiert den Buchstaben "ố" in drei verschiedenen Arten in drei verschiedenen Zeichen folgen und verwendet einen Ordinalvergleich für Gleichheit, um zu bestimmen, ob jede Zeichenfolge von den beiden anderen Zeichen folgen abweicht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-436">It defines the letter "ố" in three different ways in three different strings, and uses an ordinal comparison for equality to determine that each string differs from the other two strings.</span></span> <span data-ttu-id="8b8da-437">Anschließend konvertiert Sie jede Zeichenfolge in die unterstützten Normalisierungsformen und führt erneut einen Ordinalvergleich der einzelnen Zeichen folgen in einer angegebenen normalisierungs Form durch.</span><span class="sxs-lookup"><span data-stu-id="8b8da-437">It then converts each string to the supported normalization forms, and again performs an ordinal comparison of each string in a specified normalization form.</span></span> <span data-ttu-id="8b8da-438">In jedem Fall zeigt der zweite Test auf Gleichheit, dass die Zeichen folgen gleich sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-438">In each case, the second test for equality shows that the strings are equal.</span></span>

 [!code-cpp[System.String.Class#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.normalize.cpp#14)]
 [!code-csharp[System.String.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/normalize1.cs#14)]
 [!code-vb[System.String.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/normalize1.vb#14)]

 <span data-ttu-id="8b8da-439">Weitere Informationen zu normalisierungs-und normalisierungs Formularen finden Sie unter <xref:System.Text.NormalizationForm?displayProperty=nameWithType>und [Unicode-Standard Anhang #15: Unicode-normalisierungs Formulare](https://unicode.org/reports/tr15/) und häufig gestellte Fragen zur [Normalisierung](https://www.unicode.org/faq/normalization.html) auf der Unicode.org-Website.</span><span class="sxs-lookup"><span data-stu-id="8b8da-439">For more information about normalization and normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=nameWithType>, as well as [Unicode Standard Annex #15: Unicode Normalization Forms](https://unicode.org/reports/tr15/) and the [Normalization FAQ](https://www.unicode.org/faq/normalization.html) on the unicode.org website.</span></span>

<a name="ByCategory"></a>
## <a name="string-operations-by-category"></a><span data-ttu-id="8b8da-440">Zeichen folgen Vorgänge nach Kategorie</span><span class="sxs-lookup"><span data-stu-id="8b8da-440">String operations by category</span></span>
 <span data-ttu-id="8b8da-441">Die <xref:System.String>-Klasse stellt Member zum Vergleichen von Zeichen folgen, zum Testen von Zeichen folgen auf Gleichheit, zum Suchen von Zeichen oder Teil Zeichenfolgen in einer Zeichenfolge, zum Ändern einer Zeichenfolge, zum Extrahieren von Teil Zeichenfolgen aus einer Zeichenfolge, zum Kombinieren von Zeichen folgen, zum Formatieren von Werten</span><span class="sxs-lookup"><span data-stu-id="8b8da-441">The <xref:System.String> class provides members for comparing strings, testing strings for equality, finding characters or substrings in a string, modifying a string, extracting substrings from a string, combining strings, formatting values, copying a string, and normalizing a string.</span></span>

### <a name="comparing-strings"></a><span data-ttu-id="8b8da-442">Vergleichen von Zeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="8b8da-442">Comparing strings</span></span>
 <span data-ttu-id="8b8da-443">Sie können Zeichen folgen vergleichen, um ihre relative Position in der Sortierreihenfolge zu ermitteln, indem Sie die folgenden <xref:System.String> Methoden verwenden:</span><span class="sxs-lookup"><span data-stu-id="8b8da-443">You can compare strings to determine their relative position in the sort order by using the following <xref:System.String> methods:</span></span>

-   <span data-ttu-id="8b8da-444"><xref:System.String.Compare%2A> gibt eine ganze Zahl zurück, die die Beziehung zwischen einer Zeichenfolge und einer zweiten Zeichenfolge in der Sortierreihenfolge angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-444"><xref:System.String.Compare%2A> returns an integer that indicates the relationship of one string to a second string in the sort order.</span></span>

-   <span data-ttu-id="8b8da-445"><xref:System.String.CompareOrdinal%2A> gibt eine ganze Zahl zurück, die die Beziehung zwischen einer Zeichenfolge und einer zweiten Zeichenfolge auf Grundlage eines Vergleichs ihrer Code Punkte angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-445"><xref:System.String.CompareOrdinal%2A> returns an integer that indicates the relationship of one string to a second string based on a comparison of their code points.</span></span>

-   <span data-ttu-id="8b8da-446"><xref:System.String.CompareTo%2A> gibt eine ganze Zahl zurück, die die Beziehung der aktuellen Zeichen folgen Instanz zu einer zweiten Zeichenfolge in der Sortierreihenfolge angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-446"><xref:System.String.CompareTo%2A> returns an integer that indicates the relationship of the current string instance to a second string in the sort order.</span></span> <span data-ttu-id="8b8da-447">Die <xref:System.String.CompareTo%28System.String%29>-Methode stellt die <xref:System.IComparable>-und <xref:System.IComparable%601>-Implementierungen für die <xref:System.String>-Klasse bereit.</span><span class="sxs-lookup"><span data-stu-id="8b8da-447">The <xref:System.String.CompareTo%28System.String%29> method provides the <xref:System.IComparable> and <xref:System.IComparable%601> implementations for the <xref:System.String> class.</span></span>

### <a name="testing-strings-for-equality"></a><span data-ttu-id="8b8da-448">Testen von Zeichen folgen auf Gleichheit</span><span class="sxs-lookup"><span data-stu-id="8b8da-448">Testing strings for equality</span></span>
 <span data-ttu-id="8b8da-449">Die <xref:System.String.Equals%2A>-Methode wird aufgerufen, um zu bestimmen, ob zwei Zeichen folgen gleich sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-449">You call the <xref:System.String.Equals%2A> method to determine whether two strings are equal.</span></span> <span data-ttu-id="8b8da-450">Mit der Instanz <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> und den statischen <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> Überladungen können Sie angeben, ob der Vergleich Kultur abhängig ist, und ob die Groß-/Kleinschreibung berücksichtigt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-450">The instance <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> and the static <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> overloads let you specify whether the comparison is culture-sensitive or ordinal, and whether case is considered or ignored.</span></span> <span data-ttu-id="8b8da-451">Die meisten Gleichheits Tests sind Ordinalzahlen, und Vergleiche auf Gleichheit, die den Zugriff auf eine System Ressource bestimmen (z. b. ein Dateisystem Objekt), sollten immer eine Ordinalzahl sein.</span><span class="sxs-lookup"><span data-stu-id="8b8da-451">Most tests for equality are ordinal, and comparisons for equality that determine access to a system resource (such as a file system object) should always be ordinal.</span></span>

### <a name="finding-characters-in-a-string"></a><span data-ttu-id="8b8da-452">Suchen von Zeichen in einer Zeichenfolge</span><span class="sxs-lookup"><span data-stu-id="8b8da-452">Finding characters in a string</span></span>
 <span data-ttu-id="8b8da-453">Die <xref:System.String>-Klasse enthält zwei Arten von Suchmethoden:</span><span class="sxs-lookup"><span data-stu-id="8b8da-453">The <xref:System.String> class includes two kinds of search methods:</span></span>

-   <span data-ttu-id="8b8da-454">Methoden, die einen <xref:System.Boolean> Wert zurückgeben, um anzugeben, ob eine bestimmte Teil Zeichenfolge in einer Zeichen folgen Instanz vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-454">Methods that return a <xref:System.Boolean> value to indicate whether a particular substring is present in a string instance.</span></span> <span data-ttu-id="8b8da-455">Hierzu gehören die Methoden <xref:System.String.Contains%2A>, <xref:System.String.EndsWith%2A>und <xref:System.String.StartsWith%2A>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-455">These include the <xref:System.String.Contains%2A>, <xref:System.String.EndsWith%2A>, and <xref:System.String.StartsWith%2A> methods.</span></span>

-   <span data-ttu-id="8b8da-456">Methoden, die die Anfangsposition einer Teil Zeichenfolge in einer Zeichen folgen Instanz angeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-456">Methods that indicate the starting position of a substring in a string instance.</span></span> <span data-ttu-id="8b8da-457">Hierzu gehören die Methoden <xref:System.String.IndexOf%2A>, <xref:System.String.IndexOfAny%2A>, <xref:System.String.LastIndexOf%2A>und <xref:System.String.LastIndexOfAny%2A>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-457">These include the <xref:System.String.IndexOf%2A>, <xref:System.String.IndexOfAny%2A>, <xref:System.String.LastIndexOf%2A>, and <xref:System.String.LastIndexOfAny%2A> methods.</span></span>

> [!WARNING]
>  <span data-ttu-id="8b8da-458">Wenn Sie eine Zeichenfolge nach einem bestimmten Muster und nicht nach einer bestimmten Teil Zeichenfolge durchsuchen möchten, sollten Sie reguläre Ausdrücke verwenden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-458">If you want to search a string for a particular pattern rather than a specific substring, you should use regular expressions.</span></span> <span data-ttu-id="8b8da-459">Weitere Informationen finden Sie unter [reguläre Ausdrücke in .net](~/docs/standard/base-types/regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="8b8da-459">For more information, see [.NET Regular Expressions](~/docs/standard/base-types/regular-expressions.md).</span></span>

### <a name="modifying-a-string"></a><span data-ttu-id="8b8da-460">Ändern einer Zeichenfolge</span><span class="sxs-lookup"><span data-stu-id="8b8da-460">Modifying a string</span></span>
 <span data-ttu-id="8b8da-461">Die <xref:System.String>-Klasse enthält die folgenden Methoden, um den Wert einer Zeichenfolge zu ändern:</span><span class="sxs-lookup"><span data-stu-id="8b8da-461">The <xref:System.String> class includes the following methods that appear to modify the value of a string:</span></span>

-   <span data-ttu-id="8b8da-462"><xref:System.String.Insert%2A> fügt eine Zeichenfolge in die aktuelle <xref:System.String> Instanz ein.</span><span class="sxs-lookup"><span data-stu-id="8b8da-462"><xref:System.String.Insert%2A> inserts a string into the current <xref:System.String> instance.</span></span>

-   <span data-ttu-id="8b8da-463"><xref:System.String.PadLeft%2A> fügt ein oder mehrere Vorkommen eines angegebenen Zeichens am Anfang einer Zeichenfolge ein.</span><span class="sxs-lookup"><span data-stu-id="8b8da-463"><xref:System.String.PadLeft%2A> inserts one or more occurrences of a specified character at the beginning of a string.</span></span>

-   <span data-ttu-id="8b8da-464"><xref:System.String.PadRight%2A> fügt ein oder mehrere Vorkommen eines angegebenen Zeichens am Ende einer Zeichenfolge ein.</span><span class="sxs-lookup"><span data-stu-id="8b8da-464"><xref:System.String.PadRight%2A> inserts one or more occurrences of a specified character at the end of a string.</span></span>

-   <span data-ttu-id="8b8da-465"><xref:System.String.Remove%2A> löscht eine Teil Zeichenfolge aus der aktuellen <xref:System.String> Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-465"><xref:System.String.Remove%2A> deletes a substring from the current <xref:System.String> instance.</span></span>

-   <span data-ttu-id="8b8da-466"><xref:System.String.Replace%2A> ersetzt eine Teil Zeichenfolge durch eine andere Teil Zeichenfolge in der aktuellen <xref:System.String> Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-466"><xref:System.String.Replace%2A> replaces a substring with another substring in the current <xref:System.String> instance.</span></span>

-   <span data-ttu-id="8b8da-467"><xref:System.String.ToLower%2A> und <xref:System.String.ToLowerInvariant%2A> alle Zeichen in einer Zeichenfolge in Kleinbuchstaben konvertieren.</span><span class="sxs-lookup"><span data-stu-id="8b8da-467"><xref:System.String.ToLower%2A> and <xref:System.String.ToLowerInvariant%2A> convert all the characters in a string to lowercase.</span></span>

-   <span data-ttu-id="8b8da-468"><xref:System.String.ToUpper%2A> und <xref:System.String.ToUpperInvariant%2A> alle Zeichen in einer Zeichenfolge in Großbuchstaben konvertieren.</span><span class="sxs-lookup"><span data-stu-id="8b8da-468"><xref:System.String.ToUpper%2A> and <xref:System.String.ToUpperInvariant%2A> convert all the characters in a string to uppercase.</span></span>

-   <span data-ttu-id="8b8da-469"><xref:System.String.Trim%2A> entfernt alle Vorkommen eines Zeichens am Anfang und am Ende einer Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-469"><xref:System.String.Trim%2A> removes all occurrences of a character from the beginning and end of a string.</span></span>

-   <span data-ttu-id="8b8da-470"><xref:System.String.TrimEnd%2A> entfernt alle Vorkommen eines Zeichens vom Ende einer Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-470"><xref:System.String.TrimEnd%2A> removes all occurrences of a character from the end of a string.</span></span>

-   <span data-ttu-id="8b8da-471"><xref:System.String.TrimStart%2A> entfernt alle Vorkommen eines Zeichens am Anfang einer Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-471"><xref:System.String.TrimStart%2A> removes all occurrences of a character from the beginning of a string.</span></span>

> [!IMPORTANT]
>  <span data-ttu-id="8b8da-472">Alle Methoden zum Ändern von Zeichen folgen geben ein neues <xref:System.String> Objekt zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-472">All string modification methods return a new <xref:System.String> object.</span></span> <span data-ttu-id="8b8da-473">Der Wert der aktuellen Instanz wird nicht geändert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-473">They don't modify the value of the current instance.</span></span>

### <a name="extracting-substrings-from-a-string"></a><span data-ttu-id="8b8da-474">Extrahieren von Teil Zeichenfolgen aus einer Zeichenfolge</span><span class="sxs-lookup"><span data-stu-id="8b8da-474">Extracting substrings from a string</span></span>
 <span data-ttu-id="8b8da-475">Die <xref:System.String.Split%2A?displayProperty=nameWithType>-Methode trennt eine einzelne Zeichenfolge in mehrere Zeichen folgen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-475">The <xref:System.String.Split%2A?displayProperty=nameWithType> method separates a single string into multiple strings.</span></span> <span data-ttu-id="8b8da-476">Über Ladungen der-Methode ermöglichen es Ihnen, mehrere Trennzeichen anzugeben, um die maximale Anzahl von Teil Zeichenfolgen zu bestimmen, die von der Methode extrahiert werden, und um zu bestimmen, ob leere Zeichen folgen, die bei angrenzenden Trennzeichen auftreten, in den zurückgegebenen Zeichen folgen enthalten sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-476">Overloads of the method allow you to specify multiple delimiters, to determine the maximum number of substrings that the method extracts, and to determine whether empty strings (which occur when delimiters are adjacent) are included among the returned strings.</span></span>

### <a name="combining-strings"></a><span data-ttu-id="8b8da-477">Verbinden von Zeichen folgen</span><span class="sxs-lookup"><span data-stu-id="8b8da-477">Combining strings</span></span>
 <span data-ttu-id="8b8da-478">Die folgenden <xref:System.String> Methoden können für die Verkettung von Zeichen folgen verwendet werden:</span><span class="sxs-lookup"><span data-stu-id="8b8da-478">The following <xref:System.String> methods can be used for string concatenation:</span></span>

-   <span data-ttu-id="8b8da-479"><xref:System.String.Concat%2A> kombiniert mindestens eine Teil Zeichenfolge zu einer einzelnen Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-479"><xref:System.String.Concat%2A> combines one or more substrings into a single string.</span></span>

-   <span data-ttu-id="8b8da-480"><xref:System.String.Join%2A> verkettet eine oder mehrere Teil Zeichenfolgen zu einem einzelnen Element und fügt zwischen den einzelnen Teil Zeichenfolgen ein Trennzeichen hinzu.</span><span class="sxs-lookup"><span data-stu-id="8b8da-480"><xref:System.String.Join%2A> concatenates one or more substrings into a single element and adds a separator between each substring.</span></span>

### <a name="formatting-values"></a><span data-ttu-id="8b8da-481">Formatieren von Werten</span><span class="sxs-lookup"><span data-stu-id="8b8da-481">Formatting values</span></span>
 <span data-ttu-id="8b8da-482">Die <xref:System.String.Format%2A?displayProperty=nameWithType>-Methode verwendet die Funktion für die kombinierte Formatierung, um einen oder mehrere Platzhalter in einer Zeichenfolge durch die Zeichen folgen Darstellung eines Objekts oder Werts zu ersetzen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-482">The <xref:System.String.Format%2A?displayProperty=nameWithType> method uses the composite formatting feature to replace one or more placeholders in a string with the string representation of some object or value.</span></span> <span data-ttu-id="8b8da-483">Die <xref:System.String.Format%2A>-Methode wird häufig für folgende Aufgaben verwendet:</span><span class="sxs-lookup"><span data-stu-id="8b8da-483">The <xref:System.String.Format%2A> method is often used to do the following:</span></span>

-   <span data-ttu-id="8b8da-484">, Um die Zeichen folgen Darstellung eines numerischen Werts in eine Zeichenfolge einzubetten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-484">To embed the string representation of a numeric value in a string.</span></span>

-   <span data-ttu-id="8b8da-485">, Um die Zeichen folgen Darstellung eines Datums-und Uhrzeitwerts in eine Zeichenfolge einzubetten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-485">To embed the string representation of a date and time value in a string.</span></span>

-   <span data-ttu-id="8b8da-486">, Um die Zeichen folgen Darstellung eines Enumerationswerts in eine Zeichenfolge einzubetten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-486">To embed the string representation of an enumeration value in a string.</span></span>

-   <span data-ttu-id="8b8da-487">Zum Einbetten der Zeichen folgen Darstellung eines Objekts, das die <xref:System.IFormattable>-Schnittstelle in einer Zeichenfolge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-487">To embed the string representation of some object that supports the <xref:System.IFormattable> interface in a string.</span></span>

-   <span data-ttu-id="8b8da-488">, Um eine Teil Zeichenfolge in einem Feld innerhalb einer größeren Zeichenfolge nach rechts zu begründen oder linksbündig zu begründen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-488">To right-justify or left-justify a substring in a field within a larger string.</span></span>

 <span data-ttu-id="8b8da-489">Ausführliche Informationen zu Formatierungs Vorgängen und Beispielen finden Sie in der Übersicht über die <xref:System.String.Format%2A> Überladung.</span><span class="sxs-lookup"><span data-stu-id="8b8da-489">For detailed information about formatting operations and examples, see the <xref:System.String.Format%2A> overload summary.</span></span>

### <a name="copying-a-string"></a><span data-ttu-id="8b8da-490">Kopieren einer Zeichenfolge</span><span class="sxs-lookup"><span data-stu-id="8b8da-490">Copying a string</span></span>
 <span data-ttu-id="8b8da-491">Sie können die folgenden <xref:System.String>-Methoden zum Erstellen einer Kopie einer Zeichenfolge aufzurufen:</span><span class="sxs-lookup"><span data-stu-id="8b8da-491">You can call the following <xref:System.String> methods to make a copy of a string:</span></span>

-   <span data-ttu-id="8b8da-492"><xref:System.String.Clone%2A> gibt einen Verweis auf ein vorhandenes <xref:System.String>-Objekt zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-492"><xref:System.String.Clone%2A> returns a reference to an existing <xref:System.String> object.</span></span>

-   <span data-ttu-id="8b8da-493"><xref:System.String.Copy%2A> erstellt eine Kopie einer vorhandenen Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-493"><xref:System.String.Copy%2A> creates a copy of an existing string.</span></span>

-   <span data-ttu-id="8b8da-494"><xref:System.String.CopyTo%2A> kopiert einen Teil einer Zeichenfolge in ein Zeichen Array.</span><span class="sxs-lookup"><span data-stu-id="8b8da-494"><xref:System.String.CopyTo%2A> copies a portion of a string to a character array.</span></span>

### <a name="normalizing-a-string"></a><span data-ttu-id="8b8da-495">Normalisieren einer Zeichenfolge</span><span class="sxs-lookup"><span data-stu-id="8b8da-495">Normalizing a string</span></span>
 <span data-ttu-id="8b8da-496">In Unicode kann ein einzelnes Zeichen über mehrere Code Punkte verfügen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-496">In Unicode, a single character can have multiple code points.</span></span> <span data-ttu-id="8b8da-497">Bei der Normalisierung werden diese äquivalenten Zeichen in dieselbe binäre Darstellung konvertiert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-497">Normalization converts these equivalent characters into the same binary representation.</span></span> <span data-ttu-id="8b8da-498">Die <xref:System.String.Normalize%2A?displayProperty=nameWithType>-Methode führt die Normalisierung aus, und die <xref:System.String.IsNormalized%2A?displayProperty=nameWithType>-Methode bestimmt, ob eine Zeichenfolge normalisiert wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-498">The <xref:System.String.Normalize%2A?displayProperty=nameWithType> method performs the normalization, and the <xref:System.String.IsNormalized%2A?displayProperty=nameWithType> method determines whether a string is normalized.</span></span>

 <span data-ttu-id="8b8da-499">Weitere Informationen und ein Beispiel finden Sie im Abschnitt [Normalisierung](#Normalization) weiter oben in diesem Thema.</span><span class="sxs-lookup"><span data-stu-id="8b8da-499">For more information and an example, see the [Normalization](#Normalization) section earlier in this topic.</span></span>

 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://www.microsoft.com/download/details.aspx?id=10921"><span data-ttu-id="8b8da-500">Sortieren von Gewichtungs Tabellen für Windows-Betriebssysteme</span><span class="sxs-lookup"><span data-stu-id="8b8da-500">Sorting Weight Tables for Windows operating systems</span></span></related>
    <related type="ExternalDocumentation" href="https://www.unicode.org/Public/UCA/latest/allkeys.txt"><span data-ttu-id="8b8da-501">Standardmäßige Unicode-Sortierungs Element Tabelle für Linux und macOS</span><span class="sxs-lookup"><span data-stu-id="8b8da-501">Default Unicode Collation Element Table, for Linux and macOS</span></span></related>
    <threadsafe><span data-ttu-id="8b8da-502">Dieser Typ ist threadsicher.</span><span class="sxs-lookup"><span data-stu-id="8b8da-502">This type is thread safe.</span></span></threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.ICloneable" />
    <altmember cref="T:System.IConvertible" />
    <altmember cref="T:System.Collections.IEnumerable" />
    <altmember cref="T:System.Text.StringBuilder" />
    <altmember cref="T:System.Globalization.CultureInfo" />
    <related type="Article" href="~/docs/standard/base-types/formatting-types.md"><span data-ttu-id="8b8da-503">Formatieren von Typen in .NET</span><span class="sxs-lookup"><span data-stu-id="8b8da-503">Formatting Types in .NET</span></span></related>
    <related type="Article" href="~/docs/standard/base-types/best-practices-strings.md"><span data-ttu-id="8b8da-504">Empfohlene Vorgehensweisen für die Verwendung von Zeichenfolgen in .NET</span><span class="sxs-lookup"><span data-stu-id="8b8da-504">Best Practices for Using Strings in .NET</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8b8da-505">Initialisiert eine neue Instanz der <see cref="T:System.String" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="8b8da-505">Initializes a new instance of the <see cref="T:System.String" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
<span data-ttu-id="8b8da-506">In diesem Abschnitt</span><span class="sxs-lookup"><span data-stu-id="8b8da-506">In this section:</span></span>

<span data-ttu-id="8b8da-507">[Syntax für überladene Konstruktoren](#Syntax)</span><span class="sxs-lookup"><span data-stu-id="8b8da-507">[Overloaded constructor syntax](#Syntax)</span></span>\
<span data-ttu-id="8b8da-508">[Parameter](#Params)</span><span class="sxs-lookup"><span data-stu-id="8b8da-508">[Parameters](#Params)</span></span>\
<span data-ttu-id="8b8da-509">[Ausnahmen](#Exceptions)</span><span class="sxs-lookup"><span data-stu-id="8b8da-509">[Exceptions](#Exceptions)</span></span>\
<span data-ttu-id="8b8da-510">[Welche Methode rufe ich auf?](#Tasks)</span><span class="sxs-lookup"><span data-stu-id="8b8da-510">[Which method do I call?](#Tasks)</span></span>\
<span data-ttu-id="8b8da-511">[Erstellen](#Creating_Strings) von Zeichen folgen</span><span class="sxs-lookup"><span data-stu-id="8b8da-511">[Creating strings](#Creating_Strings)</span></span>\
[<span data-ttu-id="8b8da-512">Wiederkehrende Zeichen folgen behandeln</span><span class="sxs-lookup"><span data-stu-id="8b8da-512">Handle repetitive strings</span></span>](#Repetitive)

<span data-ttu-id="8b8da-513">Beispiele für das Instanziieren von Zeichen folgen:</span><span class="sxs-lookup"><span data-stu-id="8b8da-513">Examples of instantiating strings:</span></span>

<span data-ttu-id="8b8da-514">[Zeichen folgen Zuweisung\ verwenden](#Ctor1_Example)</span><span class="sxs-lookup"><span data-stu-id="8b8da-514">[Use string assignment](#Ctor1_Example)\</span></span>
<span data-ttu-id="8b8da-515">[Zeichen Array verwenden](#Ctor2_Example)</span><span class="sxs-lookup"><span data-stu-id="8b8da-515">[Use a character array](#Ctor2_Example)</span></span>\
<span data-ttu-id="8b8da-516">[Verwenden Sie einen Teil eines Zeichen Arrays, und wiederholen Sie ein einzelnes Zeichen](#Ctor3_Example)</span><span class="sxs-lookup"><span data-stu-id="8b8da-516">[Use a portion of a character array and repeating a single character](#Ctor3_Example)</span></span>\
<span data-ttu-id="8b8da-517">[Verwenden Sie einen Zeiger auf ein Zeichen Array](#Ctor4_Example)</span><span class="sxs-lookup"><span data-stu-id="8b8da-517">[Use a pointer to a character array](#Ctor4_Example)</span></span>\
<span data-ttu-id="8b8da-518">[Verwenden Sie einen Zeiger und einen Bereich eines Arrays](#Ctor5_Example)</span><span class="sxs-lookup"><span data-stu-id="8b8da-518">[Use  a pointer and a range of an array](#Ctor5_Example)</span></span>\
<span data-ttu-id="8b8da-519">[Verwenden Sie einen Zeiger auf ein Bytearray mit](#Ctor6_Example) Vorzeichen</span><span class="sxs-lookup"><span data-stu-id="8b8da-519">[Use a pointer to a signed byte array](#Ctor6_Example)</span></span>\
[<span data-ttu-id="8b8da-520">Versionsinformationen</span><span class="sxs-lookup"><span data-stu-id="8b8da-520">Version information</span></span>](#Versions)

<a name="Syntax"></a>
## <a name="overloaded-constructor-syntax"></a><span data-ttu-id="8b8da-521">Syntax für überladene Konstruktoren</span><span class="sxs-lookup"><span data-stu-id="8b8da-521">Overloaded constructor syntax</span></span>
 <span data-ttu-id="8b8da-522">Zeichenfolgenkonstruktoren werden in zwei Kategorien unterteilt: solche ohne Zeiger Parameter und solche mit Zeiger Parametern.</span><span class="sxs-lookup"><span data-stu-id="8b8da-522">String constructors fall into two categories: those without pointer parameters, and those with pointer parameters.</span></span> <span data-ttu-id="8b8da-523">Die Konstruktoren, die Zeiger verwenden, sind nicht CLS-kompatibel.</span><span class="sxs-lookup"><span data-stu-id="8b8da-523">The constructors that use pointers are not CLS-compliant.</span></span> <span data-ttu-id="8b8da-524">Darüber hinaus unterstützt Visual Basic nicht die Verwendung von Zeigern und C# erfordert Code, der Zeiger verwendet, um in einem unsicheren Kontext ausgeführt zu werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-524">In addition, Visual Basic does not support the use of pointers, and C# requires code that uses pointers to run in an unsafe context.</span></span> <span data-ttu-id="8b8da-525">Weitere Informationen finden Sie unter [unsafe](~/docs/csharp/language-reference/keywords/unsafe.md).</span><span class="sxs-lookup"><span data-stu-id="8b8da-525">For more information, see [unsafe](~/docs/csharp/language-reference/keywords/unsafe.md).</span></span>

 <span data-ttu-id="8b8da-526">Weitere Anleitungen zum Auswählen einer Überladung finden [Sie unter welche Methode rufe ich auf?](#Tasks)</span><span class="sxs-lookup"><span data-stu-id="8b8da-526">For additional guidance on choosing an overload, see [Which method do I call?](#Tasks)</span></span>

 <span data-ttu-id="8b8da-527">`String(Char[] value)` initialisiert die neue-Instanz mit dem Wert, der durch ein Array von Unicode-Zeichen angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-527">`String(Char[] value)` Initializes the new instance to the value indicated by an array of Unicode characters.</span></span> <span data-ttu-id="8b8da-528">Dieser Konstruktor kopiert Unicode-Zeichen ([z](#Ctor2_Example). b.).</span><span class="sxs-lookup"><span data-stu-id="8b8da-528">This constructor copies Unicode characters([example](#Ctor2_Example)).</span></span>

 <span data-ttu-id="8b8da-529">`String(Char[] value, Int32 startIndex, Int32 length)` initialisiert die neue-Instanz mit dem Wert, der durch ein Array von Unicode-Zeichen, die Position des ersten Zeichens innerhalb dieses Arrays und eine Länge ([z](#Ctor3_Example). b.) angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-529">`String(Char[] value, Int32 startIndex, Int32 length)` Initializes the new instance to the value indicated by an array of Unicode characters, a starting character position within that array, and a length ([example](#Ctor3_Example)).</span></span>

 <span data-ttu-id="8b8da-530">`String(Char c, Int32 count)` initialisiert die neue-Instanz mit dem Wert, der von einem angegebenen Unicode-Zeichen angegeben wird, das[so oft wie](#Ctor3_Example)angegeben wiederholt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-530">`String(Char c, Int32 count)` Initializes the new instance to the value indicated by a specified Unicode character repeated a specified number of times ([example](#Ctor3_Example)).</span></span>

 <span data-ttu-id="8b8da-531">`String(char* value)` **(nicht CLS-kompatibel)** initialisiert die neue-Instanz mit dem Wert, der durch einen Zeiger auf ein Array von Unicode-Zeichen angegeben wird, die durch ein NULL-Zeichen (U + 0000 oder ' \ 0 ') beendet werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-531">`String(char* value)` **(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of Unicode characters that is terminated by a null character (U+0000 or '\0').</span></span> <span data-ttu-id="8b8da-532">([Beispiel](#Ctor4_Example)).</span><span class="sxs-lookup"><span data-stu-id="8b8da-532">([example](#Ctor4_Example)).</span></span>

 <span data-ttu-id="8b8da-533">Berechtigung: <xref:System.Security.SecurityCriticalAttribute>, erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="8b8da-533">Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller.</span></span> <span data-ttu-id="8b8da-534">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-534">This member cannot be used by partially trusted or transparent code.</span></span>

 <span data-ttu-id="8b8da-535">`String(char* value, Int32 startIndex, Int32 length)` **(nicht CLS-kompatibel)** initialisiert die neue-Instanz mit dem Wert, der durch einen Zeiger auf ein Array von Unicode-Zeichen, die Position des ersten Zeichens innerhalb dieses Arrays und eine Länge angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-535">`String(char* value, Int32 startIndex, Int32 length)` **(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of Unicode characters, a starting character position within that array, and a length.</span></span> <span data-ttu-id="8b8da-536">Der-Konstruktor kopiert die Unicode-Zeichen aus `value` beginnend bei Index `startIndex` und endet bei Index `startIndex` + `length`-1 ([Beispiel](#Ctor5_Example)).</span><span class="sxs-lookup"><span data-stu-id="8b8da-536">The constructor copies the Unicode characters from `value` starting at index `startIndex` and ending at index `startIndex` + `length` - 1 ([example](#Ctor5_Example)).</span></span>

 <span data-ttu-id="8b8da-537">Berechtigung: <xref:System.Security.SecurityCriticalAttribute>, erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="8b8da-537">Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller.</span></span> <span data-ttu-id="8b8da-538">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-538">This member cannot be used by partially trusted or transparent code.</span></span>

 <span data-ttu-id="8b8da-539">`String(SByte* value)` **(nicht CLS-kompatibel)** initialisiert die neue-Instanz mit dem Wert, der durch einen Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-539">`String(SByte* value)` **(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of 8-bit signed integers.</span></span> <span data-ttu-id="8b8da-540">Es wird davon ausgegangen, dass das Array eine Zeichenfolge darstellt, die mithilfe der aktuellen System Codepage codiert ist (d. h. die durch <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>angegebene Codierung).</span><span class="sxs-lookup"><span data-stu-id="8b8da-540">The array is assumed to represent a string encoded using the current system code page (that is, the encoding specified by <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>).</span></span> <span data-ttu-id="8b8da-541">Der-Konstruktor verarbeitet Zeichen aus `value` beginnend mit dem durch den-Zeiger angegebenen Speicherort, bis ein NULL-Zeichen (0x00) erreicht wird ([z](#Ctor6_Example). b.).</span><span class="sxs-lookup"><span data-stu-id="8b8da-541">The constructor processes characters from `value` starting from the location specified by the pointer until a null character (0x00) is reached ([example](#Ctor6_Example)).</span></span>

 <span data-ttu-id="8b8da-542">Berechtigung: <xref:System.Security.SecurityCriticalAttribute>, erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="8b8da-542">Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller.</span></span> <span data-ttu-id="8b8da-543">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-543">This member cannot be used by partially trusted or transparent code.</span></span>

 <span data-ttu-id="8b8da-544">`String(SByte* value, Int32 startIndex, Int32 length)` **(nicht CLS-kompatibel)** initialisiert die neue-Instanz mit dem Wert, der durch einen Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen, die Startposition innerhalb dieses Arrays und eine Länge angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-544">`String(SByte* value, Int32 startIndex, Int32 length)` **(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of 8-bit signed integers, a starting position within that array, and a length.</span></span>  <span data-ttu-id="8b8da-545">Es wird davon ausgegangen, dass das Array eine Zeichenfolge darstellt, die mithilfe der aktuellen System Codepage codiert ist (d. h. die durch <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>angegebene Codierung).</span><span class="sxs-lookup"><span data-stu-id="8b8da-545">The array is assumed to represent a string encoded using the current system code page (that is, the encoding specified by <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>).</span></span> <span data-ttu-id="8b8da-546">Der Konstruktor verarbeitet Zeichen von einem Wert ab `startIndex` und endet bei `startIndex` + `length`-1 ([z](#Ctor6_Example). b.).</span><span class="sxs-lookup"><span data-stu-id="8b8da-546">The constructor processes characters from value starting at `startIndex` and ending at `startIndex` + `length` - 1 ([example](#Ctor6_Example)).</span></span>

 <span data-ttu-id="8b8da-547">Berechtigung: <xref:System.Security.SecurityCriticalAttribute>, erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="8b8da-547">Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller.</span></span> <span data-ttu-id="8b8da-548">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-548">This member cannot be used by partially trusted or transparent code.</span></span>

 <span data-ttu-id="8b8da-549">`String(SByte* value, Int32 startIndex, Int32 length, Encoding enc)` **(nicht CLS-kompatibel)** initialisiert die neue-Instanz mit dem Wert, der durch einen Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen, die Startposition innerhalb dieses Arrays, eine Länge und ein <xref:System.Text.Encoding>-Objekt angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-549">`String(SByte* value, Int32 startIndex, Int32 length, Encoding enc)` **(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of 8-bit signed integers, a starting position within that array, a length, and an <xref:System.Text.Encoding> object.</span></span>

 <span data-ttu-id="8b8da-550">Berechtigung: <xref:System.Security.SecurityCriticalAttribute>, erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="8b8da-550">Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller.</span></span> <span data-ttu-id="8b8da-551">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-551">This member cannot be used by partially trusted or transparent code.</span></span>

<a name="Params"></a>
## <a name="parameters"></a><span data-ttu-id="8b8da-552">Parameter</span><span class="sxs-lookup"><span data-stu-id="8b8da-552">Parameters</span></span>
 <span data-ttu-id="8b8da-553">Im folgenden finden Sie eine umfassende Liste der Parameter, die von <xref:System.String> Konstruktoren verwendet werden, die keinen Zeiger Parameter enthalten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-553">Here is a complete list of parameters used by <xref:System.String> constructors that don't include a pointer parameter.</span></span> <span data-ttu-id="8b8da-554">Informationen zu den von den einzelnen über Ladungen verwendeten Parametern finden Sie in der obigen Überladungs Syntax.</span><span class="sxs-lookup"><span data-stu-id="8b8da-554">For the parameters used by each overload, see the overload syntax above.</span></span>

|<span data-ttu-id="8b8da-555">Parameter</span><span class="sxs-lookup"><span data-stu-id="8b8da-555">Parameter</span></span>|<span data-ttu-id="8b8da-556">Geben Sie Folgendes ein:</span><span class="sxs-lookup"><span data-stu-id="8b8da-556">Type</span></span>|<span data-ttu-id="8b8da-557">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="8b8da-557">Description</span></span>|
|---------------|----------|-----------------|
|`value`|<span data-ttu-id="8b8da-558"><xref:System.Char>[]</span><span class="sxs-lookup"><span data-stu-id="8b8da-558"><xref:System.Char>[]</span></span>|<span data-ttu-id="8b8da-559">Ein Array von Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-559">An array of Unicode characters.</span></span>|
|`c`|<xref:System.Char>|<span data-ttu-id="8b8da-560">Ein Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-560">A Unicode character.</span></span>|
|`startIndex`|<xref:System.Int32>|<span data-ttu-id="8b8da-561">Die Anfangsposition in `value` des ersten Zeichens in der neuen Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-561">The starting position in `value` of the first character in the new string.</span></span><br /><br /> <span data-ttu-id="8b8da-562">Standardwert: 0</span><span class="sxs-lookup"><span data-stu-id="8b8da-562">Default value: 0</span></span>|
|`length`|<xref:System.Int32>|<span data-ttu-id="8b8da-563">Die Anzahl der Zeichen in `value`, die in die neue Zeichenfolge eingeschlossen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-563">The number of characters in `value` to include in the new string.</span></span><br /><br /> <span data-ttu-id="8b8da-564">Standardwert: <xref:System.Array.Length%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="8b8da-564">Default value: <xref:System.Array.Length%2A?displayProperty=nameWithType></span></span>|
|`count`|<xref:System.Int32>|<span data-ttu-id="8b8da-565">Gibt an, wie oft das Zeichen `c` in der neuen Zeichenfolge wiederholt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-565">The number of times the character `c` is repeated in the new string.</span></span> <span data-ttu-id="8b8da-566">Wenn `count` NULL ist, wird der Wert des neuen Objekts <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-566">If `count` is zero, the value of the new object is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>|

 <span data-ttu-id="8b8da-567">Im folgenden finden Sie eine umfassende Liste der Parameter, die von <xref:System.String> Konstruktoren verwendet werden, die einen Zeiger Parameter enthalten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-567">Here is a complete list of parameters used by <xref:System.String> constructors that include a pointer parameter.</span></span> <span data-ttu-id="8b8da-568">Informationen zu den von den einzelnen über Ladungen verwendeten Parametern finden Sie in der obigen Überladungs Syntax.</span><span class="sxs-lookup"><span data-stu-id="8b8da-568">For the parameters used by each overload, see the overload syntax above.</span></span>

|<span data-ttu-id="8b8da-569">Parameter</span><span class="sxs-lookup"><span data-stu-id="8b8da-569">Parameter</span></span>|<span data-ttu-id="8b8da-570">Geben Sie Folgendes ein:</span><span class="sxs-lookup"><span data-stu-id="8b8da-570">Type</span></span>|<span data-ttu-id="8b8da-571">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="8b8da-571">Description</span></span>|
|---------------|----------|-----------------|
|`value`|<xref:System.Char>*<br /><br /> <span data-ttu-id="8b8da-572">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-572">-or-</span></span><br /><br /> <xref:System.SByte>\*|<span data-ttu-id="8b8da-573">Ein Zeiger auf ein mit Null endendes Array von Unicode-Zeichen oder ein Array von 8-Bit-Ganzzahlen mit Vorzeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-573">A pointer to a null-terminated array of Unicode characters or an array of 8-bit signed integers.</span></span> <span data-ttu-id="8b8da-574">Wenn `value` `null` oder ein leeres Array ist, wird der Wert der neuen Zeichenfolge <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-574">If `value` is `null` or an empty array, the value of the new string is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>|
|`startIndex`|<xref:System.Int32>|<span data-ttu-id="8b8da-575">Der Index des Array Elements, das das erste Zeichen in der neuen Zeichenfolge definiert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-575">The index of the array element that defines the first character in the new string.</span></span><br /><br /> <span data-ttu-id="8b8da-576">Standardwert: 0</span><span class="sxs-lookup"><span data-stu-id="8b8da-576">Default value: 0</span></span>|
|`length`|<xref:System.Int32>|<span data-ttu-id="8b8da-577">Die Anzahl der Array Elemente, die zum Erstellen der neuen Zeichenfolge verwendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-577">The number of array elements to use to create the new string.</span></span> <span data-ttu-id="8b8da-578">Wenn die Länge 0 (null) ist, erstellt der Konstruktor eine Zeichenfolge, deren Wert <xref:System.String.Empty?displayProperty=nameWithType>ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-578">If length is zero, the constructor creates a string whose value is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span><br /><br /> <span data-ttu-id="8b8da-579">Standardwert: <xref:System.Array.Length%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="8b8da-579">Default value: <xref:System.Array.Length%2A?displayProperty=nameWithType></span></span>|
|`enc`|<xref:System.Text.Encoding>|<span data-ttu-id="8b8da-580">Ein-Objekt, das angibt, wie das `value` Array codiert wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-580">An object that specifies how the `value` array is encoded.</span></span><br /><br /> <span data-ttu-id="8b8da-581">Standardwert: <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>oder die aktuelle ANSI-Codepage des Systems.</span><span class="sxs-lookup"><span data-stu-id="8b8da-581">Default value: <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>, or the system's current ANSI code page</span></span>|

<a name="Exceptions"></a>
## <a name="exceptions"></a><span data-ttu-id="8b8da-582">Ausnahmen</span><span class="sxs-lookup"><span data-stu-id="8b8da-582">Exceptions</span></span>
 <span data-ttu-id="8b8da-583">Im folgenden finden Sie eine Liste der Ausnahmen, die von Konstruktoren ausgelöst werden, die keine Zeiger Parameter enthalten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-583">Here's a list of exceptions thrown by constructors that don't include pointer parameters.</span></span>

|<span data-ttu-id="8b8da-584">Ausnahme</span><span class="sxs-lookup"><span data-stu-id="8b8da-584">Exception</span></span>|<span data-ttu-id="8b8da-585">Bedingung</span><span class="sxs-lookup"><span data-stu-id="8b8da-585">Condition</span></span>|<span data-ttu-id="8b8da-586">Ausgelöst von</span><span class="sxs-lookup"><span data-stu-id="8b8da-586">Thrown by</span></span>|
|---------------|---------------|---------------|
|<xref:System.ArgumentNullException>|<span data-ttu-id="8b8da-587">`value` ist `null`.</span><span class="sxs-lookup"><span data-stu-id="8b8da-587">`value` is `null`.</span></span>|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|
|<xref:System.ArgumentOutOfRangeException>|<span data-ttu-id="8b8da-588">`startIndex`,`length`oder `count` ist kleiner als 0 (null).</span><span class="sxs-lookup"><span data-stu-id="8b8da-588">`startIndex`,`length`, or `count` is less than zero.</span></span><br /><br /> <span data-ttu-id="8b8da-589">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-589">-or-</span></span><br /><br /> <span data-ttu-id="8b8da-590">Die Summe von `startIndex` und `length` ist größer als die Anzahl von Elementen in `value`.</span><span class="sxs-lookup"><span data-stu-id="8b8da-590">The sum of `startIndex` and `length` is greater than the number of elements in `value`.</span></span><br /><br /> <span data-ttu-id="8b8da-591">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-591">-or-</span></span><br /><br /> <span data-ttu-id="8b8da-592">`count` ist kleiner als Null.</span><span class="sxs-lookup"><span data-stu-id="8b8da-592">`count` is less than zero.</span></span>|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|

 <span data-ttu-id="8b8da-593">Im folgenden finden Sie eine Liste der Ausnahmen, die von Konstruktoren ausgelöst werden, die Zeiger Parameter einschließen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-593">Here's a list of exceptions thrown by constructors that include pointer parameters.</span></span>

|<span data-ttu-id="8b8da-594">Ausnahme</span><span class="sxs-lookup"><span data-stu-id="8b8da-594">Exception</span></span>|<span data-ttu-id="8b8da-595">Bedingung</span><span class="sxs-lookup"><span data-stu-id="8b8da-595">Condition</span></span>|<span data-ttu-id="8b8da-596">Ausgelöst von</span><span class="sxs-lookup"><span data-stu-id="8b8da-596">Thrown by</span></span>|
|---------------|---------------|---------------|
|<xref:System.ArgumentException>|<span data-ttu-id="8b8da-597">`value` gibt ein Array an, das ein ungültiges Unicode-Zeichen enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-597">`value` specifies an array that contains an invalid Unicode character.</span></span><br /><br /> <span data-ttu-id="8b8da-598">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-598">-or-</span></span><br /><br /> <span data-ttu-id="8b8da-599">`value` oder `value` + `startIndex` eine Adresse mit einer Größe von weniger als 64K angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-599">`value` or `value` + `startIndex` specifies an address that is less than 64K.</span></span><br /><br /> <span data-ttu-id="8b8da-600">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-600">-or-</span></span><br /><br /> <span data-ttu-id="8b8da-601">Eine neue <xref:System.String> Instanz konnte nicht aus dem `value` Bytearray initialisiert werden, da `value` die Standard Code Page Codierung nicht verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-601">A new <xref:System.String> instance could not be initialized from the `value` byte array because `value` does not use the default code page encoding.</span></span>|<span data-ttu-id="8b8da-602">Alle Konstruktoren mit Zeigern.</span><span class="sxs-lookup"><span data-stu-id="8b8da-602">All constructors with pointers.</span></span>|
|<xref:System.ArgumentNullException>|<span data-ttu-id="8b8da-603">`value` ist NULL.</span><span class="sxs-lookup"><span data-stu-id="8b8da-603">`value` is null.</span></span>|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|
|<xref:System.ArgumentOutOfRangeException>|<span data-ttu-id="8b8da-604">Der aktuelle Prozess hat keinen Lesezugriff auf alle adressierten Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-604">The current process does not have read access to all the addressed characters.</span></span><br /><br /> <span data-ttu-id="8b8da-605">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-605">-or-</span></span><br /><br /> <span data-ttu-id="8b8da-606">`startIndex` oder `length` ist kleiner als 0 (null), `value` + `startIndex` verursacht einen Zeigerüberlauf oder der aktuelle Prozess hat keinen Lesezugriff auf alle adressierten Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-606">`startIndex` or `length` is less than zero, `value` + `startIndex` cause a pointer overflow, or the current process does not have read access to all the addressed characters.</span></span><br /><br /> <span data-ttu-id="8b8da-607">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-607">-or-</span></span><br /><br /> <span data-ttu-id="8b8da-608">Die Länge der neuen Zeichenfolge ist zu groß, um zuzuordnen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-608">The length of the new string is too large to allocate.</span></span>|<span data-ttu-id="8b8da-609">Alle Konstruktoren mit Zeigern.</span><span class="sxs-lookup"><span data-stu-id="8b8da-609">All constructors with pointers.</span></span>|
|<xref:System.AccessViolationException>|<span data-ttu-id="8b8da-610">`value`, oder `value` + `startIndex` + `length`-1, gibt eine ungültige Adresse an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-610">`value`, or `value` + `startIndex` + `length` - 1, specifies an invalid address.</span></span>|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|

<a name="Tasks"></a>
## <a name="which-method-do-i-call"></a><span data-ttu-id="8b8da-611">Welche Methode rufe ich auf?</span><span class="sxs-lookup"><span data-stu-id="8b8da-611">Which method do I call?</span></span>

|<span data-ttu-id="8b8da-612">An</span><span class="sxs-lookup"><span data-stu-id="8b8da-612">To</span></span>|<span data-ttu-id="8b8da-613">Anrufen oder verwenden</span><span class="sxs-lookup"><span data-stu-id="8b8da-613">Call or use</span></span>|
|--------|-----------------|
|<span data-ttu-id="8b8da-614">Erstellen Sie eine Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-614">Create a string.</span></span>|<span data-ttu-id="8b8da-615">Zuweisung eines Zeichenfolgenliterals oder einer vorhandenen Zeichenfolge ([Beispiel](#Ctor1_Example))</span><span class="sxs-lookup"><span data-stu-id="8b8da-615">Assignment from a string literal or an existing string ([example](#Ctor1_Example))</span></span>|
|<span data-ttu-id="8b8da-616">Erstellen Sie eine Zeichenfolge aus einem gesamten Zeichen Array.</span><span class="sxs-lookup"><span data-stu-id="8b8da-616">Create a string from an entire character array.</span></span>|<span data-ttu-id="8b8da-617"><xref:System.String.%23ctor%28System.Char%5B%5D%29> ([Beispiel](#Ctor2_Example))</span><span class="sxs-lookup"><span data-stu-id="8b8da-617"><xref:System.String.%23ctor%28System.Char%5B%5D%29> ([example](#Ctor2_Example))</span></span>|
|<span data-ttu-id="8b8da-618">Erstellen Sie eine Zeichenfolge aus einem Teil eines Zeichen Arrays.</span><span class="sxs-lookup"><span data-stu-id="8b8da-618">Create a string from a portion of a character array.</span></span>|<span data-ttu-id="8b8da-619"><xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> ([Beispiel](#Ctor3_Example))</span><span class="sxs-lookup"><span data-stu-id="8b8da-619"><xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> ([example](#Ctor3_Example))</span></span>|
|<span data-ttu-id="8b8da-620">Erstellen Sie eine Zeichenfolge, die das gleiche Zeichen mehrmals wiederholt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-620">Create a string that repeats the same character multiple times.</span></span>|<span data-ttu-id="8b8da-621"><xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> ([Beispiel](#Ctor3_Example))</span><span class="sxs-lookup"><span data-stu-id="8b8da-621"><xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> ([example](#Ctor3_Example))</span></span>|
|<span data-ttu-id="8b8da-622">Erstellen Sie eine Zeichenfolge aus einem Zeiger auf ein Unicode-oder ein breit Zeichen Array.</span><span class="sxs-lookup"><span data-stu-id="8b8da-622">Create a string from a pointer to a Unicode or wide character array.</span></span>|<xref:System.String.%23ctor%28System.Char%2A%29>|
|<span data-ttu-id="8b8da-623">Erstellen Sie mithilfe des-Zeigers eine Zeichenfolge aus einem Teil eines Unicode-oder Wide Character-Arrays.</span><span class="sxs-lookup"><span data-stu-id="8b8da-623">Create a string from a portion of a Unicode or wide character array by using its pointer.</span></span>|<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>|
|<span data-ttu-id="8b8da-624">Erstellen Sie eine Zeichenfolge C++ aus einem `char` Array.</span><span class="sxs-lookup"><span data-stu-id="8b8da-624">Create a string from a C++ `char` array.</span></span>|<span data-ttu-id="8b8da-625"><xref:System.String.%23ctor%28System.SByte%2A%29>, <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29></span><span class="sxs-lookup"><span data-stu-id="8b8da-625"><xref:System.String.%23ctor%28System.SByte%2A%29>, <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29></span></span><br /><br /> <span data-ttu-id="8b8da-626">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-626">-or-</span></span><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|
|<span data-ttu-id="8b8da-627">Erstellen Sie eine Zeichenfolge aus ASCII-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-627">Create a string from ASCII characters.</span></span>|<xref:System.Text.ASCIIEncoding.GetString%2A?displayProperty=nameWithType>|

<a name="Creating_Strings"></a>
## <a name="create-strings"></a><span data-ttu-id="8b8da-628">Erstellen von Zeichen folgen</span><span class="sxs-lookup"><span data-stu-id="8b8da-628">Create strings</span></span>
 <span data-ttu-id="8b8da-629">Das am häufigsten verwendete Verfahren zum programmgesteuerten Erstellen von Zeichen folgen ist eine einfache Zuweisung, wie in [diesem Beispiel](#Ctor1_Example)veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-629">The most commonly used technique for creating strings programmatically is simple assignment, as illustrated in [this example](#Ctor1_Example).</span></span> <span data-ttu-id="8b8da-630">Die <xref:System.String>-Klasse enthält auch vier Typen von Konstruktorüberladungen, mit denen Sie Zeichen folgen aus den folgenden Werten erstellen können:</span><span class="sxs-lookup"><span data-stu-id="8b8da-630">The <xref:System.String> class also includes four types of constructor overloads that let you create strings from the following values:</span></span>

-   <span data-ttu-id="8b8da-631">Aus einem Zeichen Array (ein Array von UTF-16-codierten Zeichen).</span><span class="sxs-lookup"><span data-stu-id="8b8da-631">From a character array (an array of UTF-16-encoded characters).</span></span> <span data-ttu-id="8b8da-632">Sie können ein neues <xref:System.String>-Objekt aus den Zeichen im gesamten Array oder einem Teil davon erstellen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-632">You can create a new <xref:System.String> object from the characters in the entire array or a portion of it.</span></span> <span data-ttu-id="8b8da-633">Der <xref:System.String.%23ctor%28System.Char%5B%5D%29>-Konstruktor kopiert alle Zeichen im Array in die neue Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-633">The <xref:System.String.%23ctor%28System.Char%5B%5D%29> constructor copies all the characters in the array to the new string.</span></span> <span data-ttu-id="8b8da-634">Der <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>-Konstruktor kopiert die Zeichen aus dem Index `startIndex` `startIndex` + `length`-1 in die neue Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-634">The <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructor copies the characters from index `startIndex` to index `startIndex` + `length` - 1 to the new string.</span></span> <span data-ttu-id="8b8da-635">Wenn `length` NULL ist, wird der Wert der neuen Zeichenfolge <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-635">If `length` is zero, the value of the new string is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>

     <span data-ttu-id="8b8da-636">Wenn Ihr Code Zeichen folgen mit dem gleichen Wert wiederholt instanziiert, können Sie die Anwendungsleistung verbessern, indem Sie eine alternative Möglichkeit zum Erstellen von Zeichen folgen verwenden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-636">If your code repeatedly instantiates strings that have the same value, you can improve application performance by using an alternate means of creating strings.</span></span> <span data-ttu-id="8b8da-637">Weitere Informationen finden Sie unter [Behandeln von Wiederkehr](#Repetitive)enden Zeichen folgen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-637">For more information, see [Handling repetitive strings](#Repetitive).</span></span>

-   <span data-ttu-id="8b8da-638">Von einem einzelnen Zeichen, das NULL, einmal oder mehrmals dupliziert wird, mit dem <xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29>-Konstruktor.</span><span class="sxs-lookup"><span data-stu-id="8b8da-638">From a single character that is duplicated zero, one, or more times, by using the <xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> constructor.</span></span> <span data-ttu-id="8b8da-639">Wenn `count` NULL ist, wird der Wert der neuen Zeichenfolge <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-639">If `count` is zero, the value of the new string is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>

-   <span data-ttu-id="8b8da-640">Von einem Zeiger auf ein mit Null endendes Zeichen Array mit dem <xref:System.String.%23ctor%28System.Char%2A%29>-oder <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>-Konstruktor.</span><span class="sxs-lookup"><span data-stu-id="8b8da-640">From a pointer to a null-terminated character array, by using the <xref:System.String.%23ctor%28System.Char%2A%29> or <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> constructor.</span></span> <span data-ttu-id="8b8da-641">Das gesamte Array oder ein angegebener Bereich kann verwendet werden, um die Zeichenfolge zu initialisieren.</span><span class="sxs-lookup"><span data-stu-id="8b8da-641">Either the entire array or a specified range can be used to initialize the string.</span></span> <span data-ttu-id="8b8da-642">Der-Konstruktor kopiert eine Sequenz von Unicode-Zeichen beginnend mit dem angegebenen Zeiger oder aus dem angegebenen Zeiger Plus `startIndex` und setzt das Ende des Arrays oder für `length` Zeichen fort.</span><span class="sxs-lookup"><span data-stu-id="8b8da-642">The constructor copies a sequence of Unicode characters starting from the specified pointer or from the specified pointer plus `startIndex` and continuing to the end of the array or for `length` characters.</span></span> <span data-ttu-id="8b8da-643">Wenn `value` ein NULL-Zeiger ist oder `length` 0 (null) ist, erstellt der Konstruktor eine Zeichenfolge, deren Wert <xref:System.String.Empty?displayProperty=nameWithType>ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-643">If `value` is a null pointer or `length` is zero, the constructor creates a string whose value is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8b8da-644">Wenn der Kopiervorgang bis zum Ende des Arrays verläuft und das Array nicht auf NULL endet, ist das konstruktorverhalten System abhängig.</span><span class="sxs-lookup"><span data-stu-id="8b8da-644">If the copy operation proceeds to the end of the array and the array is not null-terminated, the constructor behavior is system-dependent.</span></span> <span data-ttu-id="8b8da-645">Eine solche Bedingung kann eine Zugriffsverletzung verursachen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-645">Such a condition might cause an access violation.</span></span>

     <span data-ttu-id="8b8da-646">Wenn das Array eingebettete NULL-Zeichen (U + 0000 oder ' \ 0 ') enthält und die <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> Überladung aufgerufen wird, enthält die Zeichen folgen Instanz `length` Zeichen einschließlich aller eingebetteten Nullen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-646">If the array contains any embedded null characters (U+0000 or '\0') and the <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> overload is called, the string instance contains `length` characters including any embedded nulls.</span></span> <span data-ttu-id="8b8da-647">Das folgende Beispiel zeigt, was geschieht, wenn ein Zeiger auf ein Array mit 10 Elementen, das zwei NULL-Zeichen enthält, an die <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>-Methode übermittelt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-647">The following example shows what happens when a pointer to an array of 10 elements that includes two null characters is passed to the <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> method.</span></span> <span data-ttu-id="8b8da-648">Da es sich bei der Adresse um den Anfang des Arrays handelt und alle Elemente im Array der Zeichenfolge hinzugefügt werden sollen, instanziiert der Konstruktor eine Zeichenfolge mit zehn Zeichen, einschließlich zwei eingebetteter Nullen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-648">Because the address is the beginning of the array and all elements in the array are to be added to the string, the constructor instantiates a string with ten characters, including two embedded nulls.</span></span> <span data-ttu-id="8b8da-649">Wenn das gleiche Array hingegen an den <xref:System.String.%23ctor%28System.Char%2A%29>-Konstruktor übergeben wird, ist das Ergebnis eine Zeichenfolge mit vier Zeichen, die das erste Null-Zeichen nicht enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-649">On the other hand, if the same array is passed to the <xref:System.String.%23ctor%28System.Char%2A%29> constructor, the result is a four-character string that does not include the first null character.</span></span>

     [!code-cpp[System.String.ctor#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/chptrctor_null.cpp#5)]
     [!code-csharp[System.String.ctor#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/chptrctor_null.cs#5)]

     <span data-ttu-id="8b8da-650">Das Array muss Unicode-Zeichen enthalten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-650">The array must contain Unicode characters.</span></span> <span data-ttu-id="8b8da-651">In C++ bedeutet dies, dass das Zeichen Array entweder als verwalteter <xref:System.Char>[]-Typ oder als nicht verwalteter`wchar_t`[]-Typ definiert werden muss.</span><span class="sxs-lookup"><span data-stu-id="8b8da-651">In C++, this means that the character array must be defined either as the managed <xref:System.Char>[] type or the unmanaged`wchar_t`[] type.</span></span>

     <span data-ttu-id="8b8da-652">Wenn die <xref:System.String.%23ctor%28System.Char%2A%29> Überladung aufgerufen wird und das Array nicht auf NULL endet, oder wenn die <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> Überladung aufgerufen wird und `startIndex` + `length`-1 einen Bereich enthält, der außerhalb des für die Zeichenfolge zugeordneten Arbeitsspeichers liegt, ist das Verhalten des Konstruktors System abhängig, und es kann eine Zugriffsverletzung auftreten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-652">If the <xref:System.String.%23ctor%28System.Char%2A%29> overload is called and the array is not null-terminated, or if the <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> overload is called and `startIndex` + `length`-1 includes a range that it outside the memory allocated for the sequence of characters, the behavior of the constructor is system-dependent, and an access violation may occur.</span></span> <span data-ttu-id="8b8da-653">Außerdem können Aufrufe an den <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>-Konstruktor auf dem Intel Itanium-Prozessor eine <xref:System.DataMisalignedException> Ausnahme auslösen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-653">In addition, on the Intel Itanium processor, calls to the <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> constructor may throw a <xref:System.DataMisalignedException> exception.</span></span> <span data-ttu-id="8b8da-654">Wenn dies der Fall ist, müssen Sie stattdessen den <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> abrufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-654">If this occurs, call the <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> instead.</span></span>

-   <span data-ttu-id="8b8da-655">Von einem Zeiger auf ein Bytearray mit Vorzeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-655">From a pointer to a signed byte array.</span></span> <span data-ttu-id="8b8da-656">Das gesamte Array oder ein angegebener Bereich kann verwendet werden, um die Zeichenfolge zu initialisieren.</span><span class="sxs-lookup"><span data-stu-id="8b8da-656">Either the entire array or a specified range can be used to initialize the string.</span></span> <span data-ttu-id="8b8da-657">Die Byte Sequenz kann mit der Standard Code Page Codierung interpretiert werden, oder es kann eine Codierung im konstruktorbefehl angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-657">The sequence of bytes can be interpreted by using the default code page encoding, or an encoding can be specified in the constructor call.</span></span> <span data-ttu-id="8b8da-658">Wenn der Konstruktor versucht, eine Zeichenfolge aus einem ganzen Array zu instanziieren, das nicht mit NULL endet, oder wenn der Bereich des Arrays von `value` + `startIndex` `value` + `startIndex` + `length`-1 außerhalb des für das Array zugeordneten Arbeitsspeichers liegt, ist das Verhalten dieses Konstruktors System abhängig, und es kann eine Zugriffsverletzung auftreten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-658">If the constructor tries to instantiate a string from an entire array that is not null-terminated, or if the range of the array from `value` + `startIndex` to `value` + `startIndex` + `length` -1 is outside of the memory allocated for the array, the behavior of this constructor is system-dependent, and an access violation may occur.</span></span>

     <span data-ttu-id="8b8da-659">Die drei Konstruktoren, die ein Bytearray mit Vorzeichen als Parameter enthalten, werden in erster C++ Linie so entworfen, dass ein `char` Array in eine Zeichenfolge konvertiert wird, wie im folgenden Beispiel gezeigt:</span><span class="sxs-lookup"><span data-stu-id="8b8da-659">The three constructors that include a signed byte array as a parameter are designed primarily to convert a C++ `char` array to a string, as shown in this example:</span></span>

     [!code-cpp[System.String.Ctor#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/sbyte_ctor1.cpp#4)]

     <span data-ttu-id="8b8da-660">Wenn das Array NULL Zeichen (' \ 0 ') oder Bytes enthält, deren Wert 0 ist und die <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> Überladung aufgerufen wird, enthält die Zeichen folgen Instanz `length` Zeichen einschließlich aller eingebetteten Nullen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-660">If the array contains any null characters ('\0') or bytes whose value is 0 and the <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> overload is called, the string instance contains `length` characters including any embedded nulls.</span></span> <span data-ttu-id="8b8da-661">Das folgende Beispiel zeigt, was geschieht, wenn ein Zeiger auf ein Array mit 10 Elementen, das zwei NULL-Zeichen enthält, an die <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29>-Methode übermittelt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-661">The following example shows what happens when a pointer to an array of 10 elements that includes two null characters is passed to the <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> method.</span></span> <span data-ttu-id="8b8da-662">Da es sich bei der Adresse um den Anfang des Arrays handelt und alle Elemente im Array der Zeichenfolge hinzugefügt werden sollen, instanziiert der Konstruktor eine Zeichenfolge mit zehn Zeichen, einschließlich zwei eingebetteter Nullen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-662">Because the address is the beginning of the array and all elements in the array are to be added to the string, the constructor instantiates a string with ten characters, including two embedded nulls.</span></span> <span data-ttu-id="8b8da-663">Wenn das gleiche Array hingegen an den <xref:System.String.%23ctor%28System.SByte%2A%29>-Konstruktor übergeben wird, ist das Ergebnis eine Zeichenfolge mit vier Zeichen, die das erste Null-Zeichen nicht enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-663">On the other hand, if the same array is passed to the <xref:System.String.%23ctor%28System.SByte%2A%29> constructor, the result is a four-character string that does not include the first null character.</span></span>

     [!code-cpp[System.String.ctor#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/ptrctor_null.cpp#6)]
     [!code-csharp[System.String.ctor#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ptrctor_null.cs#6)]

     <span data-ttu-id="8b8da-664">Da die <xref:System.String.%23ctor%28System.SByte%2A%29>-und <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29>-Konstruktoren `value` mithilfe der standardmäßigen ANSI-Codepage interpretieren, können beim Aufrufen dieser Konstruktoren mit identischen Byte Arrays Zeichen folgen erstellt werden, die unterschiedliche Werte für verschiedene Systeme aufweisen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-664">Because the <xref:System.String.%23ctor%28System.SByte%2A%29> and <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> constructors interpret `value` by using the default ANSI code page, calling these constructors with identical byte arrays may create strings that have different values on different systems.</span></span>

<a name="Repetitive"></a>
## <a name="handle-repetitive-strings"></a><span data-ttu-id="8b8da-665">Wiederkehrende Zeichen folgen behandeln</span><span class="sxs-lookup"><span data-stu-id="8b8da-665">Handle repetitive strings</span></span>
 <span data-ttu-id="8b8da-666">Apps, die Text Ströme analysieren oder decodieren, verwenden häufig den <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>-Konstruktor oder die <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>-Methode, um Zeichen folgen in eine Zeichenfolge zu konvertieren.</span><span class="sxs-lookup"><span data-stu-id="8b8da-666">Apps that parse or decode streams of text often use the <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructor or the <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to convert sequences of characters into a string.</span></span> <span data-ttu-id="8b8da-667">Wiederholtes Erstellen neuer Zeichen folgen mit demselben Wert, anstatt eine Zeichenfolge zu erstellen und wieder zu verwenden, verschwendet Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="8b8da-667">Repeatedly creating new strings with the same value instead of creating and reusing one string wastes memory.</span></span> <span data-ttu-id="8b8da-668">Wenn Sie wahrscheinlich den gleichen Zeichen folgen Wert wiederholt durch Aufrufen des <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>-Konstruktors erstellen, können Sie stattdessen eine Nachschlage Tabelle verwenden, auch wenn Sie nicht im Voraus wissen, welche identischen Zeichen folgen Werte Sie verwenden können.</span><span class="sxs-lookup"><span data-stu-id="8b8da-668">If you are likely to create the same string value repeatedly by calling the <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructor, even if you don't know in advance what those identical string values may be, you can use a lookup table instead.</span></span>

 <span data-ttu-id="8b8da-669">Angenommen, Sie lesen und analysieren einen Datenstrom aus einer Datei, die XML-Tags und-Attribute enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-669">For example, suppose you read and parse a stream of characters from a file that contains XML tags and attributes.</span></span> <span data-ttu-id="8b8da-670">Wenn Sie den Stream analysieren, stoßen Sie wiederholt auf bestimmte Token (d. h. Zeichen folgen, die eine symbolische Bedeutung haben).</span><span class="sxs-lookup"><span data-stu-id="8b8da-670">When you parse the stream, you repeatedly encounter certain tokens (that is, sequences of characters that have a symbolic meaning).</span></span> <span data-ttu-id="8b8da-671">Token, die den Zeichen folgen "0", "1", "true" und "false" entsprechen, treten wahrscheinlich häufig in einem XML-Stream auf.</span><span class="sxs-lookup"><span data-stu-id="8b8da-671">Tokens equivalent to the strings "0", "1", "true", and "false" are likely to occur frequently in an XML stream.</span></span>

 <span data-ttu-id="8b8da-672">Anstatt jedes Token in eine neue Zeichenfolge zu wandeln, können Sie ein <xref:System.Xml.NameTable?displayProperty=nameWithType> Objekt erstellen, um häufig auftretende Zeichen folgen zu speichern.</span><span class="sxs-lookup"><span data-stu-id="8b8da-672">Instead of converting each token into a new string, you can create a <xref:System.Xml.NameTable?displayProperty=nameWithType> object to hold commonly occurring strings.</span></span> <span data-ttu-id="8b8da-673">Das <xref:System.Xml.NameTable>-Objekt verbessert die Leistung, da gespeicherte Zeichen folgen abgerufen werden, ohne temporären Arbeitsspeicher zuzuweisen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-673">The <xref:System.Xml.NameTable> object improves performance, because it retrieves stored strings without allocating temporary memory.</span></span> <span data-ttu-id="8b8da-674">Wenn Sie ein Token finden, verwenden Sie die <xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>-Methode, um das Token aus der Tabelle abzurufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-674">When you encounter a token, use the <xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to retrieve the token from the table.</span></span> <span data-ttu-id="8b8da-675">Wenn das Token vorhanden ist, gibt die Methode die entsprechende Zeichenfolge zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-675">If the token exists, the method returns the corresponding string.</span></span> <span data-ttu-id="8b8da-676">Wenn das Token nicht vorhanden ist, verwenden Sie die <xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>-Methode, um das Token in die Tabelle einzufügen und die entsprechende Zeichenfolge zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-676">If the token does not exist, use the <xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to insert the token into the table and to get the corresponding string.</span></span>

<a name="Ctor1_Example"></a>
## <a name="example-1-use-string-assignment"></a><span data-ttu-id="8b8da-677">Beispiel 1: Verwenden der Zeichen folgen Zuweisung</span><span class="sxs-lookup"><span data-stu-id="8b8da-677">Example 1: Use string assignment</span></span>
 <span data-ttu-id="8b8da-678">Im folgenden Beispiel wird eine neue Zeichenfolge durch Zuweisen eines Zeichenfolgenliterals erstellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-678">The following example creates a new string by assigning it a string literal.</span></span> <span data-ttu-id="8b8da-679">Es wird eine zweite Zeichenfolge erstellt, indem der Wert der ersten Zeichenfolge zugewiesen wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-679">It creates a second string by assigning the value of the first string to it.</span></span> <span data-ttu-id="8b8da-680">Dies sind die beiden gängigsten Methoden zum Instanziieren eines neuen <xref:System.String> Objekts.</span><span class="sxs-lookup"><span data-stu-id="8b8da-680">These are the two most common ways to instantiate a new <xref:System.String> object.</span></span>

 [!code-cpp[System.String.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/assignment.cpp#1)]
 [!code-csharp[System.String.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.String.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.ctor/vb/ctor1.vb#1)]

<a name="Ctor2_Example"></a>
## <a name="example-2-use-a-character-array"></a><span data-ttu-id="8b8da-681">Beispiel 2: Verwenden eines Zeichen Arrays</span><span class="sxs-lookup"><span data-stu-id="8b8da-681">Example 2: Use a character array</span></span>
 <span data-ttu-id="8b8da-682">Im folgenden Beispiel wird veranschaulicht, wie ein neues <xref:System.String>-Objekt aus einem Zeichen Array erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-682">The following example demonstrates how to create a new <xref:System.String> object from a character array.</span></span>

 [!code-cpp[stringexample1#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#1)]
 [!code-csharp[stringexample1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#1)]
 [!code-vb[stringexample1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#1)]

<a name="Ctor3_Example"></a>
## <a name="example-3-use-a-portion-of-a-character-array-and-repeating-a-single-character"></a><span data-ttu-id="8b8da-683">Beispiel 3: Verwenden eines Teils eines Zeichen Arrays und Wiederholen eines einzelnen Zeichens</span><span class="sxs-lookup"><span data-stu-id="8b8da-683">Example 3: Use a portion of a character array and repeating a single character</span></span>
 <span data-ttu-id="8b8da-684">Im folgenden Beispiel wird veranschaulicht, wie ein neues <xref:System.String>-Objekt aus einem Teil eines Zeichen Arrays erstellt wird und wie ein neues <xref:System.String>-Objekt erstellt wird, das mehrere Vorkommen eines einzelnen Zeichens enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-684">The following example demonstrates how to create a new <xref:System.String> object from a portion of a character array, and how to create a new <xref:System.String> object that contains multiple occurrences of a single character.</span></span>

 [!code-cpp[stringexample1#3](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#3)]
 [!code-csharp[stringexample1#3](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#3)]
 [!code-vb[stringexample1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#3)]

<a name="Ctor4_Example"></a>
## <a name="example-4-use-a-pointer-to-a-character-array"></a><span data-ttu-id="8b8da-685">Beispiel 4: Verwenden eines Zeigers auf ein Zeichen Array</span><span class="sxs-lookup"><span data-stu-id="8b8da-685">Example 4: Use a pointer to a character array</span></span>
 <span data-ttu-id="8b8da-686">Im folgenden Beispiel wird veranschaulicht, wie ein neues <xref:System.String>-Objekt aus einem Zeiger auf ein Zeichen Array erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-686">The following example demonstrates how to create a new <xref:System.String> object from a pointer to an array of characters.</span></span> <span data-ttu-id="8b8da-687">Das C# Beispiel muss mithilfe des `/unsafe`-Compilerschalters kompiliert werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-687">The C# example must be compiled by using the `/unsafe` compiler switch.</span></span>

 [!code-cpp[System.String.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char1_ctor.cpp#2)]
 [!code-csharp[System.String.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor2.cs#2)]

<a name="Ctor5_Example"></a>
## <a name="example-5-instantiate-a-string-from-a-pointer-and-a-range-of-an-array"></a><span data-ttu-id="8b8da-688">Beispiel 5: Instanziieren einer Zeichenfolge aus einem Zeiger und einem Bereich eines Arrays</span><span class="sxs-lookup"><span data-stu-id="8b8da-688">Example 5: Instantiate a string from a pointer and a range of an array</span></span>
 <span data-ttu-id="8b8da-689">Im folgenden Beispiel werden die Elemente eines Zeichen Arrays für einen Punkt oder ein Ausrufezeichen untersucht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-689">The following example examines the elements of a character array for either a period or an exclamation point.</span></span> <span data-ttu-id="8b8da-690">Wenn eine Zeichenfolge gefunden wird, wird eine Zeichenfolge aus den Zeichen im Array instanziiert, die dem Interpunktions Zeichen vorangestellt ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-690">If one is found, it instantiates a string from the characters in the array that precede the punctuation symbol.</span></span> <span data-ttu-id="8b8da-691">Wenn dies nicht der Fall ist, wird eine Zeichenfolge mit dem gesamten Inhalt des Arrays instanziiert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-691">If not, it instantiates a string with the entire contents of the array.</span></span> <span data-ttu-id="8b8da-692">Das C# Beispiel muss mithilfe des `/unsafe`-Compilerschalters kompiliert werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-692">The C# example must be compiled using the `/unsafe` compiler switch.</span></span>

 [!code-cpp[System.String.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char2_ctor.cpp#3)]
 [!code-csharp[System.String.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/char2_ctor.cs#3)]

<a name="Ctor6_Example"></a>
## <a name="example-6-instantiate-a-string-from-a-pointer-to-a-signed-byte-array"></a><span data-ttu-id="8b8da-693">Beispiel 6: Instanziieren einer Zeichenfolge aus einem Zeiger auf ein Bytearray mit Vorzeichen</span><span class="sxs-lookup"><span data-stu-id="8b8da-693">Example 6: Instantiate a string from a pointer to a signed byte array</span></span>
 <span data-ttu-id="8b8da-694">Im folgenden Beispiel wird veranschaulicht, wie Sie eine Instanz der <xref:System.String>-Klasse mit dem <xref:System.String.%23ctor%28System.SByte%2A%29>-Konstruktor erstellen können.</span><span class="sxs-lookup"><span data-stu-id="8b8da-694">The following example demonstrates how you can create an instance of the <xref:System.String> class with the <xref:System.String.%23ctor%28System.SByte%2A%29> constructor.</span></span>

 [!code-cpp[stringexample1#2](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#2)]
 [!code-csharp[stringexample1#2](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#2)]

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-695">Ein Zeiger auf ein mit Null endendes Array von Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-695">A pointer to a null-terminated array of Unicode characters.</span></span></param>
        <summary><span data-ttu-id="8b8da-696">Initialisiert eine neue Instanz der <see cref="T:System.String" />-Klasse mit dem Wert, der durch einen angegebenen Zeiger auf ein Array von Unicode-Zeichen bestimmt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-696">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified pointer to an array of Unicode characters.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
>  <span data-ttu-id="8b8da-697">Beispiele und umfassende Verwendungs Informationen zu dieser und anderen `String`-Konstruktorüberladungen finden Sie in der Zusammenfassung des <xref:System.String.%23ctor%2A>-Konstruktors.</span><span class="sxs-lookup"><span data-stu-id="8b8da-697">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-698">Der aktuelle Prozess hat keinen Lesezugriff auf alle adressierten Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-698">The current process does not have read access to all the addressed characters.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8b8da-699"><paramref name="value" /> gibt ein Array an, das ein ungültiges Unicode-Zeichen enthält, oder <paramref name="value" /> gibt eine Adresse kleiner als 64000 an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-699"><paramref name="value" /> specifies an array that contains an invalid Unicode character, or <paramref name="value" /> specifies an address less than 64000.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new string : char[] -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-700">Ein Array von Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-700">An array of Unicode characters.</span></span></param>
        <summary><span data-ttu-id="8b8da-701">Initialisiert eine neue Instanz der <see cref="T:System.String" />-Klasse mit den im angegebenen Zeichenarray genannten Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-701">Initializes a new instance of the <see cref="T:System.String" /> class to the Unicode characters indicated in the specified character array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
>  <span data-ttu-id="8b8da-702">Beispiele und umfassende Verwendungs Informationen zu dieser und anderen `String`-Konstruktorüberladungen finden Sie in der Zusammenfassung des <xref:System.String.%23ctor%2A>-Konstruktors.</span><span class="sxs-lookup"><span data-stu-id="8b8da-702">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="new string : ReadOnlySpan&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-703">Ein schreibgeschützter Bereich von Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-703">A read-only span of Unicode characters.</span></span></param>
        <summary><span data-ttu-id="8b8da-704">Initialisiert eine neue Instanz der <see cref="T:System.String" />-Klasse mit den im angegebenen schreibgeschützten Bereich genannten Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-704">Initializes a new instance of the <see cref="T:System.String" /> class to the Unicode characters indicated in the specified read-only span.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-705">Ein Zeiger auf ein mit NULL endendes Array von 8-Bit-Ganzzahlen mit Vorzeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-705">A pointer to a null-terminated array of 8-bit signed integers.</span></span> <span data-ttu-id="8b8da-706">Die Ganzzahlen werden mit der aktuellen Systemcodeseiten-Codierung interpretiert (d.h. der durch <see cref="P:System.Text.Encoding.Default" /> angegebenen Codierung).</span><span class="sxs-lookup"><span data-stu-id="8b8da-706">The integers are interpreted using the current system code page encoding (that is, the encoding specified by <see cref="P:System.Text.Encoding.Default" />).</span></span></param>
        <summary><span data-ttu-id="8b8da-707">Initialisiert eine neue Instanz der <see cref="T:System.String" />-Klasse mit dem durch einen Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen angegebenen Wert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-707">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a pointer to an array of 8-bit signed integers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
>  <span data-ttu-id="8b8da-708">Beispiele und umfassende Verwendungs Informationen zu dieser und anderen `String`-Konstruktorüberladungen finden Sie in der Zusammenfassung des <xref:System.String.%23ctor%2A>-Konstruktors.</span><span class="sxs-lookup"><span data-stu-id="8b8da-708">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-709"><paramref name="value" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-709"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8b8da-710">Eine neue Instanz von <see cref="T:System.String" /> konnte nicht mit <paramref name="value" /> initialisiert werden, wobei angenommen wurde, dass <paramref name="value" /> in ANSI codiert ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-710">A new instance of <see cref="T:System.String" /> could not be initialized using <paramref name="value" />, assuming <paramref name="value" /> is encoded in ANSI.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-711">Die Länge der neuen zu initialisierenden Zeichenfolge, die durch das NULL-Abschlusszeichen von <paramref name="value" /> bestimmt wird, ist zu groß für die Zuordnung.</span><span class="sxs-lookup"><span data-stu-id="8b8da-711">The length of the new string to initialize, which is determined by the null termination character of <paramref name="value" />, is too large to allocate.</span></span></exception>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="8b8da-712"><paramref name="value" /> gibt eine ungültige Adresse an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-712"><paramref name="value" /> specifies an invalid address.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char c, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char c, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (c As Char, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char c, int count);" />
      <MemberSignature Language="F#" Value="new string : char * int -&gt; string" Usage="new System.string (c, count)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="c"><span data-ttu-id="8b8da-713">Ein Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-713">A Unicode character.</span></span></param>
        <param name="count"><span data-ttu-id="8b8da-714">Die Anzahl des Vorkommens von <paramref name="c" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-714">The number of times <paramref name="c" /> occurs.</span></span></param>
        <summary><span data-ttu-id="8b8da-715">Initialisiert eine neue Instanz der <see cref="T:System.String" />-Klasse mit dem Wert, der durch ein angegebenes so oft wie angegeben wiederholtes Unicode-Zeichen bestimmt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-715">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified Unicode character repeated a specified number of times.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
>  <span data-ttu-id="8b8da-716">Beispiele und umfassende Verwendungs Informationen zu dieser und anderen `String`-Konstruktorüberladungen finden Sie in der Zusammenfassung des <xref:System.String.%23ctor%2A>-Konstruktors.</span><span class="sxs-lookup"><span data-stu-id="8b8da-716">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-717"><paramref name="count" /> ist kleiner als Null.</span><span class="sxs-lookup"><span data-stu-id="8b8da-717"><paramref name="count" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-718">Ein Zeiger auf ein Array von Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-718">A pointer to an array of Unicode characters.</span></span></param>
        <param name="startIndex"><span data-ttu-id="8b8da-719">Die Anfangsposition in <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-719">The starting position within <paramref name="value" />.</span></span></param>
        <param name="length"><span data-ttu-id="8b8da-720">Die Anzahl der aus <paramref name="value" /> zu verwendenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-720">The number of characters within <paramref name="value" /> to use.</span></span></param>
        <summary><span data-ttu-id="8b8da-721">Initialisiert eine neue Instanz der <see cref="T:System.String" />-Klasse mit dem Wert, der durch einen angegebenen Zeiger auf ein Array von Unicode-Zeichen, durch die Position des ersten Zeichens innerhalb dieses Arrays und durch eine Länge bestimmt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-721">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified pointer to an array of Unicode characters, a starting character position within that array, and a length.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
>  <span data-ttu-id="8b8da-722">Beispiele und umfassende Verwendungs Informationen zu dieser und anderen `String`-Konstruktorüberladungen finden Sie in der Zusammenfassung des <xref:System.String.%23ctor%2A>-Konstruktors.</span><span class="sxs-lookup"><span data-stu-id="8b8da-722">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-723"><paramref name="startIndex" /> oder <paramref name="length" /> ist kleiner als 0 (null), <paramref name="value" /> + <paramref name="startIndex" /> verursacht einen Zeigerüberlauf oder der aktuelle Prozess hat keinen Lesezugriff auf alle adressierten Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-723"><paramref name="startIndex" /> or <paramref name="length" /> is less than zero, <paramref name="value" /> + <paramref name="startIndex" /> cause a pointer overflow, or the current process does not have read access to all the addressed characters.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8b8da-724"><paramref name="value" /> gibt ein Array an, das ein ungültiges Unicode-Zeichen enthält, oder <paramref name="value" /> + <paramref name="startIndex" /> gibt eine Adresse kleiner als 64000 an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-724"><paramref name="value" /> specifies an array that contains an invalid Unicode character, or <paramref name="value" /> + <paramref name="startIndex" /> specifies an address less than 64000.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : char[] * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-725">Ein Array von Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-725">An array of Unicode characters.</span></span></param>
        <param name="startIndex"><span data-ttu-id="8b8da-726">Die Anfangsposition in <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-726">The starting position within <paramref name="value" />.</span></span></param>
        <param name="length"><span data-ttu-id="8b8da-727">Die Anzahl der aus <paramref name="value" /> zu verwendenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-727">The number of characters within <paramref name="value" /> to use.</span></span></param>
        <summary><span data-ttu-id="8b8da-728">Initialisiert eine neue Instanz der <see cref="T:System.String" />-Klasse mit dem Wert, der durch ein Array von Unicode-Zeichen, die Position des ersten Zeichens innerhalb dieses Arrays und eine Länge bestimmt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-728">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by an array of Unicode characters, a starting character position within that array, and a length.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
>  <span data-ttu-id="8b8da-729">Beispiele und umfassende Verwendungs Informationen zu dieser und anderen `String`-Konstruktorüberladungen finden Sie in der Zusammenfassung des <xref:System.String.%23ctor%2A>-Konstruktors.</span><span class="sxs-lookup"><span data-stu-id="8b8da-729">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-730"><paramref name="value" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-730"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-731"><paramref name="startIndex" /> oder <paramref name="length" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="8b8da-731"><paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</span></span>

<span data-ttu-id="8b8da-732">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-732">-or-</span></span>

<span data-ttu-id="8b8da-733">Die Summe von <paramref name="startIndex" /> und <paramref name="length" /> ist größer als die Anzahl von Elementen in <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-733">The sum of <paramref name="startIndex" /> and <paramref name="length" /> is greater than the number of elements in <paramref name="value" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-734">Ein Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-734">A pointer to an array of 8-bit signed integers.</span></span> <span data-ttu-id="8b8da-735">Die Ganzzahlen werden mit der aktuellen Systemcodeseiten-Codierung interpretiert (d.h. der durch <see cref="P:System.Text.Encoding.Default" /> angegebenen Codierung).</span><span class="sxs-lookup"><span data-stu-id="8b8da-735">The integers are interpreted using the current system code page encoding (that is, the encoding specified by <see cref="P:System.Text.Encoding.Default" />).</span></span></param>
        <param name="startIndex"><span data-ttu-id="8b8da-736">Die Anfangsposition in <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-736">The starting position within <paramref name="value" />.</span></span></param>
        <param name="length"><span data-ttu-id="8b8da-737">Die Anzahl der aus <paramref name="value" /> zu verwendenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-737">The number of characters within <paramref name="value" /> to use.</span></span></param>
        <summary><span data-ttu-id="8b8da-738">Initialisiert eine neue Instanz der <see cref="T:System.String" />-Klasse mit dem Wert, der durch einen angegebenen Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen, die Startposition innerhalb dieses Arrays und die Länge angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-738">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified pointer to an array of 8-bit signed integers, a starting position within that array, and a length.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
>  <span data-ttu-id="8b8da-739">Beispiele und umfassende Verwendungs Informationen zu dieser und anderen `String`-Konstruktorüberladungen finden Sie in der Zusammenfassung des <xref:System.String.%23ctor%2A>-Konstruktors.</span><span class="sxs-lookup"><span data-stu-id="8b8da-739">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-740"><paramref name="value" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-740"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-741"><paramref name="startIndex" /> oder <paramref name="length" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="8b8da-741"><paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</span></span>

<span data-ttu-id="8b8da-742">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-742">-or-</span></span>

<span data-ttu-id="8b8da-743">Die durch <paramref name="value" /> + <paramref name="startIndex" /> angegebene Adresse ist für die aktuelle Plattform zu groß, d.h., bei der Berechnung der Adresse ist ein Überlauf aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-743">The address specified by <paramref name="value" /> + <paramref name="startIndex" /> is too large for the current platform; that is, the address calculation overflowed.</span></span>

<span data-ttu-id="8b8da-744">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-744">-or-</span></span>

<span data-ttu-id="8b8da-745">Die Länge der zu initialisierenden neuen Zeichenfolge ist zu groß und kann daher nicht zugeordnet werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-745">The length of the new string to initialize is too large to allocate.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8b8da-746">Die durch <paramref name="value" /> + <paramref name="startIndex" /> angegebene Adresse ist kleiner als 64K.</span><span class="sxs-lookup"><span data-stu-id="8b8da-746">The address specified by <paramref name="value" /> + <paramref name="startIndex" /> is less than 64K.</span></span>

<span data-ttu-id="8b8da-747">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-747">-or-</span></span>

<span data-ttu-id="8b8da-748">Eine neue Instanz von <see cref="T:System.String" /> konnte nicht mit <paramref name="value" /> initialisiert werden, wobei angenommen wurde, dass <paramref name="value" /> in ANSI codiert ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-748">A new instance of <see cref="T:System.String" /> could not be initialized using <paramref name="value" />, assuming <paramref name="value" /> is encoded in ANSI.</span></span></exception>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="8b8da-749"><paramref name="value" />, <paramref name="startIndex" /> und <paramref name="length" /> geben zusammen eine ungültige Adresse an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-749"><paramref name="value" />, <paramref name="startIndex" />, and <paramref name="length" /> collectively specify an invalid address.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length, System.Text.Encoding enc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length, class System.Text.Encoding enc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length, System::Text::Encoding ^ enc);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int * System.Text.Encoding -&gt; string" Usage="new System.string (value, startIndex, length, enc)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="enc" Type="System.Text.Encoding" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-750">Ein Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-750">A pointer to an array of 8-bit signed integers.</span></span></param>
        <param name="startIndex"><span data-ttu-id="8b8da-751">Die Anfangsposition in <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-751">The starting position within <paramref name="value" />.</span></span></param>
        <param name="length"><span data-ttu-id="8b8da-752">Die Anzahl der aus <paramref name="value" /> zu verwendenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-752">The number of characters within <paramref name="value" /> to use.</span></span></param>
        <param name="enc"><span data-ttu-id="8b8da-753">Ein Objekt, das angibt, wie das Array codiert ist, auf das <paramref name="value" /> verweist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-753">An object that specifies how the array referenced by <paramref name="value" /> is encoded.</span></span> <span data-ttu-id="8b8da-754">Wenn <paramref name="enc" /><see langword="null" /> ist, wird von ANSI-Codierung ausgegangen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-754">If <paramref name="enc" /> is <see langword="null" />, ANSI encoding is assumed.</span></span></param>
        <summary><span data-ttu-id="8b8da-755">Initialisiert eine neue Instanz der <see cref="T:System.String" />-Klasse mit dem Wert, der durch einen angegebenen Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen, die Startposition innerhalb dieses Arrays, eine Länge und ein <see cref="T:System.Text.Encoding" />-Objekt angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-755">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified pointer to an array of 8-bit signed integers, a starting position within that array, a length, and an <see cref="T:System.Text.Encoding" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
>  <span data-ttu-id="8b8da-756">Beispiele und umfassende Verwendungs Informationen zu dieser und anderen `String`-Konstruktorüberladungen finden Sie in der Zusammenfassung des <xref:System.String.%23ctor%2A>-Konstruktors.</span><span class="sxs-lookup"><span data-stu-id="8b8da-756">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-757"><paramref name="value" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-757"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-758"><paramref name="startIndex" /> oder <paramref name="length" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="8b8da-758"><paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</span></span>

<span data-ttu-id="8b8da-759">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-759">-or-</span></span>

<span data-ttu-id="8b8da-760">Die durch <paramref name="value" /> + <paramref name="startIndex" /> angegebene Adresse ist für die aktuelle Plattform zu groß, d.h., bei der Berechnung der Adresse ist ein Überlauf aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-760">The address specified by <paramref name="value" /> + <paramref name="startIndex" /> is too large for the current platform; that is, the address calculation overflowed.</span></span>

<span data-ttu-id="8b8da-761">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-761">-or-</span></span>

<span data-ttu-id="8b8da-762">Die Länge der zu initialisierenden neuen Zeichenfolge ist zu groß und kann daher nicht zugeordnet werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-762">The length of the new string to initialize is too large to allocate.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8b8da-763">Die durch <paramref name="value" /> + <paramref name="startIndex" /> angegebene Adresse ist kleiner als 64K.</span><span class="sxs-lookup"><span data-stu-id="8b8da-763">The address specified by <paramref name="value" /> + <paramref name="startIndex" /> is less than 64K.</span></span>

<span data-ttu-id="8b8da-764">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-764">-or-</span></span>

<span data-ttu-id="8b8da-765">Eine neue Instanz von <see cref="T:System.String" /> konnte nicht mit <paramref name="value" /> initialisiert werden, wobei angenommen wurde, dass <paramref name="value" /> entsprechend der Angabe durch <paramref name="enc" /> codiert ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-765">A new instance of <see cref="T:System.String" /> could not be initialized using <paramref name="value" />, assuming <paramref name="value" /> is encoded as specified by <paramref name="enc" />.</span></span></exception>
        <exception cref="T:System.AccessViolationException"><span data-ttu-id="8b8da-766"><paramref name="value" />, <paramref name="startIndex" /> und <paramref name="length" /> geben zusammen eine ungültige Adresse an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-766"><paramref name="value" />, <paramref name="startIndex" />, and <paramref name="length" /> collectively specify an invalid address.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="8b8da-767">Eine Position in der aktuellen Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-767">A position in the current string.</span></span></param>
        <summary><span data-ttu-id="8b8da-768">Ruft das <see cref="T:System.Char" />-Objekt an einer angegebenen Zeichenposition innerhalb des aktuellen <see cref="T:System.String" />-Objekts ab.</span><span class="sxs-lookup"><span data-stu-id="8b8da-768">Gets the <see cref="T:System.Char" /> object at a specified position in the current <see cref="T:System.String" /> object.</span></span></summary>
        <value><span data-ttu-id="8b8da-769">Das Objekt an der <paramref name="index" />-Position.</span><span class="sxs-lookup"><span data-stu-id="8b8da-769">The object at position <paramref name="index" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-770">Der `index`-Parameter ist NULL basiert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-770">The `index` parameter is zero-based.</span></span>

 <span data-ttu-id="8b8da-771">Diese Eigenschaft gibt das <xref:System.Char> Objekt an der durch den `index`-Parameter angegebenen Position zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-771">This property returns the <xref:System.Char> object at the position specified by the `index` parameter.</span></span> <span data-ttu-id="8b8da-772">Ein Unicode-Zeichen kann jedoch durch mehr als eine <xref:System.Char>dargestellt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-772">However, a Unicode character might be represented by more than one <xref:System.Char>.</span></span> <span data-ttu-id="8b8da-773">Verwenden Sie die <xref:System.Globalization.StringInfo?displayProperty=nameWithType>-Klasse, um mit Unicode-Zeichen anstelle von <xref:System.Char>-Objekten zu arbeiten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-773">Use the <xref:System.Globalization.StringInfo?displayProperty=nameWithType> class to work with Unicode characters instead of <xref:System.Char> objects.</span></span> <span data-ttu-id="8b8da-774">Weitere Informationen finden Sie im Abschnitt "Char-Objekte und Unicode-Zeichen" in der Übersicht über <xref:System.String>-Klasse.</span><span class="sxs-lookup"><span data-stu-id="8b8da-774">For more information, see the "Char Objects and Unicode Characters" section in the <xref:System.String> class overview.</span></span>

 <span data-ttu-id="8b8da-775">In C#handelt es sich bei der <xref:System.String.Chars%2A>-Eigenschaft um einen Indexer.</span><span class="sxs-lookup"><span data-stu-id="8b8da-775">In C#, the <xref:System.String.Chars%2A> property is an indexer.</span></span> <span data-ttu-id="8b8da-776">In Visual Basic ist dies die Standard Eigenschaft der <xref:System.String>-Klasse.</span><span class="sxs-lookup"><span data-stu-id="8b8da-776">In Visual Basic, it is the default property of the <xref:System.String> class.</span></span> <span data-ttu-id="8b8da-777">Auf jedes <xref:System.Char> Objekt in der Zeichenfolge kann mithilfe von Code wie dem folgenden zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-777">Each <xref:System.Char> object in the string can be accessed by using code such as the following.</span></span>
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.chars/cs/chars1.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.chars/vb/chars1.vb" id="Snippet1":::


 
## Examples
 <span data-ttu-id="8b8da-778">Im folgenden Beispiel wird veranschaulicht, wie Sie diesen Indexer in einer Routine verwenden können, um eine Zeichenfolge zu validieren.</span><span class="sxs-lookup"><span data-stu-id="8b8da-778">The following example demonstrates how you can use this indexer in a routine to validate a string.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/Uri_IsHexDigit/CPP/uri_ishexdigit.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/Uri_IsHexDigit/CS/uri_ishexdigit.cs" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/Uri_IsHexDigit/VB/uri_ishexdigit.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="8b8da-779"><paramref name="index" /> ist größer oder gleich der Länge dieses Objekts oder kleiner als 0 (null).</span><span class="sxs-lookup"><span data-stu-id="8b8da-779"><paramref name="index" /> is greater than or equal to the length of this object or less than zero.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.GetEnumerator" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="string.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8b8da-780">Gibt einen Verweis auf diese Instanz von <see cref="T:System.String" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-780">Returns a reference to this instance of <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="8b8da-781">Diese Instanz von <see cref="T:System.String" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-781">This instance of <see cref="T:System.String" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-782">Der Rückgabewert ist keine unabhängige Kopie dieser Instanz. Es handelt sich einfach um eine weitere Ansicht der gleichen Daten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-782">The return value is not an independent copy of this instance; it is simply another view of the same data.</span></span> <span data-ttu-id="8b8da-783">Verwenden Sie die <xref:System.String.Copy%2A>-oder <xref:System.String.CopyTo%2A>-Methode, um ein separates <xref:System.String> Objekt mit demselben Wert wie diese Instanz zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-783">Use the <xref:System.String.Copy%2A> or <xref:System.String.CopyTo%2A> method to create a separate <xref:System.String> object with the same value as this instance.</span></span>

 <span data-ttu-id="8b8da-784">Da die <xref:System.String.Clone%2A>-Methode einfach die vorhandene Zeichen folgen Instanz zurückgibt, gibt es kaum einen Grund, Sie direkt aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-784">Because the <xref:System.String.Clone%2A> method simply returns the existing string instance, there is little reason to call it directly.</span></span>

 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Copy(System.String)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Compare">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8b8da-785">Vergleicht zwei angegebene <see cref="T:System.String" />-Objekte und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-785">Compares two specified <see cref="T:System.String" /> objects and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-786">Alle Überladungen der Methode <xref:System.String.Compare%2A> geben eine 32-Bit-Ganzzahl mit Vorzeichen zurück, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-786">All overloads of the <xref:System.String.Compare%2A> method return a 32-bit signed integer indicating the lexical relationship between the two comparands.</span></span>

|<span data-ttu-id="8b8da-787">Wert</span><span class="sxs-lookup"><span data-stu-id="8b8da-787">Value</span></span>|<span data-ttu-id="8b8da-788">Bedingung</span><span class="sxs-lookup"><span data-stu-id="8b8da-788">Condition</span></span>|
|-----------|---------------|
|<span data-ttu-id="8b8da-789">Kleiner als 0 (null)</span><span class="sxs-lookup"><span data-stu-id="8b8da-789">Less than zero</span></span>|<span data-ttu-id="8b8da-790">Die erste Teil Zeichenfolge steht in der Sortierreihenfolge vor der zweiten Teil Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-790">The first substring precedes the second substring in the sort order.</span></span>|
|<span data-ttu-id="8b8da-791">Zero</span><span class="sxs-lookup"><span data-stu-id="8b8da-791">Zero</span></span>|<span data-ttu-id="8b8da-792">Die Teilzeichenfolgen treten in der Sortierreihenfolge an der gleichen Position auf, oder `length` ist 0 (null).</span><span class="sxs-lookup"><span data-stu-id="8b8da-792">The substrings occur in the same position in the sort order, or `length` is zero.</span></span>|
|<span data-ttu-id="8b8da-793">Größer als 0 (null)</span><span class="sxs-lookup"><span data-stu-id="8b8da-793">Greater than zero</span></span>|<span data-ttu-id="8b8da-794">Die erste Teil Zeichenfolge folgt der zweiten Teil Zeichenfolge in der Sortierreihenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-794">The first substring follows the second substring in the sort order.</span></span>|

> [!WARNING]
>  <span data-ttu-id="8b8da-795">Wenn möglich, sollten Sie eine Überladung der <xref:System.String.Compare%2A>-Methode aufrufen, die einen <xref:System.StringComparison>-Parameter enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-795">Whenever possible, you should call an overload of the <xref:System.String.Compare%2A> method that includes a <xref:System.StringComparison> parameter.</span></span> <span data-ttu-id="8b8da-796">Weitere Informationen finden Sie unter [Empfohlene Vorgehensweisen für die Verwendung von Zeichenfolgen in .NET Framework](~/docs/standard/base-types/best-practices-strings.md).</span><span class="sxs-lookup"><span data-stu-id="8b8da-796">For more information, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>

 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/best-practices-strings.md"><span data-ttu-id="8b8da-797">Empfohlene Vorgehensweisen für die Verwendung von Zeichenfolgen in .NET</span><span class="sxs-lookup"><span data-stu-id="8b8da-797">Best Practices for Using Strings in .NET</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string -&gt; int" Usage="System.string.Compare (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="8b8da-798">Die erste zu vergleichende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-798">The first string to compare.</span></span></param>
        <param name="strB"><span data-ttu-id="8b8da-799">Die zweite zu vergleichende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-799">The second string to compare.</span></span></param>
        <summary><span data-ttu-id="8b8da-800">Vergleicht zwei angegebene <see cref="T:System.String" />-Objekte und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-800">Compares two specified <see cref="T:System.String" /> objects and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="8b8da-801">Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-801">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>

 <list type="table"><listheader><term> <span data-ttu-id="8b8da-802">Wert</span><span class="sxs-lookup"><span data-stu-id="8b8da-802">Value</span></span>

 </term><description> <span data-ttu-id="8b8da-803">Bedingung</span><span class="sxs-lookup"><span data-stu-id="8b8da-803">Condition</span></span>

 </description></listheader><item><term> <span data-ttu-id="8b8da-804">Kleiner als 0 (null)</span><span class="sxs-lookup"><span data-stu-id="8b8da-804">Less than zero</span></span>

 </term><description><span data-ttu-id="8b8da-805"><paramref name="strA" /> steht in der Sortierreihenfolge vor <paramref name="strB" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-805"><paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.</span></span>

 </description></item><item><term> <span data-ttu-id="8b8da-806">Zero</span><span class="sxs-lookup"><span data-stu-id="8b8da-806">Zero</span></span>

 </term><description><span data-ttu-id="8b8da-807"><paramref name="strA" /> tritt in der Sortierreihenfolge an der gleichen Position wie <paramref name="strB" /> auf.</span><span class="sxs-lookup"><span data-stu-id="8b8da-807"><paramref name="strA" /> occurs in the same position as <paramref name="strB" /> in the sort order.</span></span>

 </description></item><item><term> <span data-ttu-id="8b8da-808">Größer als 0 (null)</span><span class="sxs-lookup"><span data-stu-id="8b8da-808">Greater than zero</span></span>

 </term><description><span data-ttu-id="8b8da-809"><paramref name="strA" /> steht in der Sortierreihenfolge nach <paramref name="strB" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-809"><paramref name="strA" /> follows <paramref name="strB" /> in the sort order.</span></span>

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-810">Der Vergleich verwendet die aktuelle Kultur, um kulturspezifische Informationen wie z. b. Regeln für die Groß-/Kleinschreibung und die alphabetische Reihenfolge einzelner Zeichen abzurufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-810">The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="8b8da-811">Beispielsweise könnte eine Kultur angeben, dass bestimmte Kombinationen von Zeichen als einzelnes Zeichen behandelt werden sollen, dass groß-und Kleinbuchstaben auf eine bestimmte Weise verglichen werden sollen, oder dass die Sortierreihenfolge eines Zeichens von den Zeichen abhängig ist, die vorangestellt oder befolgt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-811">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>

 <span data-ttu-id="8b8da-812">Der Vergleich erfolgt mithilfe von Wort Sortierregeln.</span><span class="sxs-lookup"><span data-stu-id="8b8da-812">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="8b8da-813">Weitere Informationen zu Wort-, Zeichen folgen-und ordinalsortierungen finden Sie unter <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-813">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>

> [!WARNING]
>  <span data-ttu-id="8b8da-814">Beim Vergleichen von Zeichen folgen sollten Sie die <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>-Methode verwenden, die erfordert, dass Sie den Typ des Zeichen folgen Vergleichs, der von der Methode verwendet wird, explizit angeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-814">When comparing strings, you should call the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, which requires that you explicitly specify the type of string comparison that the method uses.</span></span> <span data-ttu-id="8b8da-815">Weitere Informationen finden Sie unter [Empfohlene Vorgehensweisen für die Verwendung von Zeichenfolgen in .NET Framework](~/docs/standard/base-types/best-practices-strings.md).</span><span class="sxs-lookup"><span data-stu-id="8b8da-815">For more information, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>

 <span data-ttu-id="8b8da-816">Ein oder beide Vergleiche können `null`werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-816">One or both comparands can be `null`.</span></span> <span data-ttu-id="8b8da-817">Definitionsgemäß vergleicht jede Zeichenfolge, einschließlich der leeren Zeichenfolge (""), größer als ein NULL-Verweis. und zwei NULL-Verweise vergleichen einander.</span><span class="sxs-lookup"><span data-stu-id="8b8da-817">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>

 <span data-ttu-id="8b8da-818">Der Vergleich wird beendet, wenn eine Ungleichheit erkannt oder beide Zeichen folgen verglichen wurden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-818">The comparison terminates when an inequality is discovered or both strings have been compared.</span></span> <span data-ttu-id="8b8da-819">Wenn die beiden Zeichen folgen jedoch gleich dem Ende einer Zeichenfolge sind und die andere Zeichenfolge Zeichen enthält, wird die Zeichenfolge mit den verbleibenden Zeichen als größer betrachtet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-819">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="8b8da-820">Der Rückgabewert ist das Ergebnis des letzten auszuführenden Vergleichs.</span><span class="sxs-lookup"><span data-stu-id="8b8da-820">The return value is the result of the last comparison performed.</span></span>

 <span data-ttu-id="8b8da-821">Unerwartete Ergebnisse können auftreten, wenn Vergleiche von kulturspezifischen Regeln für Groß-und Kleinschreibung betroffen sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-821">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="8b8da-822">In der türkischen Sprache führt das folgende Beispiel z. b. zu den falschen Ergebnissen, da das Dateisystem in der türkischen Sprache keine Regeln für die linguistische Schreibweise für den Buchstaben "i" in "file" verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-822">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>

 [!code-cpp[System.String.Compare#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#10)]
 [!code-csharp[System.String.Compare#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#10)]
 [!code-vb[System.String.Compare#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#10)]

 <span data-ttu-id="8b8da-823">Vergleichen Sie den Pfadnamen mit "file", indem Sie einen Ordinalvergleich verwenden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-823">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="8b8da-824">Der richtige Code hierfür lautet wie folgt:</span><span class="sxs-lookup"><span data-stu-id="8b8da-824">The correct code to do this is as follows:</span></span>

 [!code-cpp[System.String.Compare#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#11)]
 [!code-csharp[System.String.Compare#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#11)]
 [!code-vb[System.String.Compare#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#11)]



## Examples
 <span data-ttu-id="8b8da-825">Im folgenden Beispiel wird die <xref:System.String.Compare%28System.String%2CSystem.String%29>-Methode aufgerufen, um drei Sätze von Zeichen folgen zu vergleichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-825">The following example calls the <xref:System.String.Compare%28System.String%2CSystem.String%29> method to compare three sets of strings.</span></span>

 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp-interactive[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]

 <span data-ttu-id="8b8da-826">Im folgenden Beispiel veranschaulicht die `ReverseStringComparer`-Klasse, wie Sie zwei Zeichen folgen mit der <xref:System.String.Compare%2A>-Methode auswerten können.</span><span class="sxs-lookup"><span data-stu-id="8b8da-826">In the following example, the `ReverseStringComparer` class demonstrates how you can evaluate two strings with the <xref:System.String.Compare%2A> method.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/ArrayList/CPP/ArrayListSample.cpp" id="Snippet7":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/ArrayList/CS/ArrayListSample.cs" interactive="try-dotnet" id="Snippet7":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/ArrayList/VB/ArrayListSample.vb" id="Snippet7":::

 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-827">Zeichensätze enthalten ignorierbare Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-827">Character sets include ignorable characters.</span></span> <span data-ttu-id="8b8da-828">Die <see cref="M:System.String.Compare(System.String,System.String)" />-Methode berücksichtigt solche Zeichen nicht, wenn Sie einen Kultur abhängigen Vergleich durchführt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-828">The <see cref="M:System.String.Compare(System.String,System.String)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="8b8da-829">Wenn der folgende Code z. b. auf der [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher ausgeführt wird, gibt ein Kultur abhängiger Vergleich von "Animal" mit "Ani-mal" (mit einem weichen Bindestrich oder U + 00ad) an, dass die beiden Zeichen folgen äquivalent sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-829">For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a culture-sensitive comparison of "animal" with "ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</span></span>

<span data-ttu-id="8b8da-830">[! Code-csharp[System. String. Compare # 21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare21.cs#21)] [! Code-vb[System. String. Compare # 21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare21.vb#21)]</span><span class="sxs-lookup"><span data-stu-id="8b8da-830">[!code-csharp[System.String.Compare#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare21.cs#21)] [!code-vb[System.String.Compare#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare21.vb#21)]</span></span>

<span data-ttu-id="8b8da-831">Um Ignorable-Zeichen in einem Zeichen folgen Vergleich zu erkennen, müssen Sie die <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" />-Methode aufrufen und für den `comparisonType`-Parameter entweder <see cref="F:System.Globalization.CompareOptions.Ordinal" /> oder <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> angeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-831">To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> method and supply a value of either <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the `comparisonType` parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="8b8da-832">Die erste zu vergleichende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-832">The first string to compare.</span></span></param>
        <param name="strB"><span data-ttu-id="8b8da-833">Die zweite zu vergleichende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-833">The second string to compare.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="8b8da-834"><see langword="true" />, wenn die Groß-/Kleinschreibung beim Vergleich ignoriert werden soll, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-834"><see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="8b8da-835">Vergleicht zwei angegebene <see cref="T:System.String" />-Objekte, wobei ihre Groß- und Kleinschreibung entweder ignoriert oder berücksichtigt wird, und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-835">Compares two specified <see cref="T:System.String" /> objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="8b8da-836">Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-836">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>

 <list type="table"><listheader><term> <span data-ttu-id="8b8da-837">Wert</span><span class="sxs-lookup"><span data-stu-id="8b8da-837">Value</span></span>

 </term><description> <span data-ttu-id="8b8da-838">Bedingung</span><span class="sxs-lookup"><span data-stu-id="8b8da-838">Condition</span></span>

 </description></listheader><item><term> <span data-ttu-id="8b8da-839">Kleiner als 0 (null)</span><span class="sxs-lookup"><span data-stu-id="8b8da-839">Less than zero</span></span>

 </term><description><span data-ttu-id="8b8da-840"><paramref name="strA" /> steht in der Sortierreihenfolge vor <paramref name="strB" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-840"><paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.</span></span>

 </description></item><item><term> <span data-ttu-id="8b8da-841">Zero</span><span class="sxs-lookup"><span data-stu-id="8b8da-841">Zero</span></span>

 </term><description><span data-ttu-id="8b8da-842"><paramref name="strA" /> tritt in der Sortierreihenfolge an der gleichen Position wie <paramref name="strB" /> auf.</span><span class="sxs-lookup"><span data-stu-id="8b8da-842"><paramref name="strA" /> occurs in the same position as <paramref name="strB" /> in the sort order.</span></span>

 </description></item><item><term> <span data-ttu-id="8b8da-843">Größer als 0 (null)</span><span class="sxs-lookup"><span data-stu-id="8b8da-843">Greater than zero</span></span>

 </term><description><span data-ttu-id="8b8da-844"><paramref name="strA" /> steht in der Sortierreihenfolge nach <paramref name="strB" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-844"><paramref name="strA" /> follows <paramref name="strB" /> in the sort order.</span></span>

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-845">Der Vergleich verwendet die aktuelle Kultur, um kulturspezifische Informationen wie z. b. Regeln für die Groß-/Kleinschreibung und die alphabetische Reihenfolge einzelner Zeichen abzurufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-845">The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="8b8da-846">Beispielsweise könnte eine Kultur angeben, dass bestimmte Kombinationen von Zeichen als einzelnes Zeichen behandelt werden sollen, dass groß-und Kleinbuchstaben auf eine bestimmte Weise verglichen werden sollen, oder dass die Sortierreihenfolge eines Zeichens von den Zeichen abhängig ist, die vorangestellt oder befolgt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-846">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>

 <span data-ttu-id="8b8da-847">Der Vergleich erfolgt mithilfe von Wort Sortierregeln.</span><span class="sxs-lookup"><span data-stu-id="8b8da-847">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="8b8da-848">Weitere Informationen zu Wort-, Zeichen folgen-und ordinalsortierungen finden Sie unter <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-848">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>

> [!WARNING]
>  <span data-ttu-id="8b8da-849">Beim Vergleichen von Zeichen folgen sollten Sie die <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>-Methode verwenden, die erfordert, dass Sie den Typ des Zeichen folgen Vergleichs, der von der Methode verwendet wird, explizit angeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-849">When comparing strings, you should call the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, which requires that you explicitly specify the type of string comparison that the method uses.</span></span> <span data-ttu-id="8b8da-850">Weitere Informationen finden Sie unter [Empfohlene Vorgehensweisen für die Verwendung von Zeichenfolgen in .NET Framework](~/docs/standard/base-types/best-practices-strings.md).</span><span class="sxs-lookup"><span data-stu-id="8b8da-850">For more information, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>

 <span data-ttu-id="8b8da-851">Ein oder beide Vergleiche können `null`werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-851">One or both comparands can be `null`.</span></span> <span data-ttu-id="8b8da-852">Definitionsgemäß vergleicht jede Zeichenfolge, einschließlich der leeren Zeichenfolge (""), größer als ein NULL-Verweis. und zwei NULL-Verweise vergleichen einander.</span><span class="sxs-lookup"><span data-stu-id="8b8da-852">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>

 <span data-ttu-id="8b8da-853">Der Vergleich wird beendet, wenn eine Ungleichheit erkannt oder beide Zeichen folgen verglichen wurden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-853">The comparison terminates when an inequality is discovered or both strings have been compared.</span></span> <span data-ttu-id="8b8da-854">Wenn die beiden Zeichen folgen jedoch gleich dem Ende einer Zeichenfolge sind und die andere Zeichenfolge Zeichen enthält, wird die Zeichenfolge mit den verbleibenden Zeichen als größer betrachtet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-854">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="8b8da-855">Der Rückgabewert ist das Ergebnis des letzten auszuführenden Vergleichs.</span><span class="sxs-lookup"><span data-stu-id="8b8da-855">The return value is the result of the last comparison performed.</span></span>

 <span data-ttu-id="8b8da-856">Unerwartete Ergebnisse können auftreten, wenn Vergleiche von kulturspezifischen Regeln für Groß-und Kleinschreibung betroffen sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-856">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="8b8da-857">In der türkischen Sprache führt das folgende Beispiel z. b. zu den falschen Ergebnissen, da das Dateisystem in der türkischen Sprache keine Regeln für die linguistische Schreibweise für den Buchstaben "i" in "file" verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-857">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>

 [!code-cpp[System.String.Compare#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#12)]
 [!code-csharp[System.String.Compare#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#12)]
 [!code-vb[System.String.Compare#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#12)]

 <span data-ttu-id="8b8da-858">Vergleichen Sie den Pfadnamen mit "file", indem Sie einen Ordinalvergleich verwenden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-858">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="8b8da-859">Der richtige Code hierfür lautet wie folgt:</span><span class="sxs-lookup"><span data-stu-id="8b8da-859">The correct code to do this is as follows:</span></span>

 [!code-cpp[System.String.Compare#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#13)]
 [!code-csharp[System.String.Compare#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#13)]
 [!code-vb[System.String.Compare#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#13)]



## Examples
 <span data-ttu-id="8b8da-860">Im folgenden Beispiel wird veranschaulicht, dass die <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29>-Methode der Verwendung <xref:System.String.ToUpper%2A> oder <xref:System.String.ToLower%2A> beim Vergleichen von Zeichen folgen entspricht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-860">The following example demonstrates that the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29> method is equivalent to using <xref:System.String.ToUpper%2A> or <xref:System.String.ToLower%2A> when comparing strings.</span></span>

 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp-interactive[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]

 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-861">Zeichensätze enthalten ignorierbare Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-861">Character sets include ignorable characters.</span></span> <span data-ttu-id="8b8da-862">Die <see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" />-Methode berücksichtigt solche Zeichen nicht, wenn Sie einen Kultur abhängigen Vergleich durchführt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-862">The <see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="8b8da-863">Wenn der folgende Code z. b. auf der [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher ausgeführt wird, gibt ein Kultur abhängiger Vergleich von "Animal" mit "Ani-mal" (mit einem weichen Bindestrich oder U + 00ad) an, dass die beiden Zeichen folgen äquivalent sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-863">For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a culture-sensitive, case-insensitive comparison of "animal" with "Ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</span></span>

<span data-ttu-id="8b8da-864">[! Code-csharp[System. String. Compare # 22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare22.cs#22)] [! Code-vb[System. String. Compare # 22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare22.vb#22)]</span><span class="sxs-lookup"><span data-stu-id="8b8da-864">[!code-csharp[System.String.Compare#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare22.cs#22)] [!code-vb[System.String.Compare#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare22.vb#22)]</span></span>

<span data-ttu-id="8b8da-865">Um Ignorable-Zeichen in einem Zeichen folgen Vergleich zu erkennen, müssen Sie die <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" />-Methode aufrufen und für den <paramref name="comparisonType" />-Parameter entweder <see cref="F:System.Globalization.CompareOptions.Ordinal" /> oder <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> angeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-865">To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> method and supply a value of either <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * StringComparison -&gt; int" Usage="System.string.Compare (strA, strB, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="8b8da-866">Die erste zu vergleichende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-866">The first string to compare.</span></span></param>
        <param name="strB"><span data-ttu-id="8b8da-867">Die zweite zu vergleichende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-867">The second string to compare.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="8b8da-868">Einer der Enumerationswerte, der die für den Vergleich zu verwendenden Regeln angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-868">One of the enumeration values that specifies the rules to use in the comparison.</span></span></param>
        <summary><span data-ttu-id="8b8da-869">Vergleicht zwei angegebene <see cref="T:System.String" />-Objekte gemäß den angegebenen Vergleichsregeln und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-869">Compares two specified <see cref="T:System.String" /> objects using the specified rules, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="8b8da-870">Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-870">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>

 <list type="table"><listheader><term> <span data-ttu-id="8b8da-871">Wert</span><span class="sxs-lookup"><span data-stu-id="8b8da-871">Value</span></span>

 </term><description> <span data-ttu-id="8b8da-872">Bedingung</span><span class="sxs-lookup"><span data-stu-id="8b8da-872">Condition</span></span>

 </description></listheader><item><term> <span data-ttu-id="8b8da-873">Kleiner als 0 (null)</span><span class="sxs-lookup"><span data-stu-id="8b8da-873">Less than zero</span></span>

 </term><description><span data-ttu-id="8b8da-874"><paramref name="strA" /> steht in der Sortierreihenfolge vor <paramref name="strB" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-874"><paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.</span></span>

 </description></item><item><term> <span data-ttu-id="8b8da-875">Zero</span><span class="sxs-lookup"><span data-stu-id="8b8da-875">Zero</span></span>

 </term><description><span data-ttu-id="8b8da-876"><paramref name="strA" /> befindet sich in der Sortierreihenfolge an der gleichen Position wie <paramref name="strB" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-876"><paramref name="strA" /> is in the same position as <paramref name="strB" /> in the sort order.</span></span>

 </description></item><item><term> <span data-ttu-id="8b8da-877">Größer als 0 (null)</span><span class="sxs-lookup"><span data-stu-id="8b8da-877">Greater than zero</span></span>

 </term><description><span data-ttu-id="8b8da-878"><paramref name="strA" /> steht in der Sortierreihenfolge nach <paramref name="strB" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-878"><paramref name="strA" /> follows <paramref name="strB" /> in the sort order.</span></span>

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-879">Der `comparisonType`-Parameter gibt an, ob beim Vergleich die aktuelle oder invariante Kultur verwendet werden soll, ob die Groß-/Kleinschreibung der Vergleichs Elemente berücksichtigt oder ignoriert werden soll, oder ob Wort-Sortierregeln (Kultur abhängig) oder Ordinalzahl (Kultur abhängig) verwendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-879">The `comparisonType` parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the comparands, or use word (culture-sensitive) or ordinal (culture-insensitive) sort rules.</span></span>

 <span data-ttu-id="8b8da-880">Ein oder beide Vergleiche können `null`werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-880">One or both comparands can be `null`.</span></span> <span data-ttu-id="8b8da-881">Definitionsgemäß vergleicht jede Zeichenfolge, einschließlich der leeren Zeichenfolge (""), größer als ein NULL-Verweis. und zwei NULL-Verweise vergleichen einander.</span><span class="sxs-lookup"><span data-stu-id="8b8da-881">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>

 <span data-ttu-id="8b8da-882">Der Vergleich wird beendet, wenn eine Ungleichheit erkannt oder beide Zeichen folgen verglichen wurden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-882">The comparison terminates when an inequality is discovered or both strings have been compared.</span></span> <span data-ttu-id="8b8da-883">Wenn die beiden Zeichen folgen jedoch gleich dem Ende einer Zeichenfolge sind und die andere Zeichenfolge Zeichen enthält, wird die Zeichenfolge mit den verbleibenden Zeichen als größer betrachtet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-883">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with remaining characters is considered greater.</span></span> <span data-ttu-id="8b8da-884">Der Rückgabewert ist das Ergebnis des letzten auszuführenden Vergleichs.</span><span class="sxs-lookup"><span data-stu-id="8b8da-884">The return value is the result of the last comparison performed.</span></span>

 <span data-ttu-id="8b8da-885">Unerwartete Ergebnisse können auftreten, wenn Vergleiche von kulturspezifischen Regeln für Groß-und Kleinschreibung betroffen sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-885">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="8b8da-886">In der türkischen Sprache führt das folgende Beispiel z. b. zu den falschen Ergebnissen, da das Dateisystem in der türkischen Sprache keine Regeln für die linguistische Schreibweise für den Buchstaben "i" in "file" verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-886">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>

 [!code-cpp[System.String.Compare#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#16)]
 [!code-csharp[System.String.Compare#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#16)]
 [!code-vb[System.String.Compare#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#16)]

 <span data-ttu-id="8b8da-887">Vergleichen Sie den Pfadnamen mit "file", indem Sie einen Ordinalvergleich verwenden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-887">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="8b8da-888">Der richtige Code hierfür lautet wie folgt:</span><span class="sxs-lookup"><span data-stu-id="8b8da-888">The correct code to do this is as follows:</span></span>

 [!code-cpp[System.String.Compare#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#17)]
 [!code-csharp[System.String.Compare#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#17)]
 [!code-vb[System.String.Compare#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#17)]



## Examples
 <span data-ttu-id="8b8da-889">Im folgenden Beispiel werden drei Versionen des Buchstabens "I" verglichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-889">The following example compares three versions of the letter "I".</span></span> <span data-ttu-id="8b8da-890">Die Ergebnisse sind von der Auswahl der Kultur betroffen, unabhängig davon, ob die Groß-/Kleinschreibung ignoriert wird und ob ein Ordinalvergleich durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-890">The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed.</span></span>

 [!code-cpp[System.String.CompareCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.CompareCmp/cpp/cmpcmp.cpp#1)]
 [!code-csharp[System.String.CompareCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.CompareCmp/cs/cmpcmp.cs#1)]
 [!code-vb[System.String.CompareCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.CompareCmp/vb/cmpcmp.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8b8da-891"><paramref name="comparisonType" /> ist kein <see cref="T:System.StringComparison" />-Wert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-891"><paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="8b8da-892"><see cref="T:System.StringComparison" /> wird nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-892"><see cref="T:System.StringComparison" /> is not supported.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-893">Zeichensätze enthalten ignorierbare Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-893">Character sets include ignorable characters.</span></span> <span data-ttu-id="8b8da-894">Die <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" />-Methode berücksichtigt solche Zeichen nicht, wenn Sie einen Kultur abhängigen Vergleich durchführt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-894">The <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="8b8da-895">Um Ignorable-Zeichen im Vergleich zu erkennen, geben Sie den Wert <see cref="F:System.StringComparison.Ordinal" /> oder <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> für den <paramref name="comparisonType" />-Parameter an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-895">To recognize ignorable characters in your comparison, supply a value of <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="8b8da-896">Die erste zu vergleichende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-896">The first string to compare.</span></span></param>
        <param name="strB"><span data-ttu-id="8b8da-897">Die zweite zu vergleichende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-897">The second string to compare.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="8b8da-898"><see langword="true" />, wenn die Groß-/Kleinschreibung beim Vergleich ignoriert werden soll, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-898"><see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span></span></param>
        <param name="culture"><span data-ttu-id="8b8da-899">Ein Objekt, das kulturspezifische Vergleichsinformationen angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-899">An object that supplies culture-specific comparison information.</span></span></param>
        <summary><span data-ttu-id="8b8da-900">Vergleicht zwei angegebene <see cref="T:System.String" />-Objekte, wobei ihre Groß- und Kleinschreibung entweder ignoriert oder berücksichtigt und der Vergleich durch kulturspezifische Informationen beeinflusst wird, und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-900">Compares two specified <see cref="T:System.String" /> objects, ignoring or honoring their case, and using culture-specific information to influence the comparison, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="8b8da-901">Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-901">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>

 <list type="table"><listheader><term> <span data-ttu-id="8b8da-902">Wert</span><span class="sxs-lookup"><span data-stu-id="8b8da-902">Value</span></span>

 </term><description> <span data-ttu-id="8b8da-903">Bedingung</span><span class="sxs-lookup"><span data-stu-id="8b8da-903">Condition</span></span>

 </description></listheader><item><term> <span data-ttu-id="8b8da-904">Kleiner als 0 (null)</span><span class="sxs-lookup"><span data-stu-id="8b8da-904">Less than zero</span></span>

 </term><description><span data-ttu-id="8b8da-905"><paramref name="strA" /> steht in der Sortierreihenfolge vor <paramref name="strB" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-905"><paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.</span></span>

 </description></item><item><term> <span data-ttu-id="8b8da-906">Zero</span><span class="sxs-lookup"><span data-stu-id="8b8da-906">Zero</span></span>

 </term><description><span data-ttu-id="8b8da-907"><paramref name="strA" /> tritt in der Sortierreihenfolge an der gleichen Position wie <paramref name="strB" /> auf.</span><span class="sxs-lookup"><span data-stu-id="8b8da-907"><paramref name="strA" /> occurs in the same position as <paramref name="strB" /> in the sort order.</span></span>

 </description></item><item><term> <span data-ttu-id="8b8da-908">Größer als 0 (null)</span><span class="sxs-lookup"><span data-stu-id="8b8da-908">Greater than zero</span></span>

 </term><description><span data-ttu-id="8b8da-909"><paramref name="strA" /> steht in der Sortierreihenfolge nach <paramref name="strB" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-909"><paramref name="strA" /> follows <paramref name="strB" /> in the sort order.</span></span>

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-910">Beim Vergleich wird der `culture`-Parameter verwendet, um kulturspezifische Informationen wie z. b. Regeln für die Groß-und Kleinschreibung von einzelnen Zeichen abzurufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-910">The comparison uses the `culture` parameter to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="8b8da-911">Beispielsweise könnte eine Kultur angeben, dass bestimmte Kombinationen von Zeichen als einzelnes Zeichen behandelt werden sollen, dass groß-und Kleinbuchstaben auf eine bestimmte Weise verglichen werden sollen, oder dass die Sortierreihenfolge eines Zeichens von den Zeichen abhängig ist, die vorangestellt oder befolgt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-911">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>

 <span data-ttu-id="8b8da-912">Der Vergleich erfolgt mithilfe von Wort Sortierregeln.</span><span class="sxs-lookup"><span data-stu-id="8b8da-912">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="8b8da-913">Weitere Informationen zu Wort-, Zeichen folgen-und ordinalsortierungen finden Sie unter <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-913">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>

 <span data-ttu-id="8b8da-914">Ein oder beide Vergleiche können `null`werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-914">One or both comparands can be `null`.</span></span> <span data-ttu-id="8b8da-915">Definitionsgemäß vergleicht jede Zeichenfolge, einschließlich der leeren Zeichenfolge (""), größer als ein NULL-Verweis. und zwei NULL-Verweise vergleichen einander.</span><span class="sxs-lookup"><span data-stu-id="8b8da-915">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>

 <span data-ttu-id="8b8da-916">Der Vergleich wird beendet, wenn eine Ungleichheit erkannt oder beide Zeichen folgen verglichen wurden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-916">The comparison terminates when an inequality is discovered or both strings have been compared.</span></span> <span data-ttu-id="8b8da-917">Wenn die beiden Zeichen folgen jedoch gleich dem Ende einer Zeichenfolge sind und die andere Zeichenfolge Zeichen enthält, wird die Zeichenfolge mit den verbleibenden Zeichen als größer betrachtet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-917">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="8b8da-918">Der Rückgabewert ist das Ergebnis des letzten auszuführenden Vergleichs.</span><span class="sxs-lookup"><span data-stu-id="8b8da-918">The return value is the result of the last comparison performed.</span></span>

 <span data-ttu-id="8b8da-919">Unerwartete Ergebnisse können auftreten, wenn Vergleiche von kulturspezifischen Regeln für Groß-und Kleinschreibung betroffen sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-919">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="8b8da-920">In der türkischen Sprache führt das folgende Beispiel z. b. zu den falschen Ergebnissen, da das Dateisystem in der türkischen Sprache keine Regeln für die linguistische Schreibweise für den Buchstaben "i" in "file" verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-920">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>

 [!code-cpp[System.String.Compare#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#14)]
 [!code-csharp[System.String.Compare#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#14)]
 [!code-vb[System.String.Compare#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#14)]

 <span data-ttu-id="8b8da-921">Vergleichen Sie den Pfadnamen mit "file", indem Sie einen Ordinalvergleich verwenden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-921">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="8b8da-922">Der richtige Code hierfür lautet wie folgt:</span><span class="sxs-lookup"><span data-stu-id="8b8da-922">The correct code to do this is as follows:</span></span>

 [!code-cpp[System.String.Compare#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#15)]
 [!code-csharp[System.String.Compare#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#15)]
 [!code-vb[System.String.Compare#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#15)]



## Examples
 <span data-ttu-id="8b8da-923">Im folgenden Beispiel wird veranschaulicht, wie sich die Kultur auf einen Vergleich auswirken kann.</span><span class="sxs-lookup"><span data-stu-id="8b8da-923">The following example demonstrates how culture can affect a comparison.</span></span> <span data-ttu-id="8b8da-924">In der Kultur der Tschechischen Republik ist "ch" ein einzelnes Zeichen, das größer als "d" ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-924">In Czech - Czech Republic culture, "ch" is a single character that is greater than "d".</span></span> <span data-ttu-id="8b8da-925">In englischer Sprache USA Kultur besteht "ch" aus zwei Zeichen, und "c" ist kleiner als "d".</span><span class="sxs-lookup"><span data-stu-id="8b8da-925">However, in English - United States culture, "ch" consists of two characters, and "c" is less than "d".</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.comp4/CPP/string.comp4.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.comp4/CS/string.comp4.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.comp4/VB/string.comp4.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-926"><paramref name="culture" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-926"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-927">Zeichensätze enthalten ignorierbare Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-927">Character sets include ignorable characters.</span></span> <span data-ttu-id="8b8da-928">Die <see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />-Methode berücksichtigt solche Zeichen nicht, wenn Sie einen Kultur abhängigen Vergleich durchführt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-928">The <see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="8b8da-929">Wenn z. b. der folgende Code für die [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher ausgeführt wird, gibt ein Vergleich von "Animal" mit "Ani-mal" (mit einem weichen Bindestrich oder U + 00ad), der die invariante Kultur verwendet, eine Entsprechung für die beiden Zeichen folgen an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-929">For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a case-insensitive comparison of "animal" with "Ani-mal" (using a soft hyphen, or U+00AD) using the invariant culture indicates that the two strings are equivalent.</span></span>

<span data-ttu-id="8b8da-930">[! Code-csharp[System. String. Compare # 23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare23.cs#23)] [! Code-vb[System. String. Compare # 23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare23.vb#23)]</span><span class="sxs-lookup"><span data-stu-id="8b8da-930">[!code-csharp[System.String.Compare#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare23.cs#23)] [!code-vb[System.String.Compare#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare23.vb#23)]</span></span>

<span data-ttu-id="8b8da-931">Um Ignorable-Zeichen in einem Zeichen folgen Vergleich zu erkennen, müssen Sie die <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />-Methode aufrufen und für den <paramref name="options" />-Parameter entweder <see cref="F:System.Globalization.CompareOptions.Ordinal" /> oder <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> angeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-931">To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> method and supply a value of either <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="options" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, strB, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="8b8da-932">Die erste zu vergleichende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-932">The first string to compare.</span></span></param>
        <param name="strB"><span data-ttu-id="8b8da-933">Die zweite zu vergleichende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-933">The second string to compare.</span></span></param>
        <param name="culture"><span data-ttu-id="8b8da-934">Die Kultur, die kulturspezifische Vergleichsinformationen liefert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-934">The culture that supplies culture-specific comparison information.</span></span></param>
        <param name="options"><span data-ttu-id="8b8da-935">Die beim Ausführen des Vergleichs zu verwendenden Optionen (z. B. Ignorieren von Groß- und Kleinschreibung oder Symbolen).</span><span class="sxs-lookup"><span data-stu-id="8b8da-935">Options to use when performing the comparison (such as ignoring case or symbols).</span></span></param>
        <summary><span data-ttu-id="8b8da-936">Vergleicht zwei angegebene <see cref="T:System.String" />-Objekte mit den festgelegten Vergleichsoptionen und kulturspezifischen Informationen, die den Vergleich beeinflussen, und gibt eine ganze Zahl zurück, die die Beziehung der beiden Zeichenfolgen zueinander in der Sortierreihenfolge angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-936">Compares two specified <see cref="T:System.String" /> objects using the specified comparison options and culture-specific information to influence the comparison, and returns an integer that indicates the relationship of the two strings to each other in the sort order.</span></span></summary>
        <returns><span data-ttu-id="8b8da-937">Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung zwischen <paramref name="strA" /> und <paramref name="strB" /> angibt, wie in der folgenden Tabelle veranschaulicht wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-937">A 32-bit signed integer that indicates the lexical relationship between <paramref name="strA" /> and <paramref name="strB" />, as shown in the following table</span></span>

 <list type="table"><listheader><term> <span data-ttu-id="8b8da-938">Wert</span><span class="sxs-lookup"><span data-stu-id="8b8da-938">Value</span></span>

 </term><description> <span data-ttu-id="8b8da-939">Bedingung</span><span class="sxs-lookup"><span data-stu-id="8b8da-939">Condition</span></span>

 </description></listheader><item><term> <span data-ttu-id="8b8da-940">Kleiner als 0 (null)</span><span class="sxs-lookup"><span data-stu-id="8b8da-940">Less than zero</span></span>

 </term><description><span data-ttu-id="8b8da-941"><paramref name="strA" /> steht in der Sortierreihenfolge vor <paramref name="strB" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-941"><paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.</span></span>

 </description></item><item><term> <span data-ttu-id="8b8da-942">Zero</span><span class="sxs-lookup"><span data-stu-id="8b8da-942">Zero</span></span>

 </term><description><span data-ttu-id="8b8da-943"><paramref name="strA" /> tritt in der Sortierreihenfolge an der gleichen Position wie <paramref name="strB" /> auf.</span><span class="sxs-lookup"><span data-stu-id="8b8da-943"><paramref name="strA" /> occurs in the same position as <paramref name="strB" /> in the sort order.</span></span>

 </description></item><item><term> <span data-ttu-id="8b8da-944">Größer als 0 (null)</span><span class="sxs-lookup"><span data-stu-id="8b8da-944">Greater than zero</span></span>

 </term><description><span data-ttu-id="8b8da-945"><paramref name="strA" /> steht in der Sortierreihenfolge nach <paramref name="strB" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-945"><paramref name="strA" /> follows <paramref name="strB" /> in the sort order.</span></span>

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-946">Der-Vergleich verwendet den `culture`-Parameter, um kulturspezifische Informationen abzurufen, z. b. Regeln für die Groß-und Kleinschreibung von einzelnen Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-946">The comparison uses the `culture` parameter to obtain culture-specific information, such as casing rules and the alphabetical order of individual characters.</span></span> <span data-ttu-id="8b8da-947">Eine bestimmte Kultur könnte z. b. angeben, dass bestimmte Zeichenkombinationen als einzelnes Zeichen behandelt werden sollen, dass groß-und Kleinbuchstaben auf eine bestimmte Weise verglichen werden sollen oder dass die Sortierreihenfolge eines Zeichens von den vorangestellten Zeichen abhängig ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-947">For example, a particular culture could specify that certain combinations of characters be treated as a single character, that uppercase and lowercase characters be compared in a particular way, or that the sort order of a character depends on the characters that precede or follow it.</span></span>

> [!CAUTION]
>  <span data-ttu-id="8b8da-948">Die <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>-Methode ist hauptsächlich für die Verwendung in Sortier-oder alphabetisierungsvorgängen vorgesehen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-948">The <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> method is designed primarily for use in sorting or alphabetizing operations.</span></span> <span data-ttu-id="8b8da-949">Er sollte nicht verwendet werden, wenn der primäre Zweck des Methoden Aufrufes ist, zu bestimmen, ob zwei Zeichen folgen äquivalent sind (d. h., wenn der Zweck des Methoden Aufrufes ist, auf einen Rückgabewert von NULL zu testen).</span><span class="sxs-lookup"><span data-stu-id="8b8da-949">It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent (that is, when the purpose of the method call is to test for a return value of zero).</span></span> <span data-ttu-id="8b8da-950">Um zu ermitteln, ob zwei Zeichen folgen äquivalent sind, müssen Sie die <xref:System.String.Equals%2A>-Methode abrufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-950">To determine whether two strings are equivalent, call the <xref:System.String.Equals%2A> method.</span></span>

 <span data-ttu-id="8b8da-951">Der Vergleich kann weiter durch den `options`-Parameter angegeben werden, der aus einem oder mehreren Membern der <xref:System.Globalization.CompareOptions>-Enumeration besteht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-951">The comparison can be further specified by the `options` parameter, which consists of one or more members of the <xref:System.Globalization.CompareOptions> enumeration.</span></span> <span data-ttu-id="8b8da-952">Da der Zweck dieser Methode jedoch darin besteht, einen Kultur abhängigen Zeichen folgen Vergleich durchzuführen, haben die Werte für <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> und <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-952">However, because the purpose of this method is to conduct a culture-sensitive string comparison, the <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> and <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> values have no effect.</span></span>

 <span data-ttu-id="8b8da-953">Entweder oder beide Vergleiche können `null`werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-953">Either or both comparands can be `null`.</span></span> <span data-ttu-id="8b8da-954">Definitionsgemäß vergleichen alle Zeichen folgen, einschließlich <xref:System.String.Empty?displayProperty=nameWithType>, einen höheren Wert als einen NULL-Verweis, und zwei NULL-Verweise vergleichen einander.</span><span class="sxs-lookup"><span data-stu-id="8b8da-954">By definition, any string, including <xref:System.String.Empty?displayProperty=nameWithType>, compares greater than a null reference, and two null references compare equal to each other.</span></span>

 <span data-ttu-id="8b8da-955">Der Vergleich wird beendet, wenn eine Ungleichheit erkannt oder beide Zeichen folgen verglichen wurden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-955">The comparison terminates when an inequality is discovered or both strings have been compared.</span></span> <span data-ttu-id="8b8da-956">Wenn die beiden Zeichen folgen jedoch gleich dem Ende einer Zeichenfolge sind und die andere Zeichenfolge Zeichen enthält, wird die Zeichenfolge mit den verbleibenden Zeichen als größer betrachtet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-956">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with the remaining characters is considered greater.</span></span>



## Examples
 <span data-ttu-id="8b8da-957">Im folgenden Beispiel werden zwei Zeichen folgen auf drei verschiedene Arten verglichen: Verwenden Sie den linguistischen Vergleich für die Kultur "en-US". Verwenden von linguistischer Berücksichtigung der Groß-/Kleinschreibung für die Kultur "en-US" und einen Ordinalvergleich verwenden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-957">The following example compares two strings in three different ways: Use linguistic comparison for the en-US culture; using linguistic case-sensitive comparison for the en-US culture; and using an ordinal comparison.</span></span> <span data-ttu-id="8b8da-958">Es veranschaulicht, wie die drei Vergleichsmethoden drei verschiedene Ergebnisse verursachen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-958">It illustrates how the three methods of comparison produce three different results.</span></span>

 [!code-cpp[System.String.Compare#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/example.cpp#1)]
 [!code-csharp[System.String.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/Example.cs#1)]
 [!code-vb[System.String.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/Example.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8b8da-959"><paramref name="options" /> ist kein <see cref="T:System.Globalization.CompareOptions" />-Wert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-959"><paramref name="options" /> is not a <see cref="T:System.Globalization.CompareOptions" /> value.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-960"><paramref name="culture" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-960"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-961">Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-961">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="8b8da-962">Die <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />-Methode berücksichtigt solche Zeichen nicht, wenn Sie einen Kultur abhängigen Vergleich durchführt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-962">The <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="8b8da-963">Um Ignorable-Zeichen im Vergleich zu erkennen, geben Sie den Wert <see cref="F:System.Globalization.CompareOptions.Ordinal" /> oder <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> für den <paramref name="options" />-Parameter an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-963">To recognize ignorable characters in your comparison, supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="options" /> parameter.</span></span></para></block>
        <altmember cref="Overload:System.String.CompareOrdinal" />
        <altmember cref="Overload:System.String.CompareTo" />
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="8b8da-964">Die erste im Vergleich zu verwendende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-964">The first string to use in the comparison.</span></span></param>
        <param name="indexA"><span data-ttu-id="8b8da-965">Die Position der Teilzeichenfolge innerhalb von <paramref name="strA" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-965">The position of the substring within <paramref name="strA" />.</span></span></param>
        <param name="strB"><span data-ttu-id="8b8da-966">Die zweite im Vergleich zu verwendende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-966">The second string to use in the comparison.</span></span></param>
        <param name="indexB"><span data-ttu-id="8b8da-967">Die Position der Teilzeichenfolge innerhalb von <paramref name="strB" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-967">The position of the substring within <paramref name="strB" />.</span></span></param>
        <param name="length"><span data-ttu-id="8b8da-968">Die maximale Anzahl der zu vergleichenden Zeichen der Teilzeichenfolgen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-968">The maximum number of characters in the substrings to compare.</span></span></param>
        <summary><span data-ttu-id="8b8da-969">Vergleicht zwei angegebene <see cref="T:System.String" />-Objekte und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-969">Compares substrings of two specified <see cref="T:System.String" /> objects and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="8b8da-970">Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-970">A 32-bit signed integer indicating the lexical relationship between the two comparands.</span></span>

 <list type="table"><listheader><term> <span data-ttu-id="8b8da-971">Wert</span><span class="sxs-lookup"><span data-stu-id="8b8da-971">Value</span></span>

 </term><description> <span data-ttu-id="8b8da-972">Bedingung</span><span class="sxs-lookup"><span data-stu-id="8b8da-972">Condition</span></span>

 </description></listheader><item><term> <span data-ttu-id="8b8da-973">Kleiner als 0 (null)</span><span class="sxs-lookup"><span data-stu-id="8b8da-973">Less than zero</span></span>

 </term><description> <span data-ttu-id="8b8da-974">Die Teilzeichenfolge in <paramref name="strA" /> ist der Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge vorangestellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-974">The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.</span></span>

 </description></item><item><term> <span data-ttu-id="8b8da-975">Zero</span><span class="sxs-lookup"><span data-stu-id="8b8da-975">Zero</span></span>

 </term><description> <span data-ttu-id="8b8da-976">Die Teilzeichenfolgen treten in der Sortierreihenfolge an der gleichen Position auf, oder <paramref name="length" /> ist 0 (null).</span><span class="sxs-lookup"><span data-stu-id="8b8da-976">The substrings occur in the same position in the sort order, or <paramref name="length" /> is zero.</span></span>

 </description></item><item><term> <span data-ttu-id="8b8da-977">Größer als 0 (null)</span><span class="sxs-lookup"><span data-stu-id="8b8da-977">Greater than zero</span></span>

 </term><description> <span data-ttu-id="8b8da-978">Die Teilzeichenfolge in <paramref name="strA" /> folgt der Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-978">The substring in <paramref name="strA" /> follows the substring in <paramref name="strB" /> in the sort order.</span></span>

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-979">Die zu vergleichenden Teil Zeichenfolgen beginnen in `strA` `indexA` und in `strB` bei `indexB`.</span><span class="sxs-lookup"><span data-stu-id="8b8da-979">The substrings to compare start in `strA` at `indexA` and in `strB` at `indexB`.</span></span> <span data-ttu-id="8b8da-980">Sowohl `indexA` als auch `indexB` sind NULL basiert. Das heißt, das erste Zeichen in `strA` und `strB` ist an der Position 0 (null).</span><span class="sxs-lookup"><span data-stu-id="8b8da-980">Both `indexA` and `indexB` are zero-based; that is, the first character in `strA` and `strB` is at position zero.</span></span> <span data-ttu-id="8b8da-981">Die Länge der ersten Teil Zeichenfolge entspricht der Länge `strA` minus `indexA` plus eins.</span><span class="sxs-lookup"><span data-stu-id="8b8da-981">The length of the first substring is equal to the length of `strA` minus `indexA` plus one.</span></span> <span data-ttu-id="8b8da-982">Die Länge der zweiten Teil Zeichenfolge entspricht der Länge `strB` minus `indexB` plus eins.</span><span class="sxs-lookup"><span data-stu-id="8b8da-982">The length of the second substring is equal to the length of `strB` minus `indexB` plus one.</span></span>

 <span data-ttu-id="8b8da-983">Die Anzahl der zu vergleichenden Zeichen ist geringer als die Länge der beiden Teil Zeichenfolgen und `length`.</span><span class="sxs-lookup"><span data-stu-id="8b8da-983">The number of characters to compare is the lesser of the lengths of the two substrings, and `length`.</span></span> <span data-ttu-id="8b8da-984">Die Parameter `indexA`, `indexB`und `length` dürfen nicht negativ sein.</span><span class="sxs-lookup"><span data-stu-id="8b8da-984">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>

 <span data-ttu-id="8b8da-985">Der Vergleich verwendet die aktuelle Kultur, um kulturspezifische Informationen wie z. b. Regeln für die Groß-/Kleinschreibung und die alphabetische Reihenfolge einzelner Zeichen abzurufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-985">The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="8b8da-986">Beispielsweise könnte eine Kultur angeben, dass bestimmte Kombinationen von Zeichen als einzelnes Zeichen behandelt werden sollen, dass groß-und Kleinbuchstaben auf eine bestimmte Weise verglichen werden sollen, oder dass die Sortierreihenfolge eines Zeichens von den Zeichen abhängig ist, die vorangestellt oder befolgt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-986">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>

 <span data-ttu-id="8b8da-987">Der Vergleich erfolgt mithilfe von Wort Sortierregeln.</span><span class="sxs-lookup"><span data-stu-id="8b8da-987">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="8b8da-988">Weitere Informationen zu Wort-, Zeichen folgen-und ordinalsortierungen finden Sie unter <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-988">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>

> [!WARNING]
>  <span data-ttu-id="8b8da-989">Beim Vergleichen von Zeichen folgen sollten Sie die <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29>-Methode verwenden, die erfordert, dass Sie den Typ des Zeichen folgen Vergleichs, der von der Methode verwendet wird, explizit angeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-989">When comparing strings, you should call the <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> method, which requires that you explicitly specify the type of string comparison that the method uses.</span></span> <span data-ttu-id="8b8da-990">Weitere Informationen finden Sie unter [Empfohlene Vorgehensweisen für die Verwendung von Zeichenfolgen in .NET Framework](~/docs/standard/base-types/best-practices-strings.md).</span><span class="sxs-lookup"><span data-stu-id="8b8da-990">For more information, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>

 <span data-ttu-id="8b8da-991">Ein oder beide Vergleiche können `null`werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-991">One or both comparands can be `null`.</span></span> <span data-ttu-id="8b8da-992">Definitionsgemäß vergleicht jede Zeichenfolge, einschließlich der leeren Zeichenfolge (""), größer als ein NULL-Verweis. und zwei NULL-Verweise vergleichen einander.</span><span class="sxs-lookup"><span data-stu-id="8b8da-992">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>

 <span data-ttu-id="8b8da-993">Der Vergleich wird beendet, wenn eine Ungleichheit erkannt oder beide Teil Zeichenfolgen verglichen wurden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-993">The comparison terminates when an inequality is discovered or both substrings have been compared.</span></span> <span data-ttu-id="8b8da-994">Wenn die beiden Zeichen folgen jedoch gleich dem Ende einer Zeichenfolge sind und die andere Zeichenfolge Zeichen enthält, wird die Zeichenfolge mit den verbleibenden Zeichen als größer betrachtet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-994">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="8b8da-995">Der Rückgabewert ist das Ergebnis des letzten auszuführenden Vergleichs.</span><span class="sxs-lookup"><span data-stu-id="8b8da-995">The return value is the result of the last comparison performed.</span></span>

 <span data-ttu-id="8b8da-996">Unerwartete Ergebnisse können auftreten, wenn Vergleiche von kulturspezifischen Regeln für Groß-und Kleinschreibung betroffen sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-996">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="8b8da-997">In der türkischen Sprache führt das folgende Beispiel z. b. zu den falschen Ergebnissen, da das Dateisystem in der türkischen Sprache keine Regeln für die linguistische Schreibweise für den Buchstaben "i" in "file" verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-997">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>

 [!code-cpp[System.String.Compare#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#2)]
 [!code-csharp[System.String.Compare#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#2)]
 [!code-vb[System.String.Compare#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#2)]

 <span data-ttu-id="8b8da-998">Vergleichen Sie den Pfadnamen mit "file", indem Sie einen Ordinalvergleich verwenden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-998">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="8b8da-999">Der richtige Code hierfür lautet wie folgt:</span><span class="sxs-lookup"><span data-stu-id="8b8da-999">The correct code to do this is as follows:</span></span>

 [!code-cpp[System.String.Compare#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#3)]
 [!code-csharp[System.String.Compare#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#3)]
 [!code-vb[System.String.Compare#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#3)]



## Examples
 <span data-ttu-id="8b8da-1000">Im folgenden Beispiel werden zwei Teil Zeichenfolgen verglichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1000">The following example compares two substrings.</span></span>

 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp-interactive[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-1001"><paramref name="indexA" /> ist größer als <paramref name="strA" /><see cref="P:System.String.Length" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1001"><paramref name="indexA" /> is greater than <paramref name="strA" />.<see cref="P:System.String.Length" />.</span></span>

<span data-ttu-id="8b8da-1002">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-1002">-or-</span></span>

 <span data-ttu-id="8b8da-1003"><paramref name="indexB" /> ist größer als <paramref name="strB" /><see cref="P:System.String.Length" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1003"><paramref name="indexB" /> is greater than <paramref name="strB" />.<see cref="P:System.String.Length" />.</span></span>

<span data-ttu-id="8b8da-1004">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-1004">-or-</span></span>

 <span data-ttu-id="8b8da-1005"><paramref name="indexA" />, <paramref name="indexB" /> oder <paramref name="length" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1005"><paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span></span>

<span data-ttu-id="8b8da-1006">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-1006">-or-</span></span>

<span data-ttu-id="8b8da-1007">Entweder <paramref name="indexA" /> oder <paramref name="indexB" /> ist <see langword="null" />, und <paramref name="length" /> ist größer als 0 (null).</span><span class="sxs-lookup"><span data-stu-id="8b8da-1007">Either <paramref name="indexA" /> or <paramref name="indexB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-1008">Zeichensätze enthalten ignorierbare Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1008">Character sets include ignorable characters.</span></span> <span data-ttu-id="8b8da-1009">Die <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" />-Methode berücksichtigt diese Zeichen nicht, wenn Sie einen linguistischen oder Kultur abhängigen Vergleich durchführt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1009">The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="8b8da-1010">Um Ignorable-Zeichen im Vergleich zu erkennen, müssen Sie die <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />-Methode aufrufen und für den <paramref name="comparisonType" />-Parameter den Wert <see cref="F:System.Globalization.CompareOptions.Ordinal" /> oder <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> angeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1010">To recognize ignorable characters in your comparison, call the <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> method and supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="8b8da-1011">Die erste im Vergleich zu verwendende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1011">The first string to use in the comparison.</span></span></param>
        <param name="indexA"><span data-ttu-id="8b8da-1012">Die Position der Teilzeichenfolge innerhalb von <paramref name="strA" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1012">The position of the substring within <paramref name="strA" />.</span></span></param>
        <param name="strB"><span data-ttu-id="8b8da-1013">Die zweite im Vergleich zu verwendende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1013">The second string to use in the comparison.</span></span></param>
        <param name="indexB"><span data-ttu-id="8b8da-1014">Die Position der Teilzeichenfolge innerhalb von <paramref name="strB" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1014">The position of the substring within <paramref name="strB" />.</span></span></param>
        <param name="length"><span data-ttu-id="8b8da-1015">Die maximale Anzahl der zu vergleichenden Zeichen der Teilzeichenfolgen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1015">The maximum number of characters in the substrings to compare.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="8b8da-1016"><see langword="true" />, wenn die Groß-/Kleinschreibung beim Vergleich ignoriert werden soll, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1016"><see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="8b8da-1017">Vergleicht Teilzeichenfolgen von zwei angegebenen <see cref="T:System.String" />-Objekten, wobei ihre Groß- und Kleinschreibung entweder ignoriert oder berücksichtigt wird, und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1017">Compares substrings of two specified <see cref="T:System.String" /> objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1018">Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1018">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>

 <list type="table"><listheader><term> <span data-ttu-id="8b8da-1019">Wert</span><span class="sxs-lookup"><span data-stu-id="8b8da-1019">Value</span></span>

 </term><description> <span data-ttu-id="8b8da-1020">Bedingung</span><span class="sxs-lookup"><span data-stu-id="8b8da-1020">Condition</span></span>

 </description></listheader><item><term> <span data-ttu-id="8b8da-1021">Kleiner als 0 (null)</span><span class="sxs-lookup"><span data-stu-id="8b8da-1021">Less than zero</span></span>

 </term><description> <span data-ttu-id="8b8da-1022">Die Teilzeichenfolge in <paramref name="strA" /> ist der Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge vorangestellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1022">The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.</span></span>

 </description></item><item><term> <span data-ttu-id="8b8da-1023">Zero</span><span class="sxs-lookup"><span data-stu-id="8b8da-1023">Zero</span></span>

 </term><description> <span data-ttu-id="8b8da-1024">Die Teilzeichenfolgen treten in der Sortierreihenfolge an der gleichen Position auf, oder <paramref name="length" /> ist 0 (null).</span><span class="sxs-lookup"><span data-stu-id="8b8da-1024">The substrings occur in the same position in the sort order, or <paramref name="length" /> is zero.</span></span>

 </description></item><item><term> <span data-ttu-id="8b8da-1025">Größer als 0 (null)</span><span class="sxs-lookup"><span data-stu-id="8b8da-1025">Greater than zero</span></span>

 </term><description> <span data-ttu-id="8b8da-1026">Die Teilzeichenfolge in <paramref name="strA" /> folgt der Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1026">The substring in <paramref name="strA" /> follows the substring in <paramref name="strB" /> in the sort order.</span></span>

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-1027">Die zu vergleichenden Teil Zeichenfolgen beginnen in `strA` `indexA`und in `strB` bei `indexB`.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1027">The substrings to compare start in `strA` at `indexA`, and in `strB` at `indexB`.</span></span> <span data-ttu-id="8b8da-1028">Sowohl `indexA` als auch `indexB` sind NULL basiert. Das heißt, das erste Zeichen in `strA` und `strB` ist an der Position 0 (null).</span><span class="sxs-lookup"><span data-stu-id="8b8da-1028">Both `indexA` and `indexB` are zero-based; that is, the first character in `strA` and `strB` is at position zero.</span></span> <span data-ttu-id="8b8da-1029">Die Länge der ersten Teil Zeichenfolge entspricht der Länge `strA` minus `indexA` plus eins.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1029">The length of the first substring is equal to the length of `strA` minus `indexA` plus one.</span></span> <span data-ttu-id="8b8da-1030">Die Länge der zweiten Teil Zeichenfolge entspricht der Länge `strB` minus `indexB` plus eins.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1030">The length of the second substring is equal to the length of `strB` minus `indexB` plus one.</span></span>

 <span data-ttu-id="8b8da-1031">Die Anzahl der zu vergleichenden Zeichen ist geringer als die Länge der beiden Teil Zeichenfolgen und `length`.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1031">The number of characters to compare is the lesser of the lengths of the two substrings, and `length`.</span></span> <span data-ttu-id="8b8da-1032">Die Parameter `indexA`, `indexB`und `length` dürfen nicht negativ sein.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1032">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>

 <span data-ttu-id="8b8da-1033">Der Vergleich verwendet die aktuelle Kultur, um kulturspezifische Informationen wie z. b. Regeln für die Groß-/Kleinschreibung und die alphabetische Reihenfolge einzelner Zeichen abzurufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1033">The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="8b8da-1034">Beispielsweise könnte eine Kultur angeben, dass bestimmte Kombinationen von Zeichen als einzelnes Zeichen behandelt werden sollen, dass groß-und Kleinbuchstaben auf eine bestimmte Weise verglichen werden sollen, oder dass die Sortierreihenfolge eines Zeichens von den Zeichen abhängig ist, die vorangestellt oder befolgt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1034">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>

 <span data-ttu-id="8b8da-1035">Der Vergleich erfolgt mithilfe von Wort Sortierregeln.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1035">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="8b8da-1036">Weitere Informationen zu Wort-, Zeichen folgen-und ordinalsortierungen finden Sie unter <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1036">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>

> [!WARNING]
>  <span data-ttu-id="8b8da-1037">Beim Vergleichen von Zeichen folgen sollten Sie die <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29>-Methode verwenden, die erfordert, dass Sie den Typ des Zeichen folgen Vergleichs, der von der Methode verwendet wird, explizit angeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1037">When comparing strings, you should call the <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> method, which requires that you explicitly specify the type of string comparison that the method uses.</span></span> <span data-ttu-id="8b8da-1038">Weitere Informationen finden Sie unter [Empfohlene Vorgehensweisen für die Verwendung von Zeichenfolgen in .NET Framework](~/docs/standard/base-types/best-practices-strings.md).</span><span class="sxs-lookup"><span data-stu-id="8b8da-1038">For more information, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>

 <span data-ttu-id="8b8da-1039">Ein oder beide Vergleiche können `null`werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1039">One or both comparands can be `null`.</span></span> <span data-ttu-id="8b8da-1040">Definitionsgemäß vergleicht jede Zeichenfolge, einschließlich der leeren Zeichenfolge (""), größer als ein NULL-Verweis. und zwei NULL-Verweise vergleichen einander.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1040">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>

 <span data-ttu-id="8b8da-1041">Der Vergleich wird beendet, wenn eine Ungleichheit erkannt oder beide Teil Zeichenfolgen verglichen wurden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1041">The comparison terminates when an inequality is discovered or both substrings have been compared.</span></span> <span data-ttu-id="8b8da-1042">Wenn die beiden Zeichen folgen jedoch gleich dem Ende einer Zeichenfolge sind und die andere Zeichenfolge Zeichen enthält, wird die Zeichenfolge mit den verbleibenden Zeichen als größer betrachtet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1042">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="8b8da-1043">Der Rückgabewert ist das Ergebnis des letzten auszuführenden Vergleichs.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1043">The return value is the result of the last comparison performed.</span></span>

 <span data-ttu-id="8b8da-1044">Unerwartete Ergebnisse können auftreten, wenn Vergleiche von kulturspezifischen Regeln für Groß-und Kleinschreibung betroffen sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1044">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="8b8da-1045">In der türkischen Sprache führt das folgende Beispiel z. b. zu den falschen Ergebnissen, da das Dateisystem in der türkischen Sprache keine Regeln für die linguistische Schreibweise für den Buchstaben "i" in "file" verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1045">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>

 [!code-cpp[System.String.Compare#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#4)]
 [!code-csharp[System.String.Compare#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#4)]
 [!code-vb[System.String.Compare#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#4)]

 <span data-ttu-id="8b8da-1046">Der Pfadname muss invarianten Weise verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1046">The path name needs to be compared in an invariant manner.</span></span> <span data-ttu-id="8b8da-1047">Der richtige Code hierfür ist wie folgt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1047">The correct code to do this is as follows.</span></span>

 [!code-cpp[System.String.Compare#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#5)]
 [!code-csharp[System.String.Compare#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#5)]
 [!code-vb[System.String.Compare#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#5)]



## Examples
 <span data-ttu-id="8b8da-1048">Im folgenden Beispiel werden zwei Vergleiche zweier Teil Zeichenfolgen durchführt, die sich nur in Groß-und Kleinschreibung</span><span class="sxs-lookup"><span data-stu-id="8b8da-1048">The following example performs two comparisons of two substrings that only differ in case.</span></span> <span data-ttu-id="8b8da-1049">Der erste Vergleich ignoriert die Groß-und Kleinschreibung.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1049">The first comparison ignores case and the second comparison considers case.</span></span>

 [!code-cpp[string.compare4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare4/CPP/comp4.cpp#1)]
 [!code-csharp-interactive[string.compare4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare4/CS/comp4.cs#1)]
 [!code-vb[string.compare4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare4/VB/comp4.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-1050"><paramref name="indexA" /> ist größer als <paramref name="strA" /><see cref="P:System.String.Length" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1050"><paramref name="indexA" /> is greater than <paramref name="strA" />.<see cref="P:System.String.Length" />.</span></span>

<span data-ttu-id="8b8da-1051">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-1051">-or-</span></span>

 <span data-ttu-id="8b8da-1052"><paramref name="indexB" /> ist größer als <paramref name="strB" /><see cref="P:System.String.Length" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1052"><paramref name="indexB" /> is greater than <paramref name="strB" />.<see cref="P:System.String.Length" />.</span></span>

<span data-ttu-id="8b8da-1053">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-1053">-or-</span></span>

 <span data-ttu-id="8b8da-1054"><paramref name="indexA" />, <paramref name="indexB" /> oder <paramref name="length" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1054"><paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span></span>

<span data-ttu-id="8b8da-1055">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-1055">-or-</span></span>

<span data-ttu-id="8b8da-1056">Entweder <paramref name="indexA" /> oder <paramref name="indexB" /> ist <see langword="null" />, und <paramref name="length" /> ist größer als 0 (null).</span><span class="sxs-lookup"><span data-stu-id="8b8da-1056">Either <paramref name="indexA" /> or <paramref name="indexB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-1057">Zeichensätze enthalten ignorierbare Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1057">Character sets include ignorable characters.</span></span> <span data-ttu-id="8b8da-1058">Die <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" />-Methode berücksichtigt diese Zeichen nicht, wenn Sie einen linguistischen oder Kultur abhängigen Vergleich durchführt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1058">The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="8b8da-1059">Um Ignorable-Zeichen im Vergleich zu erkennen, müssen Sie die <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />-Methode aufrufen und für den <paramref name="comparisonType" />-Parameter den Wert <see cref="F:System.Globalization.CompareOptions.Ordinal" /> oder <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> angeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1059">To recognize ignorable characters in your comparison, call the <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> method and supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * StringComparison -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="5" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="8b8da-1060">Die erste im Vergleich zu verwendende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1060">The first string to use in the comparison.</span></span></param>
        <param name="indexA"><span data-ttu-id="8b8da-1061">Die Position der Teilzeichenfolge innerhalb von <paramref name="strA" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1061">The position of the substring within <paramref name="strA" />.</span></span></param>
        <param name="strB"><span data-ttu-id="8b8da-1062">Die zweite im Vergleich zu verwendende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1062">The second string to use in the comparison.</span></span></param>
        <param name="indexB"><span data-ttu-id="8b8da-1063">Die Position der Teilzeichenfolge innerhalb von <paramref name="strB" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1063">The position of the substring within <paramref name="strB" />.</span></span></param>
        <param name="length"><span data-ttu-id="8b8da-1064">Die maximale Anzahl der zu vergleichenden Zeichen der Teilzeichenfolgen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1064">The maximum number of characters in the substrings to compare.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="8b8da-1065">Einer der Enumerationswerte, der die für den Vergleich zu verwendenden Regeln angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1065">One of the enumeration values that specifies the rules to use in the comparison.</span></span></param>
        <summary><span data-ttu-id="8b8da-1066">Vergleicht Teilzeichenfolgen von zwei angegebenen <see cref="T:System.String" />-Objekten gemäß den angegebenen Vergleichsregeln und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1066">Compares substrings of two specified <see cref="T:System.String" /> objects using the specified rules, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1067">Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1067">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>

 <list type="table"><listheader><term> <span data-ttu-id="8b8da-1068">Wert</span><span class="sxs-lookup"><span data-stu-id="8b8da-1068">Value</span></span>

 </term><description> <span data-ttu-id="8b8da-1069">Bedingung</span><span class="sxs-lookup"><span data-stu-id="8b8da-1069">Condition</span></span>

 </description></listheader><item><term> <span data-ttu-id="8b8da-1070">Kleiner als 0 (null)</span><span class="sxs-lookup"><span data-stu-id="8b8da-1070">Less than zero</span></span>

 </term><description> <span data-ttu-id="8b8da-1071">Die Teilzeichenfolge in <paramref name="strA" /> ist der Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge vorangestellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1071">The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.</span></span>

 </description></item><item><term> <span data-ttu-id="8b8da-1072">Zero</span><span class="sxs-lookup"><span data-stu-id="8b8da-1072">Zero</span></span>

 </term><description> <span data-ttu-id="8b8da-1073">Die Teilzeichenfolgen treten in der Sortierreihenfolge an der gleichen Position auf, oder der <paramref name="length" />-Parameter ist 0 (null).</span><span class="sxs-lookup"><span data-stu-id="8b8da-1073">The substrings occur in the same position in the sort order, or the <paramref name="length" /> parameter is zero.</span></span>

 </description></item><item><term> <span data-ttu-id="8b8da-1074">Größer als 0 (null)</span><span class="sxs-lookup"><span data-stu-id="8b8da-1074">Greater than zero</span></span>

 </term><description> <span data-ttu-id="8b8da-1075">Die Teilzeichenfolge in <paramref name="strA" /> folgt der Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1075">The substring in <paramref name="strA" /> follows the substring in <paramref name="strB" /> in the sort order.</span></span>

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-1076">Die zu vergleichenden Teil Zeichenfolgen beginnen in `strA` `indexA` und in `strB` bei `indexB`.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1076">The substrings to compare start in `strA` at `indexA` and in `strB` at `indexB`.</span></span> <span data-ttu-id="8b8da-1077">Sowohl `indexA` als auch `indexB` sind NULL basiert. Das heißt, das erste Zeichen in `strA` und `strB` befindet sich an Position 0 (null) und nicht an Position 1.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1077">Both `indexA` and `indexB` are zero-based; that is, the first character in `strA` and `strB` is at position zero, not position one.</span></span> <span data-ttu-id="8b8da-1078">Die Länge der ersten Teil Zeichenfolge entspricht der Länge `strA` minus `indexA` plus eins.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1078">The length of the first substring is equal to the length of `strA` minus `indexA` plus one.</span></span> <span data-ttu-id="8b8da-1079">Die Länge der zweiten Teil Zeichenfolge entspricht der Länge `strB` minus `indexB` plus eins.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1079">The length of the second substring is equal to the length of `strB` minus `indexB` plus one.</span></span>

 <span data-ttu-id="8b8da-1080">Die Anzahl der zu vergleichenden Zeichen ist geringer als die Länge der beiden Teil Zeichenfolgen und `length`.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1080">The number of characters to compare is the lesser of the lengths of the two substrings, and `length`.</span></span> <span data-ttu-id="8b8da-1081">Die Parameter `indexA`, `indexB`und `length` dürfen nicht negativ sein.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1081">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>

 <span data-ttu-id="8b8da-1082">Der `comparisonType`-Parameter gibt an, ob beim Vergleich die aktuelle oder invariante Kultur verwendet werden soll, ob die Groß-/Kleinschreibung der Vergleichs Elemente berücksichtigt oder ignoriert werden soll, oder ob Wort-Sortierregeln (Kultur abhängig) oder Ordinalzahl (Kultur abhängig) verwendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1082">The `comparisonType` parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the comparands, or use word (culture-sensitive) or ordinal (culture-insensitive) sort rules.</span></span>

 <span data-ttu-id="8b8da-1083">Ein oder beide Vergleiche können `null`werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1083">One or both comparands can be `null`.</span></span> <span data-ttu-id="8b8da-1084">Definitionsgemäß vergleicht jede Zeichenfolge, einschließlich der leeren Zeichenfolge (""), größer als ein NULL-Verweis. und zwei NULL-Verweise vergleichen einander.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1084">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>

 <span data-ttu-id="8b8da-1085">Der Vergleich wird beendet, wenn eine Ungleichheit erkannt oder beide Teil Zeichenfolgen verglichen wurden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1085">The comparison terminates when an inequality is discovered or both substrings have been compared.</span></span> <span data-ttu-id="8b8da-1086">Wenn die beiden Zeichen folgen jedoch gleich dem Ende einer Zeichenfolge sind und die andere Zeichenfolge Zeichen enthält, wird die Zeichenfolge mit den verbleibenden Zeichen als größer betrachtet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1086">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with remaining characters is considered greater.</span></span> <span data-ttu-id="8b8da-1087">Der Rückgabewert ist das Ergebnis des letzten auszuführenden Vergleichs.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1087">The return value is the result of the last comparison performed.</span></span>

 <span data-ttu-id="8b8da-1088">Unerwartete Ergebnisse können auftreten, wenn Vergleiche von kulturspezifischen Regeln für Groß-und Kleinschreibung betroffen sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1088">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="8b8da-1089">In der türkischen Sprache führt das folgende Beispiel z. b. zu den falschen Ergebnissen, da das Dateisystem in der türkischen Sprache keine Regeln für die linguistische Schreibweise für den Buchstaben "i" in "file" verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1089">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>

 [!code-cpp[System.String.Compare#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#8)]
 [!code-csharp[System.String.Compare#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#8)]
 [!code-vb[System.String.Compare#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#8)]

 <span data-ttu-id="8b8da-1090">Vergleichen Sie den Pfadnamen mit "file", indem Sie einen Ordinalvergleich verwenden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1090">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="8b8da-1091">Der richtige Code hierfür lautet wie folgt:</span><span class="sxs-lookup"><span data-stu-id="8b8da-1091">The correct code to do this is as follows:</span></span>

 [!code-cpp[System.String.Compare#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#9)]
 [!code-csharp[System.String.Compare#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#9)]
 [!code-vb[System.String.Compare#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#9)]



## Examples
 <span data-ttu-id="8b8da-1092">Im folgenden Beispiel werden zwei Teil Zeichenfolgen verglichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1092">The following example compares two substrings.</span></span>

 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp-interactive[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-1093"><paramref name="indexA" /> ist größer als <paramref name="strA" /><see cref="P:System.String.Length" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1093"><paramref name="indexA" /> is greater than <paramref name="strA" />.<see cref="P:System.String.Length" />.</span></span>

<span data-ttu-id="8b8da-1094">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-1094">-or-</span></span>

 <span data-ttu-id="8b8da-1095"><paramref name="indexB" /> ist größer als <paramref name="strB" /><see cref="P:System.String.Length" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1095"><paramref name="indexB" /> is greater than <paramref name="strB" />.<see cref="P:System.String.Length" />.</span></span>

<span data-ttu-id="8b8da-1096">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-1096">-or-</span></span>

 <span data-ttu-id="8b8da-1097"><paramref name="indexA" />, <paramref name="indexB" /> oder <paramref name="length" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1097"><paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span></span>

<span data-ttu-id="8b8da-1098">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-1098">-or-</span></span>

<span data-ttu-id="8b8da-1099">Entweder <paramref name="indexA" /> oder <paramref name="indexB" /> ist <see langword="null" />, und <paramref name="length" /> ist größer als 0 (null).</span><span class="sxs-lookup"><span data-stu-id="8b8da-1099">Either <paramref name="indexA" /> or <paramref name="indexB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8b8da-1100"><paramref name="comparisonType" /> ist kein <see cref="T:System.StringComparison" />-Wert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1100"><paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-1101">Zeichensätze enthalten ignorierbare Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1101">Character sets include ignorable characters.</span></span> <span data-ttu-id="8b8da-1102">Die <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />-Methode berücksichtigt diese Zeichen nicht, wenn Sie einen linguistischen oder Kultur abhängigen Vergleich durchführt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1102">The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="8b8da-1103">Um Ignorable-Zeichen im Vergleich zu erkennen, geben Sie den Wert <see cref="F:System.StringComparison.Ordinal" /> oder <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> für den <paramref name="comparisonType" />-Parameter an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1103">To recognize ignorable characters in your comparison, supply a value of <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="8b8da-1104">Die erste im Vergleich zu verwendende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1104">The first string to use in the comparison.</span></span></param>
        <param name="indexA"><span data-ttu-id="8b8da-1105">Die Position der Teilzeichenfolge innerhalb von <paramref name="strA" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1105">The position of the substring within <paramref name="strA" />.</span></span></param>
        <param name="strB"><span data-ttu-id="8b8da-1106">Die zweite im Vergleich zu verwendende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1106">The second string to use in the comparison.</span></span></param>
        <param name="indexB"><span data-ttu-id="8b8da-1107">Die Position der Teilzeichenfolge innerhalb von <paramref name="strB" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1107">The position of the substring within <paramref name="strB" />.</span></span></param>
        <param name="length"><span data-ttu-id="8b8da-1108">Die maximale Anzahl der zu vergleichenden Zeichen der Teilzeichenfolgen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1108">The maximum number of characters in the substrings to compare.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="8b8da-1109"><see langword="true" />, wenn die Groß-/Kleinschreibung beim Vergleich ignoriert werden soll, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1109"><see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span></span></param>
        <param name="culture"><span data-ttu-id="8b8da-1110">Ein Objekt, das kulturspezifische Vergleichsinformationen angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1110">An object that supplies culture-specific comparison information.</span></span></param>
        <summary><span data-ttu-id="8b8da-1111">Vergleicht Teilzeichenfolgen von zwei angegebenen <see cref="T:System.String" />-Objekten, wobei ihre Groß- und Kleinschreibung entweder ignoriert oder berücksichtigt und der Vergleich durch kulturspezifische Informationen beeinflusst wird, und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1111">Compares substrings of two specified <see cref="T:System.String" /> objects, ignoring or honoring their case and using culture-specific information to influence the comparison, and returns an integer that indicates their relative position in the sort order.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1112">Eine ganze Zahl, die die lexikalische Beziehung zwischen den beiden Vergleichswerten angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1112">An integer that indicates the lexical relationship between the two comparands.</span></span>

 <list type="table"><listheader><term> <span data-ttu-id="8b8da-1113">Wert</span><span class="sxs-lookup"><span data-stu-id="8b8da-1113">Value</span></span>

 </term><description> <span data-ttu-id="8b8da-1114">Bedingung</span><span class="sxs-lookup"><span data-stu-id="8b8da-1114">Condition</span></span>

 </description></listheader><item><term> <span data-ttu-id="8b8da-1115">Kleiner als 0 (null)</span><span class="sxs-lookup"><span data-stu-id="8b8da-1115">Less than zero</span></span>

 </term><description> <span data-ttu-id="8b8da-1116">Die Teilzeichenfolge in <paramref name="strA" /> ist der Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge vorangestellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1116">The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.</span></span>

 </description></item><item><term> <span data-ttu-id="8b8da-1117">Zero</span><span class="sxs-lookup"><span data-stu-id="8b8da-1117">Zero</span></span>

 </term><description> <span data-ttu-id="8b8da-1118">Die Teilzeichenfolgen treten in der Sortierreihenfolge an der gleichen Position auf, oder <paramref name="length" /> ist 0 (null).</span><span class="sxs-lookup"><span data-stu-id="8b8da-1118">The substrings occur in the same position in the sort order, or <paramref name="length" /> is zero.</span></span>

 </description></item><item><term> <span data-ttu-id="8b8da-1119">Größer als 0 (null)</span><span class="sxs-lookup"><span data-stu-id="8b8da-1119">Greater than zero</span></span>

 </term><description> <span data-ttu-id="8b8da-1120">Die Teilzeichenfolge in <paramref name="strA" /> folgt der Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1120">The substring in <paramref name="strA" /> follows the substring in <paramref name="strB" /> in the sort order.</span></span>

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-1121">Die zu vergleichenden Teil Zeichenfolgen beginnen in `strA` `indexA`und in `strB` bei `indexB`.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1121">The substrings to compare start in `strA` at `indexA`, and in `strB` at `indexB`.</span></span> <span data-ttu-id="8b8da-1122">Sowohl `indexA` als auch `indexB` sind NULL basiert. Das heißt, das erste Zeichen in `strA` und `strB` befindet sich an Position 0 (null) und nicht an Position 1.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1122">Both `indexA` and `indexB` are zero-based; that is, the first character in `strA` and `strB` is at position zero, not position one.</span></span> <span data-ttu-id="8b8da-1123">Die Länge der ersten Teil Zeichenfolge entspricht der Länge `strA` minus `indexA` plus eins.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1123">The length of the first substring is equal to the length of `strA` minus `indexA` plus one.</span></span> <span data-ttu-id="8b8da-1124">Die Länge der zweiten Teil Zeichenfolge entspricht der Länge `strB` minus `indexB` plus eins.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1124">The length of the second substring is equal to the length of `strB` minus `indexB` plus one.</span></span>

 <span data-ttu-id="8b8da-1125">Die Anzahl der zu vergleichenden Zeichen ist geringer als die Länge der beiden Teil Zeichenfolgen und `length`.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1125">The number of characters to compare is the lesser of the lengths of the two substrings, and `length`.</span></span> <span data-ttu-id="8b8da-1126">Die Parameter `indexA`, `indexB`und `length` dürfen nicht negativ sein.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1126">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>

 <span data-ttu-id="8b8da-1127">Beim Vergleich wird der `culture`-Parameter verwendet, um kulturspezifische Informationen wie z. b. Regeln für die Groß-und Kleinschreibung von einzelnen Zeichen abzurufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1127">The comparison uses the `culture` parameter to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="8b8da-1128">Beispielsweise könnte eine Kultur angeben, dass bestimmte Kombinationen von Zeichen als einzelnes Zeichen behandelt werden sollen, dass groß-und Kleinbuchstaben auf eine bestimmte Weise verglichen werden sollen, oder dass die Sortierreihenfolge eines Zeichens von den Zeichen abhängig ist, die vorangestellt oder befolgt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1128">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>

 <span data-ttu-id="8b8da-1129">Der Vergleich erfolgt mithilfe von Wort Sortierregeln.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1129">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="8b8da-1130">Weitere Informationen zu Wort-, Zeichen folgen-und ordinalsortierungen finden Sie unter <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1130">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>

 <span data-ttu-id="8b8da-1131">Ein oder beide Vergleiche können `null`werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1131">One or both comparands can be `null`.</span></span> <span data-ttu-id="8b8da-1132">Definitionsgemäß vergleicht jede Zeichenfolge, einschließlich der leeren Zeichenfolge (""), größer als ein NULL-Verweis. und zwei NULL-Verweise vergleichen einander.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1132">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>

 <span data-ttu-id="8b8da-1133">Der Vergleich wird beendet, wenn eine Ungleichheit erkannt oder beide Teil Zeichenfolgen verglichen wurden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1133">The comparison terminates when an inequality is discovered or both substrings have been compared.</span></span> <span data-ttu-id="8b8da-1134">Wenn die beiden Zeichen folgen jedoch gleich dem Ende einer Zeichenfolge sind und die andere Zeichenfolge Zeichen enthält, wird die Zeichenfolge mit den verbleibenden Zeichen als größer betrachtet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1134">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="8b8da-1135">Der Rückgabewert ist das Ergebnis des letzten auszuführenden Vergleichs.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1135">The return value is the result of the last comparison performed.</span></span>

 <span data-ttu-id="8b8da-1136">Unerwartete Ergebnisse können auftreten, wenn Vergleiche von kulturspezifischen Regeln für Groß-und Kleinschreibung betroffen sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1136">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="8b8da-1137">In der türkischen Sprache führt das folgende Beispiel z. b. zu den falschen Ergebnissen, da das Dateisystem in der türkischen Sprache keine Regeln für die linguistische Schreibweise für den Buchstaben "i" in "file" verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1137">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>

 [!code-cpp[System.String.Compare#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#6)]
 [!code-csharp[System.String.Compare#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#6)]
 [!code-vb[System.String.Compare#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#6)]

 <span data-ttu-id="8b8da-1138">Vergleichen Sie den Pfadnamen mit "file", indem Sie einen Ordinalvergleich verwenden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1138">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="8b8da-1139">Der richtige Code hierfür lautet wie folgt:</span><span class="sxs-lookup"><span data-stu-id="8b8da-1139">The correct code to do this is as follows:</span></span>

 [!code-cpp[System.String.Compare#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#7)]
 [!code-csharp[System.String.Compare#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#7)]
 [!code-vb[System.String.Compare#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#7)]



## Examples
 <span data-ttu-id="8b8da-1140">Im folgenden Beispiel werden zwei Teil Zeichenfolgen mit verschiedenen Kulturen verglichen und die Groß-/Kleinschreibung der Teil Zeichenfolgen ignoriert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1140">The following example compares two substrings using different cultures and ignoring the case of the substrings.</span></span> <span data-ttu-id="8b8da-1141">Die Auswahl der Kultur wirkt sich darauf aus, wie der Buchstabe "I" verglichen wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1141">The choice of culture affects how the letter "I" is compared.</span></span>

 [!code-cpp[string.compare5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare5/CPP/comp5.cpp#1)]
 [!code-csharp[string.compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare5/CS/comp5.cs#1)]
 [!code-vb[string.compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare5/VB/comp5.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-1142"><paramref name="indexA" /> ist größer als <paramref name="strA" /><see cref="P:System.String.Length" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1142"><paramref name="indexA" /> is greater than <paramref name="strA" />.<see cref="P:System.String.Length" />.</span></span>

<span data-ttu-id="8b8da-1143">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-1143">-or-</span></span>

 <span data-ttu-id="8b8da-1144"><paramref name="indexB" /> ist größer als <paramref name="strB" /><see cref="P:System.String.Length" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1144"><paramref name="indexB" /> is greater than <paramref name="strB" />.<see cref="P:System.String.Length" />.</span></span>

<span data-ttu-id="8b8da-1145">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-1145">-or-</span></span>

 <span data-ttu-id="8b8da-1146"><paramref name="indexA" />, <paramref name="indexB" /> oder <paramref name="length" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1146"><paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span></span>

<span data-ttu-id="8b8da-1147">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-1147">-or-</span></span>

<span data-ttu-id="8b8da-1148">Entweder <paramref name="strA" /> oder <paramref name="strB" /> ist <see langword="null" />, und <paramref name="length" /> ist größer als 0 (null).</span><span class="sxs-lookup"><span data-stu-id="8b8da-1148">Either <paramref name="strA" /> or <paramref name="strB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-1149"><paramref name="culture" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1149"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-1150">Zeichensätze enthalten ignorierbare Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1150">Character sets include ignorable characters.</span></span> <span data-ttu-id="8b8da-1151">Die <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" />-Methode berücksichtigt diese Zeichen nicht, wenn Sie einen linguistischen oder Kultur abhängigen Vergleich durchführt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1151">The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="8b8da-1152">Um Ignorable-Zeichen im Vergleich zu erkennen, müssen Sie die <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />-Methode aufrufen und für den <paramref name="options" />-Parameter den Wert <see cref="F:System.Globalization.CompareOptions.Ordinal" /> oder <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> angeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1152">To recognize ignorable characters in your comparison, call the <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> method and supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="options" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="8b8da-1153">Die erste im Vergleich zu verwendende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1153">The first string to use in the comparison.</span></span></param>
        <param name="indexA"><span data-ttu-id="8b8da-1154">Die Anfangsposition der Teilzeichenfolge innerhalb des <paramref name="strA" />-Parameters.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1154">The starting position of the substring within <paramref name="strA" />.</span></span></param>
        <param name="strB"><span data-ttu-id="8b8da-1155">Die zweite im Vergleich zu verwendende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1155">The second string to use in the comparison.</span></span></param>
        <param name="indexB"><span data-ttu-id="8b8da-1156">Die Anfangsposition der Teilzeichenfolge innerhalb des <paramref name="strB" />-Parameters.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1156">The starting position of the substring within <paramref name="strB" />.</span></span></param>
        <param name="length"><span data-ttu-id="8b8da-1157">Die maximale Anzahl der zu vergleichenden Zeichen der Teilzeichenfolgen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1157">The maximum number of characters in the substrings to compare.</span></span></param>
        <param name="culture"><span data-ttu-id="8b8da-1158">Ein Objekt, das kulturspezifische Vergleichsinformationen angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1158">An object that supplies culture-specific comparison information.</span></span></param>
        <param name="options"><span data-ttu-id="8b8da-1159">Die beim Ausführen des Vergleichs zu verwendenden Optionen (z. B. Ignorieren von Groß- und Kleinschreibung oder Symbolen).</span><span class="sxs-lookup"><span data-stu-id="8b8da-1159">Options to use when performing the comparison (such as ignoring case or symbols).</span></span></param>
        <summary><span data-ttu-id="8b8da-1160">Vergleicht Teilzeichenfolgen von zwei angegebenen <see cref="T:System.String" />-Objekten mit den festgelegten Vergleichsoptionen und kulturspezifischen Informationen, die den Vergleich beeinflussen, und gibt eine ganze Zahl zurück, die die Beziehung der beiden Teilzeichenfolgen zueinander in der Sortierreihenfolge angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1160">Compares substrings of two specified <see cref="T:System.String" /> objects using the specified comparison options and culture-specific information to influence the comparison, and returns an integer that indicates the relationship of the two substrings to each other in the sort order.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1161">Eine ganze Zahl, die die lexikalische Beziehung zwischen den beiden Teilzeichenfolgen angibt, wie in der folgenden Tabelle veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1161">An integer that indicates the lexical relationship between the two substrings, as shown in the following table.</span></span>

 <list type="table"><listheader><term> <span data-ttu-id="8b8da-1162">Wert</span><span class="sxs-lookup"><span data-stu-id="8b8da-1162">Value</span></span>

 </term><description> <span data-ttu-id="8b8da-1163">Bedingung</span><span class="sxs-lookup"><span data-stu-id="8b8da-1163">Condition</span></span>

 </description></listheader><item><term> <span data-ttu-id="8b8da-1164">Kleiner als 0 (null)</span><span class="sxs-lookup"><span data-stu-id="8b8da-1164">Less than zero</span></span>

 </term><description> <span data-ttu-id="8b8da-1165">Die Teilzeichenfolge in <paramref name="strA" /> ist der Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge vorangestellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1165">The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.</span></span>

 </description></item><item><term> <span data-ttu-id="8b8da-1166">Zero</span><span class="sxs-lookup"><span data-stu-id="8b8da-1166">Zero</span></span>

 </term><description> <span data-ttu-id="8b8da-1167">Die Teilzeichenfolgen treten in der Sortierreihenfolge an der gleichen Position auf, oder <paramref name="length" /> ist 0 (null).</span><span class="sxs-lookup"><span data-stu-id="8b8da-1167">The substrings occur in the same position in the sort order, or <paramref name="length" /> is zero.</span></span>

 </description></item><item><term> <span data-ttu-id="8b8da-1168">Größer als 0 (null)</span><span class="sxs-lookup"><span data-stu-id="8b8da-1168">Greater than zero</span></span>

 </term><description> <span data-ttu-id="8b8da-1169">Die Teilzeichenfolge in <paramref name="strA" /> folgt der Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1169">The substring in <paramref name="strA" /> follows the substring in <paramref name="strB" /> in the sort order.</span></span>

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-1170">Die zu vergleichenden Teil Zeichenfolgen beginnen in `strA` an der Position `indexA` und in `strB` an der Position `indexB`.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1170">The substrings to compare start in `strA` at position `indexA` and in `strB` at position `indexB`.</span></span> <span data-ttu-id="8b8da-1171">Die Länge der ersten Teil Zeichenfolge ist die Länge `strA` minus `indexA`.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1171">The length of the first substring is the length of `strA` minus `indexA`.</span></span> <span data-ttu-id="8b8da-1172">Die Länge der zweiten Teil Zeichenfolge ist die Länge `strB` minus `indexB`.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1172">The length of the second substring is the length of `strB` minus `indexB`.</span></span>

 <span data-ttu-id="8b8da-1173">Die Anzahl der zu vergleichenden Zeichen ist geringer als die Länge der beiden Teil Zeichenfolgen und `length`.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1173">The number of characters to compare is the lesser of the lengths of the two substrings, and `length`.</span></span> <span data-ttu-id="8b8da-1174">Die Parameter `indexA`, `indexB`und `length` dürfen nicht negativ sein.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1174">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>

 <span data-ttu-id="8b8da-1175">Der-Vergleich verwendet den `culture`-Parameter, um kulturspezifische Informationen abzurufen, z. b. Regeln für die Groß-und Kleinschreibung von einzelnen Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1175">The comparison uses the `culture` parameter to obtain culture-specific information, such as casing rules and the alphabetical order of individual characters.</span></span> <span data-ttu-id="8b8da-1176">Eine bestimmte Kultur könnte z. b. angeben, dass bestimmte Zeichenkombinationen als einzelnes Zeichen behandelt werden sollen, dass groß-und Kleinbuchstaben auf eine bestimmte Weise verglichen werden sollen oder dass die Sortierreihenfolge eines Zeichens von den vorangestellten Zeichen abhängig ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1176">For example, a particular culture could specify that certain combinations of characters be treated as a single character, that uppercase and lowercase characters be compared in a particular way, or that the sort order of a character depends on the characters that precede or follow it.</span></span>

> [!CAUTION]
>  <span data-ttu-id="8b8da-1177">Die <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>-Methode ist hauptsächlich für die Verwendung in Sortier-oder alphabetisierungsvorgängen vorgesehen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1177">The <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> method is designed primarily for use in sorting or alphabetizing operations.</span></span> <span data-ttu-id="8b8da-1178">Er sollte nicht verwendet werden, wenn der primäre Zweck des Methoden Aufrufes ist, zu bestimmen, ob zwei Teil Zeichenfolgen äquivalent sind (d. h., wenn der Zweck des Methoden Aufrufes ist, auf einen Rückgabewert von NULL zu testen).</span><span class="sxs-lookup"><span data-stu-id="8b8da-1178">It should not be used when the primary purpose of the method call is to determine whether two substrings are equivalent (that is, when the purpose of the method call is to test for a return value of zero).</span></span> <span data-ttu-id="8b8da-1179">Um zu ermitteln, ob zwei Zeichen folgen äquivalent sind, müssen Sie die <xref:System.String.Equals%2A>-Methode abrufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1179">To determine whether two strings are equivalent, call the <xref:System.String.Equals%2A> method.</span></span>

 <span data-ttu-id="8b8da-1180">Mindestens eine `strA` und `strB` kann `null`werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1180">One or both of `strA` and `strB` can be `null`.</span></span> <span data-ttu-id="8b8da-1181">Definitionsgemäß vergleichen alle Zeichen folgen, einschließlich <xref:System.String.Empty?displayProperty=nameWithType>, einen höheren Wert als einen NULL-Verweis, und zwei NULL-Verweise vergleichen einander.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1181">By definition, any string, including <xref:System.String.Empty?displayProperty=nameWithType>, compares greater than a null reference, and two null references compare equal to each other.</span></span>

 <span data-ttu-id="8b8da-1182">Der Vergleich kann weiter durch den `options`-Parameter angegeben werden, der aus einem oder mehreren Membern der <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>-Enumeration besteht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1182">The comparison can be further specified by the `options` parameter, which consists of one or more members of the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="8b8da-1183">Da der Zweck dieser Methode jedoch darin besteht, einen Kultur abhängigen Zeichen folgen Vergleich durchzuführen, haben die Werte für <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> und <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1183">However, because the purpose of this method is to conduct a culture-sensitive string comparison, the <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> and <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> values have no effect.</span></span>

 <span data-ttu-id="8b8da-1184">Der Vergleich wird beendet, wenn eine Ungleichheit erkannt oder beide Teil Zeichenfolgen verglichen wurden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1184">The comparison terminates when an inequality is discovered or both substrings have been compared.</span></span> <span data-ttu-id="8b8da-1185">Wenn die beiden Zeichen folgen jedoch gleich dem Ende einer Zeichenfolge sind und die andere Zeichenfolge Zeichen enthält, wird die Zeichenfolge mit den verbleibenden Zeichen als größer betrachtet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1185">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with the remaining characters is considered greater.</span></span> <span data-ttu-id="8b8da-1186">Der Rückgabewert ist das Ergebnis des letzten auszuführenden Vergleichs.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1186">The return value is the result of the last comparison performed.</span></span>



## Examples
 <span data-ttu-id="8b8da-1187">Im folgenden Beispiel wird die <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>-Methode verwendet, um die Nachnamen von zwei Personen zu vergleichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1187">The following example uses the <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> method to compare the last names of two people.</span></span> <span data-ttu-id="8b8da-1188">Anschließend werden Sie in alphabetischer Reihenfolge aufgelistet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1188">It then lists them in alphabetical order.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare5/cs/Example.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare5/vb/Example.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8b8da-1189"><paramref name="options" /> ist kein <see cref="T:System.Globalization.CompareOptions" />-Wert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1189"><paramref name="options" /> is not a <see cref="T:System.Globalization.CompareOptions" /> value.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-1190"><paramref name="indexA" /> ist größer als <paramref name="strA" /><see langword=".Length" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1190"><paramref name="indexA" /> is greater than <paramref name="strA" /><see langword=".Length" />.</span></span>

<span data-ttu-id="8b8da-1191">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-1191">-or-</span></span>

 <span data-ttu-id="8b8da-1192"><paramref name="indexB" /> ist größer als <paramref name="strB" /><see langword=".Length" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1192"><paramref name="indexB" /> is greater than <paramref name="strB" /><see langword=".Length" />.</span></span>

<span data-ttu-id="8b8da-1193">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-1193">-or-</span></span>

 <span data-ttu-id="8b8da-1194"><paramref name="indexA" />, <paramref name="indexB" /> oder <paramref name="length" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1194"><paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span></span>

<span data-ttu-id="8b8da-1195">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-1195">-or-</span></span>

<span data-ttu-id="8b8da-1196">Entweder <paramref name="strA" /> oder <paramref name="strB" /> ist <see langword="null" />, und <paramref name="length" /> ist größer als 0 (null).</span><span class="sxs-lookup"><span data-stu-id="8b8da-1196">Either <paramref name="strA" /> or <paramref name="strB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-1197"><paramref name="culture" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1197"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-1198">Zeichensätze enthalten ignorierbare Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1198">Character sets include ignorable characters.</span></span> <span data-ttu-id="8b8da-1199">Die <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />-Methode berücksichtigt diese Zeichen nicht, wenn Sie einen linguistischen oder Kultur abhängigen Vergleich durchführt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1199">The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="8b8da-1200">Um Ignorable-Zeichen im Vergleich zu erkennen, geben Sie den Wert <see cref="F:System.Globalization.CompareOptions.Ordinal" /> oder <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> für den <paramref name="options" />-Parameter an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1200">To recognize ignorable characters in your comparison, supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="options" /> parameter.</span></span></para></block>
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareOrdinal">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8b8da-1201">Vergleicht zwei <see cref="T:System.String" />-Objekte, indem die numerischen Werte der entsprechenden <see cref="T:System.Char" />-Objekte in den Zeichenfolgen ausgewertet werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1201">Compares two <see cref="T:System.String" /> objects by evaluating the numeric values of the corresponding <see cref="T:System.Char" /> objects in each string.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * string -&gt; int" Usage="System.string.CompareOrdinal (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="8b8da-1202">Die erste zu vergleichende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1202">The first string to compare.</span></span></param>
        <param name="strB"><span data-ttu-id="8b8da-1203">Die zweite zu vergleichende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1203">The second string to compare.</span></span></param>
        <summary><span data-ttu-id="8b8da-1204">Vergleicht zwei <see cref="T:System.String" />-Objekte, indem die numerischen Werte der entsprechenden <see cref="T:System.Char" />-Objekte in den Zeichenfolgen ausgewertet werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1204">Compares two specified <see cref="T:System.String" /> objects by evaluating the numeric values of the corresponding <see cref="T:System.Char" /> objects in each string.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1205">Eine ganze Zahl, die die lexikalische Beziehung zwischen den beiden Vergleichswerten angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1205">An integer that indicates the lexical relationship between the two comparands.</span></span>

 <list type="table"><listheader><term> <span data-ttu-id="8b8da-1206">Wert</span><span class="sxs-lookup"><span data-stu-id="8b8da-1206">Value</span></span>

 </term><description> <span data-ttu-id="8b8da-1207">Bedingung</span><span class="sxs-lookup"><span data-stu-id="8b8da-1207">Condition</span></span>

 </description></listheader><item><term> <span data-ttu-id="8b8da-1208">Kleiner als 0 (null)</span><span class="sxs-lookup"><span data-stu-id="8b8da-1208">Less than zero</span></span>

 </term><description><span data-ttu-id="8b8da-1209"><paramref name="strA" /> ist kleiner als <paramref name="strB" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1209"><paramref name="strA" /> is less than <paramref name="strB" />.</span></span>

 </description></item><item><term> <span data-ttu-id="8b8da-1210">Zero</span><span class="sxs-lookup"><span data-stu-id="8b8da-1210">Zero</span></span>

 </term><description><span data-ttu-id="8b8da-1211"><paramref name="strA" /> und <paramref name="strB" /> sind gleich.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1211"><paramref name="strA" /> and <paramref name="strB" /> are equal.</span></span>

 </description></item><item><term> <span data-ttu-id="8b8da-1212">Größer als 0 (null)</span><span class="sxs-lookup"><span data-stu-id="8b8da-1212">Greater than zero</span></span>

 </term><description><span data-ttu-id="8b8da-1213"><paramref name="strA" /> ist größer als <paramref name="strB" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1213"><paramref name="strA" /> is greater than <paramref name="strB" />.</span></span>

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-1214">Diese Methode führt einen Vergleich unter Berücksichtigung von ordinalsortierungs Regeln durch.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1214">This method performs a case-sensitive comparison using ordinal sort rules.</span></span> <span data-ttu-id="8b8da-1215">Weitere Informationen zu Wort-, Zeichen folgen-und ordinalsortierungen finden Sie unter <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1215">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8b8da-1216">Um einen Vergleich ohne Beachtung der Groß-/Kleinschreibung mithilfe von ordinalsortierungs Regeln durchzuführen, müssen Sie die <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>-Methode mit dem `comparisonType`-Argument auf <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="8b8da-1216">To perform a case-insensitive comparison using ordinal sort rules, call the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method with the `comparisonType` argument set to <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.</span></span>

 <span data-ttu-id="8b8da-1217">Da <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> eine statische Methode ist, können `strA` und `strB` `null`werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1217">Because <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> is a static method, `strA` and `strB` can be `null`.</span></span> <span data-ttu-id="8b8da-1218">Wenn beide Werte `null`sind, gibt die Methode 0 (null) zurück, was darauf hinweist, dass `strA` und `strB` gleich sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1218">If both values are `null`, the method returns 0 (zero), which indicates that `strA` and `strB` are equal.</span></span> <span data-ttu-id="8b8da-1219">Wenn nur einer der Werte `null`ist, betrachtet die Methode den Wert ungleich NULL als größer.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1219">If only one of the values is `null`, the method considers the non-null value to be greater.</span></span>



## Examples
 <span data-ttu-id="8b8da-1220">Das folgende Beispiel führt einen Ordinalvergleich zweier Zeichen folgen durch, die sich nur in Groß-/Kleinschreibung unterscheiden</span><span class="sxs-lookup"><span data-stu-id="8b8da-1220">The following example performs and ordinal comparison of two strings that only differ in case.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.compareordinal/CPP/comp0.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.compareordinal/CS/comp0.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compareordinal/VB/comp0.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * int * string * int * int -&gt; int" Usage="System.string.CompareOrdinal (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA"><span data-ttu-id="8b8da-1221">Die erste im Vergleich zu verwendende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1221">The first string to use in the comparison.</span></span></param>
        <param name="indexA"><span data-ttu-id="8b8da-1222">Der Anfangsindex der Teilzeichenfolge in <paramref name="strA" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1222">The starting index of the substring in <paramref name="strA" />.</span></span></param>
        <param name="strB"><span data-ttu-id="8b8da-1223">Die zweite im Vergleich zu verwendende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1223">The second string to use in the comparison.</span></span></param>
        <param name="indexB"><span data-ttu-id="8b8da-1224">Der Anfangsindex der Teilzeichenfolge in <paramref name="strB" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1224">The starting index of the substring in <paramref name="strB" />.</span></span></param>
        <param name="length"><span data-ttu-id="8b8da-1225">Die maximale Anzahl der zu vergleichenden Zeichen der Teilzeichenfolgen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1225">The maximum number of characters in the substrings to compare.</span></span></param>
        <summary><span data-ttu-id="8b8da-1226">Vergleicht Teilzeichenfolgen zweier angegebener <see cref="T:System.String" />-Objekte, indem die numerischen Werte der entsprechenden <see cref="T:System.Char" />-Objekte in den Teilzeichenfolgen ausgewertet werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1226">Compares substrings of two specified <see cref="T:System.String" /> objects by evaluating the numeric values of the corresponding <see cref="T:System.Char" /> objects in each substring.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1227">Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1227">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span></span>

 <list type="table"><listheader><term> <span data-ttu-id="8b8da-1228">Wert</span><span class="sxs-lookup"><span data-stu-id="8b8da-1228">Value</span></span>

 </term><description> <span data-ttu-id="8b8da-1229">Bedingung</span><span class="sxs-lookup"><span data-stu-id="8b8da-1229">Condition</span></span>

 </description></listheader><item><term> <span data-ttu-id="8b8da-1230">Kleiner als 0 (null)</span><span class="sxs-lookup"><span data-stu-id="8b8da-1230">Less than zero</span></span>

 </term><description> <span data-ttu-id="8b8da-1231">Die Teilzeichenfolge in <paramref name="strA" /> ist kleiner als die Teilzeichenfolge in <paramref name="strB" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1231">The substring in <paramref name="strA" /> is less than the substring in <paramref name="strB" />.</span></span>

 </description></item><item><term> <span data-ttu-id="8b8da-1232">Zero</span><span class="sxs-lookup"><span data-stu-id="8b8da-1232">Zero</span></span>

 </term><description> <span data-ttu-id="8b8da-1233">Die Teilzeichenfolgen sind gleich, oder <paramref name="length" /> ist 0.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1233">The substrings are equal, or <paramref name="length" /> is zero.</span></span>

 </description></item><item><term> <span data-ttu-id="8b8da-1234">Größer als 0 (null)</span><span class="sxs-lookup"><span data-stu-id="8b8da-1234">Greater than zero</span></span>

 </term><description> <span data-ttu-id="8b8da-1235">Die Teilzeichenfolge in <paramref name="strA" /> ist größer als die Teilzeichenfolge in <paramref name="strB" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1235">The substring in <paramref name="strA" /> is greater than the substring in <paramref name="strB" />.</span></span>

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-1236">Die Parameter `indexA`, `indexB`und `length` dürfen nicht negativ sein.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1236">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>

 <span data-ttu-id="8b8da-1237">Die Anzahl der verglichenen Zeichen ist kleiner als die Länge `strA` weniger `indexA`, die Länge `strB` weniger `indexB`und `length`.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1237">The number of characters compared is the lesser of the length of `strA` less `indexA`, the length of `strB` less `indexB`, and `length`.</span></span>

 <span data-ttu-id="8b8da-1238">Diese Methode führt einen Vergleich unter Berücksichtigung von ordinalsortierungs Regeln durch.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1238">This method performs a case-sensitive comparison using ordinal sort rules.</span></span> <span data-ttu-id="8b8da-1239">Weitere Informationen zu Wort-, Zeichen folgen-und ordinalsortierungen finden Sie unter <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1239">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8b8da-1240">Um einen Vergleich ohne Beachtung der Groß-/Kleinschreibung mithilfe von ordinalsortierungs Regeln durchzuführen, müssen Sie die <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29>-Methode mit dem `comparisonType`-Argument auf <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="8b8da-1240">To perform a case-insensitive comparison using ordinal sort rules, call the <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> method with the `comparisonType` argument set to <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.</span></span>

 <span data-ttu-id="8b8da-1241">Da <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> eine statische Methode ist, können `strA` und `strB` `null`werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1241">Because <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> is a static method, `strA` and `strB` can be `null`.</span></span> <span data-ttu-id="8b8da-1242">Wenn beide Werte `null`sind, gibt die Methode 0 (null) zurück, was darauf hinweist, dass `strA` und `strB` gleich sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1242">If both values are `null`, the method returns 0 (zero), which indicates that `strA` and `strB` are equal.</span></span> <span data-ttu-id="8b8da-1243">Wenn nur einer der Werte `null`ist, betrachtet die Methode den Wert ungleich NULL als größer.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1243">If only one of the values is `null`, the method considers the non-null value to be greater.</span></span>



## Examples
 <span data-ttu-id="8b8da-1244">Im folgenden Beispiel wird veranschaulicht, dass <xref:System.String.CompareOrdinal%2A> und <xref:System.String.Compare%2A> verschiedene Sortier Reihenfolgen verwenden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1244">This following example demonstrates that <xref:System.String.CompareOrdinal%2A> and <xref:System.String.Compare%2A> use different sort orders.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareOrdinal/CPP/stringcompareordinal.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareOrdinal/CS/stringcompareordinal.cs" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareOrdinal/VB/stringcompareordinal.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-1245"><paramref name="strA" /> ist nicht <see langword="null" /> und <paramref name="indexA" /> ist größer als <paramref name="strA" /><see cref="P:System.String.Length" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1245"><paramref name="strA" /> is not <see langword="null" /> and <paramref name="indexA" /> is greater than <paramref name="strA" />.<see cref="P:System.String.Length" />.</span></span>

<span data-ttu-id="8b8da-1246">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-1246">-or-</span></span>

 <span data-ttu-id="8b8da-1247"><paramref name="strB" /> ist nicht <see langword="null" /> und <paramref name="indexB" /> ist größer als <paramref name="strB" /><see cref="P:System.String.Length" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1247"><paramref name="strB" /> is not <see langword="null" /> and <paramref name="indexB" /> is greater than <paramref name="strB" />.<see cref="P:System.String.Length" />.</span></span>

<span data-ttu-id="8b8da-1248">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-1248">-or-</span></span>

 <span data-ttu-id="8b8da-1249"><paramref name="indexA" />, <paramref name="indexB" /> oder <paramref name="length" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1249"><paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span></span></exception>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8b8da-1250">Vergleicht diese Instanz mit einem angegebenen Objekt oder <see cref="T:System.String" /> und gibt eine ganze Zahl zurück, die angibt, ob diese Instanz in der Sortierreihenfolge an einer früheren, späteren oder derselben Position wie das angegebene Objekt oder <see cref="T:System.String" /> aufgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1250">Compares this instance with a specified object or <see cref="T:System.String" /> and returns an integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified object or <see cref="T:System.String" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-1251">Beide über Ladungen der <xref:System.String.CompareTo%2A>-Methode führen Kultur abhängige Vergleiche mit Unterscheidung nach Groß-/Kleinschreibung durch.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1251">Both overloads of the <xref:System.String.CompareTo%2A> method perform culture-sensitive and case-sensitive comparison.</span></span> <span data-ttu-id="8b8da-1252">Sie können diese Methode nicht verwenden, um Kultur unabhängige oder ordinale Vergleiche auszuführen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1252">You cannot use this method to perform culture-insensitive or ordinal comparisons.</span></span> <span data-ttu-id="8b8da-1253">Aus Gründen der Übersichtlichkeit des Codes wird empfohlen, die <xref:System.String.CompareTo%2A>-Methode zu vermeiden und stattdessen die <xref:System.String.Compare%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1253">For code clarity, we recommend that you avoid the <xref:System.String.CompareTo%2A> method and call the <xref:System.String.Compare%2A> method instead.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="string.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-1254">Ein Objekt, das als <see cref="T:System.String" /> ausgewertet wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1254">An object that evaluates to a <see cref="T:System.String" />.</span></span></param>
        <summary><span data-ttu-id="8b8da-1255">Vergleicht diese Instanz mit einem angegebenen <see cref="T:System.Object" /> und gibt an, ob diese Instanz in der Sortierreihenfolge an einer früheren, späteren oder derselben Position wie das angegebene <see cref="T:System.Object" /> aufgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1255">Compares this instance with a specified <see cref="T:System.Object" /> and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified <see cref="T:System.Object" />.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1256">Eine 32-Bit-Ganzzahl mit Vorzeichen, die angibt, ob diese Instanz in der Sortierreihenfolge an einer früheren, späteren oder derselben Position wie der <paramref name="value" />-Parameter aufgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1256">A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <paramref name="value" /> parameter.</span></span>

 <list type="table"><listheader><term> <span data-ttu-id="8b8da-1257">Wert</span><span class="sxs-lookup"><span data-stu-id="8b8da-1257">Value</span></span>

 </term><description> <span data-ttu-id="8b8da-1258">Bedingung</span><span class="sxs-lookup"><span data-stu-id="8b8da-1258">Condition</span></span>

 </description></listheader><item><term> <span data-ttu-id="8b8da-1259">Kleiner als 0 (null)</span><span class="sxs-lookup"><span data-stu-id="8b8da-1259">Less than zero</span></span>

 </term><description> <span data-ttu-id="8b8da-1260">Diese Instanz geht <paramref name="value" /> voran.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1260">This instance precedes <paramref name="value" />.</span></span>

 </description></item><item><term> <span data-ttu-id="8b8da-1261">Zero</span><span class="sxs-lookup"><span data-stu-id="8b8da-1261">Zero</span></span>

 </term><description> <span data-ttu-id="8b8da-1262">Diese Instanz hat in der Sortierreihenfolge dieselbe Position wie <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1262">This instance has the same position in the sort order as <paramref name="value" />.</span></span>

 </description></item><item><term> <span data-ttu-id="8b8da-1263">Größer als 0 (null)</span><span class="sxs-lookup"><span data-stu-id="8b8da-1263">Greater than zero</span></span>

 </term><description> <span data-ttu-id="8b8da-1264">Diese Instanz folgt <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1264">This instance follows <paramref name="value" />.</span></span>

<span data-ttu-id="8b8da-1265">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-1265">-or-</span></span>

 <span data-ttu-id="8b8da-1266"><paramref name="value" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1266"><paramref name="value" /> is <see langword="null" />.</span></span>

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-1267">`value` muss ein <xref:System.String> Objekt sein.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1267">`value` must be a <xref:System.String> object.</span></span>

> [!CAUTION]
>  <span data-ttu-id="8b8da-1268">Die <xref:System.String.CompareTo%2A>-Methode wurde hauptsächlich für die Verwendung in Sortier-oder alphabetisierungsvorgängen entwickelt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1268">The <xref:System.String.CompareTo%2A> method was designed primarily for use in sorting or alphabetizing operations.</span></span> <span data-ttu-id="8b8da-1269">Er sollte nicht verwendet werden, wenn der primäre Zweck des Methoden Aufrufes ist, zu bestimmen, ob zwei Zeichen folgen äquivalent sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1269">It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent.</span></span> <span data-ttu-id="8b8da-1270">Um zu ermitteln, ob zwei Zeichen folgen äquivalent sind, müssen Sie die <xref:System.String.Equals%2A>-Methode abrufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1270">To determine whether two strings are equivalent, call the <xref:System.String.Equals%2A> method.</span></span>

 <span data-ttu-id="8b8da-1271">Diese Methode führt einen Vergleich mit der aktuellen Kultur durch (Unterscheidung nach Groß-/Kleinschreibung und Kultur sensitiv).</span><span class="sxs-lookup"><span data-stu-id="8b8da-1271">This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</span></span> <span data-ttu-id="8b8da-1272">Weitere Informationen zu Wort-, Zeichen folgen-und ordinalsortierungen finden Sie unter <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1272">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>

 <span data-ttu-id="8b8da-1273">Weitere Informationen zum Verhalten dieser Methode finden Sie im Abschnitt "Hinweise" der <xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType>-Methode.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1273">For more information about the behavior of this method, see the Remarks section of the <xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType> method.</span></span>



## Examples
 <span data-ttu-id="8b8da-1274">Im folgenden Beispiel wird die <xref:System.String.CompareTo%2A>-Methode mit einem-<xref:System.Object>verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1274">The following example uses the <xref:System.String.CompareTo%2A> method with an <xref:System.Object>.</span></span> <span data-ttu-id="8b8da-1275">Da versucht wird, eine <xref:System.String> Instanz mit einem `TestClass`-Objekt zu vergleichen, löst die Methode eine <xref:System.ArgumentException>aus.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1275">Because it attempts to compare a <xref:System.String> instance to a `TestClass` object, the method throws an <xref:System.ArgumentException>.</span></span>

 [!code-cpp[ExToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ExToString/CPP/extostring.cpp#1)]
 [!code-csharp[ExToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ExToString/CS/extostring.cs#1)]
 [!code-vb[ExToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ExToString/VB/extostring.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8b8da-1276"><paramref name="value" /> ist keine <see cref="T:System.String" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1276"><paramref name="value" /> is not a <see cref="T:System.String" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-1277">Zeichensätze enthalten ignorierbare Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1277">Character sets include ignorable characters.</span></span> <span data-ttu-id="8b8da-1278">Die <see cref="M:System.String.CompareTo(System.Object)" />-Methode berücksichtigt solche Zeichen nicht, wenn Sie einen Kultur abhängigen Vergleich durchführt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1278">The <see cref="M:System.String.CompareTo(System.Object)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="8b8da-1279">Wenn der folgende Code z. b. auf der [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder später ausgeführt wird, gibt ein Vergleich von "Animal" mit "Ani-mal" (mit einem weichen Bindestrich oder "U + 00ad") an, dass die beiden Zeichen folgen äquivalent sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1279">For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a comparison of "animal" with "ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</span></span>

<span data-ttu-id="8b8da-1280">[! Code-csharp[System. String. CompareTo # 1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto1.cs#1)] [! Code-vb[System. String. CompareTo # 1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto1.vb#1)]</span><span class="sxs-lookup"><span data-stu-id="8b8da-1280">[!code-csharp[System.String.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto1.cs#1)] [!code-vb[System.String.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto1.vb#1)]</span></span>

<span data-ttu-id="8b8da-1281">Um Ignorable-Zeichen in einem Zeichen folgen Vergleich zu erkennen, müssen Sie die <see cref="M:System.String.CompareOrdinal(System.String,System.String)" />-Methode abrufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1281">To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> method.</span></span></para></block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(string strB) cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::String ^ strB);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : string -&gt; int&#xA;override this.CompareTo : string -&gt; int" Usage="string.CompareTo strB" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(string strB) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::String ^ strB);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="member this.CompareTo : string -&gt; int" Usage="string.CompareTo strB" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strB"><span data-ttu-id="8b8da-1282">Die Zeichenfolge, die mit dieser Instanz verglichen werden soll.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1282">The string to compare with this instance.</span></span></param>
        <summary><span data-ttu-id="8b8da-1283">Vergleicht diese Instanz mit einem angegebenen <see cref="T:System.String" />-Objekt und gibt an, ob diese Instanz in der Sortierreihenfolge an einer früheren, späteren oder derselben Position wie die angegebene Zeichenfolge aufgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1283">Compares this instance with a specified <see cref="T:System.String" /> object and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified string.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1284">Eine 32-Bit-Ganzzahl mit Vorzeichen, die angibt, ob diese Instanz in der Sortierreihenfolge an einer früheren, späteren oder derselben Position wie der <paramref name="strB" />-Parameter aufgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1284">A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <paramref name="strB" /> parameter.</span></span>

 <list type="table"><listheader><term> <span data-ttu-id="8b8da-1285">Wert</span><span class="sxs-lookup"><span data-stu-id="8b8da-1285">Value</span></span>

 </term><description> <span data-ttu-id="8b8da-1286">Bedingung</span><span class="sxs-lookup"><span data-stu-id="8b8da-1286">Condition</span></span>

 </description></listheader><item><term> <span data-ttu-id="8b8da-1287">Kleiner als 0 (null)</span><span class="sxs-lookup"><span data-stu-id="8b8da-1287">Less than zero</span></span>

 </term><description> <span data-ttu-id="8b8da-1288">Diese Instanz geht <paramref name="strB" /> voran.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1288">This instance precedes <paramref name="strB" />.</span></span>

 </description></item><item><term> <span data-ttu-id="8b8da-1289">Zero</span><span class="sxs-lookup"><span data-stu-id="8b8da-1289">Zero</span></span>

 </term><description> <span data-ttu-id="8b8da-1290">Diese Instanz hat in der Sortierreihenfolge dieselbe Position wie <paramref name="strB" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1290">This instance has the same position in the sort order as <paramref name="strB" />.</span></span>

 </description></item><item><term> <span data-ttu-id="8b8da-1291">Größer als 0 (null)</span><span class="sxs-lookup"><span data-stu-id="8b8da-1291">Greater than zero</span></span>

 </term><description> <span data-ttu-id="8b8da-1292">Diese Instanz folgt <paramref name="strB" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1292">This instance follows <paramref name="strB" />.</span></span>

<span data-ttu-id="8b8da-1293">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-1293">-or-</span></span>

 <span data-ttu-id="8b8da-1294"><paramref name="strB" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1294"><paramref name="strB" /> is <see langword="null" />.</span></span>

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-1295">Diese Methode führt einen Vergleich mit der aktuellen Kultur durch (Unterscheidung nach Groß-/Kleinschreibung und Kultur sensitiv).</span><span class="sxs-lookup"><span data-stu-id="8b8da-1295">This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</span></span> <span data-ttu-id="8b8da-1296">Weitere Informationen zu Wort-, Zeichen folgen-und ordinalsortierungen finden Sie unter <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1296">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>

> [!CAUTION]
>  <span data-ttu-id="8b8da-1297">Die <xref:System.String.CompareTo%2A>-Methode wurde hauptsächlich für die Verwendung in Sortier-oder alphabetisierungsvorgängen entwickelt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1297">The <xref:System.String.CompareTo%2A> method was designed primarily for use in sorting or alphabetizing operations.</span></span> <span data-ttu-id="8b8da-1298">Er sollte nicht verwendet werden, wenn der primäre Zweck des Methoden Aufrufes ist, zu bestimmen, ob zwei Zeichen folgen äquivalent sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1298">It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent.</span></span> <span data-ttu-id="8b8da-1299">Um zu ermitteln, ob zwei Zeichen folgen äquivalent sind, müssen Sie die <xref:System.String.Equals%2A>-Methode abrufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1299">To determine whether two strings are equivalent, call the <xref:System.String.Equals%2A> method.</span></span>

 <span data-ttu-id="8b8da-1300">Weitere Informationen zum Verhalten dieser Methode finden Sie im Abschnitt "Hinweise" der <xref:System.String.Compare%28System.String%2CSystem.String%29>-Methode.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1300">For more information about the behavior of this method, see the Remarks section of the <xref:System.String.Compare%28System.String%2CSystem.String%29> method.</span></span>

 <span data-ttu-id="8b8da-1301">Diese Methode implementiert die <xref:System.IComparable%601?displayProperty=nameWithType>-Schnittstelle und bietet eine etwas bessere Leistung als die <xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType>-Methode, da Sie nicht bestimmen muss, ob das `strB`-Argument ein änderbarer Werttyp ist, der geschachtelt werden muss, und der Parameter muss nicht aus einer <xref:System.Object> in eine <xref:System.String>umgewandelt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1301">This method implements the <xref:System.IComparable%601?displayProperty=nameWithType> interface and performs slightly better than the <xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType> method, because it does not have to determine whether the `strB` argument is a mutable value type that must be boxed, and it does not have to cast its parameter from an <xref:System.Object> to a <xref:System.String>.</span></span>



## Examples
 <span data-ttu-id="8b8da-1302">Im folgenden Beispiel wird die <xref:System.String.CompareTo%2A>-Methode verwendet, um die aktuelle Zeichen folgen Instanz mit einer anderen Zeichenfolge zu vergleichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1302">The following example uses the <xref:System.String.CompareTo%2A> method to compare the current string instance with another string.</span></span>

 [!code-cpp[stringcompareto#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareTo/CPP/stringcompareto.cpp#1)]
 [!code-csharp[stringcompareto#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareTo/CS/stringcompareto.cs#1)]
 [!code-vb[stringcompareto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareTo/VB/stringcompareto.vb#1)]

 <span data-ttu-id="8b8da-1303">Im folgenden Beispiel werden generische und nicht generische Versionen der CompareTo-Methode für verschiedene Wert-und Verweis Typen veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1303">The following example demonstrates generic and non-generic versions of the CompareTo method for several value and reference types.</span></span>

 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]

 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-1304">Zeichensätze enthalten ignorierbare Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1304">Character sets include ignorable characters.</span></span> <span data-ttu-id="8b8da-1305">Die <see cref="M:System.String.CompareTo(System.String)" />-Methode berücksichtigt solche Zeichen nicht, wenn Sie einen Kultur abhängigen Vergleich durchführt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1305">The <see cref="M:System.String.CompareTo(System.String)" /> method does not consider such characters when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="8b8da-1306">Wenn der folgende Code z. b. auf der [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder später ausgeführt wird, gibt ein Vergleich von "Animal" mit "Ani-mal" (mit einem weichen Bindestrich oder "U + 00ad") an, dass die beiden Zeichen folgen äquivalent sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1306">For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a comparison of "animal" with "ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</span></span>

<span data-ttu-id="8b8da-1307">[! Code-csharp[System. String. CompareTo # 2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto2.cs#2)] [! Code-vb[System. String. CompareTo # 2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto2.vb#2)]</span><span class="sxs-lookup"><span data-stu-id="8b8da-1307">[!code-csharp[System.String.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto2.cs#2)] [!code-vb[System.String.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto2.vb#2)]</span></span>

<span data-ttu-id="8b8da-1308">Um Ignorable-Zeichen in einem Zeichen folgen Vergleich zu erkennen, müssen Sie die <see cref="M:System.String.CompareOrdinal(System.String,System.String)" />-Methode abrufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1308">To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> method.</span></span></para></block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Concat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8b8da-1309">Verkettet eine oder mehrere Instanzen von <see cref="T:System.String" /> oder die <see cref="T:System.String" />-Darstellungen der Werte einer oder mehrerer Instanzen von <see cref="T:System.Object" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1309">Concatenates one or more instances of <see cref="T:System.String" />, or the <see cref="T:System.String" /> representations of the values of one or more instances of <see cref="T:System.Object" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

> [!NOTE]
>  <span data-ttu-id="8b8da-1310">Sie können auch den Operator für die Zeichen folgen Verkettung der Sprache wie `+` in C#oder `&` und `+` in Visual Basic verwenden, um Zeichen folgen zu verketten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1310">You can also use your language's string concatenation operator, such as `+` in C#, or `&` and `+` in Visual Basic, to concatenate strings.</span></span> <span data-ttu-id="8b8da-1311">Beide Compiler übersetzen den Verkettungs Operator in einen-aufruber einer der über Ladungen von `String.Concat`.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1311">Both compilers translate the concatenation operator into a call to one of the overloads of `String.Concat`.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;string&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="values"><span data-ttu-id="8b8da-1312">Ein Auflistungsobjekt, das <see cref="T:System.Collections.Generic.IEnumerable`1" /> implementiert und dessen generisches Typargument <see cref="T:System.String" /> ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1312">A collection object that implements <see cref="T:System.Collections.Generic.IEnumerable`1" /> and whose generic type argument is <see cref="T:System.String" />.</span></span></param>
        <summary><span data-ttu-id="8b8da-1313">Verkettet die Member einer erstellten <see cref="T:System.Collections.Generic.IEnumerable`1" />-Auflistung vom Typ <see cref="T:System.String" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1313">Concatenates the members of a constructed <see cref="T:System.Collections.Generic.IEnumerable`1" /> collection of type <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1314">Die verketteten Zeichenfolgen in <paramref name="values" /> oder <see cref="F:System.String.Empty" />, wenn <paramref name="values" /> ein leeres <see langword="IEnumerable(Of String)" /> ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1314">The concatenated strings in <paramref name="values" />, or <see cref="F:System.String.Empty" /> if <paramref name="values" /> is an empty <see langword="IEnumerable(Of String)" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-1315">Die-Methode verkettet jedes Objekt in `values`; Es werden keine Trennzeichen hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1315">The method concatenates each object in `values`; it does not add any delimiters.</span></span> <span data-ttu-id="8b8da-1316">Um ein Trennzeichen zwischen den einzelnen Elementen von `values`anzugeben, müssen Sie die <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1316">To specify a delimiter between each member of `values`, call the <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> method.</span></span>

 <span data-ttu-id="8b8da-1317">Anstelle eines NULL-Elements in `values`wird eine <xref:System.String.Empty?displayProperty=nameWithtype> Zeichenfolge verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1317">An <xref:System.String.Empty?displayProperty=nameWithtype> string is used in place of any null element in `values`.</span></span>

 <span data-ttu-id="8b8da-1318">Wenn `values` ein leeres `IEnumerable(Of String)`ist, gibt die Methode <xref:System.String.Empty?displayProperty=nameWithType>zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1318">If `values` is an empty `IEnumerable(Of String)`, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8b8da-1319">Wenn `values` `null`ist, löst die Methode eine <xref:System.ArgumentNullException> Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1319">If `values` is `null`, the method throws an <xref:System.ArgumentNullException> exception.</span></span>

 <span data-ttu-id="8b8da-1320"><xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> ist eine bequeme Methode, mit der Sie jedes Element in einer `IEnumerable(Of String)` Auflistung verketten können, ohne dass die Elemente zuvor in ein Zeichen folgen Array umgerechnet werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1320"><xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> is a convenience method that lets you concatenate each element in an `IEnumerable(Of String)` collection without first converting the elements to a string array.</span></span> <span data-ttu-id="8b8da-1321">Dies ist besonders nützlich bei LINQ-Abfrage Ausdrücken (Language-Integrated Query).</span><span class="sxs-lookup"><span data-stu-id="8b8da-1321">It is particularly useful with Language-Integrated Query (LINQ) query expressions.</span></span> <span data-ttu-id="8b8da-1322">Im folgenden Beispiel wird ein `List(Of String)` Objekt, das entweder die Groß-oder Kleinbuchstaben des Alphabets enthält, an einen Lambda-Ausdruck weitergeleitet, von dem Buchstaben ausgewählt werden, die gleich oder größer als ein bestimmter Buchstabe (im Beispiel "M") sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1322">The following example passes a `List(Of String)` object that contains either the uppercase or lowercase letters of the alphabet to a lambda expression that selects letters that are equal to or greater than a particular letter (which, in the example, is "M").</span></span> <span data-ttu-id="8b8da-1323">Die `IEnumerable(Of String)`-Auflistung, die von der <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType>-Methode zurückgegeben wird, wird an die <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29>-Methode übermittelt, um das Ergebnis als eine einzelne Zeichenfolge anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1323">The `IEnumerable(Of String)` collection that is returned by the <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> method is passed to the <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> method to display the result as a single string.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat2.cs" interactive="try-dotnet" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat2.vb" id="Snippet3":::

## Examples
 <span data-ttu-id="8b8da-1324">Im folgenden Beispiel wird das Sieb des Eratosthenes-Algorithmus zum Berechnen der Primzahlen, die kleiner oder gleich 100 sind, verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1324">The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</span></span> <span data-ttu-id="8b8da-1325">Das Ergebnis wird einem <xref:System.Collections.Generic.List%601> Objekt vom Typ <xref:System.String>zugewiesen, das dann an die <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29>-Methode weitergeleitet wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1325">It assigns the result to a <xref:System.Collections.Generic.List%601> object of type <xref:System.String>, which it then passes to the <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> method.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat1.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat1.vb" id="Snippet2":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-1326"><paramref name="values" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1326"><paramref name="values" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Concat : obj -&gt; string" Usage="System.string.Concat arg0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="8b8da-1327">Das darzustellende Objekt oder <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1327">The object to represent, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="8b8da-1328">Erstellt die Zeichenfolgendarstellung eines angegebenen Objekts.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1328">Creates the string  representation of a specified object.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1329">Die Zeichenfolgendarstellung des Werts von <paramref name="arg0" /> oder <see cref="F:System.String.Empty" />, wenn <paramref name="arg0" /><see langword="null" /> ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1329">The string representation of the value of <paramref name="arg0" />, or <see cref="F:System.String.Empty" /> if <paramref name="arg0" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-1330">Die <xref:System.String.Concat%28System.Object%29>-Methode stellt `arg0` als Zeichenfolge durch Aufrufen der Parameter losen `ToString`-Methode dar.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1330">The <xref:System.String.Concat%28System.Object%29> method represents `arg0` as a string by calling its parameterless `ToString` method.</span></span>



## Examples
 <span data-ttu-id="8b8da-1331">Das folgende Beispiel veranschaulicht die <xref:System.String.Concat%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1331">The following example demonstrates the <xref:System.String.Concat%2A> method.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Concat : obj[] -&gt; string" Usage="System.string.Concat args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args"><span data-ttu-id="8b8da-1332">Ein Objektarray, das die zu verkettenden Elemente enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1332">An object array that contains the elements to concatenate.</span></span></param>
        <summary><span data-ttu-id="8b8da-1333">Verkettet die Zeichenfolgendarstellungen der Elemente in einem angegebenen <see cref="T:System.Object" />-Array.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1333">Concatenates the string representations of the elements in a specified <see cref="T:System.Object" /> array.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1334">Die verketteten Zeichenfolgendarstellungen der Werte der Elemente in <paramref name="args" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1334">The concatenated string representations of the values of the elements in <paramref name="args" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-1335">Die-Methode verkettet jedes Objekt in `args` durch Aufrufen der Parameter losen `ToString`-Methode dieses Objekts. Es werden keine Trennzeichen hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1335">The method concatenates each object in `args` by calling the parameterless `ToString` method of that object; it does not add any delimiters.</span></span>

 <span data-ttu-id="8b8da-1336"><xref:System.String.Empty?displayProperty=nameWithType> wird anstelle eines NULL-Objekts im Array verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1336"><xref:System.String.Empty?displayProperty=nameWithType> is used in place of any null object in the array.</span></span>



## Examples
 <span data-ttu-id="8b8da-1337">Im folgenden Beispiel wird die Verwendung der <xref:System.String.Concat%2A>-Methode mit einem <xref:System.Object> Array veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1337">The following example demonstrates the use of the <xref:System.String.Concat%2A> method with an <xref:System.Object> array.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat1/CS/stringconcat1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat1/VB/stringconcat1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-1338"><paramref name="args" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1338"><paramref name="args" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="8b8da-1339">Nicht genügend Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1339">Out of memory.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-1340">Diese Methode wird nicht von C++ Code aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1340">This method is not called by C++ code.</span></span> <span data-ttu-id="8b8da-1341">Der C++ Compiler löst Aufrufe von <see cref="Overload:System.String.Concat" /> auf, die vier oder mehr Objekt Parameter als Aufruf an <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />haben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1341">The C++ compiler resolves calls to <see cref="Overload:System.String.Concat" /> that have four or more object parameters as a call to <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />.</span></span></para></block>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray values As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : string[] -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="values"><span data-ttu-id="8b8da-1342">Ein Array von Zeichenfolgeninstanzen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1342">An array of string instances.</span></span></param>
        <summary><span data-ttu-id="8b8da-1343">Verkettet die Elemente eines angegebenen <see cref="T:System.String" />-Arrays.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1343">Concatenates the elements of a specified <see cref="T:System.String" /> array.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1344">Die verketteten Elemente von <paramref name="values" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1344">The concatenated elements of <paramref name="values" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-1345">Die-Methode verkettet jedes Objekt in `values`; Es werden keine Trennzeichen hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1345">The method concatenates each object in `values`; it does not add any delimiters.</span></span>

 <span data-ttu-id="8b8da-1346">Anstelle eines NULL-Objekts im Array wird eine <xref:System.String.Empty?displayProperty=nameWithtype> Zeichenfolge verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1346">An <xref:System.String.Empty?displayProperty=nameWithtype> string is used in place of any null object in the array.</span></span>



## Examples
 <span data-ttu-id="8b8da-1347">Im folgenden Beispiel wird die Verwendung der <xref:System.String.Concat%2A>-Methode mit einem <xref:System.String> Array veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1347">The following example demonstrates the use of the <xref:System.String.Concat%2A> method with a <xref:System.String> array.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat3/CPP/stringconcat3.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat3/CS/stringconcat3.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat3/VB/stringconcat3.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-1348"><paramref name="values" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1348"><paramref name="values" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="8b8da-1349">Nicht genügend Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1349">Out of memory.</span></span></exception>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="8b8da-1350">Das erste zu verkettende Objekt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1350">The first object to concatenate.</span></span></param>
        <param name="arg1"><span data-ttu-id="8b8da-1351">Das zweite zu verkettende Objekt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1351">The second object to concatenate.</span></span></param>
        <summary><span data-ttu-id="8b8da-1352">Verkettet die Zeichenfolgendarstellungen zweier angegebener Objekte.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1352">Concatenates the string representations of two specified objects.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1353">Die verketteten Zeichenfolgendarstellungen der Werte von <paramref name="arg0" /> und <paramref name="arg1" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1353">The concatenated string representations of the values of <paramref name="arg0" /> and <paramref name="arg1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-1354">Die-Methode verkettet `arg0` und `arg1`, indem die Parameter lose `ToString`-Methode von `arg0` und `arg1`aufgerufen wird. Es werden keine Trennzeichen hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1354">The method concatenates `arg0` and `arg1` by calling the parameterless `ToString` method of `arg0` and `arg1`; it does not add any delimiters.</span></span>

 <span data-ttu-id="8b8da-1355"><xref:System.String.Empty?displayProperty=nameWithType> anstelle eines NULL-Arguments verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1355"><xref:System.String.Empty?displayProperty=nameWithType> is used in place of any null argument.</span></span>

 <span data-ttu-id="8b8da-1356">Wenn eines der Argumente ein Array Verweis ist, verkettet die Methode eine Zeichenfolge, die dieses Array anstelle der zugehörigen Member (z. b. "System. String []") darstellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1356">If either of the arguments is an array reference, the method concatenates a string representing that array, instead of its members (for example, "System.String[]").</span></span>



## Examples
 <span data-ttu-id="8b8da-1357">Das folgende Beispiel veranschaulicht die <xref:System.String.Concat%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1357">The following example demonstrates the <xref:System.String.Concat%2A> method.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="str0"><span data-ttu-id="8b8da-1358">Die erste zu verkettende schreibgeschützte Zeichenspanne.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1358">The first read-only character span to concatenate.</span></span></param>
        <param name="str1"><span data-ttu-id="8b8da-1359">Die zweite zu verkettende schreibgeschützte Zeichenspanne.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1359">The second read-only character span to concatenate.</span></span></param>
        <summary><span data-ttu-id="8b8da-1360">Verkettet die Zeichenfolgendarstellung von zwei angegebenen schreibgeschützten Zeichenspannen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1360">Concatenates the string representations of two specified read-only character spans.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1361">Die verketteten Zeichenfolgendarstellungen der Werte von <paramref name="str0" /> und <paramref name="str1" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1361">The concatenated string representations of the values of <paramref name="str0" /> and <paramref name="str1" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0"><span data-ttu-id="8b8da-1362">Die erste zu verkettende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1362">The first string to concatenate.</span></span></param>
        <param name="str1"><span data-ttu-id="8b8da-1363">Die zweite zu verkettende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1363">The second string to concatenate.</span></span></param>
        <summary><span data-ttu-id="8b8da-1364">Verkettet zwei angegebene Instanzen von <see cref="T:System.String" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1364">Concatenates two specified instances of <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1365">Die Verkettung von <paramref name="str0" /> und <paramref name="str1" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1365">The concatenation of <paramref name="str0" /> and <paramref name="str1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-1366">Die Methode verkettet `str0` und `str1`; Es werden keine Trennzeichen hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1366">The method concatenates `str0` and `str1`; it does not add any delimiters.</span></span>

 <span data-ttu-id="8b8da-1367">Anstelle eines NULL-Arguments wird eine <xref:System.String.Empty?displayProperty=nameWithtype> Zeichenfolge verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1367">An <xref:System.String.Empty?displayProperty=nameWithtype> string is used in place of any null argument.</span></span>

## Examples
 <span data-ttu-id="8b8da-1368">Im folgenden Beispiel werden die ersten, mittleren und Nachnamen einer Person verkettet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1368">The following example concatenates a person's first, middle, and last name.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat4/CPP/stringconcat4.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat4/CS/stringconcat4.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat4/VB/stringconcat4.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="8b8da-1369">Das erste zu verkettende Objekt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1369">The first object to concatenate.</span></span></param>
        <param name="arg1"><span data-ttu-id="8b8da-1370">Das zweite zu verkettende Objekt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1370">The second object to concatenate.</span></span></param>
        <param name="arg2"><span data-ttu-id="8b8da-1371">Das dritte zu verkettende Objekt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1371">The third object to concatenate.</span></span></param>
        <summary><span data-ttu-id="8b8da-1372">Verkettet die Zeichenfolgendarstellungen von drei angegebenen Objekten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1372">Concatenates the string representations of three specified objects.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1373">Die verketteten Zeichenfolgendarstellungen der Werte von <paramref name="arg0" />, <paramref name="arg1" /> und <paramref name="arg2" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1373">The concatenated string representations of the values of <paramref name="arg0" />, <paramref name="arg1" />, and <paramref name="arg2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-1374">Die-Methode verkettet `arg0`, `arg1`und `arg2` durch Aufrufen der Parameter losen `ToString`-Methode der einzelnen-Objekte. Es werden keine Trennzeichen hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1374">The method concatenates `arg0`, `arg1`, and `arg2` by calling the parameterless `ToString` method of each object; it does not add any delimiters.</span></span>

 <span data-ttu-id="8b8da-1375"><xref:System.String.Empty?displayProperty=nameWithType> anstelle eines NULL-Arguments verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1375"><xref:System.String.Empty?displayProperty=nameWithType> is used in place of any null argument.</span></span>



## Examples
 <span data-ttu-id="8b8da-1376">Das folgende Beispiel veranschaulicht die <xref:System.String.Concat%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1376">The following example demonstrates the <xref:System.String.Concat%2A> method.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1, valuetype System.ReadOnlySpan`1&lt;char&gt; str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char), str2 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="str2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="str0"><span data-ttu-id="8b8da-1377">Die erste zu verkettende schreibgeschützte Zeichenspanne.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1377">The first read-only character span to concatenate.</span></span></param>
        <param name="str1"><span data-ttu-id="8b8da-1378">Die zweite zu verkettende schreibgeschützte Zeichenspanne.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1378">The second read-only character span to concatenate.</span></span></param>
        <param name="str2"><span data-ttu-id="8b8da-1379">Die dritte zu verkettende schreibgeschützte Zeichenspanne.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1379">The third read-only character span to concatenate.</span></span></param>
        <summary><span data-ttu-id="8b8da-1380">Verkettet die Zeichenfolgendarstellung von drei angegebenen schreibgeschützten Zeichenspannen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1380">Concatenates the string representations of three specified read-only character spans.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1381">Die verketteten Zeichenfolgendarstellungen der Werte von <paramref name="str0" />, <paramref name="str1" /> und <paramref name="str2" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1381">The concatenated string representations of the values of <paramref name="str0" />, <paramref name="str1" /> and <paramref name="str2" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0"><span data-ttu-id="8b8da-1382">Die erste zu verkettende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1382">The first string to concatenate.</span></span></param>
        <param name="str1"><span data-ttu-id="8b8da-1383">Die zweite zu verkettende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1383">The second string to concatenate.</span></span></param>
        <param name="str2"><span data-ttu-id="8b8da-1384">Die dritte zu verkettende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1384">The third string to concatenate.</span></span></param>
        <summary><span data-ttu-id="8b8da-1385">Verkettet zwei angegebene Instanzen von <see cref="T:System.String" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1385">Concatenates three specified instances of <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1386">Die Verkettung von <paramref name="str0" />, <paramref name="str1" /> und <paramref name="str2" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1386">The concatenation of <paramref name="str0" />, <paramref name="str1" />, and <paramref name="str2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-1387">Die Methode verkettet `str0`, `str1`und `str2`. Es werden keine Trennzeichen hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1387">The method concatenates `str0`, `str1`, and `str2`; it does not add any delimiters.</span></span>

## Examples
 <span data-ttu-id="8b8da-1388">Im folgenden Beispiel wird die <xref:System.String.Concat%2A>-Methode verwendet, um drei Zeichen folgen zu verketten und das Ergebnis anzeigt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1388">The following example uses the <xref:System.String.Concat%2A> method to concatenate three strings and displays the result.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.concat/cpp/Concat6.cpp" id="Snippet6":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/Concat6.cs" interactive="try-dotnet" id="Snippet6":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/Concat6.vb" id="Snippet6":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg3" Type="System.Object" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="arg0"><span data-ttu-id="8b8da-1389">Das erste zu verkettende Objekt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1389">The first object to concatenate.</span></span></param>
        <param name="arg1"><span data-ttu-id="8b8da-1390">Das zweite zu verkettende Objekt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1390">The second object to concatenate.</span></span></param>
        <param name="arg2"><span data-ttu-id="8b8da-1391">Das dritte zu verkettende Objekt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1391">The third object to concatenate.</span></span></param>
        <param name="arg3"><span data-ttu-id="8b8da-1392">Das vierte zu verkettende Objekt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1392">The fourth object to concatenate.</span></span></param>
        <summary><span data-ttu-id="8b8da-1393">Verkettet die Zeichenfolgenentsprechungen von vier angegebenen Objekten sowie aller in einer optionalen Parameterliste variabler Länger angegebenen Objekte.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1393">Concatenates the string representations of four specified objects and any objects specified in an optional variable length parameter list.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1394">Die verkettete Zeichenfolgendarstellung aller Werte in der Parameterliste.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1394">The concatenated string representation of each value in the parameter list.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
>  <span data-ttu-id="8b8da-1395">Diese API ist nicht CLS-kompatibel.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1395">This API is not CLS-compliant.</span></span> <span data-ttu-id="8b8da-1396">Die CLS-kompatible Alternative ist <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1396">The CLS-compliant alternative is <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8b8da-1397">Der C# -und der-Visual Basic Compiler lösen einen aufzurufenden Rückruf dieser Methode automatisch als <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1397">The C# and Visual Basic compilers automatically resolve a call to this method as a call to <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>.</span></span>

 <span data-ttu-id="8b8da-1398">Die-Methode verkettet jedes Objekt in der Parameterliste durch Aufrufen seiner Parameter losen `ToString` Methode. Es werden keine Trennzeichen hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1398">The method concatenates each object in the parameter list by calling its parameterless `ToString` method; it does not add any delimiters.</span></span>

 <span data-ttu-id="8b8da-1399"><xref:System.String.Empty?displayProperty=nameWithType> anstelle eines NULL-Arguments verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1399"><xref:System.String.Empty?displayProperty=nameWithType> is used in place of any null argument.</span></span>

> [!NOTE]
>  <span data-ttu-id="8b8da-1400">Der letzte Parameter der <xref:System.String.Concat%2A>-Methode ist eine optionale durch Trennzeichen getrennte Liste mit einem oder mehreren zusätzlichen Objekten, die verkettet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1400">The last parameter of the  <xref:System.String.Concat%2A> method is an optional comma-delimited list of one or more additional objects to concatenate.</span></span>



## Examples
 <span data-ttu-id="8b8da-1401">Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29>-Methode verwendet wird, um eine Liste von Variablen Parametern zu verketten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1401">The following example illustrates the use of the <xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> method to concatenate a list of variable parameters.</span></span> <span data-ttu-id="8b8da-1402">In diesem Fall wird die-Methode mit neun Parametern aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1402">In this case, the method is called with nine parameters.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-1403">Diese Methode ist mit dem <see langword="vararg" />-Schlüsselwort gekennzeichnet, was bedeutet, dass Sie eine Variable Anzahl von Parametern unterstützt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1403">This method is marked with the <see langword="vararg" /> keyword, which means that it supports a variable number of parameters.</span></span> <span data-ttu-id="8b8da-1404">Die-Methode kann aus Visual C++aufgerufen werden, Sie kann jedoch nicht von C# oder Visual Basic Code aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1404">The method can be called from Visual C++, but it cannot be called from C# or Visual Basic code.</span></span> <span data-ttu-id="8b8da-1405">Der C# -und der-Visual Basic Compiler lösen Aufrufe <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /> als Aufrufe von <see cref="M:System.String.Concat(System.Object[])" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1405">The C# and Visual Basic compilers resolve calls to <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /> as calls to <see cref="M:System.String.Concat(System.Object[])" />.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2, ReadOnlySpan&lt;char&gt; str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1, valuetype System.ReadOnlySpan`1&lt;char&gt; str2, valuetype System.ReadOnlySpan`1&lt;char&gt; str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char), str2 As ReadOnlySpan(Of Char), str3 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2, ReadOnlySpan&lt;char&gt; str3);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="str2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="str3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="str0"><span data-ttu-id="8b8da-1406">Die erste zu verkettende schreibgeschützte Zeichenspanne.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1406">The first read-only character span to concatenate.</span></span></param>
        <param name="str1"><span data-ttu-id="8b8da-1407">Die zweite zu verkettende schreibgeschützte Zeichenspanne.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1407">The second read-only character span to concatenate.</span></span></param>
        <param name="str2"><span data-ttu-id="8b8da-1408">Die dritte zu verkettende schreibgeschützte Zeichenspanne.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1408">The third read-only character span to concatenate.</span></span></param>
        <param name="str3"><span data-ttu-id="8b8da-1409">Die vierte zu verkettende schreibgeschützte Zeichenspanne.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1409">The fourth read-only character span to concatenate.</span></span></param>
        <summary><span data-ttu-id="8b8da-1410">Verkettet die Zeichenfolgendarstellung von vier angegebenen schreibgeschützten Zeichenspannen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1410">Concatenates the string representations of four specified read-only character spans.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1411">Die verketteten Zeichenfolgendarstellungen der Werte von <paramref name="str0" />, <paramref name="str1" />, <paramref name="str2" /> und <paramref name="str3" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1411">The concatenated string representations of the values of <paramref name="str0" />, <paramref name="str1" />, <paramref name="str2" /> and <paramref name="str3" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2, string str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2, string str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String, str3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2, System::String ^ str3);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
        <Parameter Name="str3" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0"><span data-ttu-id="8b8da-1412">Die erste zu verkettende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1412">The first string to concatenate.</span></span></param>
        <param name="str1"><span data-ttu-id="8b8da-1413">Die zweite zu verkettende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1413">The second string to concatenate.</span></span></param>
        <param name="str2"><span data-ttu-id="8b8da-1414">Die dritte zu verkettende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1414">The third string to concatenate.</span></span></param>
        <param name="str3"><span data-ttu-id="8b8da-1415">Die vierte zu verkettende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1415">The fourth string to concatenate.</span></span></param>
        <summary><span data-ttu-id="8b8da-1416">Verkettet zwei angegebene Instanzen von <see cref="T:System.String" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1416">Concatenates four specified instances of <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1417">Die Verkettung von <paramref name="str0" />, <paramref name="str1" />, <paramref name="str2" /> und <paramref name="str3" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1417">The concatenation of <paramref name="str0" />, <paramref name="str1" />, <paramref name="str2" />, and <paramref name="str3" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-1418">Die Methode verkettet `str0`, `str1`, `str2`und `str3`; Es werden keine Trennzeichen hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1418">The method concatenates `str0`, `str1`, `str2`, and `str3`; it does not add any delimiters.</span></span>

## Examples
 <span data-ttu-id="8b8da-1419">Im folgenden Beispiel wird ein Array aus aus vier Buchstaben bestehenden Wörtern definiert und die einzelnen Buchstaben in einem Zeichen folgen Array gespeichert, um Sie zu verscheinigen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1419">The following example defines an array of four-letter words and stores their individual letters to a string array in order to scramble them.</span></span> <span data-ttu-id="8b8da-1420">Anschließend wird die <xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29>-Methode aufgerufen, um die aufgerufenen Wörter erneut zuzuweisen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1420">It then calls the <xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29> method to reassemble the scrambled words.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Concat&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat(Of T) (values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;'T&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="8b8da-1421">Der Typ der Member von <paramref name="values" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1421">The type of the members of <paramref name="values" />.</span></span></typeparam>
        <param name="values"><span data-ttu-id="8b8da-1422">Ein Auflistungsobjekt, das die <see cref="T:System.Collections.Generic.IEnumerable`1" />-Schnittstelle implementiert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1422">A collection object that implements the <see cref="T:System.Collections.Generic.IEnumerable`1" /> interface.</span></span></param>
        <summary><span data-ttu-id="8b8da-1423">Verkettet die Member einer <see cref="T:System.Collections.Generic.IEnumerable`1" />-Implementierung.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1423">Concatenates the members of an <see cref="T:System.Collections.Generic.IEnumerable`1" /> implementation.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1424">Die verketteten Zeichenfolgen in <paramref name="values" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1424">The concatenated members in <paramref name="values" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-1425">Die-Methode verkettet jedes Objekt in `values`; Es werden keine Trennzeichen hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1425">The method concatenates each object in `values`; it does not add any delimiters.</span></span>

 <span data-ttu-id="8b8da-1426">Anstelle eines NULL-Arguments wird eine <xref:System.String.Empty?displayProperty=nameWithtype> Zeichenfolge verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1426">An <xref:System.String.Empty?displayProperty=nameWithtype> string is used in place of any null argument.</span></span>

 <span data-ttu-id="8b8da-1427"><xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> ist eine bequeme Methode, mit der Sie jedes Element in einer <xref:System.Collections.Generic.IEnumerable%601> Auflistung verketten können, ohne dass die Elemente zuvor in Zeichen folgen umgerechnet werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1427"><xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> is a convenience method that lets you concatenate each element in an <xref:System.Collections.Generic.IEnumerable%601> collection without first converting the elements to strings.</span></span> <span data-ttu-id="8b8da-1428">Dies ist besonders nützlich mit LINQ-Abfrage Ausdrücken (Language-Integrated Query), wie im Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1428">It is particularly useful with Language-Integrated Query (LINQ) query expressions, as the example illustrates.</span></span> <span data-ttu-id="8b8da-1429">Die Zeichen folgen Darstellung der einzelnen Objekte in der <xref:System.Collections.Generic.IEnumerable%601> Auflistung wird durch Aufrufen der `ToString` Methode dieses Objekts abgeleitet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1429">The string representation of each object in the <xref:System.Collections.Generic.IEnumerable%601> collection is derived by calling that object's `ToString` method.</span></span>



## Examples
 <span data-ttu-id="8b8da-1430">Im folgenden Beispiel wird eine sehr einfache `Animal` Klasse definiert, die den Namen eines Tieres und die Reihenfolge enthält, zu der er gehört.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1430">The following example defines a very simple `Animal` class that contains the name of an animal and the order to which it belongs.</span></span> <span data-ttu-id="8b8da-1431">Anschließend wird ein <xref:System.Collections.Generic.List%601> Objekt definiert, das eine Reihe von `Animal` Objekten enthalten soll.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1431">It then defines a <xref:System.Collections.Generic.List%601> object to contain a number of `Animal` objects.</span></span> <span data-ttu-id="8b8da-1432">Die <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType>-Erweiterungsmethode wird aufgerufen, um die `Animal` Objekte zu extrahieren, deren `Order`-Eigenschaft den Wert "Rodent" hat.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1432">The <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> extension method is called to extract the `Animal` objects whose `Order` property equals "Rodent".</span></span> <span data-ttu-id="8b8da-1433">Das Ergebnis wird an die <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>-Methode übermittelt und in der Konsole angezeigt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1433">The result is passed to the <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> method and displayed to the console.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat3.cs" interactive="try-dotnet" id="Snippet4":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat3.vb" id="Snippet4":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-1434"><paramref name="values" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1434"><paramref name="values" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value);" />
      <MemberSignature Language="F#" Value="member this.Contains : char -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-1435">Das zu suchende Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1435">The character to seek.</span></span></param>
        <summary><span data-ttu-id="8b8da-1436">Gibt einen Wert zurück, der angibt, ob ein angegebenes Zeichen in dieser Zeichenfolge vorkommt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1436">Returns a value indicating whether a specified character occurs within this string.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1437"><see langword="true" />, wenn der <paramref name="value" />-Parameter innerhalb dieser Zeichenfolge auftritt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1437"><see langword="true" /> if the <paramref name="value" /> parameter occurs within this string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Contains : string -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-1438">Die zu suchende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1438">The string to seek.</span></span></param>
        <summary><span data-ttu-id="8b8da-1439">Gibt einen Wert zurück, der angibt, ob eine angegebene untergeordnete Zeichenfolge in dieser Zeichenfolge vorkommt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1439">Returns a value indicating whether a specified substring occurs within this string.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1440"><see langword="true" />, wenn der <paramref name="value" />-Parameter in dieser Zeichenfolge vorkommt oder <paramref name="value" /> eine leere Zeichenfolge ("") ist; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1440"><see langword="true" /> if the <paramref name="value" /> parameter occurs within this string, or if <paramref name="value" /> is the empty string (""); otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-1441">Diese Methode führt einen Ordinalvergleich (Groß-/Kleinschreibung und Kultur unabhängige) aus.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1441">This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span> <span data-ttu-id="8b8da-1442">Die Suche beginnt an der ersten Zeichenposition dieser Zeichenfolge und wird mit der letzten Zeichenposition fortgesetzt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1442">The search begins at the first character position of this string and continues through the last character position.</span></span>

 <span data-ttu-id="8b8da-1443">Sie können eine benutzerdefinierte Methode erstellen, um zu bestimmen, ob eine Zeichenfolge eine angegebene Teil Zeichenfolge enthält, die einen anderen als einen Ordinalvergleich verwendet (z. b. einen Kultur abhängigen Vergleich oder einen ordinalen Vergleich).</span><span class="sxs-lookup"><span data-stu-id="8b8da-1443">To determine whether a string contains a specified substring by using something other than ordinal comparison (such as culture-sensitive comparison, or ordinal case-insensitive comparison), you can create a custom method.</span></span> <span data-ttu-id="8b8da-1444">Im folgenden Beispiel wird ein solcher Ansatz veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1444">The following example illustrates one such approach.</span></span> <span data-ttu-id="8b8da-1445">Es definiert eine <xref:System.String> Erweiterungsmethode, die einen <xref:System.StringComparison>-Parameter enthält und angibt, ob eine Zeichenfolge eine Teil Zeichenfolge enthält, wenn die angegebene Form des Zeichen folgen Vergleichs verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1445">It defines a <xref:System.String> extension method  that includes a <xref:System.StringComparison> parameter and indicates whether a string contains a substring when using the specified form of string comparison.</span></span>

 [!code-csharp[System.String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#1)]
 [!code-vb[System.String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#1)]

 <span data-ttu-id="8b8da-1446">Im folgenden Beispiel wird dann die `Contains`-Erweiterungsmethode aufgerufen, um zu bestimmen, ob eine Teil Zeichenfolge in einer Zeichenfolge gefunden wird, wenn Ordinalvergleich verwendet wird und die Groß-/Kleinschreibung nicht beachtet</span><span class="sxs-lookup"><span data-stu-id="8b8da-1446">The following example then calls the `Contains` extension method to determine whether a substring is found in a string when using ordinal comparison and case-insensitive ordinal comparison.</span></span>

 [!code-csharp[System.String.Contains#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#2)]
 [!code-vb[System.String.Contains#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#2)]

 <span data-ttu-id="8b8da-1447">Wenn Sie an der Position der Teil Zeichenfolge `value` in der aktuellen Instanz interessiert sind, können Sie die <xref:System.String.IndexOf%2A>-Methode aufzurufen, um die Anfangsposition des ersten Vorkommens abzurufen, oder Sie können die <xref:System.String.LastIndexOf%2A>-Methode aufzurufen, um die Anfangsposition des letzten Vorkommens abzurufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1447">If you are interested in the position of the substring `value` in the current instance, you can call the <xref:System.String.IndexOf%2A> method to get the starting position of its first occurrence, or you can call the <xref:System.String.LastIndexOf%2A> method to get the starting position of its last occurrence.</span></span> <span data-ttu-id="8b8da-1448">Das Beispiel enthält einen aufzurufenden <xref:System.String.IndexOf%28System.String%29>-Methode, wenn eine Teil Zeichenfolge in einer Zeichen folgen Instanz gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1448">The example includes a call to the <xref:System.String.IndexOf%28System.String%29> method if a substring is found in a string instance.</span></span>



## Examples
 <span data-ttu-id="8b8da-1449">Im folgenden Beispiel wird bestimmt, ob die Zeichenfolge "Fox" eine Teil Zeichenfolge eines vertrauten Angebots ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1449">The following example determines whether the string "fox" is a substring of a familiar quotation.</span></span> <span data-ttu-id="8b8da-1450">Wenn "Fox" in der Zeichenfolge gefunden wird, wird auch die Startposition angezeigt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1450">If "fox" is found in the string, it also displays its starting position.</span></span>

 [!code-cpp[String.Contains#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.contains/CPP/cont.cpp#1)]
 [!code-csharp-interactive[String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.contains/CS/cont.cs#1)]
 [!code-vb[String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.contains/VB/cont.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-1451"><paramref name="value" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1451"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : char * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-1452">Das zu suchende Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1452">The character to seek.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="8b8da-1453">Einer der Enumerationswerte, der die für den Vergleich zu verwendenden Regeln angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1453">One of the enumeration values that specifies the rules to use in the comparison.</span></span></param>
        <summary><span data-ttu-id="8b8da-1454">Gibt mithilfe der festgelegten Vergleichsregeln einen Wert zurück, der angibt, ob ein angegebenes Zeichen innerhalb der Zeichenfolge auftritt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1454">Returns a value indicating whether a specified character occurs within this string, using the specified comparison rules.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1455"><see langword="true" />, wenn der <paramref name="value" />-Parameter innerhalb dieser Zeichenfolge auftritt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1455"><see langword="true" /> if the <paramref name="value" /> parameter occurs within this string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : string * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-1456">Die zu suchende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1456">The string to seek.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="8b8da-1457">Einer der Enumerationswerte, der die für den Vergleich zu verwendenden Regeln angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1457">One of the enumeration values that specifies the rules to use in the comparison.</span></span></param>
        <summary><span data-ttu-id="8b8da-1458">Gibt mithilfe der festgelegten Vergleichsregeln einen Wert zurück, der angibt, ob eine angegebene Zeichenfolge innerhalb der Zeichenfolge auftritt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1458">Returns a value indicating whether a specified string occurs within this string, using the specified comparison rules.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1459"><see langword="true" />, wenn der <paramref name="value" />-Parameter in dieser Zeichenfolge vorkommt oder <paramref name="value" /> eine leere Zeichenfolge ("") ist; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1459"><see langword="true" /> if the <paramref name="value" /> parameter occurs within this string, or if <paramref name="value" /> is the empty string (""); otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static string Copy (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Copy(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Copy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Copy (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Copy(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Copy : string -&gt; string" Usage="System.string.Copy str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("This API should not be used to create mutable strings. See https://go.microsoft.com/fwlink/?linkid=2084035 for alternatives.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="str"><span data-ttu-id="8b8da-1460">Die zu kopierende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1460">The string to copy.</span></span></param>
        <summary><span data-ttu-id="8b8da-1461">Erstellt eine neue Instanz von <see cref="T:System.String" /> mit demselben Wert wie eine angegebene Instanz von <see cref="T:System.String" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1461">Creates a new instance of <see cref="T:System.String" /> with the same value as a specified <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1462">Eine neue Zeichenfolge mit demselben Wert wie <paramref name="str" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1462">A new string with the same value as <paramref name="str" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="8b8da-1463">Die `Copy`-Methode gibt ein <xref:System.String> Objekt zurück, das denselben Wert wie die ursprüngliche Zeichenfolge aufweist, aber einen anderen Objekt Verweis darstellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1463">The `Copy` method returns a <xref:System.String> object that has the same value as the original string but represents a different object reference.</span></span> <span data-ttu-id="8b8da-1464">Dies unterscheidet sich von einer Zuweisungs Operation, bei der einer zusätzlichen Objektvariablen ein vorhandener Zeichen folgen Verweis zugewiesen wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1464">It differs from an assignment operation, which assigns an existing string reference to an additional object variable.</span></span>

> [!IMPORTANT]
>  <span data-ttu-id="8b8da-1465">Ab .net Core 3,0 ist diese Methode veraltet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1465">Starting with .NET Core 3.0, this method is obsolete.</span></span> <span data-ttu-id="8b8da-1466">Es wird jedoch nicht empfohlen, die Verwendung in einer .NET-Implementierung zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1466">However, we do not recommend its use in any .NET implementation.</span></span> <span data-ttu-id="8b8da-1467">Insbesondere aufgrund von Änderungen in der Zeichen folgen Internalisierung in .net Core 3,0 wird in einigen Fällen die `Copy`-Methode keine neue Zeichenfolge erstellen, sondern lediglich einen Verweis auf eine vorhandene Internpool vorhanden-Zeichenfolge zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1467">In particular, because of changes in string interning in .NET Core 3.0, in some cases the `Copy` method will not create a new string but will simply return a reference to an existing interned string.</span></span>

<span data-ttu-id="8b8da-1468">Abhängig davon, warum Sie die `Copy`-Methode abrufen möchten, gibt es eine Reihe von Alternativen:</span><span class="sxs-lookup"><span data-stu-id="8b8da-1468">Depending on Why you want to call the `Copy` method, there are a number of alternatives:</span></span>

- <span data-ttu-id="8b8da-1469">Wenn eine andere Zeichen folgen Instanz in einem Vorgang verwendet werden soll, der die Zeichenfolge ändert, verwenden Sie die ursprüngliche Zeichen folgen Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1469">If you want a different string instance to use in an operation that modifies the string, use the original string instance.</span></span> <span data-ttu-id="8b8da-1470">Da Zeichen folgen unveränderlich sind, wird durch den Zeichen folgen Vorgang eine neue Zeichen folgen Instanz erstellt, und die ursprüngliche Zeichenfolge bleibt unverändert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1470">Because strings are immutable, the string operation creates a new string instance, and the original string remains unaffected.</span></span> <span data-ttu-id="8b8da-1471">In diesem Fall sollten Sie den neuen Zeichen folgen Verweis nicht der ursprünglichen Zeichen folgen Variablen zuweisen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1471">In this case, you should not assign the new string reference to the original string variable.</span></span> <span data-ttu-id="8b8da-1472">Dies wird im folgenden Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1472">The following example provides an illustration.</span></span>

  [!code-csharp[Performing a string operation](~/samples/snippets/csharp/api/system/string/copy/program.cs#1)]
  [!code-vb[Performing a string operation](~/samples/snippets/visualbasic/api/system/string/copy/program.vb#1)]

   <span data-ttu-id="8b8da-1473">Wenn Sie die `Copy`-Methode aufrufen, um eine neue Zeichenfolge zu erstellen, bevor Sie die <xref:System.String.Substring%2A>-Methode aufrufen, wird eine neue Zeichen folgen Instanz erstellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1473">In this case, calling the `Copy` method to create a new string before calling the <xref:System.String.Substring%2A> method unnecessarily creates a new string instance.</span></span>

- <span data-ttu-id="8b8da-1474">Wenn Sie einen änderbaren Puffer mit dem gleichen Inhalt wie die ursprüngliche Zeichenfolge erstellen möchten, rufen Sie den <xref:System.String.ToCharArray%2A?displayProperty=nameWithType>-oder <xref:System.Text.StringBuilder.%23ctor(System.String)?displayProperty=nameWithType>-Konstruktor auf.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1474">If you want to create a mutable buffer with the same contents as the original string, call the <xref:System.String.ToCharArray%2A?displayProperty=nameWithType> or <xref:System.Text.StringBuilder.%23ctor(System.String)?displayProperty=nameWithType> constructor.</span></span> <span data-ttu-id="8b8da-1475">Beispiel:</span><span class="sxs-lookup"><span data-stu-id="8b8da-1475">For example:</span></span>

  [!code-csharp[Performing a string operation](~/samples/snippets/csharp/api/system/string/copy/program.cs#2)]
  [!code-vb[Performing a string operation](~/samples/snippets/visualbasic/api/system/string/copy/program.vb#2)]

- <span data-ttu-id="8b8da-1476">Wenn Sie eine änderbare Kopie der Zeichenfolge erstellen möchten, sodass Sie unsicheren Code verwenden können, um den Inhalt der Zeichenfolge zu ändern, verwenden Sie <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType>-Methode.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1476">If you want to create a mutable copy of the string so that you can use unsafe code to modify the string contents, use <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="8b8da-1477">Im folgenden Beispiel wird die <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType>-Methode verwendet, um einen Zeiger auf den Speicherort einer kopierten Zeichenfolge im nicht verwalteten Speicher zu erhalten, den Unicode-Codepunkt jedes Zeichens in der Zeichenfolge um eins zu erhöhen und die resultierende Zeichenfolge zurück in eine verwaltete Zeichenfolge zu kopieren.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1477">The following example uses the <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> method to get a pointer to the location of an copied string in unmanaged memory, increments the Unicode code point of each character in the string by one, and copies the resulting string back to a managed string.</span></span>

  [!code-csharp[Performing a string operation](~/samples/snippets/csharp/api/system/string/copy/program.cs#3)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-1478"><paramref name="str" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1478"><paramref name="str" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="string.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex"><span data-ttu-id="8b8da-1479">Der Index des ersten Zeichens in dieser Instanz, das kopiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1479">The index of the first character in this instance to copy.</span></span></param>
        <param name="destination"><span data-ttu-id="8b8da-1480">Ein Array von Unicode-Zeichen, in das Zeichen in dieser Instanz kopiert werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1480">An array of Unicode characters to which characters in this instance are copied.</span></span></param>
        <param name="destinationIndex"><span data-ttu-id="8b8da-1481">Der Index in <paramref name="destination" />, bei dem der Kopiervorgang beginnt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1481">The index in <paramref name="destination" /> at which the copy operation begins.</span></span></param>
        <param name="count"><span data-ttu-id="8b8da-1482">Die Anzahl der Zeichen in dieser Instanz, die nach <paramref name="destination" /> kopiert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1482">The number of characters in this instance to copy to <paramref name="destination" />.</span></span></param>
        <summary><span data-ttu-id="8b8da-1483">Kopiert eine angegebene Anzahl von Zeichen von einer angegebenen Position in dieser Instanz an eine angegebene Position in einem Array von Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1483">Copies a specified number of characters from a specified position in this instance to a specified position in an array of Unicode characters.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-1484">Diese Methode kopiert `count` Zeichen von der `sourceIndex` Position dieser Instanz in die `destinationIndex` Position `destination` Zeichen Arrays.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1484">This method copies `count` characters from the `sourceIndex` position of this instance to the `destinationIndex` position of `destination` character array.</span></span> <span data-ttu-id="8b8da-1485">Bei dieser Methode wird die Größe des `destination` Zeichen Arrays nicht geändert. Er muss über eine ausreichende Anzahl von Elementen verfügen, um die kopierten Zeichen aufnehmen zu können, oder die Methode löst eine <xref:System.ArgumentOutOfRangeException>aus.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1485">This method does not resize the `destination` character array; it must have a sufficient number of elements to accommodate the copied characters or the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span>

 <span data-ttu-id="8b8da-1486">`sourceIndex` und `destinationIndex` sind NULL basiert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1486">`sourceIndex` and `destinationIndex` are zero-based.</span></span>



## Examples
 <span data-ttu-id="8b8da-1487">Das folgende Beispiel veranschaulicht die <xref:System.String.CopyTo%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1487">The following example demonstrates the <xref:System.String.CopyTo%2A> method.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/stringcopyto/CPP/stringcopyto.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringcopyto/CS/stringcopyto.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringcopyto/VB/stringcopyto.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-1488"><paramref name="destination" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1488"><paramref name="destination" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-1489"><paramref name="sourceIndex" />, <paramref name="destinationIndex" /> oder <paramref name="count" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1489"><paramref name="sourceIndex" />, <paramref name="destinationIndex" />, or <paramref name="count" /> is negative</span></span>

<span data-ttu-id="8b8da-1490">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-1490">-or-</span></span>

 <span data-ttu-id="8b8da-1491"><paramref name="sourceIndex" /> identifiziert keine Position in der aktuellen Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1491"><paramref name="sourceIndex" /> does not identify a position in the current instance.</span></span>

<span data-ttu-id="8b8da-1492">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-1492">-or-</span></span>

 <span data-ttu-id="8b8da-1493"><paramref name="destinationIndex" /> identifiziert keinen gültigen Index im <paramref name="destination" />-Array.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1493"><paramref name="destinationIndex" /> does not identify a valid index in the <paramref name="destination" /> array.</span></span>

<span data-ttu-id="8b8da-1494">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-1494">-or-</span></span>

 <span data-ttu-id="8b8da-1495"><paramref name="count" /> ist größer als die Länge der Teilzeichenfolge von <paramref name="sourceIndex" /> bis zum Ende dieser Instanz</span><span class="sxs-lookup"><span data-stu-id="8b8da-1495"><paramref name="count" /> is greater than the length of the substring from <paramref name="sourceIndex" /> to the end of this instance</span></span>

<span data-ttu-id="8b8da-1496">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-1496">-or-</span></span>

 <span data-ttu-id="8b8da-1497"><paramref name="count" /> ist größer als die Länge des Teilarrays von <paramref name="destinationIndex" /> bis zum Ende des <paramref name="destination" />-Arrays.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1497"><paramref name="count" /> is greater than the length of the subarray from <paramref name="destinationIndex" /> to the end of the <paramref name="destination" /> array.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Create&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static string Create&lt;TState&gt; (int length, TState state, System.Buffers.SpanAction&lt;char,TState&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Create&lt;TState&gt;(int32 length, !!TState state, class System.Buffers.SpanAction`2&lt;char, !!TState&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Create``1(System.Int32,``0,System.Buffers.SpanAction{System.Char,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of TState) (length As Integer, state As TState, action As SpanAction(Of Char, TState)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static System::String ^ Create(int length, TState state, System::Buffers::SpanAction&lt;char, TState&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member Create : int * 'State * System.Buffers.SpanAction&lt;char, 'State&gt; -&gt; string" Usage="System.string.Create (length, state, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="length" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="action" Type="System.Buffers.SpanAction&lt;System.Char,TState&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <typeparam name="TState"><span data-ttu-id="8b8da-1498">Der Typ des Elements, das an <paramref name="action" />übergeben werden soll.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1498">The type of the element to pass to <paramref name="action" />.</span></span></typeparam>
        <param name="length"><span data-ttu-id="8b8da-1499">Die Länge der zu erstellenden Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1499">The length of the string to create.</span></span></param>
        <param name="state"><span data-ttu-id="8b8da-1500">Das an <paramref name="action" /> zu übergebende Element.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1500">The element to pass to <paramref name="action" />.</span></span></param>
        <param name="action"><span data-ttu-id="8b8da-1501">Ein Rückruf zum Initialisieren der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1501">A callback to initialize the string.</span></span></param>
        <summary><span data-ttu-id="8b8da-1502">Erstellt eine neue Zeichenfolge mit einer bestimmten Länge und initialisiert sie nach der Erstellung unter Verwendung des angegebenen Rückrufs.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1502">Creates a new string with a specific length and initializes it after creation by using the specified callback.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1503">Die erstellte Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1503">The created string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks
<span data-ttu-id="8b8da-1504">Der ursprüngliche Inhalt der Zielspanne, die an `action` übermittelt wird, ist nicht definiert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1504">The initial content of the destination span passed to `action` is undefined.</span></span> <span data-ttu-id="8b8da-1505">Daher ist es für den Delegaten zuständig, sicherzustellen, dass jedes Element der Spanne zugewiesen wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1505">Therefore, it is the delegate's responsibility to ensure that every element of the span is assigned.</span></span> <span data-ttu-id="8b8da-1506">Andernfalls könnte die resultierende Zeichenfolge zufällige Zeichen enthalten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1506">Otherwise, the resulting string could contain random characters.</span></span>
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static readonly string Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string Empty" />
      <MemberSignature Language="DocId" Value="F:System.String.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Empty As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ Empty;" />
      <MemberSignature Language="F#" Value=" staticval mutable Empty : string" Usage="System.string.Empty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8b8da-1507">Stellt die leere Zeichenfolge dar.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1507">Represents the empty string.</span></span> <span data-ttu-id="8b8da-1508">Dieses Feld ist schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1508">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-1509">Der Wert dieses Felds ist die Zeichenfolge mit der Länge 0 (null).</span><span class="sxs-lookup"><span data-stu-id="8b8da-1509">The value of this field is the zero-length string, "".</span></span>

 <span data-ttu-id="8b8da-1510">Im Anwendungscode wird dieses Feld am häufigsten in Zuweisungen verwendet, um eine Zeichen folgen Variable in eine leere Zeichenfolge zu initialisieren.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1510">In application code, this field is most commonly used in assignments to initialize a string variable to an empty string.</span></span> <span data-ttu-id="8b8da-1511">Verwenden Sie die <xref:System.String.IsNullOrEmpty%2A>-Methode, um zu testen, ob der Wert einer Zeichenfolge entweder `null` oder <xref:System.String.Empty?displayProperty=nameWithType>ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1511">To test whether the value of a string is either `null` or <xref:System.String.Empty?displayProperty=nameWithType>, use the <xref:System.String.IsNullOrEmpty%2A> method.</span></span>

 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="EndsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8b8da-1512">Bestimmt, ob das Ende dieser Zeichenfolgeninstanz mit einer angegebenen Zeichenfolge übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1512">Determines whether the end of this string instance matches a specified string.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (char value);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(char value) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.Char)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As Char) As Boolean" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(char value);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndsWith : char -&gt; bool" Usage="string.EndsWith value" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-1513">Das Zeichen, das mit dem Zeichen am Ende dieser Instanz verglichen werden soll.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1513">The character to compare to the character at the end of this instance.</span></span></param>
        <summary><span data-ttu-id="8b8da-1514">Bestimmt, ob das Ende dieser Zeichenfolgeninstanz mit dem angegebenen Zeichen übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1514">Determines whether the end of this string instance matches the specified character.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1515"><see langword="true" />, wenn <paramref name="value" /> mit dem Ende dieser Instanz übereinstimmt; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1515"><see langword="true" /> if <paramref name="value" /> matches the end of this instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="8b8da-1516">Diese Methode führt einen Kultur abhängigen Vergleich mit der aktuellen Kultur unter Beachtung von Groß-und Kleinschreibung durch.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1516">This method performs a case-sensitive and culture-sensitive comparison using the current culture.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-1517">Die Zeichenfolge, die mit der Teilzeichenfolge am Ende dieser Instanz verglichen werden soll.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1517">The string to compare to the substring at the end of this instance.</span></span></param>
        <summary><span data-ttu-id="8b8da-1518">Bestimmt, ob das Ende dieser Zeichenfolgeninstanz mit der angegebenen Zeichenfolge übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1518">Determines whether the end of this string instance matches the specified string.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1519"><see langword="true" />, wenn <paramref name="value" /> mit dem Ende dieser Instanz übereinstimmt; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1519"><see langword="true" /> if <paramref name="value" /> matches the end of this instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-1520">Diese Methode vergleicht `value` mit der Teil Zeichenfolge am Ende dieser Instanz, die dieselbe Länge wie `value`hat, und gibt eine Angabe darüber zurück, ob Sie gleich sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1520">This method compares `value` to the substring at the end of this instance that is the same length as `value`, and returns an indication whether they are equal.</span></span> <span data-ttu-id="8b8da-1521">Um gleich zu sein, müssen `value` ein Verweis auf dieselbe Instanz sein oder mit dem Ende dieser Instanz übereinstimmen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1521">To be equal, `value` must be a reference to this same instance or match the end of this instance.</span></span>

 <span data-ttu-id="8b8da-1522">Diese Methode führt einen Vergleich mit der aktuellen Kultur durch (Unterscheidung nach Groß-/Kleinschreibung und Kultur sensitiv).</span><span class="sxs-lookup"><span data-stu-id="8b8da-1522">This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</span></span>



## Examples
 <span data-ttu-id="8b8da-1523">Im folgenden Beispiel wird angegeben, ob jede Zeichenfolge in einem Array mit einem-Zeitraum (".") endet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1523">The following example indicates whether each string in an array ends with a period (".").</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.EndsWith/cs/EndsWith1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.EndsWith/vb/EndsWith1.vb" id="Snippet1":::

 <span data-ttu-id="8b8da-1524">Im folgenden Beispiel wird eine `StripEndTags`-Methode definiert, die die <xref:System.String.EndsWith%28System.String%29>-Methode verwendet, um HTML-Endtags vom Ende einer Zeile zu entfernen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1524">The following example defines a `StripEndTags` method that uses the <xref:System.String.EndsWith%28System.String%29> method to remove HTML end tags from the end of a line.</span></span> <span data-ttu-id="8b8da-1525">Beachten Sie, dass die `StripEndTags`-Methode rekursiv aufgerufen wird, um sicherzustellen, dass mehrere HTML-Endtags am Ende der Zeile entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1525">Note that the  `StripEndTags` method is called recursively to ensure that multiple HTML end tags at the end of the line are removed.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/stringendswith/CPP/stringendswith.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringendswith/CS/stringendswith.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringendswith/VB/stringendswith.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-1526"><paramref name="value" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1526"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-1527">Wie in [bewährte Methoden für die Verwendung von](~/docs/standard/base-types/best-practices-strings.md)Zeichen folgen erläutert, empfiehlt es sich, den Aufruf von Zeichen folgen Vergleichsmethoden zu vermeiden, die Standardwerte ersetzen, und stattdessen Methoden aufzurufen, für die Parameter explizit angegeben werden müssen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1527">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="8b8da-1528">Um zu ermitteln, ob eine Zeichenfolge mit einer bestimmten Teil Zeichenfolge endet, indem Sie die Regeln für den Zeichen folgen Vergleich der aktuellen Kultur verwenden, müssen Sie die <see cref="M:System.String.EndsWith(System.String,System.StringComparison)" />-Methoden Überladung mit dem Wert <see cref="F:System.StringComparison.CurrentCulture" /> für den <paramref name="comparisonType" /> Parameter aufrufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1528">To determine whether a string ends with a particular substring by using the string comparison rules of the current culture, call the <see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="M:System.String.StartsWith(System.String)" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * StringComparison -&gt; bool" Usage="string.EndsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-1529">Die Zeichenfolge, die mit der Teilzeichenfolge am Ende dieser Instanz verglichen werden soll.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1529">The string to compare to the substring at the end of this instance.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="8b8da-1530">Einer der Enumerationswerte, die bestimmen, wie diese Zeichenfolge und <paramref name="value" /> verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1530">One of the enumeration values that determines how this string and <paramref name="value" /> are compared.</span></span></param>
        <summary><span data-ttu-id="8b8da-1531">Bestimmt, ob das Ende dieser Zeichenfolgeninstanz bei einem Vergleich unter Verwendung der angegebenen Vergleichsoption mit der angegebenen Zeichenfolge übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1531">Determines whether the end of this string instance matches the specified string when compared using the specified comparison option.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1532"><see langword="true" />, wenn der <paramref name="value" />-Parameter mit dem Ende dieser Zeichenfolge übereinstimmt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1532"><see langword="true" /> if the <paramref name="value" /> parameter matches the end of this string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-1533">Die <xref:System.String.EndsWith%2A>-Methode vergleicht den `value`-Parameter mit der Teil Zeichenfolge am Ende dieser Zeichenfolge und gibt einen Wert zurück, der angibt, ob Sie gleich sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1533">The <xref:System.String.EndsWith%2A> method compares the `value` parameter to the substring at the end of this string and returns a value that indicates whether they are equal.</span></span> <span data-ttu-id="8b8da-1534">Um gleich zu sein, muss `value` ein Verweis auf dieselbe Zeichenfolge sein, muss eine leere Zeichenfolge ("") sein oder mit dem Ende dieser Zeichenfolge übereinstimmen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1534">To be equal, `value` must be a reference to this same string, must be the empty string (""), or must match the end of this string.</span></span> <span data-ttu-id="8b8da-1535">Der Typ des Vergleichs, der von der <xref:System.String.EndsWith%2A>-Methode ausgeführt wird, hängt vom Wert des `comparisonType`-Parameters ab.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1535">The type of comparison performed by the <xref:System.String.EndsWith%2A> method depends on the value of the `comparisonType` parameter.</span></span>



## Examples
 <span data-ttu-id="8b8da-1536">Im folgenden Beispiel wird bestimmt, ob eine Zeichenfolge mit einer bestimmten Teil Zeichenfolge endet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1536">The following example determines whether a string ends with a particular substring.</span></span> <span data-ttu-id="8b8da-1537">Die Ergebnisse sind von der Auswahl der Kultur betroffen, unabhängig davon, ob die Groß-/Kleinschreibung ignoriert wird und ob ein Ordinalvergleich durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1537">The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cpp/ewcmp.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cs/ewcmp.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.EndsWithCmp/vb/ewcmp.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-1538"><paramref name="value" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1538"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8b8da-1539"><paramref name="comparisonType" /> ist kein <see cref="T:System.StringComparison" />-Wert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1539"><paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.EndsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-1540">Die Zeichenfolge, die mit der Teilzeichenfolge am Ende dieser Instanz verglichen werden soll.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1540">The string to compare to the substring at the end of this instance.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="8b8da-1541"><see langword="true" />, wenn die Groß-/Kleinschreibung beim Vergleich ignoriert werden soll, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1541"><see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span></span></param>
        <param name="culture"><span data-ttu-id="8b8da-1542">Kulturinformationen, die bestimmen, wie diese Instanz und <paramref name="value" /> verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1542">Cultural information that determines how this instance and <paramref name="value" /> are compared.</span></span> <span data-ttu-id="8b8da-1543">Wenn <paramref name="culture" /><see langword="null" /> ist, wird die aktuelle Kultur verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1543">If <paramref name="culture" /> is <see langword="null" />, the current culture is used.</span></span></param>
        <summary><span data-ttu-id="8b8da-1544">Bestimmt, ob das Ende dieser Zeichenfolgeninstanz bei einem Vergleich unter Verwendung der angegebenen Kultur mit der angegebenen Zeichenfolge übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1544">Determines whether the end of this string instance matches the specified string when compared using the specified culture.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1545"><see langword="true" />, wenn der <paramref name="value" />-Parameter mit dem Ende dieser Zeichenfolge übereinstimmt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1545"><see langword="true" /> if the <paramref name="value" /> parameter matches the end of this string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-1546">Diese Methode vergleicht den `value`-Parameter mit der Teil Zeichenfolge am Ende dieser Zeichenfolge, die mit der gleichen Länge wie `value`identisch ist, und gibt einen Wert zurück, der angibt, ob Sie gleich sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1546">This method compares the `value` parameter to the substring at the end of this string that is the same length as `value`, and returns a value that indicates whether they are equal.</span></span> <span data-ttu-id="8b8da-1547">Um gleich zu sein, müssen `value` ein Verweis auf dieselbe Instanz sein oder mit dem Ende dieser Zeichenfolge übereinstimmen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1547">To be equal, `value` must be a reference to this same instance or match the end of this string.</span></span>

 <span data-ttu-id="8b8da-1548">Diese Methode führt einen (Kultur abhängigen) Wort Vergleich unter Verwendung der angegebenen Groß-und Kleinschreibung aus.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1548">This method performs a word (culture-sensitive) comparison using the specified casing and culture.</span></span>



## Examples
 <span data-ttu-id="8b8da-1549">Im folgenden Beispiel wird bestimmt, ob eine Zeichenfolge am Ende einer anderen Zeichenfolge auftritt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1549">The following example determines whether a string occurs at the end of another string.</span></span> <span data-ttu-id="8b8da-1550">Die <xref:System.String.EndsWith%2A>-Methode wird mehrmals mit Berücksichtigung von Groß-/Kleinschreibung, Unterscheidung nach Groß-/Kleinschreibung und unterschiedlichen Kulturen aufgerufen, die die Suchergebnisse beeinflussen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1550">The <xref:System.String.EndsWith%2A> method is called several times using case sensitivity, case insensitivity, and different cultures that influence the results of the search.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.EndsWithCI/cs/ewci.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.EndsWithCI/vb/ewci.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-1551"><paramref name="value" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1551"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <Member MemberName="EnumerateRunes">
      <MemberSignature Language="C#" Value="public System.Text.StringRuneEnumerator EnumerateRunes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Text.StringRuneEnumerator EnumerateRunes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EnumerateRunes" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateRunes () As StringRuneEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringRuneEnumerator EnumerateRunes();" />
      <MemberSignature Language="F#" Value="member this.EnumerateRunes : unit -&gt; System.Text.StringRuneEnumerator" Usage="string.EnumerateRunes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringRuneEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8b8da-1552">Gibt eine Enumeration von <see cref="T:System.Text.Rune" /> aus der Zeichenfolge zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1552">Returns an enumeration of <see cref="T:System.Text.Rune" /> from this string.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1553">Ein Rune-Zeichenfolgenenumerator.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1553">A string rune enumerator.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

### Remarks

<span data-ttu-id="8b8da-1554">Ungültige Sequenzen werden in der Enumeration durch <xref:System.Text.Rune.ReplacementChar?displayProperty=nameWithType>dargestellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1554">Invalid sequences are represented in the enumeration by <xref:System.Text.Rune.ReplacementChar?displayProperty=nameWithType>.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8b8da-1555">Bestimmt, ob zwei <see cref="T:System.String" />-Objekte denselben Wert haben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1555">Determines whether two <see cref="T:System.String" /> objects have the same value.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="string.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="8b8da-1556">Die Zeichenfolge, die mit dieser Instanz verglichen werden soll.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1556">The string to compare to this instance.</span></span></param>
        <summary><span data-ttu-id="8b8da-1557">Bestimmt, ob diese Instanz und ein angegebenes Objekt, das ebenfalls ein <see cref="T:System.String" />-Objekt sein muss, denselben Wert haben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1557">Determines whether this instance and a specified object, which must also be a <see cref="T:System.String" /> object, have the same value.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1558"><see langword="true" />, wenn <paramref name="obj" /> ein <see cref="T:System.String" /> ist und denselben Wert wie diese Instanz hat; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1558"><see langword="true" /> if <paramref name="obj" /> is a <see cref="T:System.String" /> and its value is the same as this instance; otherwise, <see langword="false" />.</span></span>  <span data-ttu-id="8b8da-1559">Wenn <paramref name="obj" /> gleich <see langword="null" /> ist, gibt die Methode <see langword="false" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1559">If <paramref name="obj" /> is <see langword="null" />, the method returns <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-1560">Diese Methode führt einen Ordinalvergleich (Groß-/Kleinschreibung und Kultur unabhängige) aus.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1560">This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span>



## Examples
 <span data-ttu-id="8b8da-1561">Das folgende Beispiel veranschaulicht die <xref:System.String.Equals%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1561">The following example demonstrates the <xref:System.String.Equals%2A> method.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(string value) cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::String ^ value);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.Equals : string -&gt; bool" Usage="string.Equals value" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(string value) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::String ^ value);" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-1562">Die Zeichenfolge, die mit dieser Instanz verglichen werden soll.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1562">The string to compare to this instance.</span></span></param>
        <summary><span data-ttu-id="8b8da-1563">Bestimmt, ob diese Instanz und ein anderes angegebenes <see cref="T:System.String" />-Objekt denselben Wert haben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1563">Determines whether this instance and another specified <see cref="T:System.String" /> object have the same value.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1564"><see langword="true" />, wenn der <paramref name="value" />-Parameter und diese Instanz denselben Wert haben, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1564"><see langword="true" /> if the value of the <paramref name="value" /> parameter is the same as the value of this instance; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="8b8da-1565">Wenn <paramref name="value" /> gleich <see langword="null" /> ist, gibt die Methode <see langword="false" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1565">If <paramref name="value" /> is <see langword="null" />, the method returns <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-1566">Diese Methode führt einen Ordinalvergleich (Groß-/Kleinschreibung und Kultur unabhängige) aus.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1566">This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span>



## Examples
 <span data-ttu-id="8b8da-1567">Das folgende Beispiel veranschaulicht die <xref:System.String.Equals%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1567">The following example demonstrates the <xref:System.String.Equals%2A> method.</span></span> <span data-ttu-id="8b8da-1568">Dabei wird das Wort "file" mit dem Titel "file" mit einem äquivalenten Wort, der Entsprechung in Kleinbuchstaben, der Entsprechung in Großbuchstaben und einem Wort, das lateinische Small Letter DOTLESS i (u + 0131) anstelle von Latin Small Letter i (u + 0069) enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1568">It compares the title-cased word "File" with an equivalent word, its lowercase equivalent, its uppercase equivalent, and a word that contains LATIN SMALL LETTER DOTLESS I (U+0131) instead of LATIN SMALL LETTER I (U+0069).</span></span> <span data-ttu-id="8b8da-1569">Da die <xref:System.String.Equals%28System.String%29>-Methode einen Ordinalvergleich durchführt, gibt nur der Vergleich mit einem identischen Wort `true`zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1569">Because the <xref:System.String.Equals%28System.String%29> method performs an ordinal comparison, only the comparison with an identical word returns `true`.</span></span>

 [!code-csharp[System.String.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equalsex1.cs#2)]
 [!code-vb[System.String.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equalsex1.vb#2)]

 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string -&gt; bool" Usage="System.string.Equals (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="8b8da-1570">Die erste Zeichenfolge für den Vergleich oder <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1570">The first string to compare, or <see langword="null" />.</span></span></param>
        <param name="b"><span data-ttu-id="8b8da-1571">Die zweite Zeichenfolge für den Vergleich oder <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1571">The second string to compare, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="8b8da-1572">Bestimmt, ob zwei angegebene <see cref="T:System.String" />-Objekte denselben Wert haben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1572">Determines whether two specified <see cref="T:System.String" /> objects have the same value.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1573"><see langword="true" />, wenn <paramref name="a" /> und <paramref name="b" /> denselben Wert haben, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1573"><see langword="true" /> if the value of <paramref name="a" /> is the same as the value of <paramref name="b" />; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="8b8da-1574">Wenn <paramref name="a" /> und <paramref name="b" /><see langword="null" /> sind, gibt diese Methode <see langword="true" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1574">If both <paramref name="a" /> and <paramref name="b" /> are <see langword="null" />, the method returns <see langword="true" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-1575">Diese Methode führt einen Ordinalvergleich (Groß-/Kleinschreibung und Kultur unabhängige) aus.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1575">This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span>



## Examples
 <span data-ttu-id="8b8da-1576">Das folgende Beispiel veranschaulicht die <xref:System.String.Equals%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1576">The following example demonstrates the <xref:System.String.Equals%2A> method.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.Equals : string * StringComparison -&gt; bool" Usage="string.Equals (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-1577">Die Zeichenfolge, die mit dieser Instanz verglichen werden soll.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1577">The string to compare to this instance.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="8b8da-1578">Einer der Enumerationswerte, die angeben, wie die Zeichenfolgen verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1578">One of the enumeration values that specifies how the strings will be compared.</span></span></param>
        <summary><span data-ttu-id="8b8da-1579">Bestimmt, ob diese Zeichenfolge und ein angegebenes <see cref="T:System.String" />-Objekt denselben Wert haben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1579">Determines whether this string and a specified <see cref="T:System.String" /> object have the same value.</span></span> <span data-ttu-id="8b8da-1580">Ein Parameter gibt die Kultur, Berücksichtigung von Groß- und Kleinschreibung und Sortierregeln, die für den Vergleich verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1580">A parameter specifies the culture, case, and sort rules used in the comparison.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1581"><see langword="true" />, wenn der <paramref name="value" />-Parameter und diese Zeichenfolge denselben Wert haben; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1581"><see langword="true" /> if the value of the <paramref name="value" /> parameter is the same as this string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-1582">Der `comparisonType`-Parameter gibt an, ob der Vergleich die aktuelle oder die invariante Kultur verwenden soll, die Groß-/Kleinschreibung der beiden zu vergleichenden Zeichen folgen berücksichtigt oder ignoriert oder ob Wort-oder ordinalsortier Regeln verwendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1582">The `comparisonType` parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the two strings being compared, or use word or ordinal sort rules.</span></span>



## Examples
 <span data-ttu-id="8b8da-1583">Im folgenden Beispiel wird ein Zeichen folgen Array erstellt, das aus einem Großbuchstaben "i", einem Kleinbuchstaben "i" und einem DOTLESS-"ı" besteht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1583">The following example creates a string array that consists of an uppercase "I", a lowercase "i", and a dotless "ı".</span></span> <span data-ttu-id="8b8da-1584">Anschließend wird die <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29>-Methode aufgerufen, um Sie mit jedem möglichen <xref:System.StringComparison> Enumerationswert zu vergleichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1584">It then calls the <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> method to compare them by using each possible <xref:System.StringComparison> enumeration value.</span></span>

 [!code-csharp[System.String.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/eqcmp.cs#1)]
 [!code-vb[System.String.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/eqcmp.vb#1)]

 <span data-ttu-id="8b8da-1585">Im folgenden Beispiel werden vier Sätze von Wörtern mit jedem Member der <xref:System.StringComparison>-Enumeration verglichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1585">The following example compares four sets of words by using each member of the <xref:System.StringComparison> enumeration.</span></span>  <span data-ttu-id="8b8da-1586">Die Vergleiche verwenden die Konventionen der Kulturen Englisch (USA) und Sami (Upper Sweden).</span><span class="sxs-lookup"><span data-stu-id="8b8da-1586">The comparisons use the conventions of the English (United States) and Sami (Upper Sweden) cultures.</span></span> <span data-ttu-id="8b8da-1587">Beachten Sie, dass die Zeichen folgen "enzyklopäædia" und "Enzyklopädie" in der Kultur "en-US", aber nicht in der Kultur "Sami (Nordschweden)" gleichwertig betrachtet werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1587">Note that the strings "encyclopædia" and "encyclopaedia" are considered equivalent in the en-US culture but not in the Sami (Northern Sweden) culture.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex4.cs" interactive="try-dotnet" id="Snippet4":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex4.vb" id="Snippet4":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8b8da-1588"><paramref name="comparisonType" /> ist kein <see cref="T:System.StringComparison" />-Wert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1588"><paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string * StringComparison -&gt; bool" Usage="System.string.Equals (a, b, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="b" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="8b8da-1589">Die erste Zeichenfolge für den Vergleich oder <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1589">The first string to compare, or <see langword="null" />.</span></span></param>
        <param name="b"><span data-ttu-id="8b8da-1590">Die zweite Zeichenfolge für den Vergleich oder <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1590">The second string to compare, or <see langword="null" />.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="8b8da-1591">Einer der Enumerationswerte, der die Regeln für den Vergleich angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1591">One of the enumeration values that specifies the rules for the comparison.</span></span></param>
        <summary><span data-ttu-id="8b8da-1592">Bestimmt, ob zwei angegebene <see cref="T:System.String" />-Objekte denselben Wert haben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1592">Determines whether two specified <see cref="T:System.String" /> objects have the same value.</span></span> <span data-ttu-id="8b8da-1593">Ein Parameter gibt die Kultur, Berücksichtigung von Groß- und Kleinschreibung und Sortierregeln, die für den Vergleich verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1593">A parameter specifies the culture, case, and sort rules used in the comparison.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1594"><see langword="true" />, wenn der Wert des <paramref name="a" />-Parameters dem Wert des <paramref name="b" />-Parameters entspricht, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1594"><see langword="true" /> if the value of the <paramref name="a" /> parameter is equal to the value of the <paramref name="b" /> parameter; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-1595">Der `comparisonType`-Parameter gibt an, ob der Vergleich die aktuelle oder die invariante Kultur verwenden soll, die Groß-/Kleinschreibung der beiden zu vergleichenden Zeichen folgen berücksichtigt oder ignoriert oder ob Wort-oder ordinalsortier Regeln verwendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1595">The `comparisonType` parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the two strings being compared, or use word or ordinal sort rules.</span></span>



## Examples
 <span data-ttu-id="8b8da-1596">Im folgenden Beispiel werden vier Sätze von Wörtern mit jedem Member der <xref:System.StringComparison>-Enumeration verglichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1596">The following example compares four sets of words by using each member of the <xref:System.StringComparison> enumeration.</span></span>  <span data-ttu-id="8b8da-1597">Die Vergleiche verwenden die Konventionen der Kulturen Englisch (USA) und Sami (Upper Sweden).</span><span class="sxs-lookup"><span data-stu-id="8b8da-1597">The comparisons use the conventions of the English (United States) and Sami (Upper Sweden) cultures.</span></span> <span data-ttu-id="8b8da-1598">Beachten Sie, dass die Zeichen folgen "enzyklopäædia" und "Enzyklopädie" in der Kultur "en-US", aber nicht in der Kultur "Sami (Nordschweden)" gleichwertig betrachtet werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1598">Note that the strings "encyclopædia" and "encyclopaedia" are considered equivalent in the en-US culture but not in the Sami (Northern Sweden) culture.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex3.cs" interactive="try-dotnet" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex3.vb" id="Snippet3":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8b8da-1599"><paramref name="comparisonType" /> ist kein <see cref="T:System.StringComparison" />-Wert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1599"><paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Format">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8b8da-1600">Konvertiert auf der Grundlage der angegebenen Formate den Wert von Objekten in Zeichenfolgen und fügt sie in eine andere Zeichenfolge ein.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1600">Converts the value of objects to strings based on the formats specified and inserts them into another string.</span></span>

<span data-ttu-id="8b8da-1601">Wenn Sie die `String.Format`-Methode noch nicht kennen, lesen Sie den Abschnitt zur [String.Format-Methode](#Starting), um sich einen Überblick zu verschaffen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1601">If you are new to the `String.Format` method, see the [Get started with the String.Format method](#Starting) section for a quick overview.</span></span>

<span data-ttu-id="8b8da-1602">Eine allgemeine Dokumentation zur [-Methode finden Sie im Abschnitt ](#remarks-top)Hinweise`String.Format`.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1602">See the [Remarks](#remarks-top) section for general documentation for the `String.Format` method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

<a name="remarks-top"></a>
## Remarks

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)]

 <span data-ttu-id="8b8da-1603">In diesem Abschnitt</span><span class="sxs-lookup"><span data-stu-id="8b8da-1603">In this section:</span></span>

 <span data-ttu-id="8b8da-1604">[Beginnen Sie mit der String. Format-Methode](#Starting) [, welche Methode wird aufgerufen?](#FTaskList)</span><span class="sxs-lookup"><span data-stu-id="8b8da-1604">[Get started with the String.Format method](#Starting) [Which method do I call?](#FTaskList)</span></span>
 <span data-ttu-id="8b8da-1605">[Die Format-Methode im kurzen](#Format_Brief) [Format Element](#FormatItem) [gibt an, wie Argumente formatierte](#HowFormatted) Formatierungs [Elemente aufweisen, die dieselbe Index](#SameIndex) [Formatierung und](#Format_Culture) [benutzerdefinierte Formatierung für die benutzerdefinierte Formatierung](#Format_Custom) aufweisen [. f & A](#QA)</span><span class="sxs-lookup"><span data-stu-id="8b8da-1605">[The Format method in brief](#Format_Brief) [The Format item](#FormatItem) [How arguments are formatted](#HowFormatted) [Format items that have the same index](#SameIndex) [Formatting and culture](#Format_Culture) [Custom formatting operations](#Format_Custom) [String.Format Q & A](#QA)</span></span>

<a name="Starting"></a>
## <a name="get-started-with-the-stringformat-method"></a><span data-ttu-id="8b8da-1606">Beginnen Sie mit der String. Format-Methode</span><span class="sxs-lookup"><span data-stu-id="8b8da-1606">Get started with the String.Format method</span></span>
 <span data-ttu-id="8b8da-1607">Verwenden Sie <xref:System.String.Format%2A?displayProperty=nameWithType>, wenn Sie den Wert eines Objekts, einer Variablen oder eines Ausdrucks in eine andere Zeichenfolge einfügen müssen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1607">Use <xref:System.String.Format%2A?displayProperty=nameWithType> if you need to insert the value of an object, variable, or expression into another string.</span></span> <span data-ttu-id="8b8da-1608">Beispielsweise können Sie den Wert eines <xref:System.Decimal> Werts in eine Zeichenfolge einfügen, damit Sie dem Benutzer als einzelne Zeichenfolge angezeigt wird:</span><span class="sxs-lookup"><span data-stu-id="8b8da-1608">For example, you can insert the value of a <xref:System.Decimal> value into a string to display it to the user as a single string:</span></span>

 [!code-cpp[System.String.Format#35](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#35)]
 [!code-csharp-interactive[System.String.Format#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#35)]
 [!code-vb[System.String.Format#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#35)]

 <span data-ttu-id="8b8da-1609">Und Sie können die Formatierung dieses Werts Steuern:</span><span class="sxs-lookup"><span data-stu-id="8b8da-1609">And you can control that value's formatting:</span></span>

 [!code-cpp[System.String.Format#36](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#36)]
 [!code-csharp[System.String.Format#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#36)]
 [!code-vb[System.String.Format#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#36)]

 <span data-ttu-id="8b8da-1610">Neben der Formatierung können Sie auch die Ausrichtung und den Abstand steuern.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1610">Besides formatting, you can also control alignment and spacing.</span></span>

 ### <a name="insert-a-string"></a><span data-ttu-id="8b8da-1611">Einfügen einer Zeichenfolge</span><span class="sxs-lookup"><span data-stu-id="8b8da-1611">Insert a string</span></span>

 <span data-ttu-id="8b8da-1612"><xref:System.String.Format%2A?displayProperty=nameWithType> beginnt mit einer Format Zeichenfolge, gefolgt von einem oder mehreren Objekten oder Ausdrücken, die in Zeichen folgen konvertiert und an einer bestimmten Stelle in der Format Zeichenfolge eingefügt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1612"><xref:System.String.Format%2A?displayProperty=nameWithType> starts with a format string, followed by one or more objects or expressions that will be converted to strings and inserted at a specified place in the format string.</span></span> <span data-ttu-id="8b8da-1613">Beispiel:</span><span class="sxs-lookup"><span data-stu-id="8b8da-1613">For example:</span></span>

 [!code-cpp[System.String.Format#30](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#30)]
 [!code-csharp-interactive[System.String.Format#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#30)]
 [!code-vb[System.String.Format#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#30)]

 <span data-ttu-id="8b8da-1614">Der `{0}` in der Format Zeichenfolge ist ein Format Element.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1614">The `{0}` in the format string is a format item.</span></span> <span data-ttu-id="8b8da-1615">`0` ist der Index des Objekts, dessen Zeichen folgen Wert an dieser Position eingefügt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1615">`0` is the index of the object whose string value will be inserted at that position.</span></span> <span data-ttu-id="8b8da-1616">(Indizes beginnen bei 0.) Wenn das einzufügende Objekt keine Zeichenfolge ist, wird die `ToString`-Methode aufgerufen, um Sie in eine zu konvertieren, bevor Sie in die Ergebnis Zeichenfolge eingefügt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1616">(Indexes start at 0.) If the object to be inserted is not a string, its `ToString` method is called to convert it to one before inserting it in the result string.</span></span>

 <span data-ttu-id="8b8da-1617">Im folgenden finden Sie ein weiteres Beispiel, in dem zwei Format Elemente und zwei-Objekte in der Objektliste verwendet werden:</span><span class="sxs-lookup"><span data-stu-id="8b8da-1617">Here's another example that uses two format items and two objects in the object list:</span></span>

 [!code-cpp[System.String.Format#31](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#31)]
 [!code-csharp[System.String.Format#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#31)]
 [!code-vb[System.String.Format#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#31)]

 <span data-ttu-id="8b8da-1618">Sie können beliebig viele Format Elemente und beliebig viele Objekte in der Objektliste enthalten, solange der Index jedes Format Elements über ein entsprechendes Objekt in der Objektliste verfügt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1618">You can have as many format items and as many objects in the object list as you want, as long as the index of every format item has a matching object in the object list.</span></span> <span data-ttu-id="8b8da-1619">Außerdem müssen Sie sich keine Gedanken darüber machen, welche Überlastung Sie aufrufen. der Compiler wählt den entsprechenden für Sie aus.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1619">You also don't have to worry about which overload you call; the compiler will select the appropriate one for you.</span></span>

 ### <a name="control-formatting"></a><span data-ttu-id="8b8da-1620">Formatierung von Steuerelementen</span><span class="sxs-lookup"><span data-stu-id="8b8da-1620">Control formatting</span></span>
 <span data-ttu-id="8b8da-1621">Sie können den Index in einem Format Element mit einer Format Zeichenfolge befolgen, um zu steuern, wie ein Objekt formatiert wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1621">You can follow the index in a format item with a format string to control how an object is formatted.</span></span> <span data-ttu-id="8b8da-1622">`{0:d}` wendet z. b. die Format Zeichenfolge "d" auf das erste Objekt in der Objektliste an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1622">For example, `{0:d}` applies the "d" format string to the first object in the object list.</span></span> <span data-ttu-id="8b8da-1623">Im folgenden finden Sie ein Beispiel mit einem einzelnen-Objekt und zwei Format Elementen:</span><span class="sxs-lookup"><span data-stu-id="8b8da-1623">Here is an example with a single object and two format items:</span></span>

 [!code-cpp[System.String.Format#32](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#32)]
 [!code-csharp[System.String.Format#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#32)]
 [!code-vb[System.String.Format#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#32)]

 <span data-ttu-id="8b8da-1624">Eine Reihe von Typen unterstützen Format Zeichenfolgen, einschließlich aller numerischen Typen ( [standardmäßige](~/docs/standard/base-types/standard-numeric-format-strings.md) und [benutzerdefinierte](~/docs/standard/base-types/custom-numeric-format-strings.md) Format Zeichenfolgen), Datums-und Uhrzeitangaben ( [standardmäßige](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und [benutzerdefinierte](~/docs/standard/base-types/custom-date-and-time-format-strings.md) Format Zeichenfolgen) und Zeitintervallen ( [standardmäßige](~/docs/standard/base-types/standard-timespan-format-strings.md) und [Benutzer](~/docs/standard/base-types/custom-timespan-format-strings.md) definierte Format Zeichenfolgen), alle Enumerationstypen [-](xref:System.Guid.ToString(System.String))Enumerationstypen [enumeration types](~/docs/standard/base-types/enumeration-format-strings.md)</span><span class="sxs-lookup"><span data-stu-id="8b8da-1624">A number of types support format strings, including all numeric types (both [standard](~/docs/standard/base-types/standard-numeric-format-strings.md) and [custom](~/docs/standard/base-types/custom-numeric-format-strings.md) format strings), all dates and times (both [standard](~/docs/standard/base-types/standard-date-and-time-format-strings.md) and [custom](~/docs/standard/base-types/custom-date-and-time-format-strings.md) format strings) and time intervals (both [standard](~/docs/standard/base-types/standard-timespan-format-strings.md) and [custom](~/docs/standard/base-types/custom-timespan-format-strings.md) format strings), all enumeration types [enumeration types](~/docs/standard/base-types/enumeration-format-strings.md), and [GUIDs](xref:System.Guid.ToString(System.String)).</span></span> <span data-ttu-id="8b8da-1625">Sie können auch Unterstützung für Format Zeichenfolgen zu ihren eigenen Typen hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1625">You can also add support for format strings to your own types.</span></span>

 ### <a name="control-spacing"></a><span data-ttu-id="8b8da-1626">Abstand von Steuerelementen</span><span class="sxs-lookup"><span data-stu-id="8b8da-1626">Control spacing</span></span>
 <span data-ttu-id="8b8da-1627">Sie können die Breite der Zeichenfolge, die in die Ergebnis Zeichenfolge eingefügt wird, mithilfe von Syntax definieren, wie z. b. `{0,12}`, die eine Zeichenfolge mit 12 Zeichen einfügt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1627">You can define the width of the string that is inserted into the result string by using syntax such as `{0,12}`, which inserts a 12-character string.</span></span> <span data-ttu-id="8b8da-1628">In diesem Fall wird die Zeichen folgen Darstellung des ersten Objekts rechtsbündig im Feld mit 12 Zeichen ausgerichtet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1628">In this case, the string representation of the first object is right-aligned in the 12-character field.</span></span>  <span data-ttu-id="8b8da-1629">(Wenn die Zeichen folgen Darstellung des ersten Objekts mehr als 12 Zeichen lang ist, wird jedoch die bevorzugte Feldbreite ignoriert, und die gesamte Zeichenfolge wird in die Ergebnis Zeichenfolge eingefügt.)</span><span class="sxs-lookup"><span data-stu-id="8b8da-1629">(If the string representation of the first object is more than 12 characters in length, though, the preferred field width is ignored, and the entire string is inserted into the result string.)</span></span>

 <span data-ttu-id="8b8da-1630">Im folgenden Beispiel wird ein Zeichen aus 6 Zeichen definiert, das die Zeichenfolge "Year" und einige Jahr-Zeichen folgen enthält, sowie ein Feld mit 15 Zeichen, das die Zeichenfolge "Population" und einige auffüllungs Daten enthalten soll.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1630">The following example defines a 6-character field to hold the string "Year" and some year strings, as well as an 15-character field to hold the string "Population" and some population data.</span></span> <span data-ttu-id="8b8da-1631">Beachten Sie, dass die Zeichen rechtsbündig in dem Feld ausgerichtet sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1631">Note that the characters are right-aligned in the field.</span></span>

 [!code-cpp[System.String.Format#33](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#33)]
 [!code-csharp[System.String.Format#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting3.cs#33)]
 [!code-vb[System.String.Format#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#33)]

 ### <a name="control-alignment"></a><span data-ttu-id="8b8da-1632">Steuerelement Ausrichtung</span><span class="sxs-lookup"><span data-stu-id="8b8da-1632">Control alignment</span></span>
 <span data-ttu-id="8b8da-1633">Standardmäßig werden Zeichen folgen rechtsbündig ausgerichtet, wenn Sie eine Feldbreite angeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1633">By default, strings are right-aligned within their field if you specify a field width.</span></span> <span data-ttu-id="8b8da-1634">Wenn Zeichen folgen in einem Feld linksbündig ausgerichtet werden sollen, wird der Feldbreite ein negatives Vorzeichen vorangestellt, z. b. `{0,-12}`, um ein nach links Bündiges Feld mit 12 Zeichen zu definieren.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1634">To left-align strings in a field, you preface the field width with a negative sign, such as `{0,-12}` to define a 12-character left-aligned field.</span></span>

 <span data-ttu-id="8b8da-1635">Das folgende Beispiel ähnelt dem vorherigen, mit der Ausnahme, dass es sowohl Bezeichnungen als auch Daten linksbündig ausgerichtet ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1635">The following example is similar to the previous one, except that it left-aligns both labels and data.</span></span>

 [!code-cpp[System.String.Format#34](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#34)]
 [!code-csharp[System.String.Format#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#34)]
 [!code-vb[System.String.Format#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#34)]

 <span data-ttu-id="8b8da-1636"><xref:System.String.Format%2A?displayProperty=nameWithType> verwendet die Funktion für die kombinierte Formatierung.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1636"><xref:System.String.Format%2A?displayProperty=nameWithType> makes use of the composite formatting feature.</span></span> <span data-ttu-id="8b8da-1637">Weitere Informationen finden Sie unter [Zusammengesetzte Formatierung](~/docs/standard/base-types/composite-formatting.md).</span><span class="sxs-lookup"><span data-stu-id="8b8da-1637">For more information, see [Composite Formatting](~/docs/standard/base-types/composite-formatting.md).</span></span>

<a name="FTaskList"></a>
## <a name="which-method-do-i-call"></a><span data-ttu-id="8b8da-1638">Welche Methode rufe ich auf?</span><span class="sxs-lookup"><span data-stu-id="8b8da-1638">Which method do I call?</span></span>

|<span data-ttu-id="8b8da-1639">An</span><span class="sxs-lookup"><span data-stu-id="8b8da-1639">To</span></span>|<span data-ttu-id="8b8da-1640">Call</span><span class="sxs-lookup"><span data-stu-id="8b8da-1640">Call</span></span>|
|--------|----------|
|<span data-ttu-id="8b8da-1641">Formatiert ein oder mehrere-Objekte, indem die Konventionen der aktuellen Kultur verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1641">Format one or more objects by using the conventions of the current culture.</span></span>|<span data-ttu-id="8b8da-1642">Mit Ausnahme der über Ladungen, die einen `provider`-Parameter enthalten, enthalten die verbleibenden <xref:System.String.Format%2A> Überladungen einen <xref:System.String>-Parameter, gefolgt von einem oder mehreren Objekt Parametern.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1642">Except for the overloads that include a `provider` parameter, the remaining <xref:System.String.Format%2A> overloads include a <xref:System.String> parameter followed by one or more object parameters.</span></span> <span data-ttu-id="8b8da-1643">Aus diesem Grund müssen Sie nicht ermitteln, welche <xref:System.String.Format%2A> Überladung Sie aufrufen möchten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1643">Because of this, you don't have to determine which <xref:System.String.Format%2A> overload you intend to call.</span></span> <span data-ttu-id="8b8da-1644">Der sprach Compiler wählt die entsprechende Überladung aus den über Ladungen aus, die nicht über einen `provider` Parameter verfügen, basierend auf der Argumentliste.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1644">Your language compiler selects the appropriate overload from among the overloads that don't have a `provider` parameter, based on your argument list.</span></span> <span data-ttu-id="8b8da-1645">Wenn Ihre Argumentliste beispielsweise fünf Argumente enthält, ruft der Compiler die <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29>-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1645">For example, if your argument list has five arguments, the compiler calls the <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> method.</span></span>|
|<span data-ttu-id="8b8da-1646">Formatieren eines oder mehrerer-Objekte mithilfe der Konventionen einer bestimmten Kultur.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1646">Format one or more objects by using the conventions of a specific culture.</span></span>|<span data-ttu-id="8b8da-1647">Auf jede <xref:System.String.Format%2A> Überladung, die mit einem `provider`-Parameter beginnt, folgt ein <xref:System.String> Parameter und mindestens ein Objekt Parameter.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1647">Each <xref:System.String.Format%2A> overload that begins with a `provider` parameter is followed by a <xref:System.String> parameter and one or more object parameters.</span></span> <span data-ttu-id="8b8da-1648">Aus diesem Grund müssen Sie nicht ermitteln, welche spezifische <xref:System.String.Format%2A> Überladung Sie aufrufen möchten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1648">Because of this, you don't have to determine which specific <xref:System.String.Format%2A> overload you intend to call.</span></span> <span data-ttu-id="8b8da-1649">Der sprach Compiler wählt basierend auf der Argumentliste die entsprechende Überladung aus den über Ladungen aus, die über einen `provider`-Parameter verfügen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1649">Your language compiler selects the appropriate overload from among the overloads that have a `provider` parameter, based on your argument list.</span></span> <span data-ttu-id="8b8da-1650">Wenn Ihre Argumentliste beispielsweise fünf Argumente enthält, ruft der Compiler die <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1650">For example, if your argument list has five arguments, the compiler calls the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> method.</span></span>|
|<span data-ttu-id="8b8da-1651">Führen Sie einen benutzerdefinierten Formatierungs Vorgang entweder mit einer <xref:System.ICustomFormatter>-Implementierung oder einer <xref:System.IFormattable>-Implementierung aus.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1651">Perform a custom formatting operation either with an <xref:System.ICustomFormatter> implementation or an <xref:System.IFormattable> implementation.</span></span>|<span data-ttu-id="8b8da-1652">Eine der vier über Ladungen mit einem `provider`-Parameter.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1652">Any of the four overloads with a `provider` parameter.</span></span> <span data-ttu-id="8b8da-1653">Der Compiler wählt basierend auf der Argumentliste die entsprechende Überladung aus den über Ladungen aus, die über einen `provider`-Parameter verfügen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1653">The compiler selects the appropriate overload from among the overloads that have a `provider` parameter, based on your argument list.</span></span>|

<a name="Format_Brief"></a>
## <a name="the-format-method-in-brief"></a><span data-ttu-id="8b8da-1654">Die Format-Methode kurz</span><span class="sxs-lookup"><span data-stu-id="8b8da-1654">The Format method in brief</span></span>

 <span data-ttu-id="8b8da-1655">Jede Überladung der <xref:System.String.Format%2A>-Methode verwendet die Funktion für die [kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) , um null-basierte indizierte Platzhalter ( *Format Elemente*) in einer zusammengesetzten Format Zeichenfolge einzuschließen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1655">Each overload of the <xref:System.String.Format%2A> method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to include zero-based indexed placeholders, called *format items*, in a composite format string.</span></span> <span data-ttu-id="8b8da-1656">Zur Laufzeit wird jedes Format Element durch die Zeichen folgen Darstellung des entsprechenden Arguments in einer Parameterliste ersetzt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1656">At run time, each format item is replaced with the string representation of the corresponding argument in a parameter list.</span></span> <span data-ttu-id="8b8da-1657">Wenn der Wert des Arguments `null`ist, wird das Format Element durch <xref:System.String.Empty?displayProperty=nameWithType>ersetzt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1657">If the value of the argument is `null`, the format item is replaced with <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8b8da-1658">Beispielsweise enthält der folgende Aufrufe der <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29>-Methode eine Format Zeichenfolge mit drei Format Elementen, {0}, {1}und {2}sowie eine Argumentliste mit drei Elementen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1658">For example, the following call to the <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> method includes a format string with three format items, {0}, {1}, and {2}, and an argument list with three items.</span></span>

 [!code-cpp[System.String.Format#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload1.cpp#8)]
 [!code-csharp[System.String.Format#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload1.cs#8)]
 [!code-vb[System.String.Format#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload1.vb#8)]

<a name="FormatItem"></a>
## <a name="the-format-item"></a><span data-ttu-id="8b8da-1659">Das Format Element</span><span class="sxs-lookup"><span data-stu-id="8b8da-1659">The format item</span></span>
 <span data-ttu-id="8b8da-1660">Ein Format Element weist folgende Syntax auf:</span><span class="sxs-lookup"><span data-stu-id="8b8da-1660">A format item has this syntax:</span></span>

```
{index[,alignment][:formatString]}
```

 <span data-ttu-id="8b8da-1661">Eckige Klammern kennzeichnen optionale Elemente.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1661">Brackets denote optional elements.</span></span> <span data-ttu-id="8b8da-1662">Die öffnenden und schließenden geschweiften Klammern sind erforderlich.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1662">The opening and closing braces are required.</span></span> <span data-ttu-id="8b8da-1663">(Um eine Literale öffnende oder schließende geschweifte Klammer in der Format Zeichenfolge einzuschließen, lesen Sie den Abschnitt [escapeklammern](~/docs/standard/base-types/composite-formatting.md#escaping-braces) im Artikel zusammen [gesetzte Formatierung](~/docs/standard/base-types/composite-formatting.md) .)</span><span class="sxs-lookup"><span data-stu-id="8b8da-1663">(To include a literal opening or closing brace in the format string, see the [Escaping Braces](~/docs/standard/base-types/composite-formatting.md#escaping-braces) section in the [Composite Formatting](~/docs/standard/base-types/composite-formatting.md) article.)</span></span>

 <span data-ttu-id="8b8da-1664">Ein Format Element zum Formatieren eines Währungs Werts könnte z. b. folgendermaßen aussehen:</span><span class="sxs-lookup"><span data-stu-id="8b8da-1664">For example, a format item to format a currency value might appear like this:</span></span>

 [!code-cpp[System.String.Format#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatsyntax1.cpp#12)]
 [!code-csharp[System.String.Format#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatsyntax1.cs#12)]
 [!code-vb[System.String.Format#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatsyntax1.vb#12)]

 <span data-ttu-id="8b8da-1665">Ein Format Element verfügt über die folgenden Elemente:</span><span class="sxs-lookup"><span data-stu-id="8b8da-1665">A format item has the following elements:</span></span>

 <span data-ttu-id="8b8da-1666">*Index* Der null basierte Index des Arguments, dessen Zeichen folgen Darstellung an dieser Position in der Zeichenfolge eingefügt werden soll.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1666">*index* The zero-based index of the argument whose string representation is to be included at this position in the string.</span></span> <span data-ttu-id="8b8da-1667">Wenn dieses Argument `null`ist, wird an dieser Position in der Zeichenfolge eine leere Zeichenfolge eingefügt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1667">If this argument is `null`, an empty string will be included at this position in the string.</span></span>

 <span data-ttu-id="8b8da-1668">*Ausrichtung* Optionale.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1668">*alignment* Optional.</span></span> <span data-ttu-id="8b8da-1669">Eine ganze Zahl mit Vorzeichen, die die Gesamtlänge des Felds angibt, in das das Argument eingefügt wird, und ob es rechtsbündig (eine positive ganze Zahl) oder linksbündig (eine negative Ganzzahl) ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1669">A signed integer that indicates the total length of the field into which the argument is inserted and whether it is right-aligned (a positive integer) or left-aligned (a negative integer).</span></span> <span data-ttu-id="8b8da-1670">Wenn Sie die *Ausrichtung*weglassen, wird die Zeichen folgen Darstellung des entsprechenden Arguments in ein Feld ohne führende oder nachfolgende Leerzeichen eingefügt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1670">If you omit *alignment*, the string representation of the corresponding argument is inserted in a field with no leading or trailing spaces.</span></span>

 <span data-ttu-id="8b8da-1671">Wenn der Wert der *Ausrichtung* kleiner als die Länge des einzufügenden Arguments ist, wird die *Ausrichtung* ignoriert, und die Länge der Zeichen folgen Darstellung des Arguments wird als Feldbreite verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1671">If the value of *alignment* is less than the length of the argument to be inserted, *alignment* is ignored and the length of the string representation of the argument is used as the field width.</span></span>

 <span data-ttu-id="8b8da-1672">*Format Zeichenfolge* Optionale.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1672">*formatString* Optional.</span></span> <span data-ttu-id="8b8da-1673">Eine Zeichenfolge, die das Format der Ergebnis Zeichenfolge des entsprechenden Arguments angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1673">A string that specifies the format of the corresponding argument's result string.</span></span> <span data-ttu-id="8b8da-1674">Wenn Sie *Format Zeichenfolge*weglassen, wird die Parameter lose `ToString`-Methode des entsprechenden Arguments aufgerufen, um die Zeichen folgen Darstellung zu schaffen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1674">If you omit *formatString*, the corresponding argument's parameterless `ToString` method is called to produce its string representation.</span></span> <span data-ttu-id="8b8da-1675">Wenn Sie *Format Zeichenfolge*angeben, muss das Argument, auf das vom Format Element verwiesen wird, die <xref:System.IFormattable>-Schnittstelle implementieren.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1675">If you specify *formatString*, the argument referenced by the format item must implement the <xref:System.IFormattable> interface.</span></span> <span data-ttu-id="8b8da-1676">Typen, die Format Zeichenfolgen unterstützen, sind:</span><span class="sxs-lookup"><span data-stu-id="8b8da-1676">Types that support format strings include:</span></span>

-   <span data-ttu-id="8b8da-1677">Alle ganzzahligen Typen und Gleit Komma Typen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1677">All integral and floating-point types.</span></span> <span data-ttu-id="8b8da-1678">(Siehe [Standard mäßige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und [benutzerdefinierte Zahlenformat](~/docs/standard/base-types/custom-numeric-format-strings.md)Zeichenfolgen.)</span><span class="sxs-lookup"><span data-stu-id="8b8da-1678">(See [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).)</span></span>

-   <span data-ttu-id="8b8da-1679"><xref:System.DateTime> und <xref:System.DateTimeOffset>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1679"><xref:System.DateTime> and <xref:System.DateTimeOffset>.</span></span> <span data-ttu-id="8b8da-1680">(Siehe Standard Format Zeichenfolgen für [Datum und Uhrzeit](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und benutzerdefinierte Format Zeichenfolgen für [Datum und Uhrzeit](~/docs/standard/base-types/custom-date-and-time-format-strings.md).)</span><span class="sxs-lookup"><span data-stu-id="8b8da-1680">(See [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) and [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).)</span></span>

-   <span data-ttu-id="8b8da-1681">Alle Enumerationstypen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1681">All enumeration types.</span></span> <span data-ttu-id="8b8da-1682">(Siehe [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).)</span><span class="sxs-lookup"><span data-stu-id="8b8da-1682">(See [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).)</span></span>

-   <span data-ttu-id="8b8da-1683"><xref:System.TimeSpan>-Werte sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1683"><xref:System.TimeSpan> values.</span></span> <span data-ttu-id="8b8da-1684">(Siehe [TimeSpan-Standard Format](~/docs/standard/base-types/standard-timespan-format-strings.md) Zeichenfolgen und [Benutzerdefinierte TimeSpan-Format](~/docs/standard/base-types/custom-timespan-format-strings.md)Zeichenfolgen.)</span><span class="sxs-lookup"><span data-stu-id="8b8da-1684">(See [Standard TimeSpan Format Strings](~/docs/standard/base-types/standard-timespan-format-strings.md) and [Custom TimeSpan Format Strings](~/docs/standard/base-types/custom-timespan-format-strings.md).)</span></span>

-   <span data-ttu-id="8b8da-1685">GUIDs.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1685">GUIDs.</span></span> <span data-ttu-id="8b8da-1686">(Weitere Informationen finden Sie unter <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType>-Methode.)</span><span class="sxs-lookup"><span data-stu-id="8b8da-1686">(See the <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> method.)</span></span>

 <span data-ttu-id="8b8da-1687">Beachten Sie jedoch, dass jeder benutzerdefinierte Typ <xref:System.IFormattable> implementieren oder die <xref:System.IFormattable> Implementierung eines vorhandenen Typs erweitern kann.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1687">However, note that any custom type can implement <xref:System.IFormattable> or extend an existing type's <xref:System.IFormattable> implementation.</span></span>

 <span data-ttu-id="8b8da-1688">Im folgenden Beispiel werden die Argumente `alignment` und `formatString` verwendet, um eine formatierte Ausgabe zu liefern.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1688">The following example uses the `alignment` and `formatString` arguments to produce formatted output.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload2.cpp" id="Snippet9":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload2.cs" interactive="try-dotnet-method" id="Snippet9":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload2.vb" id="Snippet9":::

<a name="HowFormatted"></a>
## <a name="how-arguments-are-formatted"></a><span data-ttu-id="8b8da-1689">Formatieren von Argumenten</span><span class="sxs-lookup"><span data-stu-id="8b8da-1689">How arguments are formatted</span></span>
 <span data-ttu-id="8b8da-1690">Format Elemente werden sequenziell vom Anfang der Zeichenfolge verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1690">Format items are processed sequentially from the beginning of the string.</span></span> <span data-ttu-id="8b8da-1691">Jedes Format Element verfügt über einen Index, der einem Objekt in der Argumentliste der Methode entspricht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1691">Each format item has an index that corresponds to an object in the method's argument list.</span></span> <span data-ttu-id="8b8da-1692">Die <xref:System.String.Format%2A>-Methode ruft das-Argument ab und leitet seine Zeichen folgen Darstellung wie folgt ab:</span><span class="sxs-lookup"><span data-stu-id="8b8da-1692">The <xref:System.String.Format%2A> method retrieves the argument and derives its string representation as follows:</span></span>

-   <span data-ttu-id="8b8da-1693">Wenn das-Argument `null`ist, fügt die-Methode <xref:System.String.Empty?displayProperty=nameWithType> in die Ergebnis Zeichenfolge ein.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1693">If the argument is `null`, the method inserts <xref:System.String.Empty?displayProperty=nameWithType> into the result string.</span></span> <span data-ttu-id="8b8da-1694">Sie müssen sich nicht mit der Behandlung einer <xref:System.NullReferenceException> für NULL-Argumente befassen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1694">You don't have to be concerned with handling a <xref:System.NullReferenceException> for null arguments.</span></span>

-   <span data-ttu-id="8b8da-1695">Wenn Sie die <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> Überladung aufrufen und die <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType>-Implementierung des `provider`-Objekts eine nicht-NULL-<xref:System.ICustomFormatter>-Implementierung zurückgibt, wird das-Argument an seine <xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType>-Methode übermittelt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1695">If you call the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> overload and the `provider` object's <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> implementation returns a non-null <xref:System.ICustomFormatter> implementation, the argument is passed to its <xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="8b8da-1696">Wenn das Format Element ein Format *String* -Argument enthält, wird es als erstes Argument an die-Methode weitergegeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1696">If the format item includes a *formatString* argument, it is passed as the first argument to the method.</span></span> <span data-ttu-id="8b8da-1697">Wenn die <xref:System.ICustomFormatter>-Implementierung verfügbar ist und eine Zeichenfolge erzeugt, die nicht NULL ist, wird diese Zeichenfolge als Zeichen folgen Darstellung des Arguments zurückgegeben. Andernfalls wird der nächste Schritt ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1697">If the <xref:System.ICustomFormatter> implementation is available and produces a non-null string, that string is returned as the string representation of the argument; otherwise, the next step executes.</span></span>

-   <span data-ttu-id="8b8da-1698">Wenn das-Argument die <xref:System.IFormattable>-Schnittstelle implementiert, wird die <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> Implementierung aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1698">If the argument implements the <xref:System.IFormattable> interface, its <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> implementation is called.</span></span>

-   <span data-ttu-id="8b8da-1699">Die Parameter lose `ToString`-Methode des Arguments, die entweder überschreibt oder von einer Basisklassen Implementierung erbt, wird aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1699">The argument's parameterless `ToString` method, which either overrides or inherits from a base class implementation, is called.</span></span>

 <span data-ttu-id="8b8da-1700">Ein Beispiel für das Abfangen von Aufrufen der <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType>-Methode und das Überprüfen der Informationen, die die <xref:System.String.Format%2A>-Methode an eine Formatierungs Methode für jedes Format Element in einer zusammengesetzten Format Zeichenfolge übergibt, finden Sie unter [example: a Intercept Provider und Roman Ziffer Formatierungs Programm](#Format7_Example).</span><span class="sxs-lookup"><span data-stu-id="8b8da-1700">For an example that intercepts calls to the <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> method and allows you to see what information the <xref:System.String.Format%2A> method passes to a formatting method for each format item in a composite format string, see [Example: An intercept provider and Roman numeral formatter](#Format7_Example).</span></span>

 <span data-ttu-id="8b8da-1701">Weitere Informationen finden Sie im Abschnitt " [Verarbeitungsreihenfolge](~/docs/standard/base-types/composite-formatting.md##processing-order) " im Artikel zur zusammen [gesetzten Formatierung](~/docs/standard/base-types/composite-formatting.md) .</span><span class="sxs-lookup"><span data-stu-id="8b8da-1701">For more information, see the [Processing Order](~/docs/standard/base-types/composite-formatting.md##processing-order) section in the [Composite Formatting](~/docs/standard/base-types/composite-formatting.md) article.</span></span>

<a name="SameIndex"></a>
## <a name="format-items-that-have-the-same-index"></a><span data-ttu-id="8b8da-1702">Formatieren von Elementen mit demselben Index</span><span class="sxs-lookup"><span data-stu-id="8b8da-1702">Format items that have the same index</span></span>
 <span data-ttu-id="8b8da-1703">Die <xref:System.String.Format%2A>-Methode löst eine <xref:System.FormatException> Ausnahme aus, wenn der Index eines Index Elements größer oder gleich der Anzahl der Argumente in der Argumentliste ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1703">The <xref:System.String.Format%2A> method throws a <xref:System.FormatException> exception if the index of an index item is greater than or equal to the number of arguments in the argument list.</span></span> <span data-ttu-id="8b8da-1704">`format` können jedoch mehr Formatierungs Elemente enthalten, als Argumente vorhanden sind, solange mehrere Format Elemente denselben Index aufweisen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1704">However, `format` can include more format items than there are arguments, as long as multiple format items have the same index.</span></span> <span data-ttu-id="8b8da-1705">Im folgenden Beispiel enthält die Argumentliste im <xref:System.String.Format%28System.String%2CSystem.Object%29>-Methode ein einzelnes Argument, die Format Zeichenfolge enthält jedoch zwei Format Elemente: eine zeigt den Dezimalwert einer Zahl an, und die andere zeigt den Hexadezimalwert an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1705">In the call to the <xref:System.String.Format%28System.String%2CSystem.Object%29> method in following example, the argument list has a single argument, but the format string includes two format items: one displays the decimal value of a number, and the other displays its hexadecimal value.</span></span>

 [!code-csharp-interactive[System.String.Format2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example1.cs#1)]
 [!code-vb[System.String.Format2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example1.vb#1)]

<a name="Format_Culture"></a>
## <a name="format-and-culture"></a><span data-ttu-id="8b8da-1706">Format und Kultur</span><span class="sxs-lookup"><span data-stu-id="8b8da-1706">Format and culture</span></span>
 <span data-ttu-id="8b8da-1707">Im Allgemeinen werden Objekte in der Argumentliste mithilfe der Konventionen der aktuellen Kultur, die von der <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>-Eigenschaft zurückgegeben wird, in ihre Zeichen folgen Darstellungen konvertiert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1707">Generally, objects in the argument list are converted to their string representations by using the conventions of the current culture, which is returned by the <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="8b8da-1708">Sie können dieses Verhalten steuern, indem Sie eine der über Ladungen von <xref:System.String.Format%2A> aufrufen, die einen `provider`-Parameter enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1708">You can control this behavior by calling one of the overloads of <xref:System.String.Format%2A> that includes a `provider` parameter.</span></span> <span data-ttu-id="8b8da-1709">Der `provider`-Parameter ist eine <xref:System.IFormatProvider> Implementierung, die benutzerdefinierte und kulturspezifische Formatierungsinformationen bereitstellt, die zum moderieren des Formatierungs Vorgangs verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1709">The `provider` parameter is an <xref:System.IFormatProvider> implementation that supplies custom and culture-specific formatting information that is used to moderate the formatting process.</span></span>

 <span data-ttu-id="8b8da-1710">Die <xref:System.IFormatProvider>-Schnittstelle verfügt über einen einzelnen Member, <xref:System.IFormatProvider.GetFormat%2A>, der für die Rückgabe des Objekts zuständig ist, das Formatierungsinformationen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1710">The <xref:System.IFormatProvider> interface has a single member, <xref:System.IFormatProvider.GetFormat%2A>, which is responsible for returning the object that provides formatting information.</span></span> <span data-ttu-id="8b8da-1711">.Net verfügt über drei <xref:System.IFormatProvider>-Implementierungen, die kulturspezifische Formatierung bereitstellen:</span><span class="sxs-lookup"><span data-stu-id="8b8da-1711">.NET has three <xref:System.IFormatProvider> implementations that provide culture-specific formatting:</span></span>

-   <span data-ttu-id="8b8da-1712"><xref:System.Globalization.CultureInfo></span><span class="sxs-lookup"><span data-stu-id="8b8da-1712"><xref:System.Globalization.CultureInfo>.</span></span> <span data-ttu-id="8b8da-1713">Die <xref:System.Globalization.CultureInfo.GetFormat%2A>-Methode gibt ein kulturspezifisches <xref:System.Globalization.NumberFormatInfo> Objekt zum Formatieren numerischer Werte und ein kulturspezifisches <xref:System.Globalization.DateTimeFormatInfo> Objekt zum Formatieren von Datums-und Uhrzeitwerten zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1713">Its <xref:System.Globalization.CultureInfo.GetFormat%2A> method returns a culture-specific <xref:System.Globalization.NumberFormatInfo> object for formatting numeric values and a culture-specific <xref:System.Globalization.DateTimeFormatInfo> object for formatting date and time values.</span></span>

-   <span data-ttu-id="8b8da-1714"><xref:System.Globalization.DateTimeFormatInfo>, die für die kulturspezifische Formatierung von Datums-und Uhrzeitwerten verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1714"><xref:System.Globalization.DateTimeFormatInfo>, which is used for culture-specific formatting of date and time values.</span></span> <span data-ttu-id="8b8da-1715">Die <xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A> Methode gibt sich selbst zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1715">Its <xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A> method returns itself.</span></span>

-   <span data-ttu-id="8b8da-1716"><xref:System.Globalization.NumberFormatInfo>, die für die kulturspezifische Formatierung numerischer Werte verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1716"><xref:System.Globalization.NumberFormatInfo>, which is used for culture-specific formatting of numeric values.</span></span> <span data-ttu-id="8b8da-1717">Die <xref:System.Globalization.NumberFormatInfo.GetFormat%2A>-Eigenschaft gibt sich selbst zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1717">Its <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> property returns itself.</span></span>

<a name="Format_Custom"></a>
## <a name="custom-formatting-operations"></a><span data-ttu-id="8b8da-1718">Benutzerdefinierte Formatierungs Vorgänge</span><span class="sxs-lookup"><span data-stu-id="8b8da-1718">Custom formatting operations</span></span>
 <span data-ttu-id="8b8da-1719">Sie können auch die über Ladungen der <xref:System.String.Format%2A>-Methode aufrufen, die über einen `provider`-Parameter vom Typ <xref:System.IFormatProvider> verfügen, um benutzerdefinierte Formatierungs Vorgänge auszuführen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1719">You can also call the any of the overloads of the <xref:System.String.Format%2A> method that have a `provider` parameter of type <xref:System.IFormatProvider> to perform custom formatting operations.</span></span> <span data-ttu-id="8b8da-1720">Beispielsweise können Sie eine ganze Zahl als Identifikationsnummer oder als Telefonnummer formatieren.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1720">For example, you could format an integer as an identification number or as a telephone number.</span></span> <span data-ttu-id="8b8da-1721">Um eine benutzerdefinierte Formatierung auszuführen, muss das `provider`-Argument sowohl die <xref:System.IFormatProvider> als auch die <xref:System.ICustomFormatter>-Schnittstelle implementieren.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1721">To perform custom formatting, your `provider` argument must implement both the <xref:System.IFormatProvider> and <xref:System.ICustomFormatter> interfaces.</span></span> <span data-ttu-id="8b8da-1722">Wenn der <xref:System.String.Format%2A>-Methode eine <xref:System.ICustomFormatter> Implementierung als `provider` Argument übermittelt wird, ruft die <xref:System.String.Format%2A>-Methode ihre <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType>-Implementierung auf und fordert ein Objekt vom Typ <xref:System.ICustomFormatter>an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1722">When the <xref:System.String.Format%2A> method is passed an <xref:System.ICustomFormatter> implementation as the `provider` argument, the <xref:System.String.Format%2A> method calls its   <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> implementation and requests an object of type <xref:System.ICustomFormatter>.</span></span> <span data-ttu-id="8b8da-1723">Anschließend wird die <xref:System.ICustomFormatter.Format%2A>-Methode des zurückgegebenen <xref:System.ICustomFormatter> Objekts aufgerufen, um jedes Format Element in der an ihn weiter gegebenen Verbund Zeichenfolge zu formatieren.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1723">It then calls the returned <xref:System.ICustomFormatter> object's <xref:System.ICustomFormatter.Format%2A> method to format each format item in the composite string passed to it.</span></span>

 <span data-ttu-id="8b8da-1724">Weitere Informationen zum Bereitstellen von benutzerdefinierten Formatierungs Lösungen finden Sie unter Gewusst [wie: definieren und Verwenden von benutzerdefinierten Zahlen Format Anbietern](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md) und <xref:System.ICustomFormatter>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1724">For more information about providing custom formatting solutions, see [How to: Define and Use Custom Numeric Format Providers](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md) and <xref:System.ICustomFormatter>.</span></span> <span data-ttu-id="8b8da-1725">Ein Beispiel, das ganze Zahlen in formatierte benutzerdefinierte Zahlen konvertiert, finden Sie unter [Beispiel: ein benutzerdefinierter Formatierungs Vorgang](#Format6_Example).</span><span class="sxs-lookup"><span data-stu-id="8b8da-1725">For an example that converts integers to formatted custom numbers, see [Example: A custom formatting operation](#Format6_Example).</span></span> <span data-ttu-id="8b8da-1726">Ein Beispiel, in dem nicht signierte Bytes in römische Zahlen konvertiert werden, finden Sie unter [Beispiel: ein Abfang Anbieter und ein Roman-Zahlen Formatierungs](#Format7_Example)Programm.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1726">For an example that converts unsigned bytes to Roman numerals, see [Example: An intercept provider and Roman numeral formatter](#Format7_Example).</span></span>

<a name="Format6_Example"></a>
### <a name="example-a-custom-formatting-operation"></a><span data-ttu-id="8b8da-1727">Beispiel: ein benutzerdefinierter Formatierungs Vorgang</span><span class="sxs-lookup"><span data-stu-id="8b8da-1727">Example: A custom formatting operation</span></span>
 <span data-ttu-id="8b8da-1728">In diesem Beispiel wird ein Format Anbieter definiert, der einen ganzzahligen Wert als Kundenkonto Nummer in der Form x-xxxxx-xx formatiert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1728">This example defines a format provider that formats an integer value as a customer account number in the form x-xxxxx-xx.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample2.cpp" id="Snippet2":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/FormatExample2.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/FormatExample2.vb" id="Snippet2":::

<a name="Format7_Example"></a>
### <a name="example-an-intercept-provider-and-roman-numeral-formatter"></a><span data-ttu-id="8b8da-1729">Beispiel: ein Abfang Anbieter und ein römischer Zahlen Formatierer</span><span class="sxs-lookup"><span data-stu-id="8b8da-1729">Example: An intercept provider and Roman numeral formatter</span></span>
 <span data-ttu-id="8b8da-1730">In diesem Beispiel wird ein benutzerdefinierter Format Anbieter definiert, der die <xref:System.ICustomFormatter> und <xref:System.IFormatProvider> Schnittstellen implementiert, um zwei Dinge auszuführen:</span><span class="sxs-lookup"><span data-stu-id="8b8da-1730">This example defines a custom format provider that implements the <xref:System.ICustomFormatter> and <xref:System.IFormatProvider> interfaces to do two things:</span></span>

-   <span data-ttu-id="8b8da-1731">Es zeigt die Parameter an, die an die <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> Implementierung übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1731">It displays the parameters passed to its <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> implementation.</span></span> <span data-ttu-id="8b8da-1732">Dadurch können wir sehen, welche Parameter die <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> Methode an die Implementierung der benutzerdefinierten Formatierung für jedes Objekt übergibt, das Sie zu formatieren versucht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1732">This enables us to see what parameters the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> method is passing to the custom formatting implementation for each object that it tries to format.</span></span> <span data-ttu-id="8b8da-1733">Dies kann hilfreich sein, wenn Sie Ihre Anwendung debuggen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1733">This can be useful when you're debugging your application.</span></span>

-   <span data-ttu-id="8b8da-1734">Wenn das zu formatierende Objekt ein Bytewert ohne Vorzeichen ist, der mit der Standardformat Zeichenfolge "R" formatiert werden soll, formatiert das benutzerdefinierte Formatierungs Programm den numerischen Wert als römische Ziffer.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1734">If the object to be formatted is an unsigned byte value that is to be formatted by using the "R" standard format string, the custom formatter formats the numeric value as a Roman numeral.</span></span>

 [!code-cpp[System.String.Format#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/interceptor2.cpp#11)]
 [!code-csharp[System.String.Format#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/interceptor2.cs#11)]
 [!code-vb[System.String.Format#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/interceptor2.vb#11)]

<a name="QA"></a>
## <a name="stringformat-q--a"></a><span data-ttu-id="8b8da-1735">String. Format Q & A</span><span class="sxs-lookup"><span data-stu-id="8b8da-1735">String.Format Q & A</span></span>

### <a name="why-do-you-recommend-string-interpolation-over-calls-to-the-stringformat-method"></a><span data-ttu-id="8b8da-1736">Warum empfehlen Sie die Zeichen folgen Interpolationsmethode für Aufrufe der `String.Format`-Methode?</span><span class="sxs-lookup"><span data-stu-id="8b8da-1736">Why do you recommend string interpolation over calls to the `String.Format` method?</span></span>

<span data-ttu-id="8b8da-1737">Zeichen folgen Interpolationen:</span><span class="sxs-lookup"><span data-stu-id="8b8da-1737">String interpolation is:</span></span>

- <span data-ttu-id="8b8da-1738">Flexibler.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1738">More flexible.</span></span> <span data-ttu-id="8b8da-1739">Sie kann in einer beliebigen Zeichenfolge verwendet werden, ohne dass eine Methode aufgerufen werden muss, die die kombinierte Formatierung unterstützt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1739">It can be used in any string without requiring a call to a method that supports composite formatting.</span></span> <span data-ttu-id="8b8da-1740">Andernfalls müssen Sie die <xref:System.String.Format%2A>-Methode oder eine andere Methode, die die kombinierte Formatierung unterstützt, wie z. b. <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> oder <xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType>, aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1740">Otherwise, you have to call the <xref:System.String.Format%2A> method or another method that supports composite formatting, such as <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> or <xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType>.</span></span>

- <span data-ttu-id="8b8da-1741">Besser lesbar.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1741">More readable.</span></span> <span data-ttu-id="8b8da-1742">Da der Ausdruck, der in eine Zeichenfolge eingefügt werden soll, im interinterinterierten Ausdruck und nicht in einer Argumentliste angezeigt wird, sind interpoliert Zeichen folgen weitaus einfacher zu programmieren und zu lesen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1742">Because the expression to insert into a string appears in the interpolated expression rather than in a argument list, interpolated strings are far easier to code and to read.</span></span> <span data-ttu-id="8b8da-1743">Aufgrund der besseren Lesbarkeit können interinterpolierte Zeichen folgen nicht nur Aufrufe von Methoden für den zusammengesetzten Format ersetzen, Sie können jedoch auch in Zeichenfolgenverkettungs Vorgängen verwendet werden, um präziseren, klareren Code zu erzielen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1743">Because of their greater readability, interpolated strings can replace not only calls to composite format methods, but they can also be used in string concatenation operations to produce more concise, clearer code.</span></span>

<span data-ttu-id="8b8da-1744">Ein Vergleich der folgenden beiden Codebeispiele veranschaulicht die Überlegenheit von interpoliert-Zeichen folgen über die Zeichen folgen Verkettung und Aufrufe von Methoden für die kombinierte Formatierung.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1744">A comparison of the following two code examples illustrates the superiority of interpolated strings over string concatenation and calls to composite formatting methods.</span></span> <span data-ttu-id="8b8da-1745">Durch die Verwendung mehrerer Zeichen folgen Verkettungs Vorgänge im folgenden Beispiel werden ausführlicher und schwer zu lesende Code erzeugt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1745">The use of multiple string concatenation operations in the following example produces verbose and hard-to-read code.</span></span>

[!code-csharp[non-interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated1.cs#QAInterpolated)]
[!code-vb[non-interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated1.vb)]

<span data-ttu-id="8b8da-1746">Im Gegensatz dazu erzeugt die Verwendung von interpoliert Zeichen folgen im folgenden Beispiel viel klareren, präziseren Code als die Zeichen folgen-Verkettungs Anweisung und den aufzurufenden <xref:System.String.Format%2A> Methode im vorherigen Beispiel.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1746">In contrast, the use of interpolated strings in the following example produce much clearer, more concise code than the string concatenation statement and the call to the <xref:System.String.Format%2A> method in the previous example.</span></span>

[!code-csharp[interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated2.cs#QAInterpolated2)]
[!code-vb[interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated2.vb)]

### <a name="where-can-i-find-a-list-of-the-predefined-format-strings-that-can-be-used-with-format-items"></a><span data-ttu-id="8b8da-1747">Wo finde ich eine Liste der vordefinierten Format Zeichenfolgen, die mit Format Elementen verwendet werden können?</span><span class="sxs-lookup"><span data-stu-id="8b8da-1747">Where can I find a list of the predefined format strings that can be used with format items?</span></span>

-   <span data-ttu-id="8b8da-1748">Informationen zu allen integralen und Gleit Komma Typen finden Sie unter [Standard mäßige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und [benutzerdefinierte Zahlenformat](~/docs/standard/base-types/custom-numeric-format-strings.md)Zeichenfolgen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1748">For all integral and floating-point types, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>

-   <span data-ttu-id="8b8da-1749">Datums-und Uhrzeit Werte finden Sie unter Standard Format Zeichenfolgen für [Datum und](~/docs/standard/base-types/standard-date-and-time-format-strings.md) Uhrzeit und benutzerdefinierte Format Zeichenfolgen für [Datum und Uhrzeit](~/docs/standard/base-types/custom-date-and-time-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="8b8da-1749">For date and time values, see [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) and [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).</span></span>

-   <span data-ttu-id="8b8da-1750">Enumerationswerte finden Sie unter [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="8b8da-1750">For enumeration values, see [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).</span></span>

-   <span data-ttu-id="8b8da-1751"><xref:System.TimeSpan> Werte finden Sie unter [TimeSpan-Standard Format](~/docs/standard/base-types/standard-timespan-format-strings.md) Zeichenfolgen und [Benutzerdefinierte TimeSpan-Format](~/docs/standard/base-types/custom-timespan-format-strings.md)Zeichenfolgen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1751">For <xref:System.TimeSpan> values, see  [Standard TimeSpan Format Strings](~/docs/standard/base-types/standard-timespan-format-strings.md) and [Custom TimeSpan Format Strings](~/docs/standard/base-types/custom-timespan-format-strings.md).</span></span>

-   <span data-ttu-id="8b8da-1752"><xref:System.Guid> Werte finden Sie im Abschnitt "Hinweise" auf der <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> Referenzseite.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1752">For <xref:System.Guid> values, see the Remarks section of the <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> reference page.</span></span>

### <a name="how-do-i-control-the-alignment-of-the-result-strings-that-replace-format-items"></a><span data-ttu-id="8b8da-1753">Gewusst wie die Ausrichtung der Ergebnis Zeichenfolgen steuern, die Format Elemente ersetzen?</span><span class="sxs-lookup"><span data-stu-id="8b8da-1753">How do I control the alignment of the result strings that replace format items?</span></span>
 <span data-ttu-id="8b8da-1754">Die allgemeine Syntax eines Format Elements lautet wie folgt:</span><span class="sxs-lookup"><span data-stu-id="8b8da-1754">The general syntax of a format item is:</span></span>

```
{index[,alignment][: formatString]}
```

 <span data-ttu-id="8b8da-1755">Where *Alignment* ist eine Ganzzahl mit Vorzeichen, die die Feldbreite definiert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1755">where *alignment* is a signed integer that defines the field width.</span></span> <span data-ttu-id="8b8da-1756">Wenn dieser Wert negativ ist, wird der Text im Feld linksbündig ausgerichtet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1756">If this value is negative, text in the field is left-aligned.</span></span> <span data-ttu-id="8b8da-1757">Wenn er positiv ist, wird der Text rechtsbündig ausgerichtet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1757">If it is positive, text is right-aligned.</span></span>

### <a name="how-do-i-control-the-number-of-digits-after-the-decimal-separator"></a><span data-ttu-id="8b8da-1758">Gewusst wie die Anzahl der Ziffern nach dem Dezimaltrennzeichen Steuern?</span><span class="sxs-lookup"><span data-stu-id="8b8da-1758">How do I control the number of digits after the decimal separator?</span></span>
 <span data-ttu-id="8b8da-1759">Alle [standardmäßigen Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen außer "D" (die nur mit ganzen Zahlen verwendet werden), "G", "R" und "X" lassen einen Genauigkeits Bezeichner zu, der die Anzahl der Dezimalstellen in der Ergebnis Zeichenfolge definiert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1759">All [standard numeric format strings](~/docs/standard/base-types/standard-numeric-format-strings.md) except "D" (which is used with integers only), "G", "R", and "X" allow a precision specifier that defines the number of decimal digits in the result string.</span></span> <span data-ttu-id="8b8da-1760">Im folgenden Beispiel werden standardmäßige numerische Format Zeichenfolgen verwendet, um die Anzahl von Dezimalstellen in der Ergebnis Zeichenfolge zu steuern.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1760">The following example uses standard numeric format strings to control the number of decimal digits in the result string.</span></span>

 [!code-csharp[System.String.Format#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa26.cs#26)]
 [!code-vb[System.String.Format#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa26.vb#26)]

 <span data-ttu-id="8b8da-1761">Wenn Sie eine [benutzerdefinierte numerische Format Zeichenfolge](~/docs/standard/base-types/custom-numeric-format-strings.md)verwenden, verwenden Sie den Format Bezeichner "0", um die Anzahl von Dezimalstellen in der Ergebnis Zeichenfolge zu steuern, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1761">If you're using a [custom numeric format string](~/docs/standard/base-types/custom-numeric-format-strings.md), use the "0" format specifier to control the number of decimal digits in the result string, as the following example shows.</span></span>

 [!code-csharp-interactive[System.String.Format#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa27.cs#27)]
 [!code-vb[System.String.Format#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa27.vb#27)]

### <a name="how-do-i-control-the-number-of-integral-digits"></a><span data-ttu-id="8b8da-1762">Gewusst wie die Anzahl der ganzzahligen Ziffern Steuern?</span><span class="sxs-lookup"><span data-stu-id="8b8da-1762">How do I control the number of integral digits?</span></span>
 <span data-ttu-id="8b8da-1763">Standardmäßig werden bei Formatierungs Vorgängen nur ganzzahlige Ziffern ungleich Null angezeigt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1763">By default, formatting operations only display non-zero integral digits.</span></span> <span data-ttu-id="8b8da-1764">Wenn Sie ganze Zahlen formatieren, können Sie einen Genauigkeits Bezeichner mit den standardmäßigen Format Zeichenfolgen "D" und "X" verwenden, um die Anzahl der Ziffern zu steuern.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1764">If you are formatting integers, you can use a precision specifier with the "D" and "X" standard format strings to control the number of digits.</span></span>

 [!code-csharp-interactive[System.String.Format#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa29.cs#29)]
 [!code-vb[System.String.Format#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa29.vb#29)]

 <span data-ttu-id="8b8da-1765">Sie können eine Ganzzahl oder eine Gleit Komma Zahl mit führenden Nullen auffüllen, um eine Ergebnis Zeichenfolge mit einer angegebenen Anzahl von ganzzahligen Ziffern zu entwickeln, indem Sie den [benutzerdefinierten numerischen Format](~/docs/standard/base-types/custom-numeric-format-strings.md)Bezeichner "0" verwenden, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1765">You can pad an integer or floating-point number with leading zeros to produce a result string with a specified number of integral digits by using the "0" [custom numeric format specifier](~/docs/standard/base-types/custom-numeric-format-strings.md), as the following example shows.</span></span>

 [!code-csharp-interactive[System.String.Format#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa28.cs#28)]
 [!code-vb[System.String.Format#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa28.vb#28)]

### <a name="how-many-items-can-i-include-in-the-format-list"></a><span data-ttu-id="8b8da-1766">Wie viele Elemente kann ich in die Liste "Format" einschließen?</span><span class="sxs-lookup"><span data-stu-id="8b8da-1766">How many items can I include in the format list?</span></span>
 <span data-ttu-id="8b8da-1767">Es gibt keine praktische Beschränkung.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1767">There is no practical limit.</span></span> <span data-ttu-id="8b8da-1768">Der zweite Parameter der <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>-Methode wird mit dem <xref:System.ParamArrayAttribute>-Attribut markiert, sodass Sie entweder eine durch Trennzeichen getrennte Liste oder ein Objekt Array als Format Liste einschließen können.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1768">The second parameter of the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> method is tagged with the <xref:System.ParamArrayAttribute> attribute, which allows you to include either a delimited list or an object array as your format list.</span></span>

<a name="braces"></a>
### <a name="how-do-i-include-literal-braces--and--in-the-result-string"></a><span data-ttu-id="8b8da-1769">Gewusst wie in die Ergebnis Zeichenfolge Literale geschweifte Klammern ("{" und "}") einschließen?</span><span class="sxs-lookup"><span data-stu-id="8b8da-1769">How do I include literal braces ("{" and "}") in the result string?</span></span>
 <span data-ttu-id="8b8da-1770">Beispielsweise verhindern Sie, dass der folgende Methodenaufrufe eine <xref:System.FormatException> Ausnahme auslöst?</span><span class="sxs-lookup"><span data-stu-id="8b8da-1770">For example, how do you prevent the following method call from throwing a <xref:System.FormatException> exception?</span></span>

 [!code-csharp[System.String.Format#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#23)]
 [!code-vb[System.String.Format#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#23)]

 <span data-ttu-id="8b8da-1771">Eine einzelne öffnende oder schließende geschweifte Klammer wird immer als Anfang oder Ende eines Format Elements interpretiert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1771">A single opening or closing brace is always interpreted as the beginning or end of a format item.</span></span> <span data-ttu-id="8b8da-1772">Damit er buchstäblich interpretiert wird, muss er mit Escapezeichen versehen werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1772">To be interpreted literally, it must be escaped.</span></span> <span data-ttu-id="8b8da-1773">Sie können eine Klammer mit Escapezeichen versehen, indem Sie eine weitere geschweifter Klammer ("{{" und "}}" anstelle von "{" und "}") hinzufügen, wie im folgenden Methoden aufzurufen:</span><span class="sxs-lookup"><span data-stu-id="8b8da-1773">You escape a brace by adding another brace ("{{" and "}}" instead of "{" and "}"), as in the following method call:</span></span>

 [!code-csharp-interactive[System.String.Format#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#24)]
 [!code-vb[System.String.Format#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#24)]

 <span data-ttu-id="8b8da-1774">Selbst mit Escapezeichen versehene geschweifte Klammern können jedoch problemlos interpretiert werden</span><span class="sxs-lookup"><span data-stu-id="8b8da-1774">However, even escaped braces are easily misinterpreted.</span></span> <span data-ttu-id="8b8da-1775">Sie sollten geschweifte Klammern in die Format Liste einschließen und Format Elemente verwenden, um Sie in die Ergebnis Zeichenfolge einzufügen, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1775">We recommend that you include braces in the format list and use format items to insert them in the result string, as the following example shows.</span></span>

 [!code-csharp-interactive[System.String.Format#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#25)]
 [!code-vb[System.String.Format#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#25)]

### <a name="why-does-my-call-to-the-stringformat-method-throw-a-formatexception"></a><span data-ttu-id="8b8da-1776">Warum löst mein Rückruf der String. Format-Methode eine FormatException aus?</span><span class="sxs-lookup"><span data-stu-id="8b8da-1776">Why does my call to the String.Format method throw a FormatException?</span></span>
 <span data-ttu-id="8b8da-1777">Die häufigste Ursache für die Ausnahme ist, dass der Index eines Format Elements keinem Objekt in der Format Liste entspricht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1777">The most common cause of the exception is that the index of a format item doesn't correspond to an object in the format list.</span></span> <span data-ttu-id="8b8da-1778">Normalerweise ist dies ein Hinweis darauf, dass Sie die Indizes von Format Elementen falsch nummeriert haben oder dass Sie vergessen haben, ein Objekt in die Format Liste einzufügen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1778">Usually this indicates that you've misnumbered the indexes of format items or you've forgotten to include an object in the format list.</span></span> <span data-ttu-id="8b8da-1779">Wenn Sie versuchen, eine Zeichenfolge mit Escapezeichen ohne Escapezeichen einzufügen, wird auch eine <xref:System.FormatException>ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1779">Attempting to include an unescaped left or right brace character also throws a <xref:System.FormatException>.</span></span> <span data-ttu-id="8b8da-1780">Gelegentlich ist die Ausnahme das Ergebnis eines Typo. ein typischer Fehler ist beispielsweise, "[" (die linke Klammer) anstelle von "{" (der linken geschweiften Klammer) zu täuschen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1780">Occasionally, the exception is the result of a typo; for example, a typical mistake is to mistype "[" (the left bracket) instead of "{" (the left brace).</span></span>

### <a name="if-the-formatsystemiformatprovidersystemstringsystemobject-method-supports-parameter-arrays-why-does-my-code-throw-an-exception-when-i-use-an-array"></a><span data-ttu-id="8b8da-1781">Wenn das Format (System. IFormatProvider, System. String, System. Object [])-Methode Parameter Arrays unterstützt, löst mein Code eine Ausnahme aus, wenn ich ein Array verwende?</span><span class="sxs-lookup"><span data-stu-id="8b8da-1781">If the Format(System.IFormatProvider,System.String,System.Object[]) method supports parameter arrays, why does my code throw an exception when I use an array?</span></span>
 <span data-ttu-id="8b8da-1782">Der folgende Code löst z. b. eine <xref:System.FormatException> Ausnahme aus:</span><span class="sxs-lookup"><span data-stu-id="8b8da-1782">For example, the following code throws a <xref:System.FormatException> exception:</span></span>

 [!code-csharp[System.String.Format#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa1.cs#21)]
 [!code-vb[System.String.Format#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa1.vb#21)]

 <span data-ttu-id="8b8da-1783">Dies ist ein Problem bei der Auflösung von compilerüberladungen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1783">This is a problem of compiler overload resolution.</span></span> <span data-ttu-id="8b8da-1784">Da der Compiler ein Array von ganzen Zahlen nicht in ein Objekt Array konvertieren kann, wird das ganzzahlige Array als einzelnes Argument behandelt, sodass die <xref:System.String.Format%28System.String%2CSystem.Object%29>-Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1784">Because the compiler cannot convert an array of integers to an object array, it treats the integer array as a single argument, so it calls the <xref:System.String.Format%28System.String%2CSystem.Object%29> method.</span></span> <span data-ttu-id="8b8da-1785">Die-Ausnahme wird ausgelöst, weil vier Format Elemente vorhanden sind, aber nur ein einzelnes Element in der Format Liste.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1785">The exception is thrown because there are four format items but only a single item in the format list.</span></span>

 <span data-ttu-id="8b8da-1786">Da weder Visual Basic noch C# ein ganzzahliges Array in ein Objekt Array konvertiert werden kann, müssen Sie die Konvertierung selbst durchführen, bevor Sie die <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29>-Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1786">Because neither Visual Basic nor C# can convert an integer array to an object array, you have to perform the conversion yourself before calling the <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> method.</span></span> <span data-ttu-id="8b8da-1787">Der folgende Code zeigt ein Implementierungsbeispiel.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1787">The following example provides one implementation.</span></span>

 [!code-csharp-interactive[System.String.Format#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa2.cs#22)]
 [!code-vb[System.String.Format#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa2.vb#22)]

## Examples

<span data-ttu-id="8b8da-1788">Viele Beispiele, die die <xref:System.String.Format%2A>-Methode aufzurufen, werden über den Abschnitt " [Hinweise](#remarks-top) " in diesem Artikel überschrieben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1788">Numerous examples that call the <xref:System.String.Format%2A> method are interspersed through the [Remarks](#remarks-top) section of this article.</span></span>

<span data-ttu-id="8b8da-1789">Sie können auch einen kompletten Satz `String.Format` Beispiele herunterladen, die ein [.net Core 2,0- C# Projekt für](https://github.com/dotnet/samples/raw/master/snippets/csharp/downloads/api/System/String.Format.zip) und ein [.net Core 2,0-Projekt für Visual Basic](https://github.com/dotnet/samples/raw/master/snippets/visualbasic/downloads/api/System/String.Format.zip)aus dem [dotnet/Samples GitHub-Repository](https://github.com/dotnet/samples)enthalten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1789">You can also download a complete set of `String.Format` examples, which are included a [.NET Core 2.0 project for C#](https://github.com/dotnet/samples/raw/master/snippets/csharp/downloads/api/System/String.Format.zip) and a [.NET Core 2.0 project for Visual Basic](https://github.com/dotnet/samples/raw/master/snippets/visualbasic/downloads/api/System/String.Format.zip), from the [dotnet/samples GitHub repository](https://github.com/dotnet/samples).</span></span>

<span data-ttu-id="8b8da-1790">Im folgenden finden Sie einige Beispiele, die im Artikel enthalten sind:</span><span class="sxs-lookup"><span data-stu-id="8b8da-1790">The following are some of the examples included in the article:</span></span>

### <a name="create-a-format-string"></a><span data-ttu-id="8b8da-1791">Erstellen einer Format Zeichenfolge</span><span class="sxs-lookup"><span data-stu-id="8b8da-1791">Create a format string</span></span>

<span data-ttu-id="8b8da-1792">[Einfügen einer Zeichenfolge](#insert-a-string)
[das Format Element](#the-format-item)
[Format Elemente, die denselben Index aufweisen](#format-items-that-have-the-same-index)</span><span class="sxs-lookup"><span data-stu-id="8b8da-1792">[Inserting a string](#insert-a-string)
[The format item](#the-format-item)
[Format items that have the same index](#format-items-that-have-the-same-index)</span></span>

### <a name="control-formatted-output"></a><span data-ttu-id="8b8da-1793">Formatierte Ausgabe formatieren</span><span class="sxs-lookup"><span data-stu-id="8b8da-1793">Control formatted output</span></span>

<span data-ttu-id="8b8da-1794">[Steuern der Formatierung](#control-formatting)
[Steuern des Abstands](#control-spacing)
[Steuern der Ausrichtung](#control-alignment)
Steuern [der Anzahl der](#how-do-i-control-the-number-of-integral-digits) ganzzahligen Ziffern
[Steuern der Anzahl von Ziffern nach dem Dezimaltrennzeichen](#how-do-i-control-the-number-of-digits-after-the-decimal-separator)
[einschließen von literalklammern in einer Ergebnis Zeichenfolge](#braces)</span><span class="sxs-lookup"><span data-stu-id="8b8da-1794">[Controlling formatting](#control-formatting)
[Controlling spacing](#control-spacing)
[Controlling alignment](#control-alignment)
[Controlling the number of integral digits](#how-do-i-control-the-number-of-integral-digits)
[Controlling the number of digits after the decimal separator](#how-do-i-control-the-number-of-digits-after-the-decimal-separator)
[Including literal braces in a result string](#braces)</span></span>

### <a name="make-format-strings-culture-sensitive"></a><span data-ttu-id="8b8da-1795">Format Zeichenfolgen Kultur abhängig machen</span><span class="sxs-lookup"><span data-stu-id="8b8da-1795">Make format strings culture-sensitive</span></span>

[<span data-ttu-id="8b8da-1796">Kultur abhängige Formatierung</span><span class="sxs-lookup"><span data-stu-id="8b8da-1796">Culture-sensitive formatting</span></span>](#culture-sensitive-formatting)

### <a name="customize-the-formatting-operation"></a><span data-ttu-id="8b8da-1797">Anpassen des Formatierungs Vorgangs</span><span class="sxs-lookup"><span data-stu-id="8b8da-1797">Customize the formatting operation</span></span>

<span data-ttu-id="8b8da-1798">[Ein benutzerdefinierter Formatierungs Vorgang](#example-a-custom-formatting-operation)
[einen Abfang Anbieter und ein Roman-Zahlen Formatierungs](#example-an-intercept-provider-and-roman-numeral-formatter) Programm</span><span class="sxs-lookup"><span data-stu-id="8b8da-1798">[A custom formatting operation](#example-a-custom-formatting-operation)
[An intercept provider and Roman numeral formatter](#example-an-intercept-provider-and-roman-numeral-formatter)</span></span>

 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md"><span data-ttu-id="8b8da-1799">Formatieren von Typen in .NET</span><span class="sxs-lookup"><span data-stu-id="8b8da-1799">Formatting Types in .NET</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md"><span data-ttu-id="8b8da-1800">Kombinierte Formatierung</span><span class="sxs-lookup"><span data-stu-id="8b8da-1800">Composite Formatting</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md"><span data-ttu-id="8b8da-1801">Standard-Formatzeichenfolgen für Datum und Uhrzeit</span><span class="sxs-lookup"><span data-stu-id="8b8da-1801">Standard Date and Time Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md"><span data-ttu-id="8b8da-1802">Benutzerdefinierte Formatzeichenfolgen für Datum und Uhrzeit</span><span class="sxs-lookup"><span data-stu-id="8b8da-1802">Custom Date and Time Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md"><span data-ttu-id="8b8da-1803">Standardmäßige Zahlenformatzeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="8b8da-1803">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md"><span data-ttu-id="8b8da-1804">Benutzerdefinierte Zahlenformatzeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="8b8da-1804">Custom Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md"><span data-ttu-id="8b8da-1805">TimeSpan-Standardformatzeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="8b8da-1805">Standard TimeSpan Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md"><span data-ttu-id="8b8da-1806">Benutzerdefinierte TimeSpan-Formatzeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="8b8da-1806">Custom TimeSpan Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md"><span data-ttu-id="8b8da-1807">Enumerationsformatzeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="8b8da-1807">Enumeration Format Strings</span></span></related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj -&gt; string" Usage="System.string.Format (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="8b8da-1808">Eine [kombinierte Formatzeichenfolge](~/docs/standard/base-types/composite-formatting.md).</span><span class="sxs-lookup"><span data-stu-id="8b8da-1808">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="arg0"><span data-ttu-id="8b8da-1809">Das zu formatierende Objekt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1809">The object to format.</span></span></param>
        <summary><span data-ttu-id="8b8da-1810">Ersetzt mindestens ein Formatelement in einer Zeichenfolge durch die Zeichenfolgendarstellung eines angegebenen Objekts.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1810">Replaces one or more format items in a string with the string representation of a specified object.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1811">Eine Kopie von <paramref name="format" />, in der alle Formatelemente durch die Zeichenfolgendarstellung von <paramref name="arg0" /> ersetzt wurden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1811">A copy of <paramref name="format" /> in which any format items are replaced by the string representation of <paramref name="arg0" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)]

<span data-ttu-id="8b8da-1812">Diese Methode verwendet die [Funktion für die kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) , um den Wert eines Ausdrucks in seine Zeichen folgen Darstellung zu konvertieren und diese Darstellung in eine Zeichenfolge einzubetten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1812">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert the value of an expression to its string representation and to embed that representation in a string.</span></span>

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-a-single-argument"></a><span data-ttu-id="8b8da-1813">Beispiel: Formatieren eines einzelnen Arguments</span><span class="sxs-lookup"><span data-stu-id="8b8da-1813">Example: Formatting a single argument</span></span>

 <span data-ttu-id="8b8da-1814">Im folgenden Beispiel wird die <xref:System.String.Format%28System.String%2CSystem.Object%29>-Methode verwendet, um das Alter einer Person in der Mitte einer Zeichenfolge einzubetten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1814">The following example uses the <xref:System.String.Format%28System.String%2CSystem.Object%29> method to embed an individual's age in the middle of a string.</span></span>

 [!code-cpp[System.String.Format#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format7.cpp#7)]
 [!code-csharp-interactive[System.String.Format#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format7.cs#7)]
 [!code-vb[System.String.Format#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format7.vb#7)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-1815"><paramref name="format" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1815"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="8b8da-1816">Das Formatelement in <paramref name="format" /> ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1816">The format item in <paramref name="format" /> is invalid.</span></span>

<span data-ttu-id="8b8da-1817">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-1817">-or-</span></span>

<span data-ttu-id="8b8da-1818">Der Index eines Formatelements ist nicht 0 (null).</span><span class="sxs-lookup"><span data-stu-id="8b8da-1818">The index of a format item is not zero.</span></span></exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md"><span data-ttu-id="8b8da-1819">Formatieren von Typen in .NET</span><span class="sxs-lookup"><span data-stu-id="8b8da-1819">Formatting Types in .NET</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md"><span data-ttu-id="8b8da-1820">Kombinierte Formatierung</span><span class="sxs-lookup"><span data-stu-id="8b8da-1820">Composite Formatting</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md"><span data-ttu-id="8b8da-1821">Standard-Formatzeichenfolgen für Datum und Uhrzeit</span><span class="sxs-lookup"><span data-stu-id="8b8da-1821">Standard Date and Time Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md"><span data-ttu-id="8b8da-1822">Benutzerdefinierte Formatzeichenfolgen für Datum und Uhrzeit</span><span class="sxs-lookup"><span data-stu-id="8b8da-1822">Custom Date and Time Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md"><span data-ttu-id="8b8da-1823">Standardmäßige Zahlenformatzeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="8b8da-1823">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md"><span data-ttu-id="8b8da-1824">Benutzerdefinierte Zahlenformatzeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="8b8da-1824">Custom Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md"><span data-ttu-id="8b8da-1825">TimeSpan-Standardformatzeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="8b8da-1825">Standard TimeSpan Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md"><span data-ttu-id="8b8da-1826">Benutzerdefinierte TimeSpan-Formatzeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="8b8da-1826">Custom TimeSpan Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md"><span data-ttu-id="8b8da-1827">Enumerationsformatzeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="8b8da-1827">Enumeration Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj[] -&gt; string" Usage="System.string.Format (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="8b8da-1828">Eine [kombinierte Formatzeichenfolge](~/docs/standard/base-types/composite-formatting.md).</span><span class="sxs-lookup"><span data-stu-id="8b8da-1828">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="args"><span data-ttu-id="8b8da-1829">Ein Objektarray mit 0 (null) oder mehr zu formatierenden Objekten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1829">An object array that contains zero or more objects to format.</span></span></param>
        <summary><span data-ttu-id="8b8da-1830">Ersetzt das Formatelement in einer angegebenen Zeichenfolge durch die Zeichenfolgendarstellung eines entsprechenden Objekts in einem angegebenen Array.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1830">Replaces the format item in a specified string with the string representation of a corresponding object in a specified array.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1831">Eine Kopie von <paramref name="format" />, in der die Formatelemente durch die Zeichenfolgendarstellung der entsprechenden Objekte in <paramref name="args" /> ersetzt wurden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1831">A copy of <paramref name="format" /> in which the format items have been replaced by the string representation of the corresponding objects in <paramref name="args" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)]

<span data-ttu-id="8b8da-1832">Diese Methode verwendet die [Funktion für die kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) , um den Wert von vier oder mehr Ausdrücken in ihre Zeichen folgen Darstellungen zu konvertieren und diese Darstellungen in eine Zeichenfolge einzubetten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1832">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert the value of four or more expressions to their string representations and to embed those representations in a string.</span></span> <span data-ttu-id="8b8da-1833">Da der `args`-Parameter mit dem <xref:System.ParamArrayAttribute?displayProperty=nameWithType>-Attribut markiert ist, können Sie die Objekte als einzelne Argumente oder als <xref:System.Object> Array an die Methode übergeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1833">Since the `args` parameter is marked with the <xref:System.ParamArrayAttribute?displayProperty=nameWithType> attribute, you can pass the objects to the method as individual arguments or as an <xref:System.Object> array.</span></span>

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-format-more-than-three-arguments"></a><span data-ttu-id="8b8da-1834">Beispiel: Formatieren von mehr als drei Argumenten</span><span class="sxs-lookup"><span data-stu-id="8b8da-1834">Example: Format more than three arguments</span></span>

 <span data-ttu-id="8b8da-1835">In diesem Beispiel wird eine Zeichenfolge erstellt, die Daten für die hohe und niedrige Temperatur an einem bestimmten Datum enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1835">This example creates a string that contains data on the high and low temperature on a particular date.</span></span> <span data-ttu-id="8b8da-1836">Die kombinierte Format Zeichenfolge enthält fünf Format Elemente C# im Beispiel und sechs im Visual Basic Beispiel.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1836">The composite format string has five format items in the C# example and six in the Visual Basic example.</span></span> <span data-ttu-id="8b8da-1837">Zwei der Format Elemente definieren die Breite der Zeichen folgen Darstellung Ihres entsprechenden Werts, und das erste Format Element enthält auch eine Standardformat Zeichenfolge für Datum und Uhrzeit.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1837">Two of the format items define the width of their corresponding value's string representation, and the first format item also includes a standard date and time format string.</span></span>

 [!code-cpp[System.String.Format#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format5.cpp#5)]
 [!code-csharp[System.String.Format#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format5.cs#5)]
 [!code-vb[System.String.Format#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format5.vb#5)]

 <span data-ttu-id="8b8da-1838">Sie können die zu formatierenden Objekte auch als Array und nicht als Argumentliste übergeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1838">You can also pass the objects to be formatted as an array rather than as an argument list.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format_paramarray1.cpp" id="Snippet10":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format_paramarray1.cs" interactive="try-dotnet" id="Snippet10":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format_paramarray1.vb" id="Snippet10":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-1839"><paramref name="format" /> oder <paramref name="args" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1839"><paramref name="format" /> or <paramref name="args" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="8b8da-1840"><paramref name="format" /> ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1840"><paramref name="format" /> is invalid.</span></span>

<span data-ttu-id="8b8da-1841">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-1841">-or-</span></span>

<span data-ttu-id="8b8da-1842">Der Index eines Formatelements ist kleiner als 0 (null) oder größer oder gleich der Länge des <paramref name="args" />-Arrays.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1842">The index of a format item is less than zero, or greater than or equal to the length of the <paramref name="args" /> array.</span></span></exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md"><span data-ttu-id="8b8da-1843">Formatieren von Typen in .NET</span><span class="sxs-lookup"><span data-stu-id="8b8da-1843">Formatting Types in .NET</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md"><span data-ttu-id="8b8da-1844">Kombinierte Formatierung</span><span class="sxs-lookup"><span data-stu-id="8b8da-1844">Composite Formatting</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md"><span data-ttu-id="8b8da-1845">Standard-Formatzeichenfolgen für Datum und Uhrzeit</span><span class="sxs-lookup"><span data-stu-id="8b8da-1845">Standard Date and Time Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md"><span data-ttu-id="8b8da-1846">Benutzerdefinierte Formatzeichenfolgen für Datum und Uhrzeit</span><span class="sxs-lookup"><span data-stu-id="8b8da-1846">Custom Date and Time Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md"><span data-ttu-id="8b8da-1847">Standardmäßige Zahlenformatzeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="8b8da-1847">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md"><span data-ttu-id="8b8da-1848">Benutzerdefinierte Zahlenformatzeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="8b8da-1848">Custom Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md"><span data-ttu-id="8b8da-1849">TimeSpan-Standardformatzeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="8b8da-1849">Standard TimeSpan Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md"><span data-ttu-id="8b8da-1850">Benutzerdefinierte TimeSpan-Formatzeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="8b8da-1850">Custom TimeSpan Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md"><span data-ttu-id="8b8da-1851">Enumerationsformatzeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="8b8da-1851">Enumeration Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj -&gt; string" Usage="System.string.Format (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="8b8da-1852">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1852">An object that supplies culture-specific formatting information.</span></span></param>
        <param name="format"><span data-ttu-id="8b8da-1853">Eine [kombinierte Formatzeichenfolge](~/docs/standard/base-types/composite-formatting.md).</span><span class="sxs-lookup"><span data-stu-id="8b8da-1853">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="arg0"><span data-ttu-id="8b8da-1854">Das zu formatierende Objekt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1854">The object to format.</span></span></param>
        <summary><span data-ttu-id="8b8da-1855">Ersetzt die Formatelemente in einer angegebenen Zeichenfolge durch die Zeichenfolgendarstellung des angegebenen Objekts.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1855">Replaces the format item or items in a specified string with the string representation of the corresponding object.</span></span> <span data-ttu-id="8b8da-1856">Ein Parameter liefert kulturspezifische Formatierungsinformationen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1856">A parameter supplies culture-specific formatting information.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1857">Eine Kopie von <paramref name="format" />, in der die Formatelemente durch die Zeichenfolgendarstellung von <paramref name="arg0" /> ersetzt wurden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1857">A copy of <paramref name="format" /> in which the format item or items have been replaced by the string representation of <paramref name="arg0" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)]

<span data-ttu-id="8b8da-1858">Diese Methode verwendet die [Funktion für die kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) , um den Wert eines Ausdrucks in seine Zeichen folgen Darstellung zu konvertieren und diese Darstellung in eine Zeichenfolge einzubetten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1858">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert the value of an expression to its string representation and to embed that representation in a string.</span></span> <span data-ttu-id="8b8da-1859">Beim Durchführen der Konvertierung verwendet die-Methode Kultur abhängige Formatierung oder einen benutzerdefinierten Formatierer.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1859">In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</span></span> <span data-ttu-id="8b8da-1860">Die-Methode konvertiert `arg0` in ihre Zeichen folgen Darstellung, indem die **ToString (IFormatProvider)** -Methode aufgerufen wird, oder, wenn das entsprechende Format Element des Objekts eine Format Zeichenfolge enthält, indem die **ToString (String, IFormatProvider)** -Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1860">The method converts `arg0` to its string representation by calling its **ToString(IFormatProvider)** method or, if the object's corresponding format item includes a format string, by calling its **ToString(String,IFormatProvider)** method.</span></span> <span data-ttu-id="8b8da-1861">Wenn diese Methoden nicht vorhanden sind, wird die **Parameter lose-** Methode des-Objekts aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1861">If these methods don't exist, it calls the object's parameterless **ToString** method.</span></span>

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-1862"><paramref name="format" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1862"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="8b8da-1863"><paramref name="format" /> ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1863"><paramref name="format" /> is invalid.</span></span>

<span data-ttu-id="8b8da-1864">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-1864">-or-</span></span>

<span data-ttu-id="8b8da-1865">Der Index eines Formatelements ist nicht 0 (null).</span><span class="sxs-lookup"><span data-stu-id="8b8da-1865">The index of a format item is not zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj[] -&gt; string" Usage="System.string.Format (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="8b8da-1866">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1866">An object that supplies culture-specific formatting information.</span></span></param>
        <param name="format"><span data-ttu-id="8b8da-1867">Eine [kombinierte Formatzeichenfolge](~/docs/standard/base-types/composite-formatting.md).</span><span class="sxs-lookup"><span data-stu-id="8b8da-1867">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="args"><span data-ttu-id="8b8da-1868">Ein Objektarray mit 0 (null) oder mehr zu formatierenden Objekten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1868">An object array that contains zero or more objects to format.</span></span></param>
        <summary><span data-ttu-id="8b8da-1869">Ersetzt die Formatelemente in einer Zeichenfolge durch die Zeichenfolgendarstellungen entsprechender Objekte in einem angegebenen Array.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1869">Replaces the format items in a string with the string representations of corresponding objects in a specified array.</span></span> <span data-ttu-id="8b8da-1870">Ein Parameter liefert kulturspezifische Formatierungsinformationen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1870">A parameter supplies culture-specific formatting information.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1871">Eine Kopie von <paramref name="format" />, in der die Formatelemente durch die Zeichenfolgendarstellung der entsprechenden Objekte in <paramref name="args" /> ersetzt wurden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1871">A copy of <paramref name="format" /> in which the format items have been replaced by the string representation of the corresponding objects in <paramref name="args" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)]

<span data-ttu-id="8b8da-1872">Diese Methode verwendet die [Funktion für die kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) , um vier oder mehr Ausdrücke in ihre Zeichen folgen Darstellungen zu konvertieren und diese Darstellungen in eine Zeichenfolge einzubetten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1872">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert four or more expressions to their string representations and to embed those representations in a string.</span></span> <span data-ttu-id="8b8da-1873">Beim Durchführen der Konvertierung verwendet die-Methode Kultur abhängige Formatierung oder einen benutzerdefinierten Formatierer.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1873">In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</span></span> <span data-ttu-id="8b8da-1874">Die-Methode konvertiert jedes <xref:System.Object> Argument in seine Zeichen folgen Darstellung, indem die **ToString (IFormatProvider)** -Methode aufgerufen wird, oder, wenn das entsprechende Format Element des Objekts eine Format Zeichenfolge enthält, indem die **ToString (String, IFormatProvider)** -Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1874">The method converts each <xref:System.Object> argument to its string representation by calling its **ToString(IFormatProvider)** method or, if the object's corresponding format item includes a format string, by calling its **ToString(String,IFormatProvider)** method.</span></span> <span data-ttu-id="8b8da-1875">Wenn diese Methoden nicht vorhanden sind, wird die **Parameter lose-** Methode des-Objekts aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1875">If these methods don't exist, it calls the object's parameterless **ToString** method.</span></span>

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]

<a name="culture-sensitive-formatting" />

### <a name="example-culture-sensitive-formatting"></a><span data-ttu-id="8b8da-1876">Beispiel: Kultur abhängige Formatierung</span><span class="sxs-lookup"><span data-stu-id="8b8da-1876">Example: Culture-sensitive formatting</span></span>

 <span data-ttu-id="8b8da-1877">In diesem Beispiel wird die <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29>-Methode verwendet, um die Zeichen folgen Darstellung einiger Datums-und Uhrzeitwerte und numerischer Werte mithilfe verschiedener Kulturen anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1877">This example uses the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> method to display the string representation of some date and time values and numeric values by using several different cultures.</span></span>

 [!code-csharp-interactive[System.String.Format2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example2.cs#2)]
 [!code-vb[System.String.Format2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example2.vb#2)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-1878"><paramref name="format" /> oder <paramref name="args" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1878"><paramref name="format" /> or <paramref name="args" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="8b8da-1879"><paramref name="format" /> ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1879"><paramref name="format" /> is invalid.</span></span>

<span data-ttu-id="8b8da-1880">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-1880">-or-</span></span>

<span data-ttu-id="8b8da-1881">Der Index eines Formatelements ist kleiner als 0 (null) oder größer oder gleich der Länge des <paramref name="args" />-Arrays.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1881">The index of a format item is less than zero, or greater than or equal to the length of the <paramref name="args" /> array.</span></span></exception>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.ICustomFormatter" />
        <altmember cref="T:System.IFormatProvider" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md"><span data-ttu-id="8b8da-1882">Formatieren von Typen in .NET</span><span class="sxs-lookup"><span data-stu-id="8b8da-1882">Formatting Types in .NET</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md"><span data-ttu-id="8b8da-1883">Kombinierte Formatierung</span><span class="sxs-lookup"><span data-stu-id="8b8da-1883">Composite Formatting</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md"><span data-ttu-id="8b8da-1884">Standard-Formatzeichenfolgen für Datum und Uhrzeit</span><span class="sxs-lookup"><span data-stu-id="8b8da-1884">Standard Date and Time Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md"><span data-ttu-id="8b8da-1885">Benutzerdefinierte Formatzeichenfolgen für Datum und Uhrzeit</span><span class="sxs-lookup"><span data-stu-id="8b8da-1885">Custom Date and Time Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md"><span data-ttu-id="8b8da-1886">Standardmäßige Zahlenformatzeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="8b8da-1886">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md"><span data-ttu-id="8b8da-1887">Benutzerdefinierte Zahlenformatzeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="8b8da-1887">Custom Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md"><span data-ttu-id="8b8da-1888">TimeSpan-Standardformatzeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="8b8da-1888">Standard TimeSpan Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md"><span data-ttu-id="8b8da-1889">Benutzerdefinierte TimeSpan-Formatzeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="8b8da-1889">Custom TimeSpan Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md"><span data-ttu-id="8b8da-1890">Enumerationsformatzeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="8b8da-1890">Enumeration Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="8b8da-1891">Eine [kombinierte Formatzeichenfolge](~/docs/standard/base-types/composite-formatting.md).</span><span class="sxs-lookup"><span data-stu-id="8b8da-1891">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="arg0"><span data-ttu-id="8b8da-1892">Das erste zu formatierende Objekt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1892">The first object to format.</span></span></param>
        <param name="arg1"><span data-ttu-id="8b8da-1893">Das zweite zu formatierende Objekt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1893">The second object to format.</span></span></param>
        <summary><span data-ttu-id="8b8da-1894">Ersetzt die Formatelemente in einer Zeichenfolge durch die Zeichenfolgendarstellung von zwei angegebenen Objekten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1894">Replaces the format items in a string with the string representation of two specified objects.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1895">Eine Kopie von <paramref name="format" />, in der Formatelemente durch die Zeichenfolgendarstellung von <paramref name="arg0" /> und <paramref name="arg1" /> ersetzt wurden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1895">A copy of <paramref name="format" /> in which format items are replaced by the string representations of <paramref name="arg0" /> and <paramref name="arg1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)]

<span data-ttu-id="8b8da-1896">Diese Methode verwendet die [Funktion für die kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) , um den Wert von zwei Ausdrücken in ihre Zeichen folgen Darstellungen zu konvertieren und diese Darstellungen in eine Zeichenfolge einzubetten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1896">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert the value of two expressions to their string representations and to embed those representations in a string.</span></span>

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-format-two-arguments"></a><span data-ttu-id="8b8da-1897">Beispiel: Formatieren von zwei Argumenten</span><span class="sxs-lookup"><span data-stu-id="8b8da-1897">Example: Format two arguments</span></span>

 <span data-ttu-id="8b8da-1898">In diesem Beispiel wird die <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29>-Methode verwendet, um in einem generischen <xref:System.Collections.Generic.Dictionary%602>-Objekt gespeicherte Zeit-und Temperaturdaten anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1898">This example uses the <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29> method to display time and temperature data stored in a generic <xref:System.Collections.Generic.Dictionary%602> object.</span></span> <span data-ttu-id="8b8da-1899">Beachten Sie, dass die Format Zeichenfolge drei Format Elemente enthält, obwohl nur zwei zu formatierende Objekte vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1899">Note that the format string has three format items, although there are only two objects to format.</span></span> <span data-ttu-id="8b8da-1900">Dies liegt daran, dass das erste Objekt in der Liste (ein Datums-und Uhrzeitwert) von zwei Format Elementen verwendet wird: das erste Format Element zeigt die Uhrzeit an, während die zweite das Datum anzeigt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1900">This is because the first object in the list (a date and time value) is used by two format items: The first format item displays the time, and the second displays the date.</span></span>

 [!code-cpp[System.String.Format#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample4.cpp#6)]
 [!code-csharp[System.String.Format#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatexample4.cs#6)]
 [!code-vb[System.String.Format#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatexample4.vb#6)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-1901"><paramref name="format" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1901"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="8b8da-1902"><paramref name="format" /> ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1902"><paramref name="format" /> is invalid.</span></span>

<span data-ttu-id="8b8da-1903">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-1903">-or-</span></span>

<span data-ttu-id="8b8da-1904">Der Index eines Formatelements ist nicht 0 (null) oder 1.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1904">The index of a format item is not zero or one.</span></span></exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md"><span data-ttu-id="8b8da-1905">Formatieren von Typen in .NET</span><span class="sxs-lookup"><span data-stu-id="8b8da-1905">Formatting Types in .NET</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md"><span data-ttu-id="8b8da-1906">Kombinierte Formatierung</span><span class="sxs-lookup"><span data-stu-id="8b8da-1906">Composite Formatting</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md"><span data-ttu-id="8b8da-1907">Standard-Formatzeichenfolgen für Datum und Uhrzeit</span><span class="sxs-lookup"><span data-stu-id="8b8da-1907">Standard Date and Time Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md"><span data-ttu-id="8b8da-1908">Benutzerdefinierte Formatzeichenfolgen für Datum und Uhrzeit</span><span class="sxs-lookup"><span data-stu-id="8b8da-1908">Custom Date and Time Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md"><span data-ttu-id="8b8da-1909">Standardmäßige Zahlenformatzeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="8b8da-1909">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md"><span data-ttu-id="8b8da-1910">Benutzerdefinierte Zahlenformatzeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="8b8da-1910">Custom Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md"><span data-ttu-id="8b8da-1911">TimeSpan-Standardformatzeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="8b8da-1911">Standard TimeSpan Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md"><span data-ttu-id="8b8da-1912">Benutzerdefinierte TimeSpan-Formatzeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="8b8da-1912">Custom TimeSpan Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md"><span data-ttu-id="8b8da-1913">Enumerationsformatzeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="8b8da-1913">Enumeration Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="8b8da-1914">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1914">An object that supplies culture-specific formatting information.</span></span></param>
        <param name="format"><span data-ttu-id="8b8da-1915">Eine [kombinierte Formatzeichenfolge](~/docs/standard/base-types/composite-formatting.md).</span><span class="sxs-lookup"><span data-stu-id="8b8da-1915">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="arg0"><span data-ttu-id="8b8da-1916">Das erste zu formatierende Objekt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1916">The first object to format.</span></span></param>
        <param name="arg1"><span data-ttu-id="8b8da-1917">Das zweite zu formatierende Objekt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1917">The second object to format.</span></span></param>
        <summary><span data-ttu-id="8b8da-1918">Ersetzt die Formatelemente in einer Zeichenfolge durch die Zeichenfolgendarstellung von zwei angegebenen Objekten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1918">Replaces the format items in a string with the string representation of two specified objects.</span></span> <span data-ttu-id="8b8da-1919">Ein Parameter liefert kulturspezifische Formatierungsinformationen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1919">A parameter supplies culture-specific formatting information.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1920">Eine Kopie von <paramref name="format" />, in der Formatelemente durch die Zeichenfolgendarstellung von <paramref name="arg0" /> und <paramref name="arg1" /> ersetzt wurden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1920">A copy of <paramref name="format" /> in which format items are replaced by the string representations of <paramref name="arg0" /> and <paramref name="arg1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)]

<span data-ttu-id="8b8da-1921">Diese Methode verwendet die [Funktion für die kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) , um zwei Ausdrücke in ihre Zeichen folgen Darstellungen zu konvertieren und diese Darstellungen in eine Zeichenfolge einzubetten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1921">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert two expressions to their string representations and to embed those representations in a string.</span></span> <span data-ttu-id="8b8da-1922">Beim Durchführen der Konvertierung verwendet die-Methode Kultur abhängige Formatierung oder einen benutzerdefinierten Formatierer.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1922">In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</span></span> <span data-ttu-id="8b8da-1923">Die-Methode konvertiert jedes <xref:System.Object> Argument in seine Zeichen folgen Darstellung, indem die **ToString (IFormatProvider)** -Methode aufgerufen wird, oder, wenn das entsprechende Format Element des Objekts eine Format Zeichenfolge enthält, indem die **ToString (String, IFormatProvider)** -Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1923">The method converts each <xref:System.Object> argument to its string representation by calling its **ToString(IFormatProvider)** method or, if the object's corresponding format item includes a format string, by calling its **ToString(String,IFormatProvider)** method.</span></span> <span data-ttu-id="8b8da-1924">Wenn diese Methoden nicht vorhanden sind, wird die **Parameter lose-** Methode des-Objekts aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1924">If these methods don't exist, it calls the object's parameterless **ToString** method.</span></span>

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-1925"><paramref name="format" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1925"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="8b8da-1926"><paramref name="format" /> ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1926"><paramref name="format" /> is invalid.</span></span>

<span data-ttu-id="8b8da-1927">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-1927">-or-</span></span>

<span data-ttu-id="8b8da-1928">Der Index eines Formatelements ist nicht 0 (null) oder 1.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1928">The index of a format item is not zero or one.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="8b8da-1929">Eine [kombinierte Formatzeichenfolge](~/docs/standard/base-types/composite-formatting.md).</span><span class="sxs-lookup"><span data-stu-id="8b8da-1929">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="arg0"><span data-ttu-id="8b8da-1930">Das erste zu formatierende Objekt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1930">The first object to format.</span></span></param>
        <param name="arg1"><span data-ttu-id="8b8da-1931">Das zweite zu formatierende Objekt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1931">The second object to format.</span></span></param>
        <param name="arg2"><span data-ttu-id="8b8da-1932">Das dritte zu formatierende Objekt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1932">The third object to format.</span></span></param>
        <summary><span data-ttu-id="8b8da-1933">Ersetzt die Formatelemente in einer Zeichenfolge durch die Zeichenfolgendarstellung von drei angegebenen Objekten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1933">Replaces the format items in a string with the string representation of three specified objects.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1934">Eine Kopie von <paramref name="format" />, in der Formatelemente durch die Zeichenfolgendarstellung von <paramref name="arg0" />, <paramref name="arg1" /> und <paramref name="arg2" /> ersetzt wurden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1934">A copy of <paramref name="format" /> in which the format items have been replaced by the string representations of <paramref name="arg0" />, <paramref name="arg1" />, and <paramref name="arg2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)]

<span data-ttu-id="8b8da-1935">Diese Methode verwendet die [Funktion für die kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) , um den Wert von drei Ausdrücken in ihre Zeichen folgen Darstellungen zu konvertieren und diese Darstellungen in eine Zeichenfolge einzubetten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1935">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert the value of three expressions to their string representations and to embed those representations in a string.</span></span>

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-format-three-arguments"></a><span data-ttu-id="8b8da-1936">Beispiel: Formatieren von drei Argumenten</span><span class="sxs-lookup"><span data-stu-id="8b8da-1936">Example: Format three arguments</span></span>

 <span data-ttu-id="8b8da-1937">In diesem Beispiel wird die <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29>-Methode verwendet, um eine Zeichenfolge zu erstellen, die das Ergebnis einer booleschen `And` Operation mit zwei ganzzahligen Werten veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1937">This example uses the <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> method to create a string that illustrates the result of a Boolean `And` operation with two integer values.</span></span> <span data-ttu-id="8b8da-1938">Beachten Sie, dass die Format Zeichenfolge sechs Format Elemente enthält, die-Methode jedoch nur drei Elemente in der Parameterliste aufweist, da jedes Element auf zwei verschiedene Arten formatiert ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1938">Note that the format string includes six format items, but the method has only three items in its parameter list, because each item is formatted in two different ways.</span></span>

 [!code-cpp[System.String.Format#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format4.cpp#4)]
 [!code-csharp-interactive[System.String.Format#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format4.cs#4)]
 [!code-vb[System.String.Format#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format4.vb#4)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-1939"><paramref name="format" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1939"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="8b8da-1940"><paramref name="format" /> ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1940"><paramref name="format" /> is invalid.</span></span>

<span data-ttu-id="8b8da-1941">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-1941">-or-</span></span>

<span data-ttu-id="8b8da-1942">Der Index eines Formatelements ist kleiner als 0 (null) oder größer als 2.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1942">The index of a format item is less than zero, or greater than two.</span></span></exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md"><span data-ttu-id="8b8da-1943">Formatieren von Typen in .NET</span><span class="sxs-lookup"><span data-stu-id="8b8da-1943">Formatting Types in .NET</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md"><span data-ttu-id="8b8da-1944">Kombinierte Formatierung</span><span class="sxs-lookup"><span data-stu-id="8b8da-1944">Composite Formatting</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="4" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="8b8da-1945">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1945">An object that supplies culture-specific formatting information.</span></span></param>
        <param name="format"><span data-ttu-id="8b8da-1946">Eine [kombinierte Formatzeichenfolge](~/docs/standard/base-types/composite-formatting.md).</span><span class="sxs-lookup"><span data-stu-id="8b8da-1946">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span></span></param>
        <param name="arg0"><span data-ttu-id="8b8da-1947">Das erste zu formatierende Objekt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1947">The first object to format.</span></span></param>
        <param name="arg1"><span data-ttu-id="8b8da-1948">Das zweite zu formatierende Objekt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1948">The second object to format.</span></span></param>
        <param name="arg2"><span data-ttu-id="8b8da-1949">Das dritte zu formatierende Objekt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1949">The third object to format.</span></span></param>
        <summary><span data-ttu-id="8b8da-1950">Ersetzt die Formatelemente in einer Zeichenfolge durch die Zeichenfolgendarstellung von drei angegebenen Objekten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1950">Replaces the format items in a string with the string representation of three specified objects.</span></span> <span data-ttu-id="8b8da-1951">Ein Parameter liefert kulturspezifische Formatierungsinformationen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1951">An parameter supplies culture-specific formatting information.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1952">Eine Kopie von <paramref name="format" />, in der Formatelemente durch die Zeichenfolgendarstellung von <paramref name="arg0" />, <paramref name="arg1" /> und <paramref name="arg2" /> ersetzt wurden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1952">A copy of <paramref name="format" /> in which the format items have been replaced by the string representations of <paramref name="arg0" />, <paramref name="arg1" />, and <paramref name="arg2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)]

<span data-ttu-id="8b8da-1953">Diese Methode verwendet die [Funktion für die kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) , um drei Ausdrücke in ihre Zeichen folgen Darstellungen zu konvertieren und diese Darstellungen in eine Zeichenfolge einzubetten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1953">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert three expressions to their string representations and to embed those representations in a string.</span></span> <span data-ttu-id="8b8da-1954">Beim Durchführen der Konvertierung verwendet die-Methode Kultur abhängige Formatierung oder einen benutzerdefinierten Formatierer.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1954">In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</span></span> <span data-ttu-id="8b8da-1955">Die-Methode konvertiert jedes <xref:System.Object> Argument in seine Zeichen folgen Darstellung, indem die **ToString (IFormatProvider)** -Methode aufgerufen wird, oder, wenn das entsprechende Format Element des Objekts eine Format Zeichenfolge enthält, indem die **ToString (String, IFormatProvider)** -Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1955">The method converts each <xref:System.Object> argument to its string representation by calling its **ToString(IFormatProvider)** method or, if the object's corresponding format item includes a format string, by calling its **ToString(String,IFormatProvider)** method.</span></span> <span data-ttu-id="8b8da-1956">Wenn diese Methoden nicht vorhanden sind, wird die **Parameter lose-** Methode des-Objekts aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1956">If these methods don't exist, it calls the object's parameterless **ToString** method.</span></span>

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-1957"><paramref name="format" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1957"><paramref name="format" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="8b8da-1958"><paramref name="format" /> ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1958"><paramref name="format" /> is invalid.</span></span>

<span data-ttu-id="8b8da-1959">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-1959">-or-</span></span>

<span data-ttu-id="8b8da-1960">Der Index eines Formatelements ist kleiner als 0 (null) oder größer als 2.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1960">The index of a format item is less than zero, or greater than two.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public CharEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.CharEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As CharEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CharEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; CharEnumerator" Usage="string.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CharEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8b8da-1961">Ruft ein Objekt ab, das die einzelnen Zeichen dieser Zeichenfolge durchlaufen kann.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1961">Retrieves an object that can iterate through the individual characters in this string.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1962">Ein Enumeratorobjekt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1962">An enumerator object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!TIP]
> <span data-ttu-id="8b8da-1963">Anstatt die <xref:System.String.GetEnumerator%2A>-Methode aufzurufende ein <xref:System.CharEnumerator> Objekt abzurufen, das Sie dann zum Auflisten einer Zeichenfolge verwenden, sollten Sie stattdessen das Iterations Konstrukt der Sprache C#(in C++, in/CLR und in Visual Basic) verwenden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1963">Rather than calling the <xref:System.String.GetEnumerator%2A> method to retrieve a <xref:System.CharEnumerator> object that you then use to enumerate a string, you should instead use your language's iteration construct (in C#, in C++/CLR, and in Visual Basic).</span></span> <span data-ttu-id="8b8da-1964">[foreach](~/docs/csharp/language-reference/keywords/foreach-in.md) in C#, [for each](/cpp/dotnet/for-each-in) in C++/CLR und [for each](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md) in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="8b8da-1964">[foreach](~/docs/csharp/language-reference/keywords/foreach-in.md) in C#, [for each](/cpp/dotnet/for-each-in) in C++/CLR, and [For Each](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md) in Visual Basic).</span></span>

 <span data-ttu-id="8b8da-1965">Diese Methode ermöglicht das Iterieren der einzelnen Zeichen in einer Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1965">This method enables you to iterate the individual characters in a string.</span></span> <span data-ttu-id="8b8da-1966">Beispielsweise rufen die Visual Basic `For Each`- C# und `foreach`-Anweisungen diese Methode auf, um ein <xref:System.CharEnumerator> Objekt zurückzugeben, das schreibgeschützten Zugriff auf die Zeichen in dieser Zeichen folgen Instanz bereitstellen kann.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1966">For example, the Visual Basic `For Each` and C# `foreach` statements invoke this method to return a <xref:System.CharEnumerator> object that can provide read-only access to the characters in this string instance.</span></span>



## Examples
 <span data-ttu-id="8b8da-1967">Im folgenden Beispiel werden die Zeichen in mehreren Zeichen folgen durchlaufen und Informationen über ihre einzelnen Zeichen angezeigt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1967">The following example iterates the characters in several strings and displays information about their individual characters.</span></span> <span data-ttu-id="8b8da-1968">Es verwendet das Language Iterations Konstrukt anstelle eines Aufrufes der <xref:System.String.GetEnumerator%2A>-Methode.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1968">It uses the language iteration construct rather than a call to the <xref:System.String.GetEnumerator%2A> method.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetEnumerator/CPP/getenumerator.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetEnumerator/CS/getenumerator.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetEnumerator/VB/getenumerator.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
        <altmember cref="T:System.Collections.IEnumerable" />
        <altmember cref="P:System.String.Chars(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="string.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8b8da-1969">Gibt den Hashcode für diese Zeichenfolge zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1969">Returns the hash code for this string.</span></span></summary>
        <returns><span data-ttu-id="8b8da-1970">Ein 32-Bit-Hashcode als ganze Zahl mit Vorzeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1970">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-1971">Das Verhalten von <xref:System.String.GetHashCode%2A> hängt von der Implementierung ab, die von einer Version des Common Language Runtime in eine andere geändert werden kann.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1971">The behavior of <xref:System.String.GetHashCode%2A> is dependent on its implementation, which might change from one version of the common language runtime to another.</span></span> <span data-ttu-id="8b8da-1972">Ein Grund, warum dies passieren kann, ist die Verbesserung der Leistung von <xref:System.String.GetHashCode%2A>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1972">A reason why this might happen is to improve the performance of <xref:System.String.GetHashCode%2A>.</span></span>

> [!IMPORTANT]
>  <span data-ttu-id="8b8da-1973">Wenn zwei Zeichen folgen Objekte gleich sind, gibt die <xref:System.String.GetHashCode%2A>-Methode identische Werte zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1973">If two string objects are equal, the <xref:System.String.GetHashCode%2A> method returns identical values.</span></span> <span data-ttu-id="8b8da-1974">Es gibt jedoch keinen eindeutigen Hashcodewert für jeden eindeutigen Zeichen folgen Wert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1974">However, there is not a unique hash code value for each unique string value.</span></span> <span data-ttu-id="8b8da-1975">Verschiedene Zeichen folgen können den gleichen Hashcode zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1975">Different strings can return the same hash code.</span></span>
>
>  <span data-ttu-id="8b8da-1976">Der Hashcode selbst ist nicht garantiert stabil.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1976">The hash code itself is not guaranteed to be stable.</span></span> <span data-ttu-id="8b8da-1977">Hashcodes für identische Zeichen folgen können in .net-Implementierungen, über .NET-Versionen und über .net-Plattformen (z. b. 32-Bit und 64-Bit) für eine einzelne Version von .net abweichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1977">Hash codes for identical strings can differ across .NET implementations, across .NET versions, and across .NET platforms (such as 32-bit and 64-bit) for a single version of .NET.</span></span> <span data-ttu-id="8b8da-1978">In einigen Fällen können Sie sich sogar je nach Anwendungsdomäne unterscheiden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1978">In some cases, they can even differ by application domain.</span></span> <span data-ttu-id="8b8da-1979">Dies bedeutet, dass zwei nachfolgende Ausführungen desselben Programms möglicherweise andere Hashcodes zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1979">This implies that two subsequent runs of the same program may return different hash codes.</span></span>
>
>  <span data-ttu-id="8b8da-1980">Daher sollten Hashcodes nie außerhalb der Anwendungsdomäne verwendet werden, in der Sie erstellt wurden. Sie sollten nie als Schlüsselfelder in einer Auflistung verwendet werden, und Sie sollten niemals persistent gespeichert werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1980">As a result, hash codes should never be used outside of the application domain in which they were created, they should never be used as key fields in a collection, and they should never be persisted.</span></span>
>
>  <span data-ttu-id="8b8da-1981">Verwenden Sie zum Schluss nicht den Hashcode anstelle eines Werts, der von einer kryptografischen Hash Funktion zurückgegeben wird, wenn Sie einen kryptografisch starken Hash benötigen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1981">Finally, don't use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash.</span></span> <span data-ttu-id="8b8da-1982">Verwenden Sie für kryptografische Hashes eine Klasse, die von der <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> oder <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> Klasse abgeleitet ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1982">For cryptographic hashes, use a class derived from the <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> or <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> class.</span></span>
>
>  <span data-ttu-id="8b8da-1983">Weitere Informationen zu Hashcodes finden Sie unter <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1983">For more information about hash codes, see <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span></span>

 <span data-ttu-id="8b8da-1984">In Desktop-Apps können Sie das [>-Element\<userandomizedstringhashalgorithm](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md) verwenden, um eindeutige Hashcodes pro Anwendungsdomäne zu generieren.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1984">In desktop apps, you can use the [\<UseRandomizedStringHashAlgorithm> element](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md) to generate unique hash codes on a per application domain basis.</span></span> <span data-ttu-id="8b8da-1985">Dadurch kann die Anzahl von Kollisionen reduziert und die Gesamtleistung von Einfügungen und Such Vorgängen, die Hash Tabellen verwenden, verbessert werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1985">This can reduce the number of collisions and improve the overall performance of insertions and lookups that use hash tables.</span></span> <span data-ttu-id="8b8da-1986">Im folgenden Beispiel wird gezeigt, wie das [\<userandomizedstringhashalgorithm > Element](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1986">The following example shows how to use the [\<UseRandomizedStringHashAlgorithm> element](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).</span></span> <span data-ttu-id="8b8da-1987">Es definiert eine `DisplayString` Klasse, die eine private Zeichen folgen Konstante enthält, `s`, deren Wert "This is a String" ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1987">It defines a `DisplayString` class that includes a private string constant, `s`, whose value is "This is a string."</span></span> <span data-ttu-id="8b8da-1988">Außerdem enthält sie eine `ShowStringHashCode`-Methode, die den Zeichenfolgenwert und dessen Hashcode zusammen mit dem Namen der Anwendungsdomäne anzeigt, in der die Methode ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1988">It also includes a `ShowStringHashCode` method that displays the string value and its hash code along with the name of the application domain in which the method is executing.</span></span>

 [!code-csharp[System.String.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/perdomain.cs#2)]
 [!code-vb[System.String.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/perdomain.vb#2)]

 <span data-ttu-id="8b8da-1989">Wenn Sie das Beispiel ausführen, ohne eine Konfigurationsdatei anzugeben, wird die folgende Ausgabe angezeigt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1989">When you run the example without supplying a configuration file, it displays output similar to the following.</span></span> <span data-ttu-id="8b8da-1990">Beachten Sie, dass die Hashcodes für die Zeichenfolge in den zwei Anwendungsdomänen identisch sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1990">Note that the hash codes for the string are identical in the two application domains.</span></span>

```
String 'This is a string.' in domain 'PerDomain.exe': 941BCEAC
String 'This is a string.' in domain 'NewDomain': 941BCEAC
```

 <span data-ttu-id="8b8da-1991">Wenn Sie jedoch die folgende Konfigurationsdatei im Verzeichnis des Beispiels hinzufügen und dann das Beispiel ausführen, unterscheiden sich die Hashcodes je nach Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1991">However, if you add the following configuration file to the example's directory and then run the example, the hash codes for the same string will differ by application domain.</span></span>

```xml
<?xml version ="1.0"?>
<configuration>
   <runtime>
      <UseRandomizedStringHashAlgorithm enabled="1" />
   </runtime>
</configuration>
```

 <span data-ttu-id="8b8da-1992">Wenn die Konfigurationsdatei vorhanden ist, zeigt das Beispiel die folgende Ausgabe an:</span><span class="sxs-lookup"><span data-stu-id="8b8da-1992">When the configuration file is present, the example displays the following output:</span></span>

```
String 'This is a string.' in domain 'PerDomain.exe': 5435776D
String 'This is a string.' in domain 'NewDomain': 75CC8236
```

> [!IMPORTANT]
>  <span data-ttu-id="8b8da-1993">Hashcodes werden verwendet, um Schlüssel gebundene Objekte effizient aus Hash Tabellen einzufügen und abzurufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1993">Hash codes are used to insert and retrieve keyed objects from hash tables efficiently.</span></span> <span data-ttu-id="8b8da-1994">Mit Hashcodes werden Zeichen folgen jedoch nicht eindeutig identifiziert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1994">However, hash codes don't uniquely identify strings.</span></span> <span data-ttu-id="8b8da-1995">Identische Zeichen folgen haben gleiche Hashcodes, aber die Common Language Runtime können auch den gleichen Hashcode anderen Zeichen folgen zuweisen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1995">Identical strings have  equal hash codes, but the common language runtime can also assign the same hash code to different strings.</span></span> <span data-ttu-id="8b8da-1996">Außerdem können Hashcodes je nach Version von .net, nach Plattform innerhalb einer einzelnen Version und nach Anwendungsdomäne variieren.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1996">In addition, hash codes can vary by version of .NET, by platform within a single version, and by application domain.</span></span> <span data-ttu-id="8b8da-1997">Aus diesem Grund sollten Sie Hash Code Werte weder serialisieren noch persistent speichern, auch wenn Sie nicht als Schlüssel in einer Hash Tabelle oder einem Wörterbuch verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1997">Because of this, you should not serialize or persist hash code values, nor should you use them as keys in a hash table or dictionary.</span></span>

 <span data-ttu-id="8b8da-1998">Weitere Informationen zur Verwendung von Hashcodes und der `GetHashCode`-Methode finden Sie unter <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1998">For additional information about the use of hash codes and the `GetHashCode` method, see <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span></span>



## Examples
 <span data-ttu-id="8b8da-1999">Im folgenden Beispiel wird die <xref:System.String.GetHashCode%2A>-Methode mithilfe verschiedener Eingabe Zeichenfolgen veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-1999">The following example demonstrates the <xref:System.String.GetHashCode%2A> method using various input strings.</span></span>

 [!code-cpp[system.string.gethashcode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetHashCode/CPP/gethashcode.cpp#1)]
 [!code-csharp[system.string.gethashcode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/gethashcode.cs#1)]
 [!code-vb[system.string.gethashcode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/gethashcode.vb#1)]

 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-2000">Der von <see cref="M:System.String.GetHashCode" /> zurückgegebene Wert ist plattformabhängig.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2000">The value returned by <see cref="M:System.String.GetHashCode" /> is platform-dependent.</span></span> <span data-ttu-id="8b8da-2001">Dies unterscheidet sich von der 32-Bit-Version und der 64-Bit-Version der .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2001">It differs on the 32-bit and 64-bit versions of the .NET Framework.</span></span> <span data-ttu-id="8b8da-2002">Sie kann sich auch zwischen den Versionen der .NET Framework und .net Core unterscheiden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2002">It also can differ between versions of the .NET Framework and .NET Core.</span></span></para></block>
        <altmember cref="M:System.Object.GetHashCode" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md"><span data-ttu-id="8b8da-2003">&lt;userandomizedstringhashalgorithm&gt; Element</span><span class="sxs-lookup"><span data-stu-id="8b8da-2003">&lt;UseRandomizedStringHashAlgorithm&gt; Element</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public static int GetHashCode (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHashCode(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHashCode (value As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHashCode(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="static member GetHashCode : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="System.string.GetHashCode value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-2004">Eine schreibgeschützte Zeichenspanne.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2004">A read-only character span.</span></span></param>
        <summary><span data-ttu-id="8b8da-2005">Gibt den Hashcode für die angegebene schreibgeschützte Zeichenspanne zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2005">Returns the hash code for the provided read-only character span.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2006">Ein 32-Bit-Hashcode als ganze Zahl mit Vorzeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2006">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public int GetHashCode (StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetHashCode(valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHashCode (comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetHashCode(StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : StringComparison -&gt; int" Usage="string.GetHashCode comparisonType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="comparisonType"><span data-ttu-id="8b8da-2007">Einer der Enumerationswerte, der die für den Vergleich zu verwendenden Regeln angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2007">One of the enumeration values that specifies the rules to use in the comparison.</span></span></param>
        <summary><span data-ttu-id="8b8da-2008">Gibt den Hashcode für diese Zeichenfolge gemäß der festgelegten Regeln zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2008">Returns the hash code for this string using the specified rules.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2009">Ein 32-Bit-Hashcode als ganze Zahl mit Vorzeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2009">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public static int GetHashCode (ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHashCode(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHashCode (value As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHashCode(ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member GetHashCode : ReadOnlySpan&lt;char&gt; * StringComparison -&gt; int" Usage="System.string.GetHashCode (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-2010">Eine schreibgeschützte Zeichenspanne.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2010">A read-only character span.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="8b8da-2011">Einer der Enumerationswerte, der die für den Vergleich zu verwendenden Regeln angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2011">One of the enumeration values that specifies the rules to use in the comparison.</span></span></param>
        <summary><span data-ttu-id="8b8da-2012">Gibt den Hashcode für die angegebene schreibgeschützte Zeichenspanne gemäß der festgelegten Regeln zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2012">Returns the hash code for the provided read-only character span using the specified rules.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2013">Ein 32-Bit-Hashcode als ganze Zahl mit Vorzeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2013">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPinnableReference">
      <MemberSignature Language="C#" Value="public ref readonly char GetPinnableReference ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char GetPinnableReference() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetPinnableReference" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPinnableReference () As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; char ^ GetPinnableReference();" />
      <MemberSignature Language="F#" Value="member this.GetPinnableReference : unit -&gt; char" Usage="string.GetPinnableReference " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Char</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="netcore-3.0">
            <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8b8da-2014">Gibt einen Verweis auf das Element der Zeichenfolge zurück, das sich bei Index 0 befindet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2014">Returns a reference to the element of the string at index zero.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2015">Ein Zeichen, das den Verweis auf das Element der Zeichenfolge bei Index 0 darstellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2015">A character representing the reference to the element of the string at index zero.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="8b8da-2016">Die `GetPinnableReference`-Methode gibt ein Zeichen zurück, das zum Fixieren einer <xref:System.String> im Speicher verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2016">The `GetPinnableReference` method returns a character that can be used for pinning a <xref:System.String> in memory.</span></span> <span data-ttu-id="8b8da-2017">Es ist erforderlich, um die Verwendung eines <xref:System.String> in einer fixed-Anweisung zu unterstützen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2017">It is required to support the use of a <xref:System.String> within a fixed statement.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="8b8da-2018">Die Zeichenfolge ist NULL.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2018">The string is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="string.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8b8da-2019">Gibt <see cref="T:System.TypeCode" /> für die <see cref="T:System.String" />-Klasse zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2019">Returns the <see cref="T:System.TypeCode" /> for the <see cref="T:System.String" /> class.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2020">Die Enumerationskonstante <see cref="F:System.TypeCode.String" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2020">The enumerated constant, <see cref="F:System.TypeCode.String" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 <span data-ttu-id="8b8da-2021">Im folgenden Beispiel wird die <xref:System.TypeCode> Enumerationskonstante für den <xref:System.String>-Typ angezeigt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2021">The following example displays the <xref:System.TypeCode> enumerated constant for the <xref:System.String> type.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.gettypecode/CPP/gtc.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.gettypecode/CS/gtc.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.gettypecode/VB/gtc.vb" id="Snippet1":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8b8da-2022">Gibt den NULL-basierten Index des ersten Vorkommens eines angegebenen Unicode-Zeichens oder einer angegebenen Unicode-Zeichenfolge in dieser Instanz an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2022">Reports the zero-based index of the first occurrence of a specified Unicode character or string within this instance.</span></span> <span data-ttu-id="8b8da-2023">Die Methode gibt -1 zurück, wenn das Zeichen oder die Zeichenfolge in dieser Instanz nicht gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2023">The method returns -1 if the character or string is not found in this instance.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-2024">Ein zu suchendes Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2024">A Unicode character to seek.</span></span></param>
        <summary><span data-ttu-id="8b8da-2025">Gibt den NULL-basierten Index des ersten Vorkommens des angegebenen Unicode-Zeichens in dieser Zeichenfolge an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2025">Reports the zero-based index of the first occurrence of the specified Unicode character in this string.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2026">Die nullbasierte Indexposition von <paramref name="value" />, wenn dieses Zeichen gefunden wurde, andernfalls -1.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2026">The zero-based index position of <paramref name="value" /> if that character is found, or -1 if it is not.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2027">Die Index Nummerierung beginnt bei Null.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2027">Index numbering starts from zero.</span></span>

 <span data-ttu-id="8b8da-2028">Diese Methode führt eine ordnungsgemäß (Kultur unabhängige) Suche aus, bei der ein Zeichen als äquivalent zu einem anderen Zeichen gilt, wenn Ihre Unicode-Skalarwerte identisch sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2028">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="8b8da-2029">So führen Sie eine Kultur abhängige Suche durch Verwenden Sie die <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>-Methode, bei der ein Unicode-Skalarwert, der ein vorzusammen gesetztes Zeichen darstellt, wie z. b. die Ligaturen "Æ" (u + 00c6), in Abhängigkeit von der Kultur als äquivalent zu jedem Vorkommen der Komponenten des Zeichens in der richtigen Reihenfolge betrachtet werden kann.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2029">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>



## Examples
 <span data-ttu-id="8b8da-2030">Im folgenden Beispiel wird veranschaulicht, wie Sie mithilfe der <xref:System.String.IndexOf%2A>-Methode eine <xref:System.String> nach einem Zeichen durchsuchen können.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2030">The following example demonstrates how you can search a <xref:System.String> for a character using the <xref:System.String.IndexOf%2A> method.</span></span>

 [!code-cpp[System.String.IndexOf#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexof_c.cpp#5)]
 [!code-csharp-interactive[System.String.IndexOf#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexof_c.cs#5)]
 [!code-vb[System.String.IndexOf#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexof_c.vb#5)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-2031">Die zu suchende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2031">The string to seek.</span></span></param>
        <summary><span data-ttu-id="8b8da-2032">Gibt den NULL-basierten Index des ersten Vorkommens der angegebenen Zeichenfolge in dieser Instanz an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2032">Reports the zero-based index of the first occurrence of the specified string in this instance.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2033">Die nullbasierte Indexposition von <paramref name="value" />, wenn diese Zeichenfolge gefunden wurde, andernfalls -1.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2033">The zero-based index position of <paramref name="value" /> if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="8b8da-2034">Wenn <paramref name="value" /><see cref="F:System.String.Empty" /> ist, wird 0 zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2034">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is 0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2035">Die Index Nummerierung beginnt bei Null.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2035">Index numbering starts from zero.</span></span>

 <span data-ttu-id="8b8da-2036">Diese Methode führt unter Verwendung der aktuellen Kultur eine Wort Suche (Groß-/Kleinschreibung und Kultur abhängige Suche) durch.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2036">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span> <span data-ttu-id="8b8da-2037">Die Suche beginnt an der ersten Zeichenposition dieser Instanz und wird bis zur letzten Zeichenposition fortgesetzt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2037">The search begins at the first character position of this instance and continues until the last character position.</span></span>

 <span data-ttu-id="8b8da-2038">Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2038">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="8b8da-2039">Bei einer kulturabhängige Suche, bei der `value` ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2039">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="8b8da-2040">Wenn `value` nur aus mindestens einem ignorierbaren Zeichen besteht, gibt die <xref:System.String.IndexOf%28System.String%29>-Methode immer 0 (null) zurück, um anzugeben, dass die Entsprechung am Anfang der aktuellen Instanz gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2040">If `value` consists only of one or more ignorable characters, the <xref:System.String.IndexOf%28System.String%29> method always returns 0 (zero) to indicate that the match is found at the beginning of the current instance.</span></span> <span data-ttu-id="8b8da-2041">Im folgenden Beispiel wird die <xref:System.String.IndexOf%28System.String%29>-Methode verwendet, um drei Teil Zeichenfolgen zu suchen (ein weicher Bindestrich (U + 00ad), ein weicher Bindestrich gefolgt von "n" und ein weicher Bindestrich, gefolgt von "m") in zwei Zeichen folgen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2041">In the following example, the <xref:System.String.IndexOf%28System.String%29> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</span></span> <span data-ttu-id="8b8da-2042">Nur eine der Zeichenfolgen enthält einen bedingten Bindestrich.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2042">Only one of the strings contains a soft hyphen.</span></span> <span data-ttu-id="8b8da-2043">Wenn das Beispiel in der [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher ausgeführt wird, ist das Ergebnis in jedem Fall, da der weiche Bindestrich ein ignorierbares Zeichen ist, das gleiche wie bei einem nicht in `value`enthaltene weiche Bindestrich.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2043">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in each case, because the soft hyphen is an ignorable character, the result is the same as if the soft hyphen had not been included in `value`.</span></span> <span data-ttu-id="8b8da-2044">Wenn nur nach einem Soft Bindestrich gesucht wird, gibt die Methode 0 (null) zurück, um anzugeben, dass eine Entsprechung am Anfang der Zeichenfolge gefunden wurde.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2044">When searching for a soft hyphen only, the method returns 0 (zero) to indicate that it has found a match at the beginning of the string.</span></span>

 [!code-csharp[System.String.IndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable21.cs#21)]
 [!code-vb[System.String.IndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable21.vb#21)]



## Examples
 <span data-ttu-id="8b8da-2045">Im folgenden Beispiel wird nach "n" in "Animal" gesucht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2045">The following example searches for the "n" in "animal".</span></span> <span data-ttu-id="8b8da-2046">Da Zeichen folgen Indizes bei Null und nicht bei 1 beginnen, gibt die <xref:System.String.IndexOf%28System.String%29>-Methode an, dass sich "n" an Position 1 befindet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2046">Because string indexes begin at zero rather than one, the <xref:System.String.IndexOf%28System.String%29> method indicates that the "n" is at position 1.</span></span>

 [!code-cpp[System.String.IndexOf#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/simple1.cpp#12)]
 [!code-csharp-interactive[System.String.IndexOf#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/simple1.cs#12)]
 [!code-vb[System.String.IndexOf#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/simple1.vb#12)]

 <span data-ttu-id="8b8da-2047">Im folgenden Beispiel wird die <xref:System.String.IndexOf%2A>-Methode verwendet, um die Anfangsposition eines Tier namens in einem Satz zu bestimmen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2047">The following example uses the <xref:System.String.IndexOf%2A> method to determine the starting position of an animal name in a sentence.</span></span> <span data-ttu-id="8b8da-2048">Diese Position wird dann verwendet, um ein Adjektiv einzufügen, das das Tier in den Satz beschreibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2048">It then uses this position to insert an adjective that describes the animal into the sentence.</span></span>

 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-2049"><paramref name="value" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2049"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-2050">Wie in [bewährte Methoden für die Verwendung von](~/docs/standard/base-types/best-practices-strings.md)Zeichen folgen erläutert, empfiehlt es sich, den Aufruf von Zeichen folgen Vergleichsmethoden zu vermeiden, die Standardwerte ersetzen, und stattdessen Methoden aufzurufen, für die Parameter explizit angegeben werden müssen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2050">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="8b8da-2051">Um den ersten Index einer Teil Zeichenfolge innerhalb einer Zeichen folgen Instanz mithilfe der Vergleichs Regeln der aktuellen Kultur zu ermitteln, müssen Sie die <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" />-Methoden Überladung mit dem Wert <see cref="F:System.StringComparison.CurrentCulture" /> für den `comparisonType` Parameter aufrufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2051">To find the first index of a substring within a string instance by using the comparison rules of the current culture, call the <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its `comparisonType` parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-2052">Ein zu suchendes Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2052">A Unicode character to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="8b8da-2053">Die Anfangsposition der Suche.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2053">The search starting position.</span></span></param>
        <summary><span data-ttu-id="8b8da-2054">Gibt den NULL-basierten Index des ersten Vorkommens des angegebenen Unicode-Zeichens in dieser Zeichenfolge an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2054">Reports the zero-based index of the first occurrence of the specified Unicode character in this string.</span></span> <span data-ttu-id="8b8da-2055">Die Suche beginnt an einer angegebenen Zeichenposition.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2055">The search starts at a specified character position.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2056">Die nullbasierte Indexposition von <paramref name="value" /> ab dem Anfang der Zeichenfolge, wenn dieses Zeichen gefunden wurde, andernfalls -1.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2056">The zero-based index position of <paramref name="value" /> from the start of the string if that character is found, or -1 if it is not.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2057">Die Index Nummerierung beginnt bei 0.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2057">Index numbering starts from 0.</span></span> <span data-ttu-id="8b8da-2058">Der `startIndex`-Parameter kann von 0 bis zu der Länge der Zeichenfolgeninstanz reichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2058">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span> <span data-ttu-id="8b8da-2059">Wenn `startIndex` der Länge der Zeichen folgen Instanz gleicht, gibt die Methode-1 zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2059">If `startIndex` equals the length of the string instance, the method returns -1.</span></span>

 <span data-ttu-id="8b8da-2060">Die Suchvorgänge reichen von `startIndex` bis zum Ende der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2060">The search ranges from `startIndex` to the end of the string.</span></span>

 <span data-ttu-id="8b8da-2061">Diese Methode führt eine ordnungsgemäß (Kultur unabhängige) Suche aus, bei der ein Zeichen als äquivalent zu einem anderen Zeichen gilt, wenn Ihre Unicode-Skalarwerte identisch sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2061">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="8b8da-2062">So führen Sie eine Kultur abhängige Suche durch Verwenden Sie die <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>-Methode, bei der ein Unicode-Skalarwert, der ein vorzusammen gesetztes Zeichen darstellt, wie z. b. die Ligaturen "Æ" (u + 00c6), in Abhängigkeit von der Kultur als äquivalent zu jedem Vorkommen der Komponenten des Zeichens in der richtigen Reihenfolge betrachtet werden kann.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2062">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>



## Examples
 <span data-ttu-id="8b8da-2063">Das folgende Beispiel veranschaulicht die <xref:System.String.IndexOf%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2063">The following example demonstrates the <xref:System.String.IndexOf%2A> method.</span></span>

 [!code-cpp[string.indexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof1/CPP/ixof1.cpp#1)]
 [!code-csharp-interactive[string.indexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof1/CS/ixof1.cs#1)]
 [!code-vb[string.indexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof1/VB/ixof1.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-2064"><paramref name="startIndex" /> ist kleiner als 0 (null) oder größer als die Länge der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2064"><paramref name="startIndex" /> is less than 0 (zero) or greater than the length of the string.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-2065">Das zu suchende Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2065">The character to seek.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="8b8da-2066">Ein Enumerationswert, der die Regeln für die Suche festlegt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2066">An enumeration value that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="8b8da-2067">Gibt den NULL-basierten Index des ersten Vorkommens des angegebenen Unicode-Zeichens in dieser Zeichenfolge an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2067">Reports the zero-based index of the first occurrence of the specified Unicode character in this string.</span></span> <span data-ttu-id="8b8da-2068">Ein Parameter gibt den Typ der Suche für das angegebene Zeichen an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2068">A parameter specifies the type of search to use for the specified character.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2069">Der nullbasierte Index von <paramref name="value" />, wenn dieses Zeichen gefunden wurde, andernfalls -1.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2069">The zero-based index of <paramref name="value" /> if that character is found, or -1 if it is not.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="8b8da-2070">Die Index Nummerierung beginnt bei Null.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2070">Index numbering starts from zero.</span></span>

<span data-ttu-id="8b8da-2071">Der `comparisonType`-Parameter ist ein <xref:System.StringComparison> Enumerationsmember, der angibt, ob die Suche nach dem `value`-Argument die aktuelle oder invariante Kultur verwendet, die Groß-/Kleinschreibung beachtet oder die Groß-/Kleinschreibung beachtet oder Wort-oder Ordinalvergleichsregeln verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2071">The `comparisonType` parameter is a <xref:System.StringComparison> enumeration member that specifies whether the search for the `value` argument uses the current or invariant culture, is case-sensitive or case-insensitive, or uses word or ordinal comparison rules.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8b8da-2072"><paramref name="comparisonType" /> ist kein gültiger <see cref="T:System.StringComparison" />-Wert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2072"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-2073">Die zu suchende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2073">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="8b8da-2074">Die Anfangsposition der Suche.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2074">The search starting position.</span></span></param>
        <summary><span data-ttu-id="8b8da-2075">Gibt den NULL-basierten Index des ersten Vorkommens der angegebenen Zeichenfolge in dieser Instanz an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2075">Reports the zero-based index of the first occurrence of the specified string in this instance.</span></span> <span data-ttu-id="8b8da-2076">Die Suche beginnt an einer angegebenen Zeichenposition.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2076">The search starts at a specified character position.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2077">Die nullbasierte Indexposition von <paramref name="value" /> vom Anfang der aktuellen Instanz, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2077">The zero-based index position of <paramref name="value" /> from the start of the current instance if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="8b8da-2078">Wenn <paramref name="value" /><see cref="F:System.String.Empty" /> ist, wird <paramref name="startIndex" /> zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2078">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is <paramref name="startIndex" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2079">Die Index Nummerierung beginnt bei 0.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2079">Index numbering starts from 0.</span></span> <span data-ttu-id="8b8da-2080">Der `startIndex`-Parameter kann von 0 bis zu der Länge der Zeichenfolgeninstanz reichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2080">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span> <span data-ttu-id="8b8da-2081">Wenn `startIndex` der Länge der Zeichen folgen Instanz gleicht, gibt die Methode-1 zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2081">If `startIndex` equals the length of the string instance, the method returns -1.</span></span>

 <span data-ttu-id="8b8da-2082">Diese Methode führt unter Verwendung der aktuellen Kultur eine Wort Suche (Groß-/Kleinschreibung und Kultur abhängige Suche) durch.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2082">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span> <span data-ttu-id="8b8da-2083">Die Suche beginnt an der `startIndex` Zeichenposition dieser Instanz und wird bis zur letzten Zeichenposition fortgesetzt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2083">The search begins at the `startIndex` character position of this instance and continues until the last character position.</span></span>

 <span data-ttu-id="8b8da-2084">Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2084">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="8b8da-2085">Bei einer kulturabhängige Suche, bei der `value` ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2085">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="8b8da-2086">Wenn `value` nur aus mindestens einem ignorierbaren Zeichen besteht, gibt die <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29>-Methode immer `startIndex`zurück. Dies ist die Zeichenposition, an der die Suche beginnt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2086">If `value` consists only of one or more ignorable characters, the <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> method always returns `startIndex`, which is the character position at which the search begins.</span></span> <span data-ttu-id="8b8da-2087">Im folgenden Beispiel wird die <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29>-Methode verwendet, um die Position eines Soft-Bindestrichs (U + 00ad), gefolgt von einem "m", in zwei Zeichen folgen zu suchen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2087">In the following example, the <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" in two strings.</span></span> <span data-ttu-id="8b8da-2088">Nur eine der Zeichenfolgen enthält die erforderliche Teilzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2088">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="8b8da-2089">Wenn das Beispiel in der [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder später ausgeführt wird, gibt die Methode in beiden Fällen den Index "m" in der Zeichenfolge zurück, da der weiche Bindestrich ein ignorierbares Zeichen ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2089">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string.</span></span> <span data-ttu-id="8b8da-2090">Beachten Sie, dass bei der ersten Zeichenfolge, die den bedingten Bindestrich gefolgt von einem "m" umfasst, die Methode den Index des bedingten Bindestrichs nicht zurückgeben kann, sondern stattdessen den Index des "m" zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2090">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</span></span>

 [!code-csharp[System.String.IndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable22.cs#22)]
 [!code-vb[System.String.IndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable22.vb#22)]



## Examples
 <span data-ttu-id="8b8da-2091">Im folgenden Beispiel wird nach allen Vorkommen einer angegebenen Zeichenfolge in einer Ziel Zeichenfolge gesucht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2091">The following example searches for all occurrences of a specified string within a target string.</span></span>

 [!code-cpp[stringindexof4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringindexof4/CPP/stringindexof4.cpp#1)]
 [!code-csharp[stringindexof4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringindexof4/CS/stringindexof4.cs#1)]
 [!code-vb[stringindexof4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringindexof4/VB/stringindexof4.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-2092"><paramref name="value" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2092"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-2093"><paramref name="startIndex" /> ist kleiner als 0 (null) oder größer als die Länge dieser Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2093"><paramref name="startIndex" /> is less than 0 (zero) or greater than the length of this string.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-2094">Wie in [bewährte Methoden für die Verwendung von](~/docs/standard/base-types/best-practices-strings.md)Zeichen folgen erläutert, empfiehlt es sich, den Aufruf von Zeichen folgen Vergleichsmethoden zu vermeiden, die Standardwerte ersetzen, und stattdessen Methoden aufzurufen, für die Parameter explizit angegeben werden müssen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2094">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="8b8da-2095">Um den ersten Index einer Teil Zeichenfolge zu ermitteln, die nach einer bestimmten Zeichenposition auftritt, indem Sie die Vergleichs Regeln der aktuellen Kultur verwenden, müssen Sie die <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />-Methoden Überladung mit dem Wert <see cref="F:System.StringComparison.CurrentCulture" /> für den `comparisonType`-Parameter aufrufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2095">To find the first index of a substring that occurs after a particular character position by using the comparison rules of the current culture, call the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its `comparisonType` parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-2096">Die zu suchende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2096">The string to seek.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="8b8da-2097">Einer der Enumerationswerte, der die Regeln für die Suche angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2097">One of the enumeration values that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="8b8da-2098">Gibt den NULL-basierten Index des ersten Vorkommens der angegebenen Zeichenfolge im aktuellen <see cref="T:System.String" />-Objekt an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2098">Reports the zero-based index of the first occurrence of the specified string in the current <see cref="T:System.String" /> object.</span></span> <span data-ttu-id="8b8da-2099">Ein Parameter gibt den Typ der Suche für die angegebene Zeichenfolge an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2099">A parameter specifies the type of search to use for the specified string.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2100">Die Indexposition des <paramref name="value" />-Parameters, wenn diese Zeichenfolge gefunden wurde, andernfalls -1.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2100">The index position of the <paramref name="value" /> parameter if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="8b8da-2101">Wenn <paramref name="value" /><see cref="F:System.String.Empty" /> ist, wird 0 zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2101">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is 0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2102">Die Index Nummerierung beginnt bei Null.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2102">Index numbering starts from zero.</span></span>

 <span data-ttu-id="8b8da-2103">Der `comparisonType`-Parameter gibt an, dass mithilfe der aktuellen oder der invarianten Kultur nach dem `value` Parameter gesucht werden soll. dabei wird die Groß-/Kleinschreibung beachtet oder die Suche ohne Beachtung der Groß-/Kleinschreibung unterschieden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2103">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>



## Examples
 <span data-ttu-id="8b8da-2104">Im folgenden Beispiel werden drei über Ladungen der <xref:System.String.IndexOf%2A>-Methode veranschaulicht, die das erste Vorkommen einer Zeichenfolge in einer anderen Zeichenfolge mithilfe verschiedener Werte der <xref:System.StringComparison> Enumeration suchen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2104">The following example demonstrates three overloads of the <xref:System.String.IndexOf%2A> method that find the first occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>

 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-2105"><paramref name="value" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2105"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8b8da-2106"><paramref name="comparisonType" /> ist kein gültiger <see cref="T:System.StringComparison" />-Wert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2106"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-2107">Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2107">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="8b8da-2108">Bei einer kulturabhängige Suche (das heißt, wenn <paramref name="comparisonType" /> nicht <see cref="F:System.StringComparison.Ordinal" /> oder <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> ist), bei der <paramref name="value" /> ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2108">In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="8b8da-2109">Wenn <paramref name="value" /> nur aus mindestens einem ignorierbaren Zeichen besteht, gibt die <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" />-Methode immer 0 (null) zurück, um anzugeben, dass die Entsprechung am Anfang der aktuellen Instanz gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2109">If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> method always returns 0 (zero) to indicate that the match is found at the beginning of the current instance.</span></span>

<span data-ttu-id="8b8da-2110">Im folgenden Beispiel wird die <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" />-Methode verwendet, um drei Teil Zeichenfolgen zu suchen (ein weicher Bindestrich (U + 00ad), ein weicher Bindestrich gefolgt von "n" und ein weicher Bindestrich, gefolgt von "m") in zwei Zeichen folgen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2110">In the following example, the <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</span></span> <span data-ttu-id="8b8da-2111">Nur eine der Zeichenfolgen enthält einen bedingten Bindestrich.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2111">Only one of the strings contains a soft hyphen.</span></span> <span data-ttu-id="8b8da-2112">Wenn das Beispiel auf [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher ausgeführt wird, weil der weiche Bindestrich ein ignorierbares Zeichen ist, gibt eine Kultur abhängige Suche denselben Wert zurück, der zurückgegeben wird, wenn der weiche Bindestrich nicht in der Such Zeichenfolge enthalten wäre.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2112">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, because the soft hyphen is an ignorable character, a culture-sensitive search returns the same value that it would return if the soft hyphen were not included in the search string.</span></span> <span data-ttu-id="8b8da-2113">Bei einer ordinalsuchsuche wird jedoch der weiche Bindestrich in einer Zeichenfolge gefunden, und es wird gemeldet, dass Sie in der zweiten Zeichenfolge nicht vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2113">An ordinal search, however, successfully finds the soft hyphen in one string and reports that it is absent from the second string.</span></span>

<span data-ttu-id="8b8da-2114">[! Code-csharp[System. String. IndexOf # 26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable26.cs#26)] [! Code-vb[System. String. IndexOf # 26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable26.vb#26)]</span><span class="sxs-lookup"><span data-stu-id="8b8da-2114">[!code-csharp[System.String.IndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable26.cs#26)] [!code-vb[System.String.IndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable26.vb#26)]</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-2115">Ein zu suchendes Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2115">A Unicode character to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="8b8da-2116">Die Anfangsposition der Suche.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2116">The search starting position.</span></span></param>
        <param name="count"><span data-ttu-id="8b8da-2117">Die Anzahl der zu überprüfenden Zeichenpositionen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2117">The number of character positions to examine.</span></span></param>
        <summary><span data-ttu-id="8b8da-2118">Gibt den NULL-basierten Index des ersten Vorkommens des angegebenen Zeichens in dieser Instanz an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2118">Reports the zero-based index of the first occurrence of the specified character in this instance.</span></span> <span data-ttu-id="8b8da-2119">Die Suche beginnt an einer angegebenen Zeichenposition, und es wird eine angegebene Anzahl von Zeichenpositionen überprüft.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2119">The search starts at a specified character position and examines a specified number of character positions.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2120">Die nullbasierte Indexposition von <paramref name="value" /> ab dem Anfang der Zeichenfolge, wenn dieses Zeichen gefunden wurde, andernfalls -1.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2120">The zero-based index position of <paramref name="value" /> from the start of the string if that character is found, or -1 if it is not.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2121">Die Suche beginnt bei `startIndex` und wird weiterhin  + `count`-1 `startIndex`.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2121">The search begins at `startIndex` and continues to `startIndex` + `count` -1.</span></span> <span data-ttu-id="8b8da-2122">Das Zeichen an `startIndex` + `count` ist nicht in der Suche enthalten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2122">The character at `startIndex` + `count` is not included in the search.</span></span>

 <span data-ttu-id="8b8da-2123">Die Index Nummerierung beginnt bei 0 (null).</span><span class="sxs-lookup"><span data-stu-id="8b8da-2123">Index numbering starts from 0 (zero).</span></span> <span data-ttu-id="8b8da-2124">Der `startIndex`-Parameter kann von 0 bis zu der Länge der Zeichenfolgeninstanz reichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2124">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span>

 <span data-ttu-id="8b8da-2125">Diese Methode führt eine ordnungsgemäß (Kultur unabhängige) Suche aus, bei der ein Zeichen als äquivalent zu einem anderen Zeichen gilt, wenn Ihre Unicode-Skalarwerte identisch sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2125">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="8b8da-2126">So führen Sie eine Kultur abhängige Suche durch Verwenden Sie die <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>-Methode, bei der ein Unicode-Skalarwert, der ein vorzusammen gesetztes Zeichen darstellt, wie z. b. die Ligaturen "Æ" (u + 00c6), in Abhängigkeit von der Kultur als äquivalent zu jedem Vorkommen der Komponenten des Zeichens in der richtigen Reihenfolge betrachtet werden kann.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2126">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>



## Examples
 <span data-ttu-id="8b8da-2127">Das folgende Beispiel veranschaulicht die <xref:System.String.IndexOf%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2127">The following example demonstrates the <xref:System.String.IndexOf%2A> method.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexofcii.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexofcii.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexofcii.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-2128"><paramref name="count" /> oder <paramref name="startIndex" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2128"><paramref name="count" /> or <paramref name="startIndex" /> is negative.</span></span>

<span data-ttu-id="8b8da-2129">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-2129">-or-</span></span>

 <span data-ttu-id="8b8da-2130"><paramref name="startIndex" /> ist größer als die Länge dieser Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2130"><paramref name="startIndex" /> is greater than the length of this string.</span></span>

<span data-ttu-id="8b8da-2131">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-2131">-or-</span></span>

 <span data-ttu-id="8b8da-2132"><paramref name="count" /> ist größer als die Länge dieser Zeichenfolge minus <paramref name="startIndex" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2132"><paramref name="count" /> is greater than the length of this string minus <paramref name="startIndex" />.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-2133">Die zu suchende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2133">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="8b8da-2134">Die Anfangsposition der Suche.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2134">The search starting position.</span></span></param>
        <param name="count"><span data-ttu-id="8b8da-2135">Die Anzahl der zu überprüfenden Zeichenpositionen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2135">The number of character positions to examine.</span></span></param>
        <summary><span data-ttu-id="8b8da-2136">Gibt den NULL-basierten Index des ersten Vorkommens der angegebenen Zeichenfolge in dieser Instanz an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2136">Reports the zero-based index of the first occurrence of the specified string in this instance.</span></span> <span data-ttu-id="8b8da-2137">Die Suche beginnt an einer angegebenen Zeichenposition, und es wird eine angegebene Anzahl von Zeichenpositionen überprüft.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2137">The search starts at a specified character position and examines a specified number of character positions.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2138">Die nullbasierte Indexposition von <paramref name="value" /> vom Anfang der aktuellen Instanz, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2138">The zero-based index position of <paramref name="value" /> from the start of the current instance if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="8b8da-2139">Wenn <paramref name="value" /><see cref="F:System.String.Empty" /> ist, wird <paramref name="startIndex" /> zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2139">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is <paramref name="startIndex" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2140">Die Index Nummerierung beginnt bei 0 (null).</span><span class="sxs-lookup"><span data-stu-id="8b8da-2140">Index numbering starts from 0 (zero).</span></span> <span data-ttu-id="8b8da-2141">Der `startIndex`-Parameter kann von 0 bis zu der Länge der Zeichenfolgeninstanz reichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2141">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span>

 <span data-ttu-id="8b8da-2142">Diese Methode führt unter Verwendung der aktuellen Kultur eine Wort Suche (Groß-/Kleinschreibung und Kultur abhängige Suche) durch.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2142">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span> <span data-ttu-id="8b8da-2143">Die Suche beginnt bei `startIndex` und wird weiterhin  + `count`-1 `startIndex`.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2143">The search begins at `startIndex` and continues to `startIndex` + `count` -1.</span></span> <span data-ttu-id="8b8da-2144">Das Zeichen an `startIndex` + `count` ist nicht in der Suche enthalten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2144">The character at `startIndex` + `count` is not included in the search.</span></span>

 <span data-ttu-id="8b8da-2145">Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2145">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="8b8da-2146">Bei einer kulturabhängige Suche, bei der `value` ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2146">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="8b8da-2147">Wenn `value` nur aus mindestens einem ignorierbaren Zeichen besteht, gibt die <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29>-Methode immer `startIndex`zurück. Dies ist die Zeichenposition, an der die Suche beginnt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2147">If `value` consists only of one or more ignorable characters, the <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> method always returns `startIndex`, which is the character position at which the search begins.</span></span> <span data-ttu-id="8b8da-2148">Im folgenden Beispiel wird die <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29>-Methode verwendet, um die Position eines Soft Bindestrichs (U + 00ad), gefolgt von einem "m", beginnend mit den dritten bis sechsten Zeichen Positionen in zwei Zeichen folgen zu suchen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2148">In the following example, the <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" starting in the third through sixth character positions in two strings.</span></span> <span data-ttu-id="8b8da-2149">Nur eine der Zeichenfolgen enthält die erforderliche Teilzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2149">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="8b8da-2150">Wenn das Beispiel in der [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder später ausgeführt wird, da der weiche Bindestrich ein ignorierbares Zeichen ist, gibt die Methode den Index von "m" in der Zeichenfolge zurück, wenn Sie einen Kultur abhängigen Vergleich durchführt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2150">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="8b8da-2151">Beachten Sie, dass bei der ersten Zeichenfolge, die den bedingten Bindestrich gefolgt von einem "m" umfasst, die Methode den Index des bedingten Bindestrichs nicht zurückgeben kann, sondern stattdessen den Index des "m" zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2151">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</span></span>

 [!code-csharp[System.String.IndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable23.cs#23)]
 [!code-vb[System.String.IndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable23.vb#23)]



## Examples
 <span data-ttu-id="8b8da-2152">Im folgenden Beispiel wird der Index aller Vorkommen der Zeichenfolge "he" in einer Teil Zeichenfolge einer anderen Zeichenfolge gefunden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2152">The following example finds the index of all occurrences of the string "he" within a substring of another string.</span></span> <span data-ttu-id="8b8da-2153">Beachten Sie, dass die Anzahl der zu durchsuchenden Zeichen für jede Such Iterations Dauer neu berechnet werden muss.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2153">Note that the number of characters to be searched must be recalculated for each search iteration.</span></span>

 [!code-cpp[string.indexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof8/CPP/ixof8.cpp#1)]
 [!code-csharp-interactive[string.indexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof8/CS/ixof8.cs#1)]
 [!code-vb[string.indexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof8/VB/ixof8.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-2154"><paramref name="value" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2154"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-2155"><paramref name="count" /> oder <paramref name="startIndex" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2155"><paramref name="count" /> or <paramref name="startIndex" /> is negative.</span></span>

<span data-ttu-id="8b8da-2156">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-2156">-or-</span></span>

 <span data-ttu-id="8b8da-2157"><paramref name="startIndex" /> ist größer als die Länge dieser Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2157"><paramref name="startIndex" /> is greater than the length of this string.</span></span>

<span data-ttu-id="8b8da-2158">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-2158">-or-</span></span>

 <span data-ttu-id="8b8da-2159"><paramref name="count" /> ist größer als die Länge dieser Zeichenfolge minus <paramref name="startIndex" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2159"><paramref name="count" /> is greater than the length of this string minus <paramref name="startIndex" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-2160">Wie in [bewährte Methoden für die Verwendung von](~/docs/standard/base-types/best-practices-strings.md)Zeichen folgen erläutert, empfiehlt es sich, den Aufruf von Zeichen folgen Vergleichsmethoden zu vermeiden, die Standardwerte ersetzen, und stattdessen Methoden aufzurufen, für die Parameter explizit angegeben werden müssen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2160">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="8b8da-2161">Um die Vergleichs Regeln der aktuellen Kultur zu verwenden, um diesen Vorgang auszuführen, müssen Sie die <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />-Methoden Überladung mit dem Wert <see cref="F:System.StringComparison.CurrentCulture" /> für den `comparisonType`-Parameter aufrufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2161">To use the comparison rules of the current culture to perform this operation, call the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its `comparisonType` parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-2162">Die zu suchende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2162">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="8b8da-2163">Die Anfangsposition der Suche.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2163">The search starting position.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="8b8da-2164">Einer der Enumerationswerte, der die Regeln für die Suche angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2164">One of the enumeration values that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="8b8da-2165">Gibt den NULL-basierten Index des ersten Vorkommens der angegebenen Zeichenfolge im aktuellen <see cref="T:System.String" />-Objekt an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2165">Reports the zero-based index of the first occurrence of the specified string in the current <see cref="T:System.String" /> object.</span></span> <span data-ttu-id="8b8da-2166">Parameter geben die Anfangssuchposition in der aktuellen Zeichenfolge und den Typ der Suche an, die für die angegebene Zeichenfolge verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2166">Parameters specify the starting search position in the current string and the type of search to use for the specified string.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2167">Die nullbasierte Indexposition des <paramref name="value" />-Parameters vom Anfang der aktuellen Instanz, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2167">The zero-based index position of the <paramref name="value" /> parameter from the start of the current instance if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="8b8da-2168">Wenn <paramref name="value" /><see cref="F:System.String.Empty" /> ist, wird <paramref name="startIndex" /> zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2168">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is <paramref name="startIndex" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2169">Die Index Nummerierung beginnt bei 0.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2169">Index numbering starts from 0.</span></span> <span data-ttu-id="8b8da-2170">Der `startIndex`-Parameter kann von 0 bis zu der Länge der Zeichenfolgeninstanz reichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2170">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span> <span data-ttu-id="8b8da-2171">Wenn `startIndex` der Länge der Zeichen folgen Instanz gleicht, gibt die Methode-1 zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2171">If `startIndex` equals the length of the string instance, the method returns -1.</span></span>

 <span data-ttu-id="8b8da-2172">Der `comparisonType`-Parameter gibt an, dass mithilfe der aktuellen oder der invarianten Kultur nach dem `value` Parameter gesucht werden soll. dabei wird die Groß-/Kleinschreibung beachtet oder die Suche ohne Beachtung der Groß-/Kleinschreibung unterschieden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2172">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>



## Examples
 <span data-ttu-id="8b8da-2173">Im folgenden Beispiel werden drei über Ladungen der <xref:System.String.IndexOf%2A>-Methode veranschaulicht, die das erste Vorkommen einer Zeichenfolge in einer anderen Zeichenfolge mithilfe verschiedener Werte der <xref:System.StringComparison> Enumeration suchen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2173">The following example demonstrates three overloads of the <xref:System.String.IndexOf%2A> method that find the first occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>

 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-2174"><paramref name="value" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2174"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-2175"><paramref name="startIndex" /> ist kleiner als 0 (null) oder größer als die Länge dieser Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2175"><paramref name="startIndex" /> is less than 0 (zero) or greater than the length of this string.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8b8da-2176"><paramref name="comparisonType" /> ist kein gültiger <see cref="T:System.StringComparison" />-Wert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2176"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-2177">Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2177">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="8b8da-2178">Bei einer kulturabhängige Suche (das heißt, wenn <paramref name="comparisonType" /> nicht <see cref="F:System.StringComparison.Ordinal" /> oder <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> ist), bei der <paramref name="value" /> ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2178">In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="8b8da-2179">Wenn <paramref name="value" /> nur aus mindestens einem ignorierbaren Zeichen besteht, gibt die <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />-Methode immer <paramref name="startIndex" />zurück. Dies ist die Zeichenposition, an der die Suche beginnt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2179">If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> method always returns <paramref name="startIndex" />, which is the character position at which the search begins.</span></span>

<span data-ttu-id="8b8da-2180">Im folgenden Beispiel wird die <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />-Methode verwendet, um die Position eines Soft Bindestrichs (U + 00ad), gefolgt von einem "m", beginnend mit der dritten Zeichenposition in zwei Zeichen folgen zu suchen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2180">In the following example, the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" starting with the third character position in two strings.</span></span> <span data-ttu-id="8b8da-2181">Nur eine der Zeichenfolgen enthält die erforderliche Teilzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2181">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="8b8da-2182">Wenn das Beispiel in der [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder später ausgeführt wird, da der weiche Bindestrich ein ignorierbares Zeichen ist, gibt die Methode den Index von "m" in der Zeichenfolge zurück, wenn Sie einen Kultur abhängigen Vergleich durchführt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2182">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="8b8da-2183">Beachten Sie, dass bei der ersten Zeichenfolge, die den bedingten Bindestrich gefolgt von einem "m" umfasst, die Methode den Index des bedingten Bindestrichs nicht zurückgeben kann, sondern stattdessen den Index des "m" zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2183">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</span></span> <span data-ttu-id="8b8da-2184">Die Methode gibt den Index des bedingten Bindestrichs in der ersten Zeichenfolge nur dann zurück, wenn sie einen Ordinalvergleich ausführt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2184">The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</span></span>

<span data-ttu-id="8b8da-2185">[! Code-csharp[System. String. IndexOf # 25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable25.cs#25)] [! Code-vb[System. String. IndexOf # 25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable25.vb#25)]</span><span class="sxs-lookup"><span data-stu-id="8b8da-2185">[!code-csharp[System.String.IndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable25.cs#25)] [!code-vb[System.String.IndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable25.vb#25)]</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-2186">Die zu suchende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2186">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="8b8da-2187">Die Anfangsposition der Suche.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2187">The search starting position.</span></span></param>
        <param name="count"><span data-ttu-id="8b8da-2188">Die Anzahl der zu überprüfenden Zeichenpositionen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2188">The number of character positions to examine.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="8b8da-2189">Einer der Enumerationswerte, der die Regeln für die Suche angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2189">One of the enumeration values that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="8b8da-2190">Gibt den NULL-basierten Index des ersten Vorkommens der angegebenen Zeichenfolge im aktuellen <see cref="T:System.String" />-Objekt an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2190">Reports the zero-based index of the first occurrence of the specified string in the current <see cref="T:System.String" /> object.</span></span> <span data-ttu-id="8b8da-2191">Parameter geben die Anfangssuchposition in der aktuellen Zeichenfolge, die Anzahl der Zeichen in der aktuellen Zeichenfolge und den Typ der Suche für die angegebene Zeichenfolge an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2191">Parameters specify the starting search position in the current string, the number of characters in the current string to search, and the type of search to use for the specified string.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2192">Die nullbasierte Indexposition des <paramref name="value" />-Parameters vom Anfang der aktuellen Instanz, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2192">The zero-based index position of the <paramref name="value" /> parameter from the start of the current instance if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="8b8da-2193">Wenn <paramref name="value" /><see cref="F:System.String.Empty" /> ist, wird <paramref name="startIndex" /> zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2193">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is <paramref name="startIndex" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2194">Die Index Nummerierung beginnt bei 0 (null).</span><span class="sxs-lookup"><span data-stu-id="8b8da-2194">Index numbering starts from 0 (zero).</span></span> <span data-ttu-id="8b8da-2195">Der `startIndex`-Parameter kann von 0 bis zu der Länge der Zeichenfolgeninstanz reichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2195">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span>

 <span data-ttu-id="8b8da-2196">Die Suche beginnt bei `startIndex` und wird weiterhin  + `count`-1 `startIndex`.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2196">The search begins at `startIndex` and continues to `startIndex` + `count` -1.</span></span> <span data-ttu-id="8b8da-2197">Das Zeichen an `startIndex` + `count` ist nicht in der Suche enthalten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2197">The character at `startIndex` + `count` is not included in the search.</span></span>

 <span data-ttu-id="8b8da-2198">Der `comparisonType`-Parameter gibt an, dass mithilfe der aktuellen oder der invarianten Kultur nach dem `value` Parameter gesucht werden soll. dabei wird die Groß-/Kleinschreibung beachtet oder die Suche ohne Beachtung der Groß-/Kleinschreibung unterschieden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2198">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>



## Examples
 <span data-ttu-id="8b8da-2199">Im folgenden Beispiel werden drei über Ladungen der <xref:System.String.IndexOf%2A>-Methode veranschaulicht, die das erste Vorkommen einer Zeichenfolge in einer anderen Zeichenfolge mithilfe verschiedener Werte der <xref:System.StringComparison> Enumeration suchen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2199">The following example demonstrates three overloads of the <xref:System.String.IndexOf%2A> method that find the first occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>

 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-2200"><paramref name="value" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2200"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-2201"><paramref name="count" /> oder <paramref name="startIndex" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2201"><paramref name="count" /> or <paramref name="startIndex" /> is negative.</span></span>

<span data-ttu-id="8b8da-2202">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-2202">-or-</span></span>

 <span data-ttu-id="8b8da-2203"><paramref name="startIndex" /> ist größer als die Länge dieser Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2203"><paramref name="startIndex" /> is greater than the length of this instance.</span></span>

<span data-ttu-id="8b8da-2204">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-2204">-or-</span></span>

 <span data-ttu-id="8b8da-2205"><paramref name="count" /> ist größer als die Länge dieser Zeichenfolge minus <paramref name="startIndex" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2205"><paramref name="count" /> is greater than the length of this string minus <paramref name="startIndex" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8b8da-2206"><paramref name="comparisonType" /> ist kein gültiger <see cref="T:System.StringComparison" />-Wert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2206"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-2207">Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2207">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="8b8da-2208">Bei einer kulturabhängige Suche (das heißt, wenn <paramref name="comparisonType" /> nicht <see cref="F:System.StringComparison.Ordinal" /> oder <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> ist), bei der <paramref name="value" /> ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2208">In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="8b8da-2209">Wenn <paramref name="value" /> nur aus mindestens einem ignorierbaren Zeichen besteht, gibt die <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />-Methode immer <paramref name="startIndex" />zurück. Dies ist die Zeichenposition, an der die Suche beginnt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2209">If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method always returns <paramref name="startIndex" />, which is the character position at which the search begins.</span></span>

<span data-ttu-id="8b8da-2210">Im folgenden Beispiel wird die <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />-Methode verwendet, um die Position eines Soft Bindestrichs (U + 00ad), gefolgt von einem "m", beginnend mit den dritten bis sechsten Zeichen Positionen in zwei Zeichen folgen zu suchen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2210">In the following example, the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" starting in the third through sixth character positions in two strings.</span></span> <span data-ttu-id="8b8da-2211">Nur eine der Zeichenfolgen enthält die erforderliche Teilzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2211">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="8b8da-2212">Wenn das Beispiel in der [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder später ausgeführt wird, da der weiche Bindestrich ein ignorierbares Zeichen ist, gibt die Methode den Index von "m" in der Zeichenfolge zurück, wenn Sie einen Kultur abhängigen Vergleich durchführt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2212">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="8b8da-2213">Wenn ein Ordinalvergleich durchführt, wird die Teil Zeichenfolge jedoch nur in der ersten Zeichenfolge gefunden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2213">When it performs an ordinal comparison, however, it finds the substring only in the first string.</span></span> <span data-ttu-id="8b8da-2214">Beachten Sie, dass bei der ersten Zeichenfolge, die den weichen Bindestrich, gefolgt von einem "m", die Methode nicht den Index des weichen Bindestrichs zurückgibt, sondern den Index des "m" zurückgibt, wenn ein Kultur abhängiger Vergleich durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2214">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m" when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="8b8da-2215">Die Methode gibt den Index des bedingten Bindestrichs in der ersten Zeichenfolge nur dann zurück, wenn sie einen Ordinalvergleich ausführt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2215">The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</span></span>

<span data-ttu-id="8b8da-2216">[! Code-csharp[System. String. IndexOf # 24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable24.cs#24)] [! Code-vb[System. String. IndexOf # 24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable24.vb#24)]</span><span class="sxs-lookup"><span data-stu-id="8b8da-2216">[!code-csharp[System.String.IndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable24.cs#24)] [!code-vb[System.String.IndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable24.vb#24)]</span></span></para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8b8da-2217">Gibt den Index des ersten Vorkommens eines beliebigen Zeichens aus einem angegebenen Array von Unicode-Zeichen in dieser Instanz an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2217">Reports the index of the first occurrence in this instance of any character in a specified array of Unicode characters.</span></span> <span data-ttu-id="8b8da-2218">Die Methode gibt -1 zurück, wenn die Zeichen im Array nicht in dieser Instanz gefunden werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2218">The method returns -1 if the characters in the array are not found in this instance.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] -&gt; int" Usage="string.IndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf"><span data-ttu-id="8b8da-2219">Ein Array von Unicode-Zeichen mit mindestens einem zu suchenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2219">A Unicode character array containing one or more characters to seek.</span></span></param>
        <summary><span data-ttu-id="8b8da-2220">Gibt den NULL-basierten Index des ersten Vorkommens eines beliebigen Zeichens aus einem angegebenen Array von Unicode-Zeichen in dieser Instanz an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2220">Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2221">Die nullbasierte Indexposition des ersten Vorkommens eines beliebigen Zeichens aus <paramref name="anyOf" /> in dieser Instanz. -1, wenn kein Zeichen in <paramref name="anyOf" /> gefunden wurde.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2221">The zero-based index position of the first occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2222">Die Index Nummerierung beginnt bei Null.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2222">Index numbering starts from zero.</span></span>

 <span data-ttu-id="8b8da-2223">Bei der Suche nach `anyOf` wird die Groß-/Kleinschreibung beachtet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2223">The search for `anyOf` is case-sensitive.</span></span> <span data-ttu-id="8b8da-2224">Wenn `anyOf` ein leeres Array ist, findet die Methode am Anfang der Zeichenfolge eine Entsprechung (d. h. bei Index null).</span><span class="sxs-lookup"><span data-stu-id="8b8da-2224">If `anyOf` is an empty array, the method finds a match at the beginning of the string (that  is, at index zero).</span></span>

 <span data-ttu-id="8b8da-2225">Diese Methode führt eine ordnungsgemäß (Kultur unabhängige) Suche aus, bei der ein Zeichen als äquivalent zu einem anderen Zeichen gilt, wenn Ihre Unicode-Skalarwerte identisch sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2225">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="8b8da-2226">So führen Sie eine Kultur abhängige Suche durch Verwenden Sie die <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>-Methode, bei der ein Unicode-Skalarwert, der ein vorzusammen gesetztes Zeichen darstellt, wie z. b. die Ligaturen "Æ" (u + 00c6), in Abhängigkeit von der Kultur als äquivalent zu jedem Vorkommen der Komponenten des Zeichens in der richtigen Reihenfolge betrachtet werden kann.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2226">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>



## Examples
 <span data-ttu-id="8b8da-2227">Im folgenden Beispiel wird der erste Vokal in einer Zeichenfolge gesucht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2227">The following example finds the first vowel in a string.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.IndexOfAny/cs/IndexOfAny1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.IndexOfAny/vb/IndexOfAny1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-2228"><paramref name="anyOf" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2228"><paramref name="anyOf" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf"><span data-ttu-id="8b8da-2229">Ein Array von Unicode-Zeichen mit mindestens einem zu suchenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2229">A Unicode character array containing one or more characters to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="8b8da-2230">Die Anfangsposition der Suche.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2230">The search starting position.</span></span></param>
        <summary><span data-ttu-id="8b8da-2231">Gibt den NULL-basierten Index des ersten Vorkommens eines beliebigen Zeichens aus einem angegebenen Array von Unicode-Zeichen in dieser Instanz an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2231">Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</span></span> <span data-ttu-id="8b8da-2232">Die Suche beginnt an einer angegebenen Zeichenposition.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2232">The search starts at a specified character position.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2233">Die nullbasierte Indexposition des ersten Vorkommens eines beliebigen Zeichens aus <paramref name="anyOf" /> in dieser Instanz. -1, wenn kein Zeichen in <paramref name="anyOf" /> gefunden wurde.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2233">The zero-based index position of the first occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2234">Die Index Nummerierung beginnt bei Null.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2234">Index numbering starts from zero.</span></span> <span data-ttu-id="8b8da-2235">Der `startIndex`-Parameter kann zwischen 0 und eins liegen, der kleiner als die Länge der Zeichen folgen Instanz ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2235">The `startIndex` parameter can range from 0 to one less than the length of the string instance.</span></span>

 <span data-ttu-id="8b8da-2236">Die Suchvorgänge reichen von `startIndex` bis zum Ende der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2236">The search ranges from `startIndex` to the end of the string.</span></span>

 <span data-ttu-id="8b8da-2237">Bei der Suche nach `anyOf` wird die Groß-/Kleinschreibung beachtet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2237">The search for `anyOf` is case-sensitive.</span></span>

 <span data-ttu-id="8b8da-2238">Diese Methode führt eine Ordinalzahl (Kultur unabhängige Suche) aus, bei der ein Zeichen als äquivalent zu einem anderen Zeichen gilt, wenn der zugehörige Unicode-Skalarwert identisch ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2238">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same.</span></span> <span data-ttu-id="8b8da-2239">So führen Sie eine Kultur abhängige Suche durch Verwenden Sie die <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>-Methode, bei der ein Unicode-Skalarwert, der ein vorzusammen gesetztes Zeichen darstellt, wie z. b. die Ligaturen "Æ" (u + 00c6), in Abhängigkeit von der Kultur als äquivalent zu jedem Vorkommen der Komponenten des Zeichens in der richtigen Reihenfolge betrachtet werden kann.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2239">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>



## Examples
 <span data-ttu-id="8b8da-2240">Im folgenden Beispiel wird der Index des Vorkommens eines beliebigen Zeichens der Zeichenfolge "is" in einer Teil Zeichenfolge einer anderen Zeichenfolge gefunden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2240">The following example finds the index of the occurrence of any character of the string "is" within a substring of another string.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany2/CPP/ixany2.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany2/CS/ixany2.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany2/VB/ixany2.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-2241"><paramref name="anyOf" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2241"><paramref name="anyOf" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-2242"><paramref name="startIndex" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2242"><paramref name="startIndex" /> is negative.</span></span>

<span data-ttu-id="8b8da-2243">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-2243">-or-</span></span>

 <span data-ttu-id="8b8da-2244"><paramref name="startIndex" /> ist größer als die Anzahl der Zeichen in dieser Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2244"><paramref name="startIndex" /> is greater than the number of characters in this instance.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf"><span data-ttu-id="8b8da-2245">Ein Array von Unicode-Zeichen mit mindestens einem zu suchenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2245">A Unicode character array containing one or more characters to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="8b8da-2246">Die Anfangsposition der Suche.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2246">The search starting position.</span></span></param>
        <param name="count"><span data-ttu-id="8b8da-2247">Die Anzahl der zu überprüfenden Zeichenpositionen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2247">The number of character positions to examine.</span></span></param>
        <summary><span data-ttu-id="8b8da-2248">Gibt den NULL-basierten Index des ersten Vorkommens eines beliebigen Zeichens aus einem angegebenen Array von Unicode-Zeichen in dieser Instanz an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2248">Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</span></span> <span data-ttu-id="8b8da-2249">Die Suche beginnt an einer angegebenen Zeichenposition, und es wird eine angegebene Anzahl von Zeichenpositionen überprüft.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2249">The search starts at a specified character position and examines a specified number of character positions.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2250">Die nullbasierte Indexposition des ersten Vorkommens eines beliebigen Zeichens aus <paramref name="anyOf" /> in dieser Instanz. -1, wenn kein Zeichen in <paramref name="anyOf" /> gefunden wurde.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2250">The zero-based index position of the first occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2251">Die Suche beginnt bei `startIndex` und wird weiterhin  + `count`-1 `startIndex`.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2251">The search begins at `startIndex` and continues to `startIndex` + `count` -1.</span></span> <span data-ttu-id="8b8da-2252">Das Zeichen an `startIndex` + `count` ist nicht in der Suche enthalten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2252">The character at `startIndex` + `count` is not included in the search.</span></span>

 <span data-ttu-id="8b8da-2253">Die Index Nummerierung beginnt bei Null.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2253">Index numbering starts from zero.</span></span> <span data-ttu-id="8b8da-2254">Der `startIndex`-Parameter kann zwischen 0 und eins liegen, der kleiner als die Länge der Zeichen folgen Instanz ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2254">The `startIndex` parameter can range from 0 to one less than the length of the string instance.</span></span>

 <span data-ttu-id="8b8da-2255">Bei der Suche nach `anyOf` wird die Groß-/Kleinschreibung beachtet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2255">The search for `anyOf` is case-sensitive.</span></span>

 <span data-ttu-id="8b8da-2256">Diese Methode führt eine Ordinalzahl (Kultur unabhängige Suche) aus, bei der ein Zeichen als äquivalent zu einem anderen Zeichen gilt, wenn der zugehörige Unicode-Skalarwert identisch ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2256">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same.</span></span> <span data-ttu-id="8b8da-2257">So führen Sie eine Kultur abhängige Suche durch Verwenden Sie die <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>-Methode, bei der ein Unicode-Skalarwert, der ein vorzusammen gesetztes Zeichen darstellt, wie z. b. die Ligaturen "Æ" (u + 00c6), in Abhängigkeit von der Kultur als äquivalent zu jedem Vorkommen der Komponenten des Zeichens in der richtigen Reihenfolge betrachtet werden kann.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2257">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>



## Examples
 <span data-ttu-id="8b8da-2258">Im folgenden Beispiel wird der Index des Vorkommens eines beliebigen Zeichens der Zeichenfolge "Aid" in einer Teil Zeichenfolge einer anderen Zeichenfolge gefunden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2258">The following example finds the index of the occurrence of any character of the string "aid" within a substring of another string.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany3/CPP/ixany3.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany3/CS/ixany3.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany3/VB/ixany3.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-2259"><paramref name="anyOf" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2259"><paramref name="anyOf" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-2260"><paramref name="count" /> oder <paramref name="startIndex" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2260"><paramref name="count" /> or <paramref name="startIndex" /> is negative.</span></span>

<span data-ttu-id="8b8da-2261">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-2261">-or-</span></span>

 <span data-ttu-id="8b8da-2262"><paramref name="count" /> + <paramref name="startIndex" /> ist größer als die Anzahl der Zeichen in dieser Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2262"><paramref name="count" /> + <paramref name="startIndex" /> is greater than the number of characters in this instance.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public string Insert (int startIndex, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Insert(int32 startIndex, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (startIndex As Integer, value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Insert(int startIndex, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; string" Usage="string.Insert (startIndex, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="startIndex"><span data-ttu-id="8b8da-2263">Die nullbasierte Indexposition für das Einfügen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2263">The zero-based index position of the insertion.</span></span></param>
        <param name="value"><span data-ttu-id="8b8da-2264">Die einzufügende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2264">The string to insert.</span></span></param>
        <summary><span data-ttu-id="8b8da-2265">Gibt eine neue Zeichenfolge zurück, in der eine angegebene Zeichenfolge an einer angegebenen Indexposition in dieser Instanz eingefügt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2265">Returns a new string in which a specified string is inserted at a specified index position in this instance.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2266">Eine neue Zeichenfolge, die dieser Instanz mit einem an der Position <paramref name="value" /> eingefügten <paramref name="startIndex" /> entspricht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2266">A new string that is equivalent to this instance, but with <paramref name="value" /> inserted at position <paramref name="startIndex" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2267">Wenn `startIndex` gleich der Länge dieser Instanz ist, wird `value` am Ende dieser Instanz angefügt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2267">If `startIndex` is equal to the length of this instance, `value` is appended to the end of this instance.</span></span>

> [!NOTE]
>  <span data-ttu-id="8b8da-2268">Diese Methode ändert nicht den Wert der aktuellen Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2268">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="8b8da-2269">Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der `value` in die aktuelle Instanz eingefügt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2269">Instead, it returns a new string in which `value` is inserted into the current instance.</span></span>

 <span data-ttu-id="8b8da-2270">Der Rückgabewert von `"abc".Insert(2, "XYZ")` ist beispielsweise "abXYZc".</span><span class="sxs-lookup"><span data-stu-id="8b8da-2270">For example, the return value of `"abc".Insert(2, "XYZ")` is "abXYZc".</span></span>



## Examples
 <span data-ttu-id="8b8da-2271">Im folgenden Beispiel wird ein Leerzeichen an der vierten Zeichenposition (das Zeichen am Index 3) einer Zeichenfolge eingefügt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2271">The following example inserts a space character in the fourth character position (the character at index 3) of a string.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Insert/cs/Insert1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Insert/vb/Insert1.vb" id="Snippet1":::

 <span data-ttu-id="8b8da-2272">Mit der folgenden Konsolenanwendung werden die Benutzer aufgefordert, mindestens einen Adjektive einzugeben, um zwei Tiere zu beschreiben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2272">The following console application prompts the users to enter one or more adjectives to describe two animals.</span></span> <span data-ttu-id="8b8da-2273">Anschließend wird die <xref:System.String.Insert%2A>-Methode aufgerufen, um den vom Benutzer eingegebenen Text in eine Zeichenfolge einzufügen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2273">It then calls the <xref:System.String.Insert%2A> method to insert the text entered by the user into a string.</span></span>

 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-2274"><paramref name="value" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2274"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-2275"><paramref name="startIndex" /> ist negativ oder größer als die Länge dieser Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2275"><paramref name="startIndex" /> is negative or greater than the length of this instance.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Intern">
      <MemberSignature Language="C#" Value="public static string Intern (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Intern(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Intern(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Intern (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Intern(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Intern : string -&gt; string" Usage="System.string.Intern str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="str"><span data-ttu-id="8b8da-2276">Eine im Internpool zu suchende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2276">A string to search for in the intern pool.</span></span></param>
        <summary><span data-ttu-id="8b8da-2277">Ruft den Verweis des Systems auf den angegebenen <see cref="T:System.String" /> ab.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2277">Retrieves the system's reference to the specified <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2278">Der Verweis des Systems auf <paramref name="str" />, wenn dieser im Internpool vorhanden ist, andernfalls ein neuer Verweis auf eine Zeichenfolge mit dem Wert von <paramref name="str" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2278">The system's reference to <paramref name="str" />, if it is interned; otherwise, a new reference to a string with the value of <paramref name="str" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2279">Der Common Language Runtime die den Zeichen folgen Speicher beibehält, indem er eine Tabelle mit dem Namen Internpool verwaltet, die einen einzelnen Verweis auf jede eindeutige Literalzeichenfolge enthält, die im Programm Programm gesteuert deklariert oder erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2279">The common language runtime conserves string storage by maintaining a table, called the intern pool, that contains a single reference to each unique literal string declared or created programmatically in your program.</span></span> <span data-ttu-id="8b8da-2280">Folglich ist eine Instanz einer Literalzeichenfolge mit einem bestimmten Wert nur einmal im System vorhanden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2280">Consequently, an instance of a literal string with a particular value only exists once in the system.</span></span>

 <span data-ttu-id="8b8da-2281">Wenn Sie z. b. die gleiche Literalzeichenfolge mehreren Variablen zuweisen, ruft die Laufzeit denselben Verweis auf die Literalzeichenfolge aus dem Internpool ab und weist Sie jeder Variablen zu.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2281">For example, if you assign the same literal string to several variables, the runtime retrieves the same reference to the literal string from the intern pool and assigns it to each variable.</span></span>

 <span data-ttu-id="8b8da-2282">Die <xref:System.String.Intern%2A>-Methode verwendet den Internpool, um nach einer Zeichenfolge zu suchen, die dem Wert von `str`entspricht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2282">The <xref:System.String.Intern%2A> method uses the intern pool to search for a string equal to the value of `str`.</span></span> <span data-ttu-id="8b8da-2283">Wenn eine solche Zeichenfolge vorhanden ist, wird der zugehörige Verweis im Internpool zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2283">If such a string exists, its reference in the intern pool is returned.</span></span> <span data-ttu-id="8b8da-2284">Wenn die Zeichenfolge nicht vorhanden ist, wird ein Verweis auf `str` dem Internpool hinzugefügt, und dieser Verweis wird zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2284">If the string does not exist, a reference to `str` is added to the intern pool, then that reference is returned.</span></span>

 <span data-ttu-id="8b8da-2285">Im folgenden Beispiel ist die Zeichenfolge S1 mit dem Wert "myTest" bereits interniert, weil es sich um ein Literalzeichen im Programm handelt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2285">In the following example, the string s1, which has a value of "MyTest", is already interned because it is a literal in the program.</span></span> <span data-ttu-id="8b8da-2286">Die <xref:System.Text.StringBuilder?displayProperty=nameWithType>-Klasse generiert ein neues String-Objekt, das den gleichen Wert wie S1 hat.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2286">The <xref:System.Text.StringBuilder?displayProperty=nameWithType> class generates a new string object that has the same value as s1.</span></span> <span data-ttu-id="8b8da-2287">Ein Verweis auf diese Zeichenfolge wird S2 zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2287">A reference to that string is assigned to s2.</span></span> <span data-ttu-id="8b8da-2288">Die <xref:System.String.Intern%2A>-Methode sucht nach einer Zeichenfolge, die über den gleichen Wert wie S2 verfügt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2288">The <xref:System.String.Intern%2A> method searches for a string that has the same value as s2.</span></span> <span data-ttu-id="8b8da-2289">Da eine solche Zeichenfolge vorhanden ist, gibt die Methode denselben Verweis zurück, der S1 zugewiesen wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2289">Because such a string exists, the method returns the same reference that is assigned to s1.</span></span> <span data-ttu-id="8b8da-2290">Dieser Verweis wird dann S3 zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2290">That reference is then assigned to s3.</span></span> <span data-ttu-id="8b8da-2291">Verweise S1 und S2 vergleichen ungleich, da Sie auf unterschiedliche Objekte verweisen. Verweise S1 und S3 vergleichen gleich, da Sie auf dieselbe Zeichenfolge verweisen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2291">References s1 and s2 compare unequal because they refer to different objects; references s1 and s3 compare equal because they refer to the same string.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern1.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern1.vb" id="Snippet1":::

 <span data-ttu-id="8b8da-2292">Vergleichen Sie diese Methode mit der <xref:System.String.IsInterned%2A>-Methode.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2292">Compare this method to the <xref:System.String.IsInterned%2A> method.</span></span>

## <a name="version-considerations"></a><span data-ttu-id="8b8da-2293">Überlegungen zur Version</span><span class="sxs-lookup"><span data-stu-id="8b8da-2293">Version considerations</span></span>

 <span data-ttu-id="8b8da-2294">Im [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]wird die <xref:System.String.Intern%2A>-Methode in Bezug auf das Zusammensetzen der leeren Zeichenfolge auf das Verhalten des .NET Framework 1,0 und 1,1 zurückgesetzt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2294">In the [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)], the <xref:System.String.Intern%2A> method reverts to its behavior in the .NET Framework 1.0 and 1.1 with regard to interning the empty string.</span></span> <span data-ttu-id="8b8da-2295">Im folgenden Beispiel wird dem Variablen `str1` ein Verweis auf <xref:System.String.Empty?displayProperty=nameWithtype>zugewiesen, und der Variablen `str2` wird der Verweis auf <xref:System.String.Empty?displayProperty=nameWithtype> zugewiesen, die durch Aufrufen der <xref:System.String.Intern%2A>-Methode zurückgegeben wird, nachdem ein <xref:System.Text.StringBuilder> Objekt, dessen Wert <xref:System.String.Empty?displayProperty=nameWithtype> ist, in eine Zeichenfolge umgerechnet wurde.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2295">In the following example, the variable `str1` is assigned a reference to <xref:System.String.Empty?displayProperty=nameWithtype>, and the variable `str2` is assigned the reference to <xref:System.String.Empty?displayProperty=nameWithtype> that is returned by calling the <xref:System.String.Intern%2A> method after converting a <xref:System.Text.StringBuilder> object whose value is <xref:System.String.Empty?displayProperty=nameWithtype> to a string.</span></span> <span data-ttu-id="8b8da-2296">Anschließend werden die in `str1` und `str2` enthaltenen Verweise auf Gleichheit verglichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2296">Then the references contained in `str1` and `str2` are compared for equality.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern2.cs" interactive="try-dotnet-method" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern2.vb" id="Snippet2":::

 <span data-ttu-id="8b8da-2297">In den [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] und [!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)]sind `str1` und `str2` nicht gleich.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2297">In the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] and [!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)], `str1` and `str2` are not equal.</span></span> <span data-ttu-id="8b8da-2298">In allen anderen Versionen sind `str1` und `str2` gleich.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2298">In all other versions, `str1` and `str2` are equal.</span></span>

## <a name="performance-considerations"></a><span data-ttu-id="8b8da-2299">Überlegungen zur Leistung</span><span class="sxs-lookup"><span data-stu-id="8b8da-2299">Performance Considerations</span></span>
 <span data-ttu-id="8b8da-2300">Wenn Sie versuchen, die Gesamtmenge des Arbeitsspeichers zu verringern, die von der Anwendung zugewiesen wird, sollten Sie Bedenken, dass das Trennen einer Zeichenfolge zwei unerwünschte Nebeneffekte hat.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2300">If you are trying to reduce the total amount of memory your application allocates, keep in mind that interning a string has two unwanted side effects.</span></span> <span data-ttu-id="8b8da-2301">Erstens wird der Arbeitsspeicher, der für Internpool vorhanden <xref:System.String> Objekten reserviert ist, wahrscheinlich erst freigegeben, wenn die Common Language Runtime (CLR) beendet wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2301">First, the memory allocated for interned <xref:System.String> objects is not likely to be released until the common language runtime (CLR) terminates.</span></span> <span data-ttu-id="8b8da-2302">Der Grund hierfür ist, dass der CLR-Verweis auf das Internpool vorhanden <xref:System.String>-Objekt beibehalten werden kann, nachdem Ihre Anwendung oder sogar Ihre Anwendungsdomäne beendet wurde.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2302">The reason is that the CLR's reference to the interned <xref:System.String> object can persist after your application, or even your application domain, terminates.</span></span> <span data-ttu-id="8b8da-2303">Zweitens müssen Sie zuerst die Zeichenfolge erstellen, um eine Zeichenfolge zu interntigen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2303">Second, to intern a string, you must first create the string.</span></span> <span data-ttu-id="8b8da-2304">Der Arbeitsspeicher, der vom <xref:System.String> Objekt verwendet wird, muss dennoch zugeordnet werden, auch wenn der Arbeitsspeicher zu einem späteren Zeitpunkt in die Garbage Collection über</span><span class="sxs-lookup"><span data-stu-id="8b8da-2304">The memory used by the <xref:System.String> object must still be allocated, even though the memory will eventually be garbage collected.</span></span>

 <span data-ttu-id="8b8da-2305">Der .NET Framework Version 2,0 führt den <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType> Enumerationsmember ein.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2305">The .NET Framework version 2.0 introduces the <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType> enumeration member.</span></span> <span data-ttu-id="8b8da-2306">Das <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning>-Element kennzeichnet eine Assembly als keine Zeichen folgen Literale interning.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2306">The <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> member marks an assembly as not requiring string-literal interning.</span></span> <span data-ttu-id="8b8da-2307">Sie können <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> mithilfe des <xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute>-Attributs auf eine Assembly anwenden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2307">You can apply <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> to an assembly using the <xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute> attribute.</span></span> <span data-ttu-id="8b8da-2308">Wenn Sie den [Ngen. exe (Native Image Generator)](~/docs/framework/tools/ngen-exe-native-image-generator.md) verwenden, um eine Assembly im Vorfeld der Laufzeit zu kompilieren, werden Zeichen folgen nicht über Module hinweg interniert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2308">Also, when you use the [Ngen.exe (Native Image Generator)](~/docs/framework/tools/ngen-exe-native-image-generator.md) to compile an assembly in advance of run time, strings are not interned across modules.</span></span>



## Examples
 <span data-ttu-id="8b8da-2309">Im folgenden Beispiel werden drei Zeichen folgen verwendet, die dem-Wert entsprechen, um zu bestimmen, ob eine neu erstellte Zeichenfolge und eine intererte Zeichenfolge gleich sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2309">The following example uses three strings that are equal in value to determine whether a newly created string and an interned string are equal.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.intern/CPP/string_intern.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.intern/CS/string_intern.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.intern/VB/string_intern.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-2310"><paramref name="str" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2310"><paramref name="str" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.IsInterned(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsInterned">
      <MemberSignature Language="C#" Value="public static string IsInterned (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string IsInterned(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsInterned(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInterned (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ IsInterned(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsInterned : string -&gt; string" Usage="System.string.IsInterned str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="str"><span data-ttu-id="8b8da-2311">Die im Internpool zu suchende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2311">The string to search for in the intern pool.</span></span></param>
        <summary><span data-ttu-id="8b8da-2312">Ruft einen Verweis auf einen angegebenen <see cref="T:System.String" /> ab.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2312">Retrieves a reference to a specified <see cref="T:System.String" />.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2313">Ein Verweis auf <paramref name="str" />, wenn sich dieser im Internpool der Common Language Runtime befindet; andernfalls <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2313">A reference to <paramref name="str" /> if it is in the common language runtime intern pool; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2314">Der Common Language Runtime verwaltet automatisch eine Tabelle, die als Internpool bezeichnet wird und eine einzelne Instanz jeder eindeutigen Literalzeichenfolgen-Konstante enthält, die in einem Programm deklariert ist, sowie jede eindeutige Instanz von <xref:System.String> die Sie Programm gesteuert durch Aufrufen der <xref:System.String.Intern%2A>-Methode hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2314">The common language runtime automatically maintains a table, called the intern pool, which contains a single instance of each unique literal string constant declared in a program, as well as any unique instance of <xref:System.String> you add programmatically by calling the <xref:System.String.Intern%2A> method.</span></span>

 <span data-ttu-id="8b8da-2315">Der Internpool bietet einen Zeichen folgen Speicher.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2315">The intern pool conserves string storage.</span></span> <span data-ttu-id="8b8da-2316">Wenn Sie mehrere Variablen eine Literalzeichenfolge-Konstante zuweisen, wird jede Variable so festgelegt, dass Sie auf dieselbe Konstante im Internpool verweist, anstatt auf verschiedene Instanzen von <xref:System.String> zu verweisen, die identische Werte aufweisen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2316">If you assign a literal string constant to several variables, each variable is set to reference the same constant in the intern pool instead of referencing several different instances of <xref:System.String> that have identical values.</span></span>

 <span data-ttu-id="8b8da-2317">Diese Methode sucht nach `str` im Internpool.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2317">This method looks up `str` in the intern pool.</span></span> <span data-ttu-id="8b8da-2318">Wenn `str` bereits interniert wurde, wird ein Verweis auf diese Instanz zurückgegeben. Andernfalls wird `null` zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2318">If `str` has already been interned, a reference to that instance is returned; otherwise, `null` is returned.</span></span>

 <span data-ttu-id="8b8da-2319">Vergleichen Sie diese Methode mit der <xref:System.String.Intern%2A>-Methode.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2319">Compare this method to the <xref:System.String.Intern%2A> method.</span></span>

 <span data-ttu-id="8b8da-2320">Diese Methode gibt keinen booleschen Wert zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2320">This method does not return a Boolean value.</span></span> <span data-ttu-id="8b8da-2321">Wenn Sie die-Methode aufzurufen, da Sie einen booleschen Wert wünschen, der angibt, ob eine bestimmte Zeichenfolge interniert ist, können Sie Code wie den folgenden verwenden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2321">If you call the method because you want a Boolean value that indicates whether a particular string is interned, you can use code such as the following.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isinterned/cs/isinternedex1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isinterned/vb/isinternedex1.vb" id="Snippet1":::

> [!NOTE]
>  <span data-ttu-id="8b8da-2322">Ab der .NET Framework Version 2,0 können Sie die Verwendung des internspools überschreiben, wenn Sie den [Ngen. exe (Native Image Generator)](~/docs/framework/tools/ngen-exe-native-image-generator.md) verwenden, um eine Assembly im Cache für Native Images auf einem lokalen Computer zu installieren.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2322">Starting with the .NET Framework version 2.0, you can override the use of the intern pool when you use the [Ngen.exe (Native Image Generator)](~/docs/framework/tools/ngen-exe-native-image-generator.md) to install an assembly to the native image cache on a local computer.</span></span> <span data-ttu-id="8b8da-2323">Weitere Informationen finden Sie unter Überlegungen zur Leistung im Abschnitt "Hinweise" für die <xref:System.String.Intern%2A>-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2323">For more information, see Performance Considerations in the Remarks section for the <xref:System.String.Intern%2A> property.</span></span>



## Examples
 <span data-ttu-id="8b8da-2324">Im folgenden Beispiel wird veranschaulicht, dass Literalzeichenfolgen automatisch vom Compiler interniert werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2324">The following example demonstrates that literal strings are interned automatically by the compiler.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.isinterned/CPP/isin.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.isinterned/CS/isin.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isinterned/VB/isin.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-2325"><paramref name="str" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2325"><paramref name="str" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.Intern(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8b8da-2326">Gibt an, ob diese Zeichenfolge in einer bestimmten Unicode-Normalisierungsform vorliegt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2326">Indicates whether this string is in a particular Unicode normalization form.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : unit -&gt; bool" Usage="string.IsNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8b8da-2327">Gibt an, ob diese Zeichenfolge in der Unicode-Normalisierungsform C vorliegt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2327">Indicates whether this string is in Unicode normalization form C.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2328"><see langword="true" />, wenn diese Zeichenfolge in der Normalisierungsform C vorliegt; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2328"><see langword="true" /> if this string is in normalization form C; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2329">Einige Unicode-Zeichen verfügen über mehrere äquivalente binäre Darstellungen, die aus Mengen von Kombination aus und/oder zusammengesetzten Unicode-Zeichen bestehen</span><span class="sxs-lookup"><span data-stu-id="8b8da-2329">Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</span></span> <span data-ttu-id="8b8da-2330">Das vorhanden sein mehrerer Darstellungen für ein einzelnes Zeichen erschwert das suchen, sortieren, abgleichen und andere Vorgänge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2330">The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</span></span>

 <span data-ttu-id="8b8da-2331">Der Unicode-Standard definiert einen Prozess namens Normalisierung, der eine binäre Darstellung zurückgibt, wenn eine der äquivalenten binären Darstellungen eines Zeichens angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2331">The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</span></span> <span data-ttu-id="8b8da-2332">Die Normalisierung kann mit mehreren Algorithmen durchgeführt werden, die als normalisierungs Formulare bezeichnet werden, die unterschiedliche Regeln einhalten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2332">Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</span></span> <span data-ttu-id="8b8da-2333">.NET unterstützt derzeit die Normalisierungsformen C, D, KC und KD.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2333">.NET currently supports normalization forms C, D, KC, and KD.</span></span>

 <span data-ttu-id="8b8da-2334">Eine Beschreibung der unterstützten Unicode-Normalisierungsformen finden Sie unter <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2334">For a description of supported Unicode normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span></span>



## Examples
 <span data-ttu-id="8b8da-2335">Im folgenden Beispiel wird bestimmt, ob eine Zeichenfolge erfolgreich in verschiedene Normalisierungsformen normalisiert wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2335">The following example determines whether a string is successfully normalized to various normalization forms.</span></span>

 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8b8da-2336">Die aktuelle Instanz enthält ungültige Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2336">The current instance contains invalid Unicode characters.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-2337">Die <see cref="Overload:System.String.IsNormalized" />-Methode gibt <see langword="false" /> zurück, sobald das erste nicht normalisierte Zeichen in einer Zeichenfolge gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2337">The <see cref="Overload:System.String.IsNormalized" /> method returns <see langword="false" /> as soon as it encounters the first non-normalized character in a string.</span></span> <span data-ttu-id="8b8da-2338">Wenn eine Zeichenfolge nicht normalisierte Zeichen gefolgt von ungültigen Unicode-Zeichen enthält, löst die <see cref="Overload:System.String.Normalize" /> Methode daher eine <see cref="T:System.ArgumentException" /> aus, obwohl <see cref="Overload:System.String.IsNormalized" /> <see langword="false" />zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2338">Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <see cref="Overload:System.String.Normalize" /> method will throw an <see cref="T:System.ArgumentException" /> although <see cref="Overload:System.String.IsNormalized" /> returns <see langword="false" />.</span></span></para></block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsNormalized (normalizationForm As NormalizationForm) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : System.Text.NormalizationForm -&gt; bool" Usage="string.IsNormalized normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="normalizationForm"><span data-ttu-id="8b8da-2339">Eine Unicode-Normalisierungsform.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2339">A Unicode normalization form.</span></span></param>
        <summary><span data-ttu-id="8b8da-2340">Gibt an, ob diese Zeichenfolge in der angegebenen Unicode-Normalisierungsform vorliegt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2340">Indicates whether this string is in the specified Unicode normalization form.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2341"><see langword="true" />, wenn diese Zeichenfolge in der vom <paramref name="normalizationForm" />-Parameter angegebenen Normalisierungsform vorliegt; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2341"><see langword="true" /> if this string is in the normalization form specified by the <paramref name="normalizationForm" /> parameter; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2342">Einige Unicode-Zeichen verfügen über mehrere äquivalente binäre Darstellungen, die aus Mengen von Kombination aus und/oder zusammengesetzten Unicode-Zeichen bestehen</span><span class="sxs-lookup"><span data-stu-id="8b8da-2342">Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</span></span> <span data-ttu-id="8b8da-2343">Das vorhanden sein mehrerer Darstellungen für ein einzelnes Zeichen erschwert das suchen, sortieren, abgleichen und andere Vorgänge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2343">The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</span></span>

 <span data-ttu-id="8b8da-2344">Der Unicode-Standard definiert einen Prozess namens Normalisierung, der eine binäre Darstellung zurückgibt, wenn eine der äquivalenten binären Darstellungen eines Zeichens angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2344">The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</span></span> <span data-ttu-id="8b8da-2345">Die Normalisierung kann mit mehreren Algorithmen durchgeführt werden, die als normalisierungs Formulare bezeichnet werden, die unterschiedliche Regeln einhalten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2345">Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</span></span> <span data-ttu-id="8b8da-2346">.NET unterstützt derzeit die Normalisierungsformen C, D, KC und KD.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2346">.NET currently supports normalization forms C, D, KC, and KD.</span></span>

 <span data-ttu-id="8b8da-2347">Eine Beschreibung der unterstützten Unicode-Normalisierungsformen finden Sie unter <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2347">For a description of supported Unicode normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span></span>



## Examples
 <span data-ttu-id="8b8da-2348">Das folgende Beispiel veranschaulicht die <xref:System.String.IsNormalized%2A> und <xref:System.String.Normalize%2A> Methoden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2348">The following example demonstrates the <xref:System.String.IsNormalized%2A> and <xref:System.String.Normalize%2A> methods.</span></span>

 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8b8da-2349">Die aktuelle Instanz enthält ungültige Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2349">The current instance contains invalid Unicode characters.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-2350">Die <see cref="Overload:System.String.IsNormalized" />-Methode gibt <see langword="false" /> zurück, sobald das erste nicht normalisierte Zeichen in einer Zeichenfolge gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2350">The <see cref="Overload:System.String.IsNormalized" /> method returns <see langword="false" /> as soon as it encounters the first non-normalized character in a string.</span></span> <span data-ttu-id="8b8da-2351">Wenn eine Zeichenfolge nicht normalisierte Zeichen gefolgt von ungültigen Unicode-Zeichen enthält, löst die <see cref="Overload:System.String.Normalize" /> Methode daher eine <see cref="T:System.ArgumentException" /> aus, obwohl <see cref="Overload:System.String.IsNormalized" /> <see langword="false" />zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2351">Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <see cref="Overload:System.String.Normalize" /> method will throw an <see cref="T:System.ArgumentException" /> although <see cref="Overload:System.String.IsNormalized" /> returns <see langword="false" />.</span></span></para></block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrEmpty">
      <MemberSignature Language="C#" Value="public static bool IsNullOrEmpty (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrEmpty(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrEmpty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrEmpty (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrEmpty(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrEmpty : string -&gt; bool" Usage="System.string.IsNullOrEmpty value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-2352">Die zu testende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2352">The string to test.</span></span></param>
        <summary><span data-ttu-id="8b8da-2353">Gibt an, ob die angegebene Zeichenfolge <see langword="null" /> oder eine leere Zeichenfolge ("") ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2353">Indicates whether the specified string is <see langword="null" /> or an empty string ("").</span></span></summary>
        <returns><span data-ttu-id="8b8da-2354"><see langword="true" />, wenn der <paramref name="value" />-Parameter <see langword="null" /> oder eine leere Zeichenfolge ("") ist; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2354"><see langword="true" /> if the <paramref name="value" /> parameter is <see langword="null" /> or an empty string (""); otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2355"><xref:System.String.IsNullOrEmpty%2A> ist eine praktische Methode, die es Ihnen ermöglicht, gleichzeitig zu testen, ob ein <xref:System.String> `null` oder sein Wert <xref:System.String.Empty?displayProperty=nameWithType>ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2355"><xref:System.String.IsNullOrEmpty%2A> is a convenience method that enables you to simultaneously test whether a <xref:System.String> is `null` or its value is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8b8da-2356">Dies entspricht dem folgenden Code:</span><span class="sxs-lookup"><span data-stu-id="8b8da-2356">It is equivalent to the following code:</span></span>

 [!code-cpp[System.String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/isnullorempty1.cpp#1)]
 [!code-csharp-interactive[System.String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/isnullorempty1.cs#1)]
 [!code-vb[System.String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/isnullorempty1.vb#1)]

 <span data-ttu-id="8b8da-2357">Sie können die <xref:System.String.IsNullOrWhiteSpace%2A>-Methode verwenden, um zu testen, ob eine Zeichenfolge `null`ist, ob der Wert <xref:System.String.Empty?displayProperty=nameWithType>ist oder nur aus Leerzeichen besteht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2357">You can use the <xref:System.String.IsNullOrWhiteSpace%2A> method to test whether a string is `null`, its value is <xref:System.String.Empty?displayProperty=nameWithType>,  or it consists only of white-space characters.</span></span>

## <a name="what-is-a-null-string"></a><span data-ttu-id="8b8da-2358">Was ist eine NULL-Zeichenfolge?</span><span class="sxs-lookup"><span data-stu-id="8b8da-2358">What is a null string?</span></span>

<span data-ttu-id="8b8da-2359">Eine Zeichenfolge wird `null`, wenn ihr kein Wert zugewiesen wurde (in C++ und Visual Basic) oder explizit ein Wert von `null`zugewiesen wurde.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2359">A string is `null` if it has not been assigned a value (in C++ and Visual Basic) or if it has explicitly been assigned a value of `null`.</span></span> <span data-ttu-id="8b8da-2360">Obwohl das Feature für die [kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) eine NULL-Zeichenfolge ordnungsgemäß verarbeiten kann, wie im folgenden Beispiel gezeigt, wird versucht, einen aufzurufen, wenn seine Member eine <xref:System.NullReferenceException>auslösen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2360">Although the [composite formatting](~/docs/standard/base-types/composite-formatting.md) feature can gracefully handle a null string, as the following example shows, attempting to call one if its members throws a <xref:System.NullReferenceException>.</span></span>

[!code-cpp[System.String.IsNullOrEmpty#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#2)]
[!code-csharp-interactive[System.String.IsNullOrEmpty#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#2)]
[!code-vb[System.String.IsNullOrEmpty#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#2)]

## <a name="what-is-an-empty-string"></a><span data-ttu-id="8b8da-2361">Was ist eine leere Zeichenfolge?</span><span class="sxs-lookup"><span data-stu-id="8b8da-2361">What is an empty string?</span></span>

<span data-ttu-id="8b8da-2362">Eine Zeichenfolge ist leer, wenn Ihr explizit eine leere Zeichenfolge ("") oder eine <xref:System.String.Empty?displayProperty=nameWithType>zugewiesen wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2362">A string is empty if it  is explicitly assigned an empty string ("") or <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8b8da-2363">Eine leere Zeichenfolge hat den <xref:System.String.Length%2A> 0.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2363">An empty string has a <xref:System.String.Length%2A> of 0.</span></span>  <span data-ttu-id="8b8da-2364">Im folgenden Beispiel wird eine leere Zeichenfolge erstellt und der zugehörige Wert und seine Länge angezeigt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2364">The following example creates an empty string and displays its value and its length.</span></span>

[!code-cpp[System.String.IsNullOrEmpty#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#3)]
[!code-csharp-interactive[System.String.IsNullOrEmpty#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#3)]
[!code-vb[System.String.IsNullOrEmpty#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#3)]

## Examples
 <span data-ttu-id="8b8da-2365">Im folgenden Beispiel werden drei Zeichen folgen überprüft und bestimmt, ob jede Zeichenfolge über einen Wert verfügt, eine leere Zeichenfolge ist oder `null`ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2365">The following example examines three strings and determines whether each string has a value, is an empty string, or is `null`.</span></span>

 [!code-cpp[String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isNullOrEmpty/CPP/inoe.cpp#1)]
 [!code-csharp-interactive[String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isNullOrEmpty/CS/inoe.cs#1)]
 [!code-vb[String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isNullOrEmpty/VB/inoe.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsNullOrWhiteSpace (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrWhiteSpace(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrWhiteSpace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrWhiteSpace (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrWhiteSpace(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrWhiteSpace : string -&gt; bool" Usage="System.string.IsNullOrWhiteSpace value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-2366">Die zu testende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2366">The string to test.</span></span></param>
        <summary><span data-ttu-id="8b8da-2367">Gibt an, ob eine angegebene Zeichenfolge <see langword="null" /> ist, leer ist oder nur aus Leerzeichen besteht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2367">Indicates whether a specified string is <see langword="null" />, empty, or consists only of white-space characters.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2368"><see langword="true" />, wenn der <paramref name="value" />-Parameter <see langword="null" /> oder <see cref="F:System.String.Empty" /> ist oder wenn <paramref name="value" /> ausschließlich aus Leerzeichen besteht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2368"><see langword="true" /> if the <paramref name="value" /> parameter is <see langword="null" /> or <see cref="F:System.String.Empty" />, or if <paramref name="value" /> consists exclusively of white-space characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2369"><xref:System.String.IsNullOrWhiteSpace%2A> ist eine bequeme Methode, die dem folgenden Code ähnelt, mit dem Unterschied, dass Sie eine bessere Leistung bietet:</span><span class="sxs-lookup"><span data-stu-id="8b8da-2369"><xref:System.String.IsNullOrWhiteSpace%2A> is a convenience method that is similar to the following  code, except that it offers superior performance:</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace.cs" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace.vb" id="Snippet2":::

 <span data-ttu-id="8b8da-2370">Leerzeichen werden durch den Unicode-Standard definiert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2370">White-space characters are defined by the Unicode standard.</span></span> <span data-ttu-id="8b8da-2371">Die <xref:System.String.IsNullOrWhiteSpace%2A>-Methode interpretiert alle Zeichen, die den Wert `true` zurückgibt, wenn Sie als Leerzeichen an die <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>-Methode übermittelt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2371">The <xref:System.String.IsNullOrWhiteSpace%2A> method interprets any character that returns a value of `true` when it is passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method as a white-space character.</span></span>



## Examples
 <span data-ttu-id="8b8da-2372">Im folgenden Beispiel wird ein Zeichen folgen Array erstellt und dann jedes Element des Arrays an die <xref:System.String.IsNullOrWhiteSpace%2A>-Methode weitergeleitet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2372">The following example creates a string array, and then passes each element of the array to the <xref:System.String.IsNullOrWhiteSpace%2A> method.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8b8da-2373">Verkettet die Elemente eines angegebenen Arrays oder die Member einer Auflistung und verwendet das angegebene Trennzeichen zwischen jedem Element bzw. Member.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2373">Concatenates the elements of a specified array or the members of a collection, using the specified separator between each element or member.</span></span></summary>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="8b8da-2374">Das als Trennlinie zu verwendende Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2374">The character to use as a separator.</span></span> <span data-ttu-id="8b8da-2375"><paramref name="separator" /> ist in der zurückgegebenen Zeichenfolge nur enthalten, wenn <paramref name="value" /> mehr als ein Element enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2375"><paramref name="separator" /> is included in the returned string only if <paramref name="value" /> has more than one element.</span></span></param>
        <param name="values"><span data-ttu-id="8b8da-2376">Ein Objektarray, dessen Zeichenfolgendarstellungen verkettet werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2376">An array of objects whose string representations will be concatenated.</span></span></param>
        <summary><span data-ttu-id="8b8da-2377">Verwendet die Zeichenfolgendarstellungen eines Objektarrays mithilfe der angegebenen Trennlinie zwischen den einzelnen Elementen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2377">Concatenates the string representations of an array of objects, using the specified separator between each member.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2378">Eine Zeichenfolge, die aus den Elementen von <paramref name="values" /> besteht, getrennt durch das Zeichen <paramref name="separator" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2378">A string that consists of the elements of <paramref name="values" /> delimited by the <paramref name="separator" /> character.</span></span>

<span data-ttu-id="8b8da-2379">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-2379">-or-</span></span>

<span data-ttu-id="8b8da-2380"><see cref="F:System.String.Empty" />, wenn <paramref name="values" /> keine Elemente enthält oder alle Elemente von <paramref name="values" /><see langword="null" /> sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2380"><see cref="F:System.String.Empty" /> if <paramref name="values" /> has zero elements or all the elements of <paramref name="values" /> are <see langword="null" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-2381"><paramref name="value" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2381"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="8b8da-2382">Die Länge der resultierenden Zeichenfolge führt zu einem Überlauf der maximal zulässigen Länge (<see cref="F:System.Int32.MaxValue" />).</span><span class="sxs-lookup"><span data-stu-id="8b8da-2382">The length of the resulting string overflows the maximum allowed length (<see cref="F:System.Int32.MaxValue" />).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="value" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="8b8da-2383">Das als Trennlinie zu verwendende Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2383">The character to use as a separator.</span></span> <span data-ttu-id="8b8da-2384"><paramref name="separator" /> ist in der zurückgegebenen Zeichenfolge nur enthalten, wenn <paramref name="value" /> mehr als ein Element enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2384"><paramref name="separator" /> is included in the returned string only if <paramref name="value" /> has more than one element.</span></span></param>
        <param name="value"><span data-ttu-id="8b8da-2385">Ein Array von zu verkettenden Zeichenfolgen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2385">An array of strings to concatenate.</span></span></param>
        <summary><span data-ttu-id="8b8da-2386">Verkettet ein Zeichenfolgenarray mithilfe der angegebenen Trennlinie zwischen den einzelnen Elementen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2386">Concatenates an array of strings, using the specified separator between each member.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2387">Eine Zeichenfolge, die aus den Elementen von <paramref name="value" /> besteht, getrennt durch das Zeichen <paramref name="separator" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2387">A string that consists of the elements of <paramref name="value" /> delimited by the <paramref name="separator" /> character.</span></span>

<span data-ttu-id="8b8da-2388">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-2388">-or-</span></span>

<span data-ttu-id="8b8da-2389"><see cref="F:System.String.Empty" />, wenn <paramref name="value" /> keine Elemente enthält oder alle Elemente von <paramref name="value" /><see langword="null" /> sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2389"><see cref="F:System.String.Empty" /> if <paramref name="value" /> has zero elements or all the elements of <paramref name="value" /> are <see langword="null" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-2390"><paramref name="value" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2390"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="8b8da-2391">Die Länge der resultierenden Zeichenfolge führt zu einem Überlauf der maximal zulässigen Länge (<see cref="F:System.Int32.MaxValue" />).</span><span class="sxs-lookup"><span data-stu-id="8b8da-2391">The length of the resulting string overflows the maximum allowed length (<see cref="F:System.Int32.MaxValue" />).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;string&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="8b8da-2392">Die Zeichenfolge, die als Trennzeichen verwendet werden soll.<paramref name="separator" /></span><span class="sxs-lookup"><span data-stu-id="8b8da-2392">The string to use as a separator.<paramref name="separator" /></span></span> <span data-ttu-id="8b8da-2393">ist in der zurückgegebenen Zeichenfolge nur enthalten, wenn <paramref name="values" /> mehr als ein Element enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2393">is included in the returned string only if <paramref name="values" /> has more than one element.</span></span></param>
        <param name="values"><span data-ttu-id="8b8da-2394">Eine Auflistung, die die zu verkettenden Zeichenfolgen enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2394">A collection that contains the strings to concatenate.</span></span></param>
        <summary><span data-ttu-id="8b8da-2395">Verkettet die Member einer erstellten <see cref="T:System.Collections.Generic.IEnumerable`1" />-Auflistung vom Typ <see cref="T:System.String" /> und verwendet das angegebene Trennzeichen zwischen den einzelnen Membern.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2395">Concatenates the members of a constructed <see cref="T:System.Collections.Generic.IEnumerable`1" /> collection of type <see cref="T:System.String" />, using the specified separator between each member.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2396">Eine Zeichenfolge, die aus den Membern von <paramref name="values" /> besteht, getrennt durch die <paramref name="separator" />-Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2396">A string that consists of the members of <paramref name="values" /> delimited by the <paramref name="separator" /> string.</span></span>

<span data-ttu-id="8b8da-2397">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-2397">-or-</span></span>

<span data-ttu-id="8b8da-2398"><see cref="F:System.String.Empty" />, wenn <paramref name="values" /> keine Elemente enthält oder alle Elemente von <paramref name="values" /><see langword="null" /> sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2398"><see cref="F:System.String.Empty" /> if <paramref name="values" /> has zero elements or all the elements of <paramref name="values" /> are <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2399">Wenn `separator` `null`ist, wird stattdessen eine leere Zeichenfolge (<xref:System.String.Empty?displayProperty=nameWithType>) verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2399">If `separator` is `null`, an empty string (<xref:System.String.Empty?displayProperty=nameWithType>) is used instead.</span></span> <span data-ttu-id="8b8da-2400">Wenn ein Member von `values` `null`ist, wird stattdessen eine leere Zeichenfolge verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2400">If any member of `values` is `null`, an empty string is used instead.</span></span>

 <span data-ttu-id="8b8da-2401"><xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> ist eine bequeme Methode, mit der Sie jedes Element in einer `IEnumerable(Of String)` Auflistung verketten können, ohne dass die Elemente zuvor in ein Zeichen folgen Array umgerechnet werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2401"><xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> is a convenience method that lets you concatenate each element in an `IEnumerable(Of String)` collection without first converting the elements to a string array.</span></span> <span data-ttu-id="8b8da-2402">Dies ist besonders nützlich bei LINQ-Abfrage Ausdrücken (Language-Integrated Query).</span><span class="sxs-lookup"><span data-stu-id="8b8da-2402">It is particularly useful with Language-Integrated Query (LINQ) query expressions.</span></span> <span data-ttu-id="8b8da-2403">Im folgenden Beispiel wird ein `List(Of String)` Objekt, das entweder die Groß-oder Kleinbuchstaben des Alphabets enthält, an einen Lambda-Ausdruck weitergeleitet, von dem Buchstaben ausgewählt werden, die gleich oder größer als ein bestimmter Buchstabe (im Beispiel "M") sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2403">The following example passes a `List(Of String)` object that contains either the uppercase or lowercase letters of the alphabet to a lambda expression that selects letters that are equal to or greater than a particular letter (which, in the example, is "M").</span></span> <span data-ttu-id="8b8da-2404">Die von der <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType>-Methode zurückgegebene `IEnumerable(Of String)` Auflistung wird an die <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29>-Methode übermittelt, um das Ergebnis als eine einzelne Zeichenfolge anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2404">The `IEnumerable(Of String)` collection returned by the <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> method is passed to the <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> method to display the result as a single string.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join4.cs" interactive="try-dotnet" id="Snippet4":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join4.vb" id="Snippet4":::

## Examples
 <span data-ttu-id="8b8da-2405">Im folgenden Beispiel wird das Sieb des Eratosthenes-Algorithmus zum Berechnen der Primzahlen, die kleiner oder gleich 100 sind, verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2405">The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</span></span> <span data-ttu-id="8b8da-2406">Das Ergebnis wird einem <xref:System.Collections.Generic.List%601> Objekt vom Typ <xref:System.String>zugewiesen, das dann an die <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29>-Methode weitergeleitet wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2406">It assigns the result to a <xref:System.Collections.Generic.List%601> object of type <xref:System.String>, which it then passes to the <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> method.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join3.cs" interactive="try-dotnet" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join3.vb" id="Snippet3":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-2407"><paramref name="values" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2407"><paramref name="values" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="8b8da-2408">Die Länge der resultierenden Zeichenfolge führt zu einem Überlauf der maximal zulässigen Länge (<see cref="F:System.Int32.MaxValue" />).</span><span class="sxs-lookup"><span data-stu-id="8b8da-2408">The length of the resulting string overflows the maximum allowed length (<see cref="F:System.Int32.MaxValue" />).</span></span></exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="8b8da-2409">Die Zeichenfolge, die als Trennzeichen verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2409">The string to use as a separator.</span></span> <span data-ttu-id="8b8da-2410"><paramref name="separator" /> ist in der zurückgegebenen Zeichenfolge nur enthalten, wenn <paramref name="values" /> mehr als ein Element enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2410"><paramref name="separator" /> is included in the returned string only if <paramref name="values" /> has more than one element.</span></span></param>
        <param name="values"><span data-ttu-id="8b8da-2411">Ein Array, das die zu verkettenden Elemente enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2411">An array that contains the elements to concatenate.</span></span></param>
        <summary><span data-ttu-id="8b8da-2412">Verkettet die Elemente eines Objektarrays und verwendet das angegebene Trennzeichen zwischen den einzelnen Elementen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2412">Concatenates the elements of an object array, using the specified separator between each element.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2413">Eine Zeichenfolge, die aus den Membern von <paramref name="values" /> besteht, getrennt durch die <paramref name="separator" />-Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2413">A string that consists of the elements of <paramref name="values" /> delimited by the <paramref name="separator" /> string.</span></span> <span data-ttu-id="8b8da-2414">Wenn <paramref name="values" /> eine leeres Array ist, gibt die Methode <see cref="F:System.String.Empty" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2414">If <paramref name="values" /> is an empty array, the method returns <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2415">Wenn `separator` `null` ist oder wenn ein Element von `values` von dem ersten Element `null`ist, wird stattdessen eine leere Zeichenfolge (<xref:System.String.Empty?displayProperty=nameWithType>) verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2415">If `separator` is `null` or if any element of `values` other than the first element is `null`, an empty string (<xref:System.String.Empty?displayProperty=nameWithType>) is used instead.</span></span> <span data-ttu-id="8b8da-2416">Weitere Informationen finden Sie im Abschnitt "Hinweise zu Aufrufern", wenn das erste Element `values` `null`ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2416">See the Notes for Callers section if the first element of `values` is `null`.</span></span>

 <span data-ttu-id="8b8da-2417"><xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> ist eine bequeme Methode, mit der Sie jedes Element in einem Objekt Array verketten können, ohne seine Elemente explizit in Zeichen folgen zu wandeln.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2417"><xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> is a convenience method that lets you concatenate each element in an object array without explicitly converting its elements to strings.</span></span> <span data-ttu-id="8b8da-2418">Die Zeichen folgen Darstellung der einzelnen Objekte im Array wird durch Aufrufen der `ToString` Methode dieses Objekts abgeleitet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2418">The string representation of each object in the array is derived by calling that object's `ToString` method.</span></span>



## Examples
 <span data-ttu-id="8b8da-2419">Im folgenden Beispiel wird das Sieb des Eratosthenes-Algorithmus zum Berechnen der Primzahlen, die kleiner oder gleich 100 sind, verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2419">The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</span></span> <span data-ttu-id="8b8da-2420">Das Ergebnis wird einem ganzzahligen Array zugewiesen, das dann an die <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29>-Methode weitergeleitet wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2420">It assigns the result to a integer array, which it then passes to the <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> method.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-2421"><paramref name="values" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2421"><paramref name="values" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="8b8da-2422">Die Länge der resultierenden Zeichenfolge führt zu einem Überlauf der maximal zulässigen Länge (<see cref="F:System.Int32.MaxValue" />).</span><span class="sxs-lookup"><span data-stu-id="8b8da-2422">The length of the resulting string overflows the maximum allowed length (<see cref="F:System.Int32.MaxValue" />).</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-2423">Wenn das erste Element von <paramref name="values" /> <see langword="null" />ist, verkettet die <see cref="M:System.String.Join(System.String,System.Object[])" />-Methode nicht die Elemente in <paramref name="values" /> sondern gibt stattdessen <see cref="F:System.String.Empty" />zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2423">If the first element of <paramref name="values" /> is <see langword="null" />, the <see cref="M:System.String.Join(System.String,System.Object[])" /> method does not concatenate the elements in <paramref name="values" /> but instead returns <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="8b8da-2424">Es sind eine Reihe von Problem Umgehungen für dieses Problem verfügbar.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2424">A number of workarounds for this issue are available.</span></span> <span data-ttu-id="8b8da-2425">Am einfachsten ist es, dem ersten Element des Arrays den Wert <see cref="F:System.String.Empty" /> zuzuweisen, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2425">The easiest is to assign a value of <see cref="F:System.String.Empty" /> to the first element of the array, as the following example shows.</span></span>

<span data-ttu-id="8b8da-2426">[! Code-CSharp-Interactive[System. String. Join # 6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/joinfix1.cs#6)] [! Code-vb[System. String. Join # 6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/joinfix1.vb#6)]</span><span class="sxs-lookup"><span data-stu-id="8b8da-2426">[!code-csharp-interactive[System.String.Join#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/joinfix1.cs#6)] [!code-vb[System.String.Join#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/joinfix1.vb#6)]</span></span></para></block>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params string[] value);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray value As String()) As String" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ value);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, value As String()) As String" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, cli::array &lt;System::String ^&gt; ^ value);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="8b8da-2427">Die Zeichenfolge, die als Trennzeichen verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2427">The string to use as a separator.</span></span> <span data-ttu-id="8b8da-2428"><paramref name="separator" /> ist in der zurückgegebenen Zeichenfolge nur enthalten, wenn <paramref name="value" /> mehr als ein Element enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2428"><paramref name="separator" /> is included in the returned string only if <paramref name="value" /> has more than one element.</span></span></param>
        <param name="value"><span data-ttu-id="8b8da-2429">Ein Array, das die zu verkettenden Elemente enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2429">An array that contains the elements to concatenate.</span></span></param>
        <summary><span data-ttu-id="8b8da-2430">Verkettet alle Elemente eines Zeichenfolgenarrays und verwendet das angegebene Trennzeichen zwischen den einzelnen Elementen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2430">Concatenates all the elements of a string array, using the specified separator between each element.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2431">Eine Zeichenfolge, die aus den Membern von <paramref name="value" /> besteht, getrennt durch die <paramref name="separator" />-Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2431">A string that consists of the elements in <paramref name="value" /> delimited by the <paramref name="separator" /> string.</span></span> <span data-ttu-id="8b8da-2432">Wenn <paramref name="value" /> eine leeres Array ist, gibt die Methode <see cref="F:System.String.Empty" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2432">If <paramref name="value" /> is an empty array, the method returns <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2433">Wenn `separator` z. b. "," ist und die Elemente `value` "Apple", "Orange", "Grape" und "Birnen" sind, gibt `Join(separator, value)` "Apple, Orange, Grape, Birnen" zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2433">For example, if `separator` is ", " and the elements of `value` are "apple", "orange", "grape", and "pear", `Join(separator, value)` returns "apple, orange, grape, pear".</span></span>

 <span data-ttu-id="8b8da-2434">Wenn `separator` `null`ist, wird stattdessen eine leere Zeichenfolge (<xref:System.String.Empty?displayProperty=nameWithType>) verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2434">If `separator` is `null`, an empty string (<xref:System.String.Empty?displayProperty=nameWithType>) is used instead.</span></span> <span data-ttu-id="8b8da-2435">Wenn ein Element in `value` `null`ist, wird stattdessen eine leere Zeichenfolge verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2435">If any element in `value` is `null`, an empty string is used instead.</span></span>



## Examples
 <span data-ttu-id="8b8da-2436">Das folgende Beispiel veranschaulicht die <xref:System.String.Join%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2436">The following example demonstrates the <xref:System.String.Join%2A> method.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/stringjoin/CPP/stringjoin.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringjoin/CS/stringjoin.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringjoin/VB/stringjoin.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-2437"><paramref name="value" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2437"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="8b8da-2438">Die Länge der resultierenden Zeichenfolge führt zu einem Überlauf der maximal zulässigen Länge (<see cref="F:System.Int32.MaxValue" />).</span><span class="sxs-lookup"><span data-stu-id="8b8da-2438">The length of the resulting string overflows the maximum allowed length (<see cref="F:System.Int32.MaxValue" />).</span></span></exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="value" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="8b8da-2439">Verkettet ein Zeichenfolgenarray mithilfe der angegebenen Trennlinie zwischen den einzelnen Elementen. Dabei beginnt das Array mit dem Element, das sich am angegebenen Index befindet, und enthält eine bestimmte Anzahl von Elementen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2439">Concatenates an array of strings, using the specified separator between each member, starting with the element located at the specified index and including a specified number of elements.</span></span></param>
        <param name="value"><span data-ttu-id="8b8da-2440">Ein Array von zu verkettenden Zeichenfolgen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2440">An array of strings to concatenate.</span></span></param>
        <param name="startIndex"><span data-ttu-id="8b8da-2441">Das erste zu verkettende Element in <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2441">The first item in <paramref name="value" /> to concatenate.</span></span></param>
        <param name="count"><span data-ttu-id="8b8da-2442">Die Anzahl der Elemente aus <paramref name="value" />, die verkettet werden sollen, beginnend mit dem Element in der Position <paramref name="startIndex" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2442">The number of elements from <paramref name="value" /> to concatenate, starting with the element in the <paramref name="startIndex" /> position.</span></span></param>
        <summary><span data-ttu-id="8b8da-2443">Verkettet ein Zeichenfolgenarray mithilfe der angegebenen Trennlinie zwischen den einzelnen Elementen. Dabei beginnt das Array mit dem Element in <paramref name="value" /> an der Position <paramref name="startIndex" />, und verkettet bis zu <paramref name="count" /> Elemente.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2443">Concatenates an array of strings, using the specified separator between each member, starting with the element in <paramref name="value" /> located at the <paramref name="startIndex" /> position, and concatenating up to <paramref name="count" /> elements.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2444">Eine Zeichenfolge, die aus den Elementen von <paramref name="value" /> besteht, getrennt durch das Zeichen <paramref name="separator" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2444">A string that consists of the elements of <paramref name="value" /> delimited by the <paramref name="separator" /> character.</span></span>

<span data-ttu-id="8b8da-2445">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-2445">-or-</span></span>

<span data-ttu-id="8b8da-2446"><see cref="F:System.String.Empty" />, wenn <paramref name="count" /> null ist, <paramref name="value" /> keine Elemente enthält oder alle Elemente von <paramref name="value" /><see langword="null" /> oder <see cref="F:System.String.Empty" /> sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2446"><see cref="F:System.String.Empty" /> if <paramref name="count" /> is zero, <paramref name="value" /> has no elements, or all the elements of <paramref name="value" /> are <see langword="null" /> or <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-2447"><paramref name="value" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2447"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-2448"><paramref name="startIndex" /> oder <paramref name="count" /> ist negativ.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2448"><paramref name="startIndex" /> or <paramref name="count" /> are negative.</span></span>

<span data-ttu-id="8b8da-2449">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-2449">-or-</span></span>

<span data-ttu-id="8b8da-2450"><paramref name="startIndex" /> ist größer als die Länge von <paramref name="value" />  - <paramref name="count" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2450"><paramref name="startIndex" /> is greater than the length of <paramref name="value" />  - <paramref name="count" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="8b8da-2451">Die Länge der resultierenden Zeichenfolge führt zu einem Überlauf der maximal zulässigen Länge (<see cref="F:System.Int32.MaxValue" />).</span><span class="sxs-lookup"><span data-stu-id="8b8da-2451">The length of the resulting string overflows the maximum allowed length (<see cref="F:System.Int32.MaxValue" />).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="8b8da-2452">Die Zeichenfolge, die als Trennzeichen verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2452">The string to use as a separator.</span></span> <span data-ttu-id="8b8da-2453"><paramref name="separator" /> ist in der zurückgegebenen Zeichenfolge nur enthalten, wenn <paramref name="value" /> mehr als ein Element enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2453"><paramref name="separator" /> is included in the returned string only if <paramref name="value" /> has more than one element.</span></span></param>
        <param name="value"><span data-ttu-id="8b8da-2454">Ein Array, das die zu verkettenden Elemente enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2454">An array that contains the elements to concatenate.</span></span></param>
        <param name="startIndex"><span data-ttu-id="8b8da-2455">Das erste zu verwendende Element aus <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2455">The first element in <paramref name="value" /> to use.</span></span></param>
        <param name="count"><span data-ttu-id="8b8da-2456">Die Anzahl der zu verwendenden Elemente aus <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2456">The number of elements of <paramref name="value" /> to use.</span></span></param>
        <summary><span data-ttu-id="8b8da-2457">Verkettet die angegebenen Elemente eines Zeichenfolgenarrays und verwendet das angegebene Trennzeichen zwischen den einzelnen Elementen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2457">Concatenates the specified elements of a string array, using the specified separator between each element.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2458">Eine Zeichenfolge, die aus den Zeichenfolgen in <paramref name="value" /> besteht, getrennt durch die <paramref name="separator" />-Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2458">A string that consists of the strings in <paramref name="value" /> delimited by the <paramref name="separator" /> string.</span></span>

<span data-ttu-id="8b8da-2459">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-2459">-or-</span></span>

 <span data-ttu-id="8b8da-2460"><see cref="F:System.String.Empty" />, wenn <paramref name="count" /> 0 (null) ist, <paramref name="value" /> keine Elemente enthält oder <paramref name="separator" /> und alle Elemente von <paramref name="value" /><see cref="F:System.String.Empty" /> sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2460"><see cref="F:System.String.Empty" /> if <paramref name="count" /> is zero, <paramref name="value" /> has no elements, or <paramref name="separator" /> and all the elements of <paramref name="value" /> are <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2461">Wenn `separator` z. b. "," ist und die Elemente `value` "Apple", "Orange", "Grape" und "Birnen" sind, gibt `Join(separator, value, 1, 2)` "Orange, Traube" zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2461">For example, if `separator` is ", " and the elements of `value` are "apple", "orange", "grape", and "pear", `Join(separator, value, 1, 2)` returns "orange, grape".</span></span>

 <span data-ttu-id="8b8da-2462">Wenn `separator` `null`ist, wird stattdessen eine leere Zeichenfolge (<xref:System.String.Empty?displayProperty=nameWithType>) verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2462">If `separator` is `null`, an empty string (<xref:System.String.Empty?displayProperty=nameWithType>) is used instead.</span></span> <span data-ttu-id="8b8da-2463">Wenn ein Element in `value` `null`ist, wird stattdessen eine leere Zeichenfolge verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2463">If any element in `value` is `null`, an empty string is used instead.</span></span>



## Examples
 <span data-ttu-id="8b8da-2464">Im folgenden Beispiel werden zwei-Elemente aus einem Array mit den Namen von Früchten verkettet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2464">The following example concatenates two elements from an array of names of fruit.</span></span>

 [!code-cpp[string.join2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.join2/CPP/join2.cpp#1)]
 [!code-csharp-interactive[string.join2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.join2/CS/join2.cs#1)]
 [!code-vb[string.join2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.join2/VB/join2.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-2465"><paramref name="value" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2465"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-2466"><paramref name="startIndex" /> oder <paramref name="count" /> ist kleiner als 0 (null).</span><span class="sxs-lookup"><span data-stu-id="8b8da-2466"><paramref name="startIndex" /> or <paramref name="count" /> is less than 0.</span></span>

<span data-ttu-id="8b8da-2467">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-2467">-or-</span></span>

<span data-ttu-id="8b8da-2468"><paramref name="startIndex" /> plus <paramref name="count" /> ist größer als die Anzahl von Elementen in <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2468"><paramref name="startIndex" /> plus <paramref name="count" /> is greater than the number of elements in <paramref name="value" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="8b8da-2469">Nicht genügend Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2469">Out of memory.</span></span></exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As Char, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="8b8da-2470">Der Typ der Member von <paramref name="values" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2470">The type of the members of <paramref name="values" />.</span></span></typeparam>
        <param name="separator"><span data-ttu-id="8b8da-2471">Das als Trennlinie zu verwendende Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2471">The character to use as a separator.</span></span> <span data-ttu-id="8b8da-2472"><paramref name="separator" /> ist in der zurückgegebenen Zeichenfolge nur enthalten, wenn <paramref name="values" /> mehr als ein Element enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2472"><paramref name="separator" /> is included in the returned string only if <paramref name="values" /> has more than one element.</span></span></param>
        <param name="values"><span data-ttu-id="8b8da-2473">Eine Auflistung, die die zu verkettenden Objekte enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2473">A collection that contains the objects to concatenate.</span></span></param>
        <summary><span data-ttu-id="8b8da-2474">Verkettet die Member einer Auflistung und verwendet das angegebene Trennzeichen zwischen den einzelnen Membern.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2474">Concatenates the members of a collection, using the specified separator between each member.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2475">Eine Zeichenfolge, die aus den Elementen von <paramref name="values" /> besteht, getrennt durch das Zeichen <paramref name="separator" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2475">A string that consists of the members of <paramref name="values" /> delimited by the <paramref name="separator" /> character.</span></span> <span data-ttu-id="8b8da-2476">Wenn <paramref name="values" /> keine Mitglieder hat, gibt die Methode <see cref="F:System.String.Empty" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2476">If <paramref name="values" /> has no members, the method returns <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-2477"><paramref name="values" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2477"><paramref name="values" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="8b8da-2478">Die Länge der resultierenden Zeichenfolge führt zu einem Überlauf der maximal zulässigen Länge (<see cref="F:System.Int32.MaxValue" />).</span><span class="sxs-lookup"><span data-stu-id="8b8da-2478">The length of the resulting string overflows the maximum allowed length (<see cref="F:System.Int32.MaxValue" />).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As String, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="8b8da-2479">Der Typ der Member von <paramref name="values" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2479">The type of the members of <paramref name="values" />.</span></span></typeparam>
        <param name="separator"><span data-ttu-id="8b8da-2480">Die Zeichenfolge, die als Trennzeichen verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2480">The string to use as a separator.</span></span> <span data-ttu-id="8b8da-2481"><paramref name="separator" /> ist in der zurückgegebenen Zeichenfolge nur enthalten, wenn <paramref name="values" /> mehr als ein Element enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2481"><paramref name="separator" /> is included in the returned string only if <paramref name="values" /> has more than one element.</span></span></param>
        <param name="values"><span data-ttu-id="8b8da-2482">Eine Auflistung, die die zu verkettenden Objekte enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2482">A collection that contains the objects to concatenate.</span></span></param>
        <summary><span data-ttu-id="8b8da-2483">Verkettet die Member einer Auflistung und verwendet das angegebene Trennzeichen zwischen den einzelnen Membern.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2483">Concatenates the members of a collection, using the specified separator between each member.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2484">Eine Zeichenfolge, die aus den Membern von <paramref name="values" /> besteht, getrennt durch die <paramref name="separator" />-Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2484">A string that consists of the members of <paramref name="values" /> delimited by the <paramref name="separator" /> string.</span></span> <span data-ttu-id="8b8da-2485">Wenn <paramref name="values" /> keine Mitglieder hat, gibt die Methode <see cref="F:System.String.Empty" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2485">If <paramref name="values" /> has no members, the method returns <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2486">Wenn `separator` `null`ist, wird stattdessen eine leere Zeichenfolge (<xref:System.String.Empty?displayProperty=nameWithType>) verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2486">If `separator` is `null`, an empty string (<xref:System.String.Empty?displayProperty=nameWithType>) is used instead.</span></span> <span data-ttu-id="8b8da-2487">Wenn ein Member von `values` `null`ist, wird stattdessen eine leere Zeichenfolge verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2487">If any member of `values` is `null`, an empty string is used instead.</span></span>

 <span data-ttu-id="8b8da-2488"><xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> ist eine bequeme Methode, mit der Sie jedes Element einer <xref:System.Collections.Generic.IEnumerable%601> Auflistung verketten können, ohne Sie zuvor in Zeichen folgen zu wandeln.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2488"><xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> is a convenience method that lets you concatenate each member of an <xref:System.Collections.Generic.IEnumerable%601> collection without first converting them to strings.</span></span> <span data-ttu-id="8b8da-2489">Die Zeichen folgen Darstellung der einzelnen Objekte in der <xref:System.Collections.Generic.IEnumerable%601> Auflistung wird durch Aufrufen der `ToString` Methode dieses Objekts abgeleitet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2489">The string representation of each object in the <xref:System.Collections.Generic.IEnumerable%601> collection is derived by calling that object's `ToString` method.</span></span>

 <span data-ttu-id="8b8da-2490">Diese Methode ist besonders nützlich, wenn LINQ-Abfrage Ausdrücke (Language-Integrated Query) eingesetzt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2490">This method is particular useful with Language-Integrated Query (LINQ) query expressions.</span></span> <span data-ttu-id="8b8da-2491">Der folgende Code definiert z. b. eine sehr einfache `Animal`-Klasse, die den Namen eines Tieres und die Reihenfolge enthält, zu der er gehört.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2491">For example, the following code defines a very simple `Animal` class that contains the name of an animal and the order to which it belongs.</span></span> <span data-ttu-id="8b8da-2492">Anschließend wird ein <xref:System.Collections.Generic.List%601> Objekt definiert, das eine Reihe von `Animal` Objekten enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2492">It then defines a <xref:System.Collections.Generic.List%601> object that contains a number of `Animal` objects.</span></span> <span data-ttu-id="8b8da-2493">Die <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType>-Erweiterungsmethode wird aufgerufen, um die `Animal` Objekte zu extrahieren, deren `Order`-Eigenschaft den Wert "Rodent" hat.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2493">The <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> extension method is called to extract the `Animal` objects whose `Order` property equals "Rodent".</span></span> <span data-ttu-id="8b8da-2494">Das Ergebnis wird an die <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>-Methode übermittelt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2494">The result is passed to the <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> method.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join5.cs" interactive="try-dotnet" id="Snippet5":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join5.vb" id="Snippet5":::

## Examples
 <span data-ttu-id="8b8da-2495">Im folgenden Beispiel wird das Sieb des Eratosthenes-Algorithmus zum Berechnen der Primzahlen, die kleiner oder gleich 100 sind, verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2495">The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</span></span> <span data-ttu-id="8b8da-2496">Das Ergebnis wird einem <xref:System.Collections.Generic.List%601>-Objekt vom Typ Integer zugewiesen, das dann an die <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>-Methode übergibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2496">It assigns the result to a <xref:System.Collections.Generic.List%601> object of type integer, which it then passes to the <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> method.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join2.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join2.vb" id="Snippet2":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-2497"><paramref name="values" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2497"><paramref name="values" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="8b8da-2498">Die Länge der resultierenden Zeichenfolge führt zu einem Überlauf der maximal zulässigen Länge (<see cref="F:System.Int32.MaxValue" />).</span><span class="sxs-lookup"><span data-stu-id="8b8da-2498">The length of the resulting string overflows the maximum allowed length (<see cref="F:System.Int32.MaxValue" />).</span></span></exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8b8da-2499">Gibt die NULL-basierte Indexposition des letzten Vorkommens eines angegebenen Unicode-Zeichens oder einer angegebenen Unicode-Zeichenfolge in dieser Instanz an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2499">Reports the zero-based index position of the last occurrence of a specified Unicode character or string within this instance.</span></span> <span data-ttu-id="8b8da-2500">Die Methode gibt -1 zurück, wenn das Zeichen oder die Zeichenfolge in dieser Instanz nicht gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2500">The method returns -1 if the character or string is not found in this instance.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-2501">Das zu suchende Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2501">The Unicode character to seek.</span></span></param>
        <summary><span data-ttu-id="8b8da-2502">Gibt die NULL-basierte Indexposition des letzten Vorkommens eines angegebenen Unicode-Zeichens in dieser Instanz an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2502">Reports the zero-based index position of the last occurrence of a specified Unicode character within this instance.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2503">Die nullbasierte Indexposition von <paramref name="value" />, wenn dieses Zeichen gefunden wurde, andernfalls -1.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2503">The zero-based index position of <paramref name="value" /> if that character is found, or -1 if it is not.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2504">Die Index Nummerierung beginnt bei Null.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2504">Index numbering starts from zero.</span></span> <span data-ttu-id="8b8da-2505">Das heißt, das erste Zeichen in der Zeichenfolge hat den Index 0 und das letzte den Wert <xref:System.String.Length%2A>-1.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2505">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>

 <span data-ttu-id="8b8da-2506">Diese Methode beginnt mit der Suche an der letzten Zeichenposition dieser Instanz und verläuft rückwärts zum Anfang, bis entweder `value` gefunden wird oder die erste Zeichenposition überprüft wurde.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2506">This method begins searching at the last character position of this instance and proceeds backward toward the beginning until either `value` is found or the first character position has been examined.</span></span> <span data-ttu-id="8b8da-2507">Bei der Suche wird die Groß- und Kleinschreibung berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2507">The search is case-sensitive.</span></span>

 <span data-ttu-id="8b8da-2508">Diese Methode führt eine ordnungsgemäß (Kultur unabhängige) Suche aus, bei der ein Zeichen als äquivalent zu einem anderen Zeichen gilt, wenn Ihre Unicode-Skalarwerte identisch sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2508">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="8b8da-2509">So führen Sie eine Kultur abhängige Suche durch Verwenden Sie die <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>-Methode, bei der ein Unicode-Skalarwert, der ein vorzusammen gesetztes Zeichen darstellt, wie z. b. die Ligaturen "Æ" (u + 00c6), in Abhängigkeit von der Kultur als äquivalent zu jedem Vorkommen der Komponenten des Zeichens in der richtigen Reihenfolge betrachtet werden kann.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2509">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>



## Examples
 <span data-ttu-id="8b8da-2510">Im folgenden Beispiel wird eine `ExtractFilename`-Methode definiert, die die <xref:System.String.LastIndexOf%28System.Char%29>-Methode verwendet, um das letzte Verzeichnis Trennzeichen in einer Zeichenfolge zu suchen und den Dateinamen der Zeichenfolge zu extrahieren.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2510">The following example defines an `ExtractFilename` method that uses the <xref:System.String.LastIndexOf%28System.Char%29> method to find the last directory separator character in a string and to extract the string's file name.</span></span> <span data-ttu-id="8b8da-2511">Wenn die Datei vorhanden ist, gibt die Methode den Dateinamen ohne ihren Pfad zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2511">If the file exists, the method returns the file name without its path.</span></span>

 [!code-csharp[System.String.LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/LastIndexOf_Example.cs#1)]
 [!code-vb[System.String.LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/LastIndexOf_Example.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-2512">Die zu suchende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2512">The string to seek.</span></span></param>
        <summary><span data-ttu-id="8b8da-2513">Gibt die NULL-basierte Indexposition des letzten Vorkommens einer angegebenen Zeichenfolge in dieser Instanz an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2513">Reports the zero-based index position of the last occurrence of a specified string within this instance.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2514">Die nullbasierte Indexposition von <paramref name="value" />, wenn diese Zeichenfolge gefunden wurde, andernfalls -1.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2514">The zero-based starting index position of <paramref name="value" /> if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="8b8da-2515">Wenn <paramref name="value" /><see cref="F:System.String.Empty" /> ist, ist der Rückgabewert die letzte Indexposition in dieser Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2515">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the last index position in this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2516">Die Index Nummerierung beginnt bei Null.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2516">Index numbering starts from zero.</span></span> <span data-ttu-id="8b8da-2517">Das heißt, das erste Zeichen in der Zeichenfolge hat den Index 0 und das letzte den Wert <xref:System.String.Length%2A>-1.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2517">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>

 <span data-ttu-id="8b8da-2518">Die Suche beginnt an der letzten Zeichenposition dieser Instanz und verläuft rückwärts zum Anfang, bis entweder `value` gefunden wird oder die erste Zeichenposition überprüft wurde.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2518">The search begins at the last character position of this instance and proceeds backward toward the beginning until either `value` is found or the first character position has been examined.</span></span>

 <span data-ttu-id="8b8da-2519">Diese Methode führt unter Verwendung der aktuellen Kultur eine Wort Suche (Groß-/Kleinschreibung und Kultur abhängige Suche) durch.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2519">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span>

 <span data-ttu-id="8b8da-2520">Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2520">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="8b8da-2521">Bei einer kulturabhängige Suche, bei der `value` ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2521">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="8b8da-2522">Wenn `value` nur aus mindestens einem Ignorable-Zeichen besteht, gibt die <xref:System.String.LastIndexOf%28System.String%29>-Methode immer <xref:System.String.Length%2A?displayProperty=nameWithType>-1 zurück, das die letzte Indexposition in der aktuellen Instanz darstellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2522">If `value` consists only of one or more ignorable characters, the <xref:System.String.LastIndexOf%28System.String%29> method always returns <xref:System.String.Length%2A?displayProperty=nameWithType> - 1, which represents the last index position in the current instance.</span></span> <span data-ttu-id="8b8da-2523">Im folgenden Beispiel wird die <xref:System.String.LastIndexOf%28System.String%29>-Methode verwendet, um drei Teil Zeichenfolgen zu suchen (ein weicher Bindestrich (U + 00ad), ein weicher Bindestrich gefolgt von "n" und ein weicher Bindestrich, gefolgt von "m") in zwei Zeichen folgen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2523">In the following example, the <xref:System.String.LastIndexOf%28System.String%29> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</span></span> <span data-ttu-id="8b8da-2524">Nur eine der Zeichenfolgen enthält einen bedingten Bindestrich.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2524">Only one of the strings contains a soft hyphen.</span></span> <span data-ttu-id="8b8da-2525">Wenn das Beispiel in der [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher ausgeführt wird, ist das Ergebnis in jedem Fall, da der weiche Bindestrich ein ignorierbares Zeichen ist, das gleiche wie bei einem nicht in `value`enthaltene weiche Bindestrich.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2525">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in each case, because the soft hyphen is an ignorable character, the result is the same as if the soft hyphen had not been included in `value`.</span></span> <span data-ttu-id="8b8da-2526">Bei der Suche nach einem Soft Bindestrich gibt die Methode 6 und 5 zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2526">When searching for a soft hyphen only, the method returns 6 and 5.</span></span> <span data-ttu-id="8b8da-2527">Diese Werte entsprechen dem Index des letzten Zeichens in den beiden Zeichen folgen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2527">These values correspond to the index of the last character in the two strings.</span></span>

 [!code-csharp[System.String.LastIndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof21.cs#21)]
 [!code-vb[System.String.LastIndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof21.vb#21)]



## Examples
 <span data-ttu-id="8b8da-2528">Im folgenden Beispiel werden öffnende und schließende HTML-Tags aus einer Zeichenfolge entfernt, wenn die Tags beginnen und die Zeichenfolge beenden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2528">The following example removes opening and closing HTML tags from a string if the tags begin and end the string.</span></span> <span data-ttu-id="8b8da-2529">Wenn eine Zeichenfolge mit einem schließenden Klammer Zeichen (">") endet, wird im Beispiel die <xref:System.String.LastIndexOf%2A>-Methode verwendet, um den Anfang des Endtags zu suchen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2529">If a string ends with a closing bracket character (">"), the example uses the <xref:System.String.LastIndexOf%2A> method to locate the start of the end tag.</span></span>

 [!code-csharp[System.String.LastIndexOf#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof_example2.cs#2)]
 [!code-vb[System.String.LastIndexOf#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof_example2.vb#2)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-2530"><paramref name="value" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2530"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-2531">Wie in [bewährte Methoden für die Verwendung von](~/docs/standard/base-types/best-practices-strings.md)Zeichen folgen erläutert, empfiehlt es sich, den Aufruf von Zeichen folgen Vergleichsmethoden zu vermeiden, die Standardwerte ersetzen, und stattdessen Methoden aufzurufen, für die Parameter explizit angegeben werden müssen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2531">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="8b8da-2532">Um den letzten Index einer Teil Zeichenfolge innerhalb einer Zeichen folgen Instanz mithilfe der Vergleichs Regeln der aktuellen Kultur zu ermitteln, müssen Sie die <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" />-Methoden Überladung mit dem Wert <see cref="F:System.StringComparison.CurrentCulture" /> für den <paramref name="comparisonType" /> Parameter aufrufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2532">To find the last index of a substring within a string instance by using the comparison rules of the current culture, call the <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-2533">Das zu suchende Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2533">The Unicode character to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="8b8da-2534">Die Anfangsposition der Suche.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2534">The starting position of the search.</span></span> <span data-ttu-id="8b8da-2535">Die Suche wird von <paramref name="startIndex" /> bis zum Anfang dieser Instanz fortgesetzt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2535">The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</span></span></param>
        <summary><span data-ttu-id="8b8da-2536">Gibt die NULL-basierte Indexposition des letzten Vorkommens eines angegebenen Unicode-Zeichens in dieser Instanz an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2536">Reports the zero-based index position of the last occurrence of a specified Unicode character within this instance.</span></span> <span data-ttu-id="8b8da-2537">Die Suche beginnt an einer angegebenen Zeichenposition und wird rückwärts bis zum Anfang der Zeichenfolge fortgesetzt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2537">The search starts at a specified character position and proceeds backward toward the beginning of the string.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2538">Die nullbasierte Indexposition von <paramref name="value" />, wenn dieses Zeichen gefunden wurde, oder -1, wenn es nicht gefunden wurde oder die aktuelle Instanz gleich <see cref="F:System.String.Empty" /> ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2538">The zero-based index position of <paramref name="value" /> if that character is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2539">Die Index Nummerierung beginnt bei Null.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2539">Index numbering starts from zero.</span></span> <span data-ttu-id="8b8da-2540">Das heißt, das erste Zeichen in der Zeichenfolge hat den Index 0 und das letzte den Wert <xref:System.String.Length%2A>-1.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2540">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span> <span data-ttu-id="8b8da-2541">Diese Methode beginnt mit der Suche an der `startIndex` Zeichenposition dieser Instanz und geht rückwärts zum Anfang der aktuellen Instanz, bis entweder `value` gefunden wird oder die erste Zeichenposition überprüft wurde.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2541">This method begins searching at the `startIndex` character position of this instance and proceeds backward toward the beginning of the current instance until either `value` is found or the first character position has been examined.</span></span> <span data-ttu-id="8b8da-2542">Wenn `startIndex` z. b. <xref:System.String.Length%2A>-1 ist, durchsucht die-Methode jedes Zeichen vom letzten Zeichen in der Zeichenfolge bis zum Anfang.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2542">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches every character from the last character in the string to the beginning.</span></span> <span data-ttu-id="8b8da-2543">Bei der Suche wird die Groß- und Kleinschreibung berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2543">The search is case-sensitive.</span></span>

 <span data-ttu-id="8b8da-2544">Diese Methode führt eine ordnungsgemäß (Kultur unabhängige) Suche aus, bei der ein Zeichen als äquivalent zu einem anderen Zeichen gilt, wenn Ihre Unicode-Skalarwerte identisch sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2544">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="8b8da-2545">So führen Sie eine Kultur abhängige Suche durch Verwenden Sie die <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>-Methode, bei der ein Unicode-Skalarwert, der ein vorzusammen gesetztes Zeichen darstellt, wie z. b. die Ligaturen "Æ" (u + 00c6), in Abhängigkeit von der Kultur als äquivalent zu jedem Vorkommen der Komponenten des Zeichens in der richtigen Reihenfolge betrachtet werden kann.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2545">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>



## Examples
 <span data-ttu-id="8b8da-2546">Im folgenden Beispiel wird der Index aller Vorkommen eines Zeichens in einer Zeichenfolge gesucht. dabei wird vom Ende der Zeichenfolge bis zum Anfang der Zeichenfolge gearbeitet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2546">The following example finds the index of all occurrences of a character in a string, working from the end of the string to the start of the string.</span></span>

 [!code-cpp[string.lastindexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof1/CPP/lastixof1.cpp#1)]
 [!code-csharp[string.lastindexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof1/CS/lastixof1.cs#1)]
 [!code-vb[string.lastindexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof1/VB/lastixof1.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-2547">Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist kleiner als 0 (null) oder größer oder gleich der Länge dieser Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2547">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than zero or greater than or equal to the length of this instance.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-2548">Die zu suchende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2548">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="8b8da-2549">Die Anfangsposition der Suche.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2549">The search starting position.</span></span> <span data-ttu-id="8b8da-2550">Die Suche wird von <paramref name="startIndex" /> bis zum Anfang dieser Instanz fortgesetzt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2550">The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</span></span></param>
        <summary><span data-ttu-id="8b8da-2551">Gibt die NULL-basierte Indexposition des letzten Vorkommens einer angegebenen Zeichenfolge in dieser Instanz an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2551">Reports the zero-based index position of the last occurrence of a specified string within this instance.</span></span> <span data-ttu-id="8b8da-2552">Die Suche beginnt an einer angegebenen Zeichenposition und wird rückwärts bis zum Anfang der Zeichenfolge fortgesetzt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2552">The search starts at a specified character position and proceeds backward toward the beginning of the string.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2553">Die nullbasierte Anfangsindexposition von <paramref name="value" />, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde oder die aktuelle Instanz gleich <see cref="F:System.String.Empty" /> ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2553">The zero-based starting index position of <paramref name="value" /> if that string is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="8b8da-2554">Wenn <paramref name="value" /><see cref="F:System.String.Empty" /> ist, ist der Rückgabewert der kleinere <paramref name="startIndex" /> und die letzte Indexposition in dieser Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2554">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the smaller of <paramref name="startIndex" /> and the last index position in this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2555">Die Index Nummerierung beginnt bei Null.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2555">Index numbering starts from zero.</span></span> <span data-ttu-id="8b8da-2556">Das heißt, das erste Zeichen in der Zeichenfolge hat den Index 0 und das letzte den Wert <xref:System.String.Length%2A>-1.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2556">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>

 <span data-ttu-id="8b8da-2557">Die Suche beginnt an der `startIndex` Zeichenposition dieser Instanz und verläuft rückwärts zum Anfang, bis entweder `value` gefunden wird oder die erste Zeichenposition überprüft wurde.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2557">The search begins at the `startIndex` character position of this instance and proceeds backward toward the beginning until either `value` is found or the first character position has been examined.</span></span> <span data-ttu-id="8b8da-2558">Wenn `startIndex` z. b. <xref:System.String.Length%2A>-1 ist, durchsucht die-Methode jedes Zeichen vom letzten Zeichen in der Zeichenfolge bis zum Anfang.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2558">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches every character from the last character in the string to the beginning.</span></span>

 <span data-ttu-id="8b8da-2559">Diese Methode führt unter Verwendung der aktuellen Kultur eine Wort Suche (Groß-/Kleinschreibung und Kultur abhängige Suche) durch.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2559">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span>

 <span data-ttu-id="8b8da-2560">Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2560">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="8b8da-2561">Bei einer kulturabhängige Suche, bei der `value` ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2561">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="8b8da-2562">Wenn `value` nur aus mindestens einem ignorierbaren Zeichen besteht, gibt die <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29>-Methode immer `startIndex`zurück. Dies ist die Zeichenposition, an der die Suche beginnt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2562">If `value` consists only of one or more ignorable characters, the <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> method always returns `startIndex`, which is the character position at which the search begins.</span></span> <span data-ttu-id="8b8da-2563">Im folgenden Beispiel wird die <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29>-Methode verwendet, um eine Teil Zeichenfolge zu suchen, die einen Soft Bindestrich (U + 00ad) enthält und der dem abschließenden "m" in einer Zeichenfolge vorangestellt ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2563">In the following example, the <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> method is used to find a substring that includes a soft hyphen (U+00AD) and that precedes or includes the final "m" in a string.</span></span> <span data-ttu-id="8b8da-2564">Wenn das Beispiel auf dem [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder später ausgeführt wird, da der weiche Bindestrich in der Such Zeichenfolge ignoriert wird und die-Methode aufgerufen wird, um eine Teil Zeichenfolge zu suchen, die aus dem Soft-Bindestrich und "m" besteht, wird die Position des "m" in der Zeichenfolge zurückgegeben, während der Aufruf erfolgt, um eine Teil Zeichenfolge zu finden</span><span class="sxs-lookup"><span data-stu-id="8b8da-2564">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, because the soft hyphen in the search string is ignored, calling the method to find a substring that consists of the soft hyphen and "m" returns the position of the "m" in the string, whereas calling it to find a substring that consists of the soft hyphen and "n" returns the position of the "n".</span></span> <span data-ttu-id="8b8da-2565">Wenn die Such Zeichenfolge nur den weichen Bindestrich enthält, gibt die Methode den Index von "m" zurück, der den Wert `startIndex`darstellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2565">When the search string contains only the soft hyphen, the method returns the index of the "m", which represents the value of `startIndex`.</span></span>

 [!code-csharp[System.String.LastIndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof22.cs#22)]
 [!code-vb[System.String.LastIndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof22.vb#22)]



## Examples
 <span data-ttu-id="8b8da-2566">Im folgenden Beispiel wird der Index aller Vorkommen einer Zeichenfolge in der Ziel Zeichenfolge gesucht, wobei vom Ende der Ziel Zeichenfolge bis zum Anfang der Ziel Zeichenfolge gearbeitet wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2566">The following example finds the index of all occurrences of a string in target string, working from the end of the target string to the start of the target string.</span></span>

 [!code-cpp[string.lastindexof7#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf7/CPP/lastixof7.cpp#1)]
 [!code-csharp[string.lastindexof7#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf7/CS/lastixof7.cs#1)]
 [!code-vb[string.lastindexof7#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf7/VB/lastixof7.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-2567"><paramref name="value" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2567"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-2568">Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist kleiner als 0 (null) oder größer als die Länge der aktuellen Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2568">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than zero or greater than the length of the current instance.</span></span>

<span data-ttu-id="8b8da-2569">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-2569">-or-</span></span>

<span data-ttu-id="8b8da-2570">Die aktuelle Instanz entspricht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist kleiner als -1 oder größer als 0 (null).</span><span class="sxs-lookup"><span data-stu-id="8b8da-2570">The current instance equals <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than -1 or greater than zero.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-2571">Wie in [bewährte Methoden für die Verwendung von](~/docs/standard/base-types/best-practices-strings.md)Zeichen folgen erläutert, empfiehlt es sich, den Aufruf von Zeichen folgen Vergleichsmethoden zu vermeiden, die Standardwerte ersetzen, und stattdessen Methoden aufzurufen, für die Parameter explizit angegeben werden müssen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2571">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="8b8da-2572">Um den Index einer Teil Zeichenfolge zu suchen, die einer bestimmten Zeichenposition vorangestellt ist, indem Sie die Vergleichs Regeln der aktuellen Kultur verwenden, rufen Sie die <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />-Methoden Überladung mit dem Wert <see cref="F:System.StringComparison.CurrentCulture" /> für den <paramref name="comparisonType" /> Parameter auf.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2572">To find the index of a substring that precedes a particular character position by using the comparison rules of the current culture, call the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * StringComparison -&gt; int" Usage="string.LastIndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-2573">Die zu suchende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2573">The string to seek.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="8b8da-2574">Einer der Enumerationswerte, der die Regeln für die Suche angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2574">One of the enumeration values that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="8b8da-2575">Gibt den NULL-basierten Index des letzten Vorkommens einer angegebenen Zeichenfolge im aktuellen <see cref="T:System.String" />-Objekt an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2575">Reports the zero-based index of the last occurrence of a specified string within the current <see cref="T:System.String" /> object.</span></span> <span data-ttu-id="8b8da-2576">Ein Parameter gibt den Typ der Suche für die angegebene Zeichenfolge an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2576">A parameter specifies the type of search to use for the specified string.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2577">Die nullbasierte Indexposition des <paramref name="value" />-Parameters, wenn diese Zeichenfolge gefunden wurde, andernfalls -1.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2577">The zero-based starting index position of the <paramref name="value" /> parameter if that string is found, or -1 if it is not.</span></span> <span data-ttu-id="8b8da-2578">Wenn <paramref name="value" /><see cref="F:System.String.Empty" /> ist, ist der Rückgabewert die letzte Indexposition in dieser Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2578">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the last index position in this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2579">Die Index Nummerierung beginnt bei Null.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2579">Index numbering starts from zero.</span></span> <span data-ttu-id="8b8da-2580">Das heißt, das erste Zeichen in der Zeichenfolge hat den Index 0 und das letzte den Wert <xref:System.String.Length%2A>-1.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2580">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>

 <span data-ttu-id="8b8da-2581">Der `comparisonType`-Parameter gibt an, dass mithilfe der aktuellen oder der invarianten Kultur nach dem `value` Parameter gesucht werden soll. dabei wird die Groß-/Kleinschreibung beachtet oder die Suche ohne Beachtung der Groß-/Kleinschreibung unterschieden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2581">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>

 <span data-ttu-id="8b8da-2582">Die Suche beginnt an der letzten Zeichenposition dieser Instanz und verläuft rückwärts zum Anfang, bis entweder `value` gefunden wird oder die erste Zeichenposition überprüft wurde.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2582">The search begins at the last character position of this instance and proceeds backward toward the beginning until either `value` is found or the first character position has been examined.</span></span>



## Examples
 <span data-ttu-id="8b8da-2583">Im folgenden Beispiel werden drei über Ladungen der <xref:System.String.LastIndexOf%2A>-Methode veranschaulicht, die das letzte Vorkommen einer Zeichenfolge in einer anderen Zeichenfolge mithilfe verschiedener Werte der <xref:System.StringComparison> Enumeration suchen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2583">The following example demonstrates three overloads of the <xref:System.String.LastIndexOf%2A> method that find the last occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>

 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-2584"><paramref name="value" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2584"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8b8da-2585"><paramref name="comparisonType" /> ist kein gültiger <see cref="T:System.StringComparison" />-Wert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2585"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-2586">Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2586">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="8b8da-2587">Bei einer kulturabhängige Suche (das heißt, wenn <paramref name="options" /> nicht <see cref="F:System.StringComparison.Ordinal" /> oder <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> ist), bei der <paramref name="value" /> ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2587">In a culture-sensitive search (that is, if <paramref name="options" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="8b8da-2588">Wenn <paramref name="value" /> nur aus mindestens einem Ignorable-Zeichen besteht, gibt die <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" />-Methode immer <see cref="P:System.String.Length" />-1 zurück, das die letzte Indexposition in der aktuellen Instanz darstellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2588">If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> method always returns <see cref="P:System.String.Length" /> - 1, which represents the last index position in the current instance.</span></span>

<span data-ttu-id="8b8da-2589">Im folgenden Beispiel wird die <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" />-Methode verwendet, um drei Teil Zeichenfolgen zu suchen (ein weicher Bindestrich (U + 00ad), ein weicher Bindestrich gefolgt von "n" und ein weicher Bindestrich, gefolgt von "m") in zwei Zeichen folgen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2589">In the following example, the <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</span></span> <span data-ttu-id="8b8da-2590">Nur eine der Zeichenfolgen enthält einen bedingten Bindestrich.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2590">Only one of the strings contains a soft hyphen.</span></span> <span data-ttu-id="8b8da-2591">Wenn das Beispiel auf [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher ausgeführt wird, weil der weiche Bindestrich ein ignorierbares Zeichen ist, gibt eine Kultur abhängige Suche denselben Wert zurück, der zurückgegeben wird, wenn der weiche Bindestrich nicht in der Such Zeichenfolge enthalten wäre.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2591">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, because the soft hyphen is an ignorable character, a culture-sensitive search returns the same value that it would return if the soft hyphen were not included in the search string.</span></span> <span data-ttu-id="8b8da-2592">Bei einer ordinalsuchsuche wird jedoch der weiche Bindestrich in einer Zeichenfolge gefunden, und es wird gemeldet, dass Sie in der zweiten Zeichenfolge nicht vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2592">An ordinal search, however, successfully finds the soft hyphen in one string and reports that it is absent from the second string.</span></span>

<span data-ttu-id="8b8da-2593">[! Code-csharp[System. String. LastIndexOf # 26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof26.cs#26)] [! Code-vb[System. String. LastIndexOf # 26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof26.vb#26)]</span><span class="sxs-lookup"><span data-stu-id="8b8da-2593">[!code-csharp[System.String.LastIndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof26.cs#26)] [!code-vb[System.String.LastIndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof26.vb#26)]</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-2594">Das zu suchende Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2594">The Unicode character to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="8b8da-2595">Die Anfangsposition der Suche.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2595">The starting position of the search.</span></span> <span data-ttu-id="8b8da-2596">Die Suche wird von <paramref name="startIndex" /> bis zum Anfang dieser Instanz fortgesetzt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2596">The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</span></span></param>
        <param name="count"><span data-ttu-id="8b8da-2597">Die Anzahl der zu überprüfenden Zeichenpositionen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2597">The number of character positions to examine.</span></span></param>
        <summary><span data-ttu-id="8b8da-2598">Gibt die NULL-basierte Indexposition des letzten Vorkommens des angegebenen Unicode-Zeichens in einer Teilzeichenfolge dieser Instanz an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2598">Reports the zero-based index position of the last occurrence of the specified Unicode character in a substring within this instance.</span></span> <span data-ttu-id="8b8da-2599">Die Suche beginnt an einer angegebenen Zeichenposition und verläuft für eine angegebene Anzahl von Zeichenpositionen rückwärts zum Anfang der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2599">The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2600">Die nullbasierte Indexposition von <paramref name="value" />, wenn dieses Zeichen gefunden wurde, oder -1, wenn es nicht gefunden wurde oder die aktuelle Instanz gleich <see cref="F:System.String.Empty" /> ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2600">The zero-based index position of <paramref name="value" /> if that character is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2601">Die Index Nummerierung beginnt bei Null.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2601">Index numbering starts from zero.</span></span> <span data-ttu-id="8b8da-2602">Das heißt, das erste Zeichen in der Zeichenfolge hat den Index 0 und das letzte den Wert <xref:System.String.Length%2A>-1.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2602">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>

 <span data-ttu-id="8b8da-2603">Diese Methode beginnt mit der Suche an der `startIndex` Zeichenposition und geht bis zum Anfang dieser Instanz zurück, bis entweder `value` gefunden wird oder `count` Zeichen Positionen überprüft wurden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2603">This method begins searching at the `startIndex` character position and proceeds backward toward the beginning of this instance until either `value` is found or `count` character positions have been examined.</span></span> <span data-ttu-id="8b8da-2604">Wenn `startIndex` z. b. <xref:System.String.Length%2A>-1 ist, sucht die Methode rückwärts `count` Zeichen aus dem letzten Zeichen in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2604">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches backward `count` characters from the last character in the string.</span></span> <span data-ttu-id="8b8da-2605">Bei der Suche wird die Groß- und Kleinschreibung berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2605">The search is case-sensitive.</span></span>

 <span data-ttu-id="8b8da-2606">Diese Methode führt eine Ordinalzahl (Kultur unabhängige Suche) aus, bei der ein Zeichen als äquivalent zu einem anderen Zeichen gilt, wenn der zugehörige Unicode-Skalarwert identisch ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2606">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same.</span></span> <span data-ttu-id="8b8da-2607">So führen Sie eine Kultur abhängige Suche durch Verwenden Sie die <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>-Methode, bei der ein Unicode-Skalarwert, der ein vorzusammen gesetztes Zeichen darstellt, wie z. b. die Ligaturen "Æ" (u + 00c6), in Abhängigkeit von der Kultur als äquivalent zu jedem Vorkommen der Komponenten des Zeichens in der richtigen Reihenfolge betrachtet werden kann.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2607">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>



## Examples
 <span data-ttu-id="8b8da-2608">Im folgenden Beispiel wird der Index aller Vorkommen eines Zeichens in einer Teil Zeichenfolge gefunden. dabei wird vom Ende der Teil Zeichenfolge bis zum Anfang der Teil Zeichenfolge gearbeitet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2608">The following example finds the index of all occurrences of a character in a substring, working from the end of the substring to the start of the substring.</span></span>

 [!code-cpp[string.lastindexof2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof2/CPP/lastixof2.cpp#1)]
 [!code-csharp[string.lastindexof2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof2/CS/lastixof2.cs#1)]
 [!code-vb[string.lastindexof2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof2/VB/lastixof2.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-2609">Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist kleiner als 0 (null) oder größer oder gleich der Länge dieser Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2609">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than zero or greater than or equal to the length of this instance.</span></span>

<span data-ttu-id="8b8da-2610">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-2610">-or-</span></span>

<span data-ttu-id="8b8da-2611">Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> - <paramref name="count" /> + 1 ist kleiner als 0 (null).</span><span class="sxs-lookup"><span data-stu-id="8b8da-2611">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> - <paramref name="count" /> + 1 is less than zero.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-2612">Die zu suchende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2612">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="8b8da-2613">Die Anfangsposition der Suche.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2613">The search starting position.</span></span> <span data-ttu-id="8b8da-2614">Die Suche wird von <paramref name="startIndex" /> bis zum Anfang dieser Instanz fortgesetzt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2614">The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</span></span></param>
        <param name="count"><span data-ttu-id="8b8da-2615">Die Anzahl der zu überprüfenden Zeichenpositionen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2615">The number of character positions to examine.</span></span></param>
        <summary><span data-ttu-id="8b8da-2616">Gibt die NULL-basierte Indexposition des letzten Vorkommens einer angegebenen Zeichenfolge in dieser Instanz an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2616">Reports the zero-based index position of the last occurrence of a specified string within this instance.</span></span> <span data-ttu-id="8b8da-2617">Die Suche beginnt an einer angegebenen Zeichenposition und verläuft für eine angegebene Anzahl von Zeichenpositionen rückwärts zum Anfang der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2617">The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2618">Die nullbasierte Anfangsindexposition von <paramref name="value" />, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde oder die aktuelle Instanz gleich <see cref="F:System.String.Empty" /> ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2618">The zero-based starting index position of <paramref name="value" /> if that string is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="8b8da-2619">Wenn <paramref name="value" /><see cref="F:System.String.Empty" /> ist, ist der Rückgabewert der kleinere <paramref name="startIndex" /> und die letzte Indexposition in dieser Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2619">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the smaller of <paramref name="startIndex" /> and the last index position in this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2620">Die Index Nummerierung beginnt bei Null.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2620">Index numbering starts from zero.</span></span> <span data-ttu-id="8b8da-2621">Das heißt, das erste Zeichen in der Zeichenfolge hat den Index 0 und das letzte den Wert <xref:System.String.Length%2A>-1.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2621">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>

 <span data-ttu-id="8b8da-2622">Die Suche beginnt an der `startIndex` Zeichenposition dieser Instanz und verläuft rückwärts zum Anfang, bis entweder `value` gefunden wird oder `count` Zeichen Positionen überprüft wurden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2622">The search begins at the `startIndex` character position of this instance and proceeds backward toward the beginning until either `value` is found or `count` character positions have been examined.</span></span> <span data-ttu-id="8b8da-2623">Wenn `startIndex` z. b. <xref:System.String.Length%2A>-1 ist, sucht die Methode rückwärts `count` Zeichen aus dem letzten Zeichen in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2623">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches backward `count` characters from the last character in the string.</span></span>

 <span data-ttu-id="8b8da-2624">Diese Methode führt unter Verwendung der aktuellen Kultur eine Wort Suche (Groß-/Kleinschreibung und Kultur abhängige Suche) durch.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2624">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span>

 <span data-ttu-id="8b8da-2625">Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2625">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="8b8da-2626">Bei einer kulturabhängige Suche, bei der `value` ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2626">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="8b8da-2627">Wenn `value` nur aus mindestens einem ignorierbaren Zeichen besteht, gibt die <xref:System.String.LastIndexOf%2A>-Methode immer `startIndex`zurück. Dies ist die Zeichenposition, an der die Suche beginnt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2627">If `value` consists only of one or more ignorable characters, the <xref:System.String.LastIndexOf%2A> method always returns `startIndex`, which is the character position at which the search begins.</span></span> <span data-ttu-id="8b8da-2628">Im folgenden Beispiel wird die <xref:System.String.LastIndexOf%2A>-Methode verwendet, um die Position eines weichen Bindestrichs (U + 00ad) in den zwei Zeichen zu finden, die dem abschließenden "m" der beiden Zeichen folgen vorangestellt sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2628">In the following example, the <xref:System.String.LastIndexOf%2A> method is used to find the position of a soft hyphen (U+00AD) in the two characters that precede the final "m" of two strings.</span></span> <span data-ttu-id="8b8da-2629">Nur eine der Zeichenfolgen enthält die erforderliche Teilzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2629">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="8b8da-2630">Wenn das Beispiel in der [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder später ausgeführt wird, da der weiche Bindestrich ein ignorierbares Zeichen ist, gibt die Methode den Index von "m" in der Zeichenfolge zurück, wenn Sie einen Kultur abhängigen Vergleich durchführt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2630">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="8b8da-2631">Beachten Sie, dass bei der ersten Zeichenfolge, die den bedingten Bindestrich gefolgt von einem "m" umfasst, die Methode den Index des bedingten Bindestrichs nicht zurückgeben kann, sondern stattdessen den Index des "m" zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2631">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</span></span>

 [!code-csharp[System.String.LastIndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof23.cs#23)]
 [!code-vb[System.String.LastIndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof23.vb#23)]



## Examples
 <span data-ttu-id="8b8da-2632">Im folgenden Beispiel wird der Index aller Vorkommen einer Zeichenfolge in der Teil Zeichenfolge gesucht, wobei vom Ende der Teil Zeichenfolge bis zum Anfang der Teil Zeichenfolge gearbeitet wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2632">The following example finds the index of all occurrences of a string in substring, working from the end of the substring to the start of the substring.</span></span>

 [!code-cpp[string.lastindexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf8/CPP/lastixof8.cpp#1)]
 [!code-csharp[string.lastindexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf8/CS/lastixof8.cs#1)]
 [!code-vb[string.lastindexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf8/VB/lastixof8.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-2633"><paramref name="value" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2633"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-2634"><paramref name="count" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2634"><paramref name="count" /> is negative.</span></span>

<span data-ttu-id="8b8da-2635">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-2635">-or-</span></span>

<span data-ttu-id="8b8da-2636">Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2636">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is negative.</span></span>

<span data-ttu-id="8b8da-2637">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-2637">-or-</span></span>

<span data-ttu-id="8b8da-2638">Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist größer als die Länge dieser Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2638">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is greater than the length of this instance.</span></span>

<span data-ttu-id="8b8da-2639">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-2639">-or-</span></span>

<span data-ttu-id="8b8da-2640">Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> - <paramref name="count" />+ 1 gibt eine Position an, die nicht innerhalb dieser Instanz liegt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2640">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> - <paramref name="count" />+ 1 specifies a position that is not within this instance.</span></span>

<span data-ttu-id="8b8da-2641">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-2641">-or-</span></span>

<span data-ttu-id="8b8da-2642">Die aktuelle Instanz entspricht <see cref="F:System.String.Empty" />, und <paramref name="start" /> ist kleiner als -1 oder größer als 0 (null).</span><span class="sxs-lookup"><span data-stu-id="8b8da-2642">The current instance equals <see cref="F:System.String.Empty" /> and <paramref name="start" /> is less than -1 or greater than zero.</span></span>

<span data-ttu-id="8b8da-2643">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-2643">-or-</span></span>

<span data-ttu-id="8b8da-2644">Die aktuelle Instanz entspricht <see cref="F:System.String.Empty" />, und <paramref name="count" /> ist größer als 1.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2644">The current instance equals <see cref="F:System.String.Empty" /> and <paramref name="count" /> is greater than 1.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-2645">Wie in [bewährte Methoden für die Verwendung von](~/docs/standard/base-types/best-practices-strings.md)Zeichen folgen erläutert, empfiehlt es sich, den Aufruf von Zeichen folgen Vergleichsmethoden zu vermeiden, die Standardwerte ersetzen, und stattdessen Methoden aufzurufen, für die Parameter explizit angegeben werden müssen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2645">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="8b8da-2646">Um diesen Vorgang mithilfe der Vergleichs Regeln der aktuellen Kultur auszuführen, müssen Sie die <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />-Methoden Überladung mit dem Wert <see cref="F:System.StringComparison.CurrentCulture" /> für den <paramref name="comparisonType" />-Parameter aufrufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2646">To perform this operation by using the comparison rules of the current culture, call the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-2647">Die zu suchende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2647">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="8b8da-2648">Die Anfangsposition der Suche.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2648">The search starting position.</span></span> <span data-ttu-id="8b8da-2649">Die Suche wird von <paramref name="startIndex" /> bis zum Anfang dieser Instanz fortgesetzt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2649">The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="8b8da-2650">Einer der Enumerationswerte, der die Regeln für die Suche angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2650">One of the enumeration values that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="8b8da-2651">Gibt den NULL-basierten Index des letzten Vorkommens einer angegebenen Zeichenfolge im aktuellen <see cref="T:System.String" />-Objekt an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2651">Reports the zero-based index of the last occurrence of a specified string within the current <see cref="T:System.String" /> object.</span></span> <span data-ttu-id="8b8da-2652">Die Suche beginnt an einer angegebenen Zeichenposition und wird rückwärts bis zum Anfang der Zeichenfolge fortgesetzt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2652">The search starts at a specified character position and proceeds backward toward the beginning of the string.</span></span> <span data-ttu-id="8b8da-2653">Ein Parameter gibt den Typ des bei der Suche nach der angegebenen Zeichenfolge auszuführenden Vergleichs an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2653">A parameter specifies the type of comparison to perform when searching for the specified string.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2654">Die nullbasierte Anfangsindexposition des <paramref name="value" />-Parameters, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde oder die aktuelle Instanz gleich <see cref="F:System.String.Empty" /> ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2654">The zero-based starting index position of the <paramref name="value" /> parameter if that string is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="8b8da-2655">Wenn <paramref name="value" /><see cref="F:System.String.Empty" /> ist, ist der Rückgabewert der kleinere <paramref name="startIndex" /> und die letzte Indexposition in dieser Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2655">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the smaller of <paramref name="startIndex" /> and the last index position in this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2656">Die Index Nummerierung beginnt bei Null.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2656">Index numbering starts from zero.</span></span> <span data-ttu-id="8b8da-2657">Das heißt, das erste Zeichen in der Zeichenfolge hat den Index 0 und das letzte den Wert <xref:System.String.Length%2A>-1.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2657">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>

 <span data-ttu-id="8b8da-2658">Die Suche beginnt an der `startIndex` Zeichenposition und wird rückwärts verlaufen, bis entweder `value` gefunden wird oder die erste Zeichenposition untersucht wurde.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2658">The search begins at the `startIndex` character position and proceeds backward until either `value` is found or the first character position has been examined.</span></span> <span data-ttu-id="8b8da-2659">Wenn `startIndex` z. b. <xref:System.String.Length%2A>-1 ist, durchsucht die-Methode jedes Zeichen vom letzten Zeichen in der Zeichenfolge bis zum Anfang.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2659">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches every character from the last character in the string to the beginning.</span></span>

 <span data-ttu-id="8b8da-2660">Der `comparisonType`-Parameter gibt an, dass mithilfe der aktuellen oder der invarianten Kultur nach dem `value` Parameter gesucht werden soll. dabei wird die Groß-/Kleinschreibung beachtet oder die Suche ohne Beachtung der Groß-/Kleinschreibung unterschieden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2660">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>



## Examples
 <span data-ttu-id="8b8da-2661">Im folgenden Beispiel werden drei über Ladungen der <xref:System.String.LastIndexOf%2A>-Methode veranschaulicht, die das letzte Vorkommen einer Zeichenfolge in einer anderen Zeichenfolge mithilfe verschiedener Werte der <xref:System.StringComparison> Enumeration suchen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2661">The following example demonstrates three overloads of the <xref:System.String.LastIndexOf%2A> method that find the last occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>

 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-2662"><paramref name="value" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2662"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-2663">Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist kleiner als 0 (null) oder größer als die Länge der aktuellen Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2663">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than zero or greater than the length of the current instance.</span></span>

<span data-ttu-id="8b8da-2664">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-2664">-or-</span></span>

<span data-ttu-id="8b8da-2665">Die aktuelle Instanz entspricht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist kleiner als -1 oder größer als 0 (null).</span><span class="sxs-lookup"><span data-stu-id="8b8da-2665">The current instance equals <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than -1 or greater than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8b8da-2666"><paramref name="comparisonType" /> ist kein gültiger <see cref="T:System.StringComparison" />-Wert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2666"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-2667">Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2667">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="8b8da-2668">Bei einer kulturabhängige Suche (das heißt, wenn <paramref name="comparisonType" /> nicht <see cref="F:System.StringComparison.Ordinal" /> oder <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> ist), bei der <paramref name="value" /> ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2668">In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="8b8da-2669">Wenn <paramref name="value" /> nur aus mindestens einem ignorierbaren Zeichen besteht, gibt die <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />-Methode immer <paramref name="startIndex" />zurück. Dies ist die Zeichenposition, an der die Suche beginnt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2669">If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> method always returns <paramref name="startIndex" />, which is the character position at which the search begins.</span></span>

<span data-ttu-id="8b8da-2670">Im folgenden Beispiel wird die <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />-Methode verwendet, um die Position eines Soft Bindestrichs (U + 00ad), gefolgt von einem "m", zu suchen, beginnend mit dem abschließenden "m" in zwei Zeichen folgen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2670">In the following example, the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> method is used to find the position of a soft hyphen (U+00AD) followed by an "m", starting with the final "m" in two strings.</span></span> <span data-ttu-id="8b8da-2671">Nur eine der Zeichenfolgen enthält die erforderliche Teilzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2671">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="8b8da-2672">Wenn das Beispiel in der [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder später ausgeführt wird, da der weiche Bindestrich ein ignorierbares Zeichen ist, gibt die Methode den Index von "m" in der Zeichenfolge zurück, wenn Sie einen Kultur abhängigen Vergleich durchführt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2672">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="8b8da-2673">Beachten Sie, dass bei der ersten Zeichenfolge, die den bedingten Bindestrich gefolgt von einem "m" umfasst, die Methode den Index des bedingten Bindestrichs nicht zurückgeben kann, sondern stattdessen den Index des "m" zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2673">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</span></span> <span data-ttu-id="8b8da-2674">Die Methode gibt den Index des bedingten Bindestrichs in der ersten Zeichenfolge nur dann zurück, wenn sie einen Ordinalvergleich ausführt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2674">The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</span></span>

<span data-ttu-id="8b8da-2675">[! Code-csharp[System. String. LastIndexOf # 25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof25.cs#25)] [! Code-vb[System. String. LastIndexOf # 25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof25.vb#25)]</span><span class="sxs-lookup"><span data-stu-id="8b8da-2675">[!code-csharp[System.String.LastIndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof25.cs#25)] [!code-vb[System.String.LastIndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof25.vb#25)]</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-2676">Die zu suchende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2676">The string to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="8b8da-2677">Die Anfangsposition der Suche.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2677">The search starting position.</span></span> <span data-ttu-id="8b8da-2678">Die Suche wird von <paramref name="startIndex" /> bis zum Anfang dieser Instanz fortgesetzt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2678">The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</span></span></param>
        <param name="count"><span data-ttu-id="8b8da-2679">Die Anzahl der zu überprüfenden Zeichenpositionen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2679">The number of character positions to examine.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="8b8da-2680">Einer der Enumerationswerte, der die Regeln für die Suche angibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2680">One of the enumeration values that specifies the rules for the search.</span></span></param>
        <summary><span data-ttu-id="8b8da-2681">Gibt die NULL-basierte Indexposition des letzten Vorkommens einer angegebenen Zeichenfolge in dieser Instanz an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2681">Reports the zero-based index position of the last occurrence of a specified string within this instance.</span></span> <span data-ttu-id="8b8da-2682">Die Suche beginnt an einer angegebenen Zeichenposition und verläuft für eine angegebene Anzahl von Zeichenpositionen rückwärts zum Anfang der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2682">The search starts at a specified character position and proceeds backward toward the beginning of the string for the specified number of character positions.</span></span> <span data-ttu-id="8b8da-2683">Ein Parameter gibt den Typ des bei der Suche nach der angegebenen Zeichenfolge auszuführenden Vergleichs an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2683">A parameter specifies the type of comparison to perform when searching for the specified string.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2684">Die nullbasierte Anfangsindexposition des <paramref name="value" />-Parameters, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde oder die aktuelle Instanz gleich <see cref="F:System.String.Empty" /> ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2684">The zero-based starting index position of the <paramref name="value" /> parameter if that string is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="8b8da-2685">Wenn <paramref name="value" /><see cref="F:System.String.Empty" /> ist, ist der Rückgabewert der kleinere <paramref name="startIndex" /> und die letzte Indexposition in dieser Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2685">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the smaller of <paramref name="startIndex" /> and the last index position in this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2686">Die Index Nummerierung beginnt bei Null.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2686">Index numbering starts from zero.</span></span> <span data-ttu-id="8b8da-2687">Das heißt, das erste Zeichen in der Zeichenfolge hat den Index 0 und das letzte den Wert <xref:System.String.Length%2A>-1.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2687">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>

 <span data-ttu-id="8b8da-2688">Die Suche beginnt an der `startIndex` Zeichenposition und wird rückwärts verlaufen, bis entweder `value` gefunden wird oder `count` Zeichen Positionen überprüft wurden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2688">The search begins at the `startIndex` character position and proceeds backward until either `value` is found or `count` character positions have been examined.</span></span> <span data-ttu-id="8b8da-2689">Wenn `startIndex` z. b. <xref:System.String.Length%2A>-1 ist, sucht die Methode rückwärts `count` Zeichen aus dem letzten Zeichen in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2689">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches backward `count` characters from the last character in the string.</span></span>

 <span data-ttu-id="8b8da-2690">Der `comparisonType`-Parameter gibt an, dass mithilfe der aktuellen oder der invarianten Kultur nach dem `value` Parameter gesucht werden soll. dabei wird die Groß-/Kleinschreibung beachtet oder die Suche ohne Beachtung der Groß-/Kleinschreibung unterschieden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2690">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>



## Examples
 <span data-ttu-id="8b8da-2691">Im folgenden Beispiel werden drei über Ladungen der <xref:System.String.LastIndexOf%2A>-Methode veranschaulicht, die das letzte Vorkommen einer Zeichenfolge in einer anderen Zeichenfolge mithilfe verschiedener Werte der <xref:System.StringComparison> Enumeration suchen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2691">The following example demonstrates three overloads of the <xref:System.String.LastIndexOf%2A> method that find the last occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>

 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-2692"><paramref name="value" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2692"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-2693"><paramref name="count" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2693"><paramref name="count" /> is negative.</span></span>

<span data-ttu-id="8b8da-2694">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-2694">-or-</span></span>

<span data-ttu-id="8b8da-2695">Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2695">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is negative.</span></span>

<span data-ttu-id="8b8da-2696">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-2696">-or-</span></span>

<span data-ttu-id="8b8da-2697">Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist größer als die Länge dieser Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2697">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is greater than the length of this instance.</span></span>

<span data-ttu-id="8b8da-2698">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-2698">-or-</span></span>

<span data-ttu-id="8b8da-2699">Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> + 1 - <paramref name="count" /> gibt eine Position an, die nicht innerhalb dieser Instanz liegt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2699">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> + 1 - <paramref name="count" /> specifies a position that is not within this instance.</span></span>

<span data-ttu-id="8b8da-2700">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-2700">-or-</span></span>

<span data-ttu-id="8b8da-2701">Die aktuelle Instanz entspricht <see cref="F:System.String.Empty" />, und <paramref name="start" /> ist kleiner als -1 oder größer als 0 (null).</span><span class="sxs-lookup"><span data-stu-id="8b8da-2701">The current instance equals <see cref="F:System.String.Empty" /> and <paramref name="start" /> is less than -1 or greater than zero.</span></span>

<span data-ttu-id="8b8da-2702">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-2702">-or-</span></span>

<span data-ttu-id="8b8da-2703">Die aktuelle Instanz entspricht <see cref="F:System.String.Empty" />, und <paramref name="count" /> ist größer als 1.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2703">The current instance equals <see cref="F:System.String.Empty" /> and <paramref name="count" /> is greater than 1.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8b8da-2704"><paramref name="comparisonType" /> ist kein gültiger <see cref="T:System.StringComparison" />-Wert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2704"><paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-2705">Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2705">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="8b8da-2706">Bei einer kulturabhängige Suche (das heißt, wenn <paramref name="comparisonType" /> nicht <see cref="F:System.StringComparison.Ordinal" /> oder <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> ist), bei der <paramref name="value" /> ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2706">In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="8b8da-2707">Wenn <paramref name="value" /> nur aus mindestens einem ignorierbaren Zeichen besteht, gibt die <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />-Methode immer <paramref name="startIndex" />zurück. Dies ist die Zeichenposition, an der die Suche beginnt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2707">If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method always returns <paramref name="startIndex" />, which is the character position at which the search begins.</span></span>

<span data-ttu-id="8b8da-2708">Im folgenden Beispiel wird die <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />-Methode verwendet, um die Position eines Soft-Bindestrichs (U + 00ad), gefolgt von einem "m", in der gesamten außer der ersten Zeichenposition vor dem abschließenden "m" in zwei Zeichen folgen zu suchen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2708">In the following example, the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" in all but the first character position before the final "m" in two strings.</span></span> <span data-ttu-id="8b8da-2709">Nur eine der Zeichenfolgen enthält die erforderliche Teilzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2709">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="8b8da-2710">Wenn das Beispiel in der [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder später ausgeführt wird, da der weiche Bindestrich ein ignorierbares Zeichen ist, gibt die Methode den Index von "m" in der Zeichenfolge zurück, wenn Sie einen Kultur abhängigen Vergleich durchführt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2710">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="8b8da-2711">Wenn ein Ordinalvergleich durchführt, wird die Teil Zeichenfolge jedoch nur in der ersten Zeichenfolge gefunden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2711">When it performs an ordinal comparison, however, it finds the substring only in the first string.</span></span> <span data-ttu-id="8b8da-2712">Beachten Sie, dass bei der ersten Zeichenfolge, die den weichen Bindestrich, gefolgt von einem "m", die Methode nicht den Index des weichen Bindestrichs zurückgibt, sondern den Index des "m" zurückgibt, wenn ein Kultur abhängiger Vergleich durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2712">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m" when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="8b8da-2713">Die Methode gibt den Index des bedingten Bindestrichs in der ersten Zeichenfolge nur dann zurück, wenn sie einen Ordinalvergleich ausführt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2713">The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</span></span>

<span data-ttu-id="8b8da-2714">[! Code-csharp[System. String. LastIndexOf # 24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof24.cs#24)] [! Code-vb[System. String. LastIndexOf # 24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof24.vb#24)]</span><span class="sxs-lookup"><span data-stu-id="8b8da-2714">[!code-csharp[System.String.LastIndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof24.cs#24)] [!code-vb[System.String.LastIndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof24.vb#24)]</span></span></para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8b8da-2715">Gibt die NULL-basierte Indexposition des letzten Vorkommens eines oder mehrerer angegebener Zeichen eines Unicode-Arrays in dieser Instanz an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2715">Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</span></span> <span data-ttu-id="8b8da-2716">Die Methode gibt -1 zurück, wenn die Zeichen im Array nicht in dieser Instanz gefunden werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2716">The method returns -1 if the characters in the array are not found in this instance.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] -&gt; int" Usage="string.LastIndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf"><span data-ttu-id="8b8da-2717">Ein Array von Unicode-Zeichen mit mindestens einem zu suchenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2717">A Unicode character array containing one or more characters to seek.</span></span></param>
        <summary><span data-ttu-id="8b8da-2718">Gibt die NULL-basierte Indexposition des letzten Vorkommens eines oder mehrerer angegebener Zeichen eines Unicode-Arrays in dieser Instanz an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2718">Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2719">Die Indexposition des letzten Vorkommens eines beliebigen Zeichens aus <paramref name="anyOf" /> in dieser Instanz. -1, wenn kein Zeichen in <paramref name="anyOf" /> gefunden wurde.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2719">The index position of the last occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2720">Die Index Nummerierung beginnt bei Null.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2720">Index numbering starts from zero.</span></span>

 <span data-ttu-id="8b8da-2721">Diese Methode beginnt mit der Suche an der letzten Zeichenposition dieser Instanz und verläuft rückwärts zum Anfang, bis entweder ein Zeichen in `anyOf` gefunden wird oder die erste Zeichenposition untersucht wurde.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2721">This method begins searching at the last character position of this instance and proceeds backward toward the beginning until either a character in `anyOf` is found or the first character position has been examined.</span></span> <span data-ttu-id="8b8da-2722">Bei der Suche wird die Groß- und Kleinschreibung berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2722">The search is case-sensitive.</span></span>

 <span data-ttu-id="8b8da-2723">Diese Methode führt eine ordnungsgemäß (Kultur unabhängige) Suche aus, bei der ein Zeichen als äquivalent zu einem anderen Zeichen gilt, wenn Ihre Unicode-Skalarwerte identisch sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2723">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="8b8da-2724">So führen Sie eine Kultur abhängige Suche durch Verwenden Sie die <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>-Methode, bei der ein Unicode-Skalarwert, der ein vorzusammen gesetztes Zeichen darstellt, wie z. b. die Ligaturen "Æ" (u + 00c6), in Abhängigkeit von der Kultur als äquivalent zu jedem Vorkommen der Komponenten des Zeichens in der richtigen Reihenfolge betrachtet werden kann.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2724">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>



## Examples
 <span data-ttu-id="8b8da-2725">Im folgenden Beispiel wird der Index des letzten Vorkommens eines beliebigen Zeichens in der Zeichenfolge "is" in einer anderen Zeichenfolge gefunden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2725">The following example finds the index of the last occurrence of any character in the string "is" within another string.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny1/CPP/lastixany1.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny1/CS/lastixany1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny1/VB/lastixany1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-2726"><paramref name="anyOf" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2726"><paramref name="anyOf" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf"><span data-ttu-id="8b8da-2727">Ein Array von Unicode-Zeichen mit mindestens einem zu suchenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2727">A Unicode character array containing one or more characters to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="8b8da-2728">Die Anfangsposition der Suche.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2728">The search starting position.</span></span> <span data-ttu-id="8b8da-2729">Die Suche wird von <paramref name="startIndex" /> bis zum Anfang dieser Instanz fortgesetzt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2729">The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</span></span></param>
        <summary><span data-ttu-id="8b8da-2730">Gibt die NULL-basierte Indexposition des letzten Vorkommens eines oder mehrerer angegebener Zeichen eines Unicode-Arrays in dieser Instanz an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2730">Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</span></span> <span data-ttu-id="8b8da-2731">Die Suche beginnt an einer angegebenen Zeichenposition und wird rückwärts bis zum Anfang der Zeichenfolge fortgesetzt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2731">The search starts at a specified character position and proceeds backward toward the beginning of the string.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2732">Die Indexposition des letzten Vorkommens eines beliebigen Zeichens aus <paramref name="anyOf" /> in dieser Instanz. -1, wenn kein Zeichen in <paramref name="anyOf" /> gefunden wurde, oder wenn die aktuelle Instanz gleich <see cref="F:System.String.Empty" /> ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2732">The index position of the last occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2733">Die Index Nummerierung beginnt bei Null.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2733">Index numbering starts from zero.</span></span>

 <span data-ttu-id="8b8da-2734">Diese Methode beginnt mit der Suche an der `startIndex` Zeichenposition dieser Instanz und verläuft rückwärts zum Anfang, bis entweder ein Zeichen in `anyOf` gefunden wird oder die erste Zeichenposition überprüft wurde.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2734">This method begins searching at the `startIndex` character position of this instance and proceeds backward toward the beginning until either a character in `anyOf` is found or the first character position has been examined.</span></span> <span data-ttu-id="8b8da-2735">Bei der Suche wird die Groß- und Kleinschreibung berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2735">The search is case-sensitive.</span></span>

 <span data-ttu-id="8b8da-2736">Diese Methode führt eine ordnungsgemäß (Kultur unabhängige) Suche aus, bei der ein Zeichen als äquivalent zu einem anderen Zeichen gilt, wenn Ihre Unicode-Skalarwerte identisch sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2736">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="8b8da-2737">So führen Sie eine Kultur abhängige Suche durch Verwenden Sie die <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>-Methode, bei der ein Unicode-Skalarwert, der ein vorzusammen gesetztes Zeichen darstellt, wie z. b. die Ligaturen "Æ" (u + 00c6), in Abhängigkeit von der Kultur als äquivalent zu jedem Vorkommen der Komponenten des Zeichens in der richtigen Reihenfolge betrachtet werden kann.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2737">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>



## Examples
 <span data-ttu-id="8b8da-2738">Im folgenden Beispiel wird der Index des letzten Vorkommens eines beliebigen Zeichens in der Zeichenfolge "is" in einer Teil Zeichenfolge einer anderen Zeichenfolge gefunden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2738">The following example finds the index of the last occurrence of any character in the string "is" within a substring of another string.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny2/CPP/lastixany2.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny2/CS/lastixany2.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny2/VB/lastixany2.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-2739"><paramref name="anyOf" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2739"><paramref name="anyOf" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-2740">Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> gibt eine Position an, die nicht innerhalb dieser Instanz liegt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2740">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> specifies a position that is not within this instance.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf"><span data-ttu-id="8b8da-2741">Ein Array von Unicode-Zeichen mit mindestens einem zu suchenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2741">A Unicode character array containing one or more characters to seek.</span></span></param>
        <param name="startIndex"><span data-ttu-id="8b8da-2742">Die Anfangsposition der Suche.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2742">The search starting position.</span></span> <span data-ttu-id="8b8da-2743">Die Suche wird von <paramref name="startIndex" /> bis zum Anfang dieser Instanz fortgesetzt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2743">The search proceeds from <paramref name="startIndex" /> toward the beginning of this instance.</span></span></param>
        <param name="count"><span data-ttu-id="8b8da-2744">Die Anzahl der zu überprüfenden Zeichenpositionen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2744">The number of character positions to examine.</span></span></param>
        <summary><span data-ttu-id="8b8da-2745">Gibt die NULL-basierte Indexposition des letzten Vorkommens eines oder mehrerer angegebener Zeichen eines Unicode-Arrays in dieser Instanz an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2745">Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</span></span> <span data-ttu-id="8b8da-2746">Die Suche beginnt an einer angegebenen Zeichenposition und verläuft für eine angegebene Anzahl von Zeichenpositionen rückwärts zum Anfang der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2746">The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2747">Die Indexposition des letzten Vorkommens eines beliebigen Zeichens aus <paramref name="anyOf" /> in dieser Instanz. -1, wenn kein Zeichen in <paramref name="anyOf" /> gefunden wurde, oder wenn die aktuelle Instanz gleich <see cref="F:System.String.Empty" /> ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2747">The index position of the last occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found or if the current instance equals <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2748">Die Index Nummerierung beginnt bei Null.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2748">Index numbering starts from zero.</span></span>

 <span data-ttu-id="8b8da-2749">Diese Methode beginnt mit der Suche an der `startIndex` Zeichenposition dieser Instanz und verläuft rückwärts zum Anfang, bis entweder ein Zeichen in `anyOf` gefunden wird oder `count` Zeichen Positionen überprüft wurden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2749">This method begins searching at the `startIndex` character position of this instance and proceeds backward toward the beginning until either a character in `anyOf` is found or `count` character positions have been examined.</span></span> <span data-ttu-id="8b8da-2750">Bei der Suche wird die Groß- und Kleinschreibung berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2750">The search is case-sensitive.</span></span>

 <span data-ttu-id="8b8da-2751">Diese Methode führt eine ordnungsgemäß (Kultur unabhängige) Suche aus, bei der ein Zeichen als äquivalent zu einem anderen Zeichen gilt, wenn Ihre Unicode-Skalarwerte identisch sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2751">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="8b8da-2752">So führen Sie eine Kultur abhängige Suche durch Verwenden Sie die <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>-Methode, bei der ein Unicode-Skalarwert, der ein vorzusammen gesetztes Zeichen darstellt, wie z. b. die Ligaturen "Æ" (u + 00c6), in Abhängigkeit von der Kultur als äquivalent zu jedem Vorkommen der Komponenten des Zeichens in der richtigen Reihenfolge betrachtet werden kann.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2752">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>



## Examples
 <span data-ttu-id="8b8da-2753">Im folgenden Beispiel wird der Index des letzten Vorkommens eines beliebigen Zeichens in der Zeichenfolge "Aid" in einer Teil Zeichenfolge einer anderen Zeichenfolge gesucht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2753">The following example finds the index of the last occurrence of any character in the string "aid" within a substring of another string.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny3/CPP/lastixany3.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny3/CS/lastixany3.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny3/VB/lastixany3.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-2754"><paramref name="anyOf" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2754"><paramref name="anyOf" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-2755">Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="count" /> oder <paramref name="startIndex" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2755">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="count" /> or <paramref name="startIndex" /> is negative.</span></span>

<span data-ttu-id="8b8da-2756">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-2756">-or-</span></span>

<span data-ttu-id="8b8da-2757">Die aktuelle Instanz ist nicht gleich <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> minus <paramref name="count" /> + 1 ist weniger als 0 (null).</span><span class="sxs-lookup"><span data-stu-id="8b8da-2757">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> minus <paramref name="count" /> + 1 is less than zero.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.String.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.string.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8b8da-2758">Ruft die Anzahl der Zeichen im aktuellen <see cref="T:System.String" />-Objekt ab.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2758">Gets the number of characters in the current <see cref="T:System.String" /> object.</span></span></summary>
        <value><span data-ttu-id="8b8da-2759">Die Anzahl der Zeichen in der aktuellen Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2759">The number of characters in the current string.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2760">Die <xref:System.String.Length%2A>-Eigenschaft gibt die Anzahl der <xref:System.Char> Objekte in dieser Instanz zurück, nicht die Anzahl der Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2760">The <xref:System.String.Length%2A> property returns the number of <xref:System.Char> objects in this instance, not the number of Unicode characters.</span></span> <span data-ttu-id="8b8da-2761">Der Grund hierfür ist, dass ein Unicode-Zeichen durch mehr als eine <xref:System.Char>dargestellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2761">The reason is that a Unicode character might be represented by more than one <xref:System.Char>.</span></span> <span data-ttu-id="8b8da-2762">Verwenden Sie die <xref:System.Globalization.StringInfo?displayProperty=nameWithType>-Klasse, um mit jedem Unicode-Zeichen anstelle der einzelnen <xref:System.Char>zu arbeiten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2762">Use the <xref:System.Globalization.StringInfo?displayProperty=nameWithType> class to work with each Unicode character instead of each <xref:System.Char>.</span></span>

 <span data-ttu-id="8b8da-2763">In einigen Sprachen, wie z. b C++. C und, gibt ein NULL-Zeichen das Ende einer Zeichenfolge an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2763">In some languages, such as C and C++, a null character indicates the end of a string.</span></span> <span data-ttu-id="8b8da-2764">In .net kann ein NULL-Zeichen in eine Zeichenfolge eingebettet werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2764">In .NET, a null character can be embedded in a string.</span></span> <span data-ttu-id="8b8da-2765">Wenn eine Zeichenfolge ein oder mehrere NULL Zeichen enthält, sind Sie in der Länge der gesamten Zeichenfolge enthalten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2765">When a string includes one or more null characters, they are included in the length of the total string.</span></span> <span data-ttu-id="8b8da-2766">In der folgenden Zeichenfolge werden z. b. die Teil Zeichenfolgen "ABC" und "Def" durch ein NULL-Zeichen voneinander getrennt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2766">For example, in the following string, the substrings "abc" and "def" are separated by a null character.</span></span> <span data-ttu-id="8b8da-2767">Die <xref:System.String.Length%2A>-Eigenschaft gibt 7 zurück, was darauf hinweist, dass Sie die sechs alphabetischen Zeichen sowie das NULL-Zeichen enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2767">The <xref:System.String.Length%2A> property returns 7, which indicates that it includes the six alphabetic characters as well as the null character.</span></span>

 [!code-cpp[System.String.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/system.string.class.cpp#1)]
 [!code-csharp-interactive[System.String.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/System.String.Class.cs#1)]
 [!code-vb[System.String.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/System.String.Class.vb#1)]



## Examples
 <span data-ttu-id="8b8da-2768">Im folgenden Beispiel wird die <xref:System.String.Length%2A>-Eigenschaft veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2768">The following example demonstrates the <xref:System.String.Length%2A> property.</span></span>

 [!code-cpp[string.length#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.length/CPP/length.cpp#1)]
 [!code-csharp-interactive[string.length#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.length/CS/length.cs#1)]
 [!code-vb[string.length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.length/VB/length.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Normalize">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8b8da-2769">Gibt eine neue Zeichenfolge zurück, deren binäre Darstellung in einer bestimmten Unicode-Normalisierungsform vorliegt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2769">Returns a new string whose binary representation is in a particular Unicode normalization form.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize" />
      <MemberSignature Language="VB.NET" Value="Public Function Normalize () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize();" />
      <MemberSignature Language="F#" Value="member this.Normalize : unit -&gt; string" Usage="string.Normalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8b8da-2770">Gibt eine neue Zeichenfolge zurück, deren Textwert mit dieser Zeichenfolge übereinstimmt, deren binäre Darstellung jedoch in der Unicode-Normalisierungsform C vorliegt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2770">Returns a new string whose textual value is the same as this string, but whose binary representation is in Unicode normalization form C.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2771">Eine neue normalisierte Zeichenfolge, deren Textwert mit dieser Zeichenfolge übereinstimmt, deren binäre Darstellung jedoch in der Normalisierungsform C vorliegt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2771">A new, normalized string whose textual value is the same as this string, but whose binary representation is in normalization form C.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2772">Einige Unicode-Zeichen verfügen über mehrere äquivalente binäre Darstellungen, die aus Mengen von Kombination aus und/oder zusammengesetzten Unicode-Zeichen bestehen</span><span class="sxs-lookup"><span data-stu-id="8b8da-2772">Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</span></span> <span data-ttu-id="8b8da-2773">Beispielsweise kann jeder der folgenden Code Punkte den Buchstaben "ắ" darstellen:</span><span class="sxs-lookup"><span data-stu-id="8b8da-2773">For example, any of the following code points can represent the letter "ắ":</span></span>

-   <span data-ttu-id="8b8da-2774">U + 1eaf</span><span class="sxs-lookup"><span data-stu-id="8b8da-2774">U+1EAF</span></span>

-   <span data-ttu-id="8b8da-2775">U+0103 U+0301</span><span class="sxs-lookup"><span data-stu-id="8b8da-2775">U+0103 U+0301</span></span>

-   <span data-ttu-id="8b8da-2776">U+0061 U+0306 U+0301</span><span class="sxs-lookup"><span data-stu-id="8b8da-2776">U+0061 U+0306 U+0301</span></span>

 <span data-ttu-id="8b8da-2777">Das vorhanden sein mehrerer Darstellungen für ein einzelnes Zeichen erschwert das suchen, sortieren, abgleichen und andere Vorgänge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2777">The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</span></span>

 <span data-ttu-id="8b8da-2778">Der Unicode-Standard definiert einen Prozess namens Normalisierung, der eine binäre Darstellung zurückgibt, wenn eine der äquivalenten binären Darstellungen eines Zeichens angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2778">The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</span></span> <span data-ttu-id="8b8da-2779">Die Normalisierung kann mit mehreren Algorithmen durchgeführt werden, die als normalisierungs Formulare bezeichnet werden, die unterschiedliche Regeln einhalten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2779">Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</span></span> <span data-ttu-id="8b8da-2780">.NET unterstützt die vier Normalisierungsformen (C, D, KC und KD), die durch den Unicode-Standard definiert werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2780">.NET supports the four normalization forms (C, D, KC, and KD) that are defined by the Unicode standard.</span></span> <span data-ttu-id="8b8da-2781">Wenn zwei Zeichen folgen in derselben normalisierungs Form dargestellt werden, können Sie mithilfe eines Ordinalvergleichs verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2781">When two strings are represented in the same normalization form, they can be compared by using ordinal comparison.</span></span>

 <span data-ttu-id="8b8da-2782">Gehen Sie folgendermaßen vor, um zwei Zeichen folgen zu normalisieren und zu vergleichen:</span><span class="sxs-lookup"><span data-stu-id="8b8da-2782">To normalize and compare two strings, do the following:</span></span>

1.  <span data-ttu-id="8b8da-2783">Abrufen der Zeichen folgen, die von einer Eingabe Quelle, z. b. einer Datei oder einem Benutzereingabe Gerät, verglichen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2783">Obtain the strings to be compared from an input source, such as a file or a user input device.</span></span>

2.  <span data-ttu-id="8b8da-2784">Ruft die <xref:System.String.Normalize>-Methode auf, um die Zeichen folgen in die normalisierungs Form C zu normalisieren.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2784">Call the <xref:System.String.Normalize> method to normalize the strings to normalization form C.</span></span>

3.  <span data-ttu-id="8b8da-2785">Um zwei Zeichen folgen zu vergleichen, müssen Sie eine Methode, die einen Ordinalzeichenfolgenvergleich unterstützt, wie z. b. die <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>-Methode, und den Wert <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> oder <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> als <xref:System.StringComparison> Argument angeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2785">To compare two strings, call a method that supports ordinal string comparison, such as the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, and supply a value of <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> as the <xref:System.StringComparison> argument.</span></span> <span data-ttu-id="8b8da-2786">Um ein Array mit normalisierten Zeichen folgen zu sortieren, übergeben Sie einen `comparer` Wert <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> oder <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> an eine entsprechende Überladung <xref:System.Array.Sort%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2786">To sort an array of normalized strings, pass a `comparer` value of <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> or <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> to an appropriate overload of <xref:System.Array.Sort%2A?displayProperty=nameWithType>.</span></span>

4.  <span data-ttu-id="8b8da-2787">Geben Sie die Zeichen folgen in der sortierten Ausgabe basierend auf der im vorherigen Schritt angegebenen Reihenfolge aus.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2787">Emit the strings in the sorted output based on the order indicated by the previous step.</span></span>

 <span data-ttu-id="8b8da-2788">Eine Beschreibung der unterstützten Unicode-Normalisierungsformen finden Sie unter <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2788">For a description of supported Unicode normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span></span>



## Examples
 <span data-ttu-id="8b8da-2789">Im folgenden Beispiel wird eine Zeichenfolge in jede von vier normalisierungs Formularen normalisiert, bestätigt, dass die Zeichenfolge in die angegebene normalisierungs Form normalisiert wurde, und listet dann die Code Punkte in der normalisierten Zeichenfolge auf.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2789">The following example normalizes a string to each of four normalization forms, confirms the string was normalized to the specified normalization form, then lists the code points in the normalized string.</span></span>

 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8b8da-2790">Die aktuelle Instanz enthält ungültige Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2790">The current instance contains invalid Unicode characters.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-2791">Die <see cref="Overload:System.String.IsNormalized" />-Methode gibt <see langword="false" /> zurück, sobald das erste nicht normalisierte Zeichen in einer Zeichenfolge gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2791">The <see cref="Overload:System.String.IsNormalized" /> method returns <see langword="false" /> as soon as it encounters the first non-normalized character in a string.</span></span> <span data-ttu-id="8b8da-2792">Wenn eine Zeichenfolge nicht normalisierte Zeichen gefolgt von ungültigen Unicode-Zeichen enthält, löst die <see cref="Overload:System.String.Normalize" /> Methode daher eine <see cref="T:System.ArgumentException" /> aus, obwohl <see cref="Overload:System.String.IsNormalized" /> <see langword="false" />zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2792">Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <see cref="Overload:System.String.Normalize" /> method will throw an <see cref="T:System.ArgumentException" /> although <see cref="Overload:System.String.IsNormalized" /> returns <see langword="false" />.</span></span></para></block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize(System.Text.NormalizationForm)" />
      <MemberSignature Language="VB.NET" Value="Public Function Normalize (normalizationForm As NormalizationForm) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.Normalize : System.Text.NormalizationForm -&gt; string" Usage="string.Normalize normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="normalizationForm"><span data-ttu-id="8b8da-2793">Eine Unicode-Normalisierungsform.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2793">A Unicode normalization form.</span></span></param>
        <summary><span data-ttu-id="8b8da-2794">Gibt eine neue Zeichenfolge zurück, deren Textwert mit dieser Zeichenfolge übereinstimmt, deren binäre Darstellung jedoch in der angegebenen Unicode-Normalisierungsform vorliegt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2794">Returns a new string whose textual value is the same as this string, but whose binary representation is in the specified Unicode normalization form.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2795">Eine neue Zeichenfolge, deren Textwert mit dieser Zeichenfolge übereinstimmt, deren binäre Darstellung jedoch in der im <paramref name="normalizationForm" />-Parameter angegebenen Normalisierungsform vorliegt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2795">A new string whose textual value is the same as this string, but whose binary representation is in the normalization form specified by the <paramref name="normalizationForm" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2796">Einige Unicode-Zeichen verfügen über mehrere äquivalente binäre Darstellungen, die aus Mengen von Kombination aus und/oder zusammengesetzten Unicode-Zeichen bestehen</span><span class="sxs-lookup"><span data-stu-id="8b8da-2796">Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</span></span> <span data-ttu-id="8b8da-2797">Das vorhanden sein mehrerer Darstellungen für ein einzelnes Zeichen erschwert das suchen, sortieren, abgleichen und andere Vorgänge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2797">The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</span></span>

 <span data-ttu-id="8b8da-2798">Der Unicode-Standard definiert einen Prozess namens Normalisierung, der eine binäre Darstellung zurückgibt, wenn eine der äquivalenten binären Darstellungen eines Zeichens angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2798">The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</span></span> <span data-ttu-id="8b8da-2799">Die Normalisierung kann mit mehreren Algorithmen durchgeführt werden, die als normalisierungs Formulare bezeichnet werden, die unterschiedliche Regeln einhalten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2799">Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</span></span> <span data-ttu-id="8b8da-2800">.NET unterstützt die vier Normalisierungsformen (C, D, KC und KD), die durch den Unicode-Standard definiert werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2800">.NET supports the four normalization forms (C, D, KC, and KD) that are defined by the Unicode standard.</span></span> <span data-ttu-id="8b8da-2801">Wenn zwei Zeichen folgen in derselben normalisierungs Form dargestellt werden, können Sie mithilfe eines Ordinalvergleichs verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2801">When two strings are represented in the same normalization form, they can be compared by using ordinal comparison.</span></span>

 <span data-ttu-id="8b8da-2802">Gehen Sie folgendermaßen vor, um zwei Zeichen folgen zu normalisieren und zu vergleichen:</span><span class="sxs-lookup"><span data-stu-id="8b8da-2802">To normalize and compare two strings, do the following:</span></span>

1.  <span data-ttu-id="8b8da-2803">Abrufen der Zeichen folgen, die von einer Eingabe Quelle, z. b. einer Datei oder einem Benutzereingabe Gerät, verglichen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2803">Obtain the strings to be compared from an input source, such as a file or a user input device.</span></span>

2.  <span data-ttu-id="8b8da-2804">Ruft die <xref:System.String.Normalize%28System.Text.NormalizationForm%29>-Methode auf, um die Zeichen folgen in eine angegebene normalisierungs Form zu normalisieren.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2804">Call the <xref:System.String.Normalize%28System.Text.NormalizationForm%29> method to normalize the strings to a specified normalization form.</span></span>

3.  <span data-ttu-id="8b8da-2805">Um zwei Zeichen folgen zu vergleichen, müssen Sie eine Methode, die einen Ordinalzeichenfolgenvergleich unterstützt, wie z. b. die <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29>-Methode, und den Wert <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> oder <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> als <xref:System.StringComparison> Argument angeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2805">To compare two strings, call a method that supports ordinal string comparison, such as the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, and supply a value of <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> as the <xref:System.StringComparison> argument.</span></span> <span data-ttu-id="8b8da-2806">Um ein Array mit normalisierten Zeichen folgen zu sortieren, übergeben Sie einen `comparer` Wert <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> oder <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> an eine entsprechende Überladung <xref:System.Array.Sort%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2806">To sort an array of normalized strings, pass a `comparer` value of <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> or <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> to an appropriate overload of <xref:System.Array.Sort%2A?displayProperty=nameWithType>.</span></span>

4.  <span data-ttu-id="8b8da-2807">Geben Sie die Zeichen folgen in der sortierten Ausgabe basierend auf der im vorherigen Schritt angegebenen Reihenfolge aus.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2807">Emit the strings in the sorted output based on the order indicated by the previous step.</span></span>

 <span data-ttu-id="8b8da-2808">Eine Beschreibung der unterstützten Unicode-Normalisierungsformen finden Sie unter <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2808">For a description of supported Unicode normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span></span>



## Examples
 <span data-ttu-id="8b8da-2809">Im folgenden Beispiel wird eine Zeichenfolge in jede von vier normalisierungs Formularen normalisiert, bestätigt, dass die Zeichenfolge in die angegebene normalisierungs Form normalisiert wurde, und listet dann die Code Punkte in der normalisierten Zeichenfolge auf.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2809">The following example normalizes a string to each of four normalization forms, confirms the string was normalized to the specified normalization form, then lists the code points in the normalized string.</span></span>

 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8b8da-2810">Die aktuelle Instanz enthält ungültige Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2810">The current instance contains invalid Unicode characters.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-2811">Die <see cref="Overload:System.String.IsNormalized" />-Methode gibt <see langword="false" /> zurück, sobald das erste nicht normalisierte Zeichen in einer Zeichenfolge gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2811">The <see cref="Overload:System.String.IsNormalized" /> method returns <see langword="false" /> as soon as it encounters the first non-normalized character in a string.</span></span> <span data-ttu-id="8b8da-2812">Wenn eine Zeichenfolge nicht normalisierte Zeichen gefolgt von ungültigen Unicode-Zeichen enthält, kann die <see cref="Overload:System.String.Normalize" /> Methode daher eine <see cref="T:System.ArgumentException" /> auslösen, obwohl <see cref="Overload:System.String.IsNormalized" /> <see langword="false" />zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2812">Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <see cref="Overload:System.String.Normalize" /> method may throw an <see cref="T:System.ArgumentException" /> although <see cref="Overload:System.String.IsNormalized" /> returns <see langword="false" />.</span></span></para></block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Equality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member ( = ) : string * string -&gt; bool" Usage="a = b" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="8b8da-2813">Die erste Zeichenfolge für den Vergleich oder <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2813">The first string to compare, or <see langword="null" />.</span></span></param>
        <param name="b"><span data-ttu-id="8b8da-2814">Die zweite Zeichenfolge für den Vergleich oder <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2814">The second string to compare, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="8b8da-2815">Bestimmt, ob zwei angegebene Zeichenfolgen denselben Wert haben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2815">Determines whether two specified strings have the same value.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2816"><see langword="true" />, wenn <paramref name="a" /> und <paramref name="b" /> denselben Wert haben, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2816"><see langword="true" /> if the value of <paramref name="a" /> is the same as the value of <paramref name="b" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2817">Die <xref:System.String.op_Equality%2A>-Methode definiert den Vorgang des Gleichheits Operators für die <xref:System.String>-Klasse.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2817">The <xref:System.String.op_Equality%2A> method defines the operation of the equality operator for the <xref:System.String> class.</span></span> <span data-ttu-id="8b8da-2818">Dadurch wird Code wie im Beispiel Abschnitt angezeigt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2818">It enables code such as that shown in the Example section.</span></span> <span data-ttu-id="8b8da-2819">Der Operator ruft wiederum die statische <xref:System.String.Equals%28System.String%2CSystem.String%29>-Methode auf, die einen Ordinalvergleich (Groß-/Kleinschreibung und Kultur unabhängige) ausführt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2819">The operator, in turn, calls the static <xref:System.String.Equals%28System.String%2CSystem.String%29> method, which performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span>

> [!NOTE]
>  <span data-ttu-id="8b8da-2820">Der Visual Basic-Compiler löst den Gleichheits Operator nicht als einen aufzurufenden <xref:System.String.op_Equality%2A> Methode auf.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2820">The Visual Basic compiler does not resolve the equality operator as a call to the <xref:System.String.op_Equality%2A> method.</span></span> <span data-ttu-id="8b8da-2821">Stattdessen umschließt der Gleichheits Operator einen aufzurufenden <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2821">Instead, the equality operator wraps a call to the <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> method.</span></span>



## Examples
 <span data-ttu-id="8b8da-2822">Im folgenden Beispiel wird der Gleichheits Operator veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2822">The following example demonstrates the equality operator.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Equality/CPP/equalityop.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Equality/CS/equalityop.cs" interactive="try-dotnet" id="Snippet1":::
 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;char&gt; (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;char&gt; op_Implicit(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Implicit(System.String)~System.ReadOnlySpan{System.Char}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As String) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;char&gt;(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.string.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-2823">Eine Zeichenfolge, die implizit konvertiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2823">A string to implicitly convert.</span></span></param>
        <summary><span data-ttu-id="8b8da-2824">Definiert eine implizite Konvertierung einer angegebenen Zeichenfolge in einen schreibgeschützten Zeichenbereich.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2824">Defines an implicit conversion of a given string to a read-only span of characters.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2825">Ein schreibgeschützter Zeichenbereich, der die Zeichenfolge darstellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2825">A new read-only span of characters representing the string.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Inequality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : string * string -&gt; bool" Usage="System.string.op_Inequality (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="8b8da-2826">Die erste Zeichenfolge für den Vergleich oder <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2826">The first string to compare, or <see langword="null" />.</span></span></param>
        <param name="b"><span data-ttu-id="8b8da-2827">Die zweite Zeichenfolge für den Vergleich oder <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2827">The second string to compare, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="8b8da-2828">Bestimmt, ob zwei angegebene Zeichenfolgen verschiedene Werte haben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2828">Determines whether two specified strings have different values.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2829"><see langword="true" />, wenn der Wert von <paramref name="a" /> vom Wert von <paramref name="b" /> verschieden ist; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2829"><see langword="true" /> if the value of <paramref name="a" /> is different from the value of <paramref name="b" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2830">Die <xref:System.String.op_Inequality%2A>-Methode definiert den Vorgang des Ungleichheits Operators für die <xref:System.String>-Klasse.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2830">The <xref:System.String.op_Inequality%2A> method defines the operation of the inequality operator for the <xref:System.String> class.</span></span>   <span data-ttu-id="8b8da-2831">Sie ermöglicht Code wie im Abschnitt "Beispiele".</span><span class="sxs-lookup"><span data-stu-id="8b8da-2831">It enables code such as that shown in the Examples section.</span></span>

 <span data-ttu-id="8b8da-2832">Der <xref:System.String.op_Inequality%2A>-Operator ruft wiederum die statische <xref:System.String.Equals%28System.String%2CSystem.String%29>-Methode auf, die einen Ordinalvergleich (Groß-/Kleinschreibung und Kultur unabhängige) ausführt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2832">The <xref:System.String.op_Inequality%2A> operator in turn calls the static <xref:System.String.Equals%28System.String%2CSystem.String%29> method, which  performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span>

> [!NOTE]
>  <span data-ttu-id="8b8da-2833">Der Visual Basic-Compiler löst nicht den Ungleichheits Operator als einen aufzurufenden <xref:System.String.op_Inequality%2A> Methode auf.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2833">The Visual Basic compiler does not resolve the inequality operator as a call to the <xref:System.String.op_Inequality%2A> method.</span></span> <span data-ttu-id="8b8da-2834">Stattdessen umschließt der Ungleichheits Operator einen aufzurufenden <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2834">Instead, the inequality operator wraps a call to the <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> method.</span></span>



## Examples
 <span data-ttu-id="8b8da-2835">Im folgenden Beispiel wird der Ungleichheits Operator veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2835">The following example demonstrates the inequality operator.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Inequality/CPP/inequalityop.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Inequality/CS/inequalityop.cs" interactive="try-dotnet" id="Snippet1":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PadLeft">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8b8da-2836">Gibt eine neue Zeichenfolge mit einer angegebenen Länge zurück, in der der Anfang der aktuellen Zeichenfolge mit Leerzeichen oder einem angegebenen Unicode-Zeichen aufgefüllt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2836">Returns a new string of a specified length in which the beginning of the current string is padded with spaces or with a specified Unicode character.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int -&gt; string" Usage="string.PadLeft totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth"><span data-ttu-id="8b8da-2837">Die Anzahl der Zeichen in der resultierenden Zeichenfolge, entsprechend der Anzahl der ursprünglichen Zeichen zuzüglich aller zusätzlichen Füllzeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2837">The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</span></span></param>
        <summary><span data-ttu-id="8b8da-2838">Gibt eine neue Zeichenfolge zurück, bei der die Zeichen in dieser Instanz rechtsbündig ausgerichtet werden, indem die linke Seite mit Leerzeichen aufgefüllt wird, um eine angegebene Gesamtlänge zu erreichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2838">Returns a new string that right-aligns the characters in this instance by padding them with spaces on the left, for a specified total length.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2839">Eine neue Zeichenfolge, die dieser Instanz entspricht, jedoch rechtsbündig ausgerichtet und links mit Leerzeichen aufgefüllt ist, sodass die Länge <paramref name="totalWidth" /> erreicht wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2839">A new string that is equivalent to this instance, but right-aligned and padded on the left with as many spaces as needed to create a length of <paramref name="totalWidth" />.</span></span> <span data-ttu-id="8b8da-2840">Wenn <paramref name="totalWidth" /> jedoch kleiner als die Länge dieser Instanz ist, gibt die Methode einen Verweis auf die vorhandene Instanz zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2840">However, if <paramref name="totalWidth" /> is less than the length of this instance, the method returns a reference to the existing instance.</span></span> <span data-ttu-id="8b8da-2841">Wenn <paramref name="totalWidth" /> gleich der Länge dieser Instanz ist, gibt die Methode eine neue Zeichenfolge zurück, die mit dieser Instanz identisch ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2841">If <paramref name="totalWidth" /> is equal to the length of this instance, the method returns a new string that is identical to this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2842">Ein Unicode-Leerzeichen ist als hexadezimal 0x0020 definiert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2842">A Unicode space is defined as hexadecimal 0x0020.</span></span>

 <span data-ttu-id="8b8da-2843">Die <xref:System.String.PadLeft%28System.Int32%29>-Methode füllt den Anfang der zurückgegebenen Zeichenfolge auf.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2843">The <xref:System.String.PadLeft%28System.Int32%29> method pads the beginning of the returned string.</span></span> <span data-ttu-id="8b8da-2844">Dies bedeutet, dass bei Verwendung mit rechts-nach-links-Sprachen der Rechte Teil der Zeichenfolge aufgefüllt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2844">This means that, when used with right-to-left languages, it pads the right portion of the string.</span></span>

> [!NOTE]
>  <span data-ttu-id="8b8da-2845">Wenn die <xref:System.String.PadLeft%2A>-Methode die aktuelle-Instanz mit Leerzeichen füllt, ändert diese Methode nicht den Wert der aktuellen Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2845">If the <xref:System.String.PadLeft%2A> method pads the current instance with white-space characters, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="8b8da-2846">Stattdessen wird eine neue Zeichenfolge zurückgegeben, die mit einem führenden Leerzeichen aufgefüllt wird, sodass die Gesamtlänge `totalWidth` Zeichen ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2846">Instead, it returns a new string that is padded with leading white space so that its total length is `totalWidth` characters.</span></span>



## Examples
 <span data-ttu-id="8b8da-2847">Das folgende Beispiel veranschaulicht die <xref:System.String.PadLeft%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2847">The following example demonstrates the <xref:System.String.PadLeft%2A> method.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CPP/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CS/source.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft Example/VB/source.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-2848"><paramref name="totalWidth" /> ist kleiner als Null.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2848"><paramref name="totalWidth" /> is less than zero.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int * char -&gt; string" Usage="string.PadLeft (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth"><span data-ttu-id="8b8da-2849">Die Anzahl der Zeichen in der resultierenden Zeichenfolge, entsprechend der Anzahl der ursprünglichen Zeichen zuzüglich aller zusätzlichen Füllzeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2849">The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</span></span></param>
        <param name="paddingChar"><span data-ttu-id="8b8da-2850">Ein Unicode-Füllzeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2850">A Unicode padding character.</span></span></param>
        <summary><span data-ttu-id="8b8da-2851">Gibt eine neue Zeichenfolge zurück, bei der die Zeichen in dieser Instanz rechtsbündig ausgerichtet werden, indem die linke Seite mit einem angegebenen Unicode-Zeichen aufgefüllt wird, um eine angegebene Gesamtlänge zu erreichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2851">Returns a new string that right-aligns the characters in this instance by padding them on the left with a specified Unicode character, for a specified total length.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2852">Eine neue Zeichenfolge, die dieser Instanz entspricht, jedoch rechtsbündig ausgerichtet und links mit <paramref name="paddingChar" />-Zeichen aufgefüllt ist, sodass die Länge <paramref name="totalWidth" /> erreicht wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2852">A new string that is equivalent to this instance, but right-aligned and padded on the left with as many <paramref name="paddingChar" /> characters as needed to create a length of <paramref name="totalWidth" />.</span></span> <span data-ttu-id="8b8da-2853">Wenn <paramref name="totalWidth" /> jedoch kleiner als die Länge dieser Instanz ist, gibt die Methode einen Verweis auf die vorhandene Instanz zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2853">However, if <paramref name="totalWidth" /> is less than the length of this instance, the method returns a reference to the existing instance.</span></span> <span data-ttu-id="8b8da-2854">Wenn <paramref name="totalWidth" /> gleich der Länge dieser Instanz ist, gibt die Methode eine neue Zeichenfolge zurück, die mit dieser Instanz identisch ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2854">If <paramref name="totalWidth" /> is equal to the length of this instance, the method returns a new string that is identical to this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2855">Die <xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29>-Methode füllt den Anfang der zurückgegebenen Zeichenfolge auf.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2855">The <xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29> method pads the beginning of the returned string.</span></span> <span data-ttu-id="8b8da-2856">Dies bedeutet, dass bei Verwendung mit rechts-nach-links-Sprachen der Rechte Teil der Zeichenfolge aufgefüllt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2856">This means that, when used with right-to-left languages, it pads the right portion of the string.</span></span>

> [!NOTE]
>  <span data-ttu-id="8b8da-2857">Wenn die <xref:System.String.PadLeft%2A>-Methode die aktuelle-Instanz mit Leerzeichen füllt, ändert diese Methode nicht den Wert der aktuellen Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2857">If the <xref:System.String.PadLeft%2A> method pads the current instance with white-space characters, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="8b8da-2858">Stattdessen wird eine neue Zeichenfolge zurückgegeben, die mit führenden `paddingChar` Zeichen aufgefüllt wird, sodass die Gesamtlänge `totalWidth` Zeichen ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2858">Instead, it returns a new string that is padded with leading `paddingChar` characters so that its total length is `totalWidth` characters.</span></span>



## Examples
 <span data-ttu-id="8b8da-2859">Das folgende Beispiel veranschaulicht die <xref:System.String.PadLeft%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2859">The following example demonstrates the <xref:System.String.PadLeft%2A> method.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CPP/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CS/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/VB/source.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-2860"><paramref name="totalWidth" /> ist kleiner als Null.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2860"><paramref name="totalWidth" /> is less than zero.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PadRight">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8b8da-2861">Gibt eine neue Zeichenfolge mit einer angegebenen Länge zurück, in der das Ende der aktuellen Zeichenfolge mit Leerzeichen oder einem angegebenen Unicode-Zeichen aufgefüllt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2861">Returns a new string of a specified length in which the end of the current string is padded with spaces or with a specified Unicode character.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int -&gt; string" Usage="string.PadRight totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth"><span data-ttu-id="8b8da-2862">Die Anzahl der Zeichen in der resultierenden Zeichenfolge, entsprechend der Anzahl der ursprünglichen Zeichen zuzüglich aller zusätzlichen Füllzeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2862">The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</span></span></param>
        <summary><span data-ttu-id="8b8da-2863">Gibt eine neue Zeichenfolge zurück, deren Zeichen linksbündig ausgerichtet werden, indem die rechte Seite mit Leerzeichen aufgefüllt wird, um eine angegebene Gesamtlänge zu erreichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2863">Returns a new string that left-aligns the characters in this string by padding them with spaces on the right, for a specified total length.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2864">Eine neue Zeichenfolge, die dieser Instanz entspricht, jedoch rechtsbündig ausgerichtet und links mit Leerzeichen aufgefüllt ist, sodass die Länge <paramref name="totalWidth" /> erreicht wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2864">A new string that is equivalent to this instance, but left-aligned and padded on the right with as many spaces as needed to create a length of <paramref name="totalWidth" />.</span></span> <span data-ttu-id="8b8da-2865">Wenn <paramref name="totalWidth" /> jedoch kleiner als die Länge dieser Instanz ist, gibt die Methode einen Verweis auf die vorhandene Instanz zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2865">However, if <paramref name="totalWidth" /> is less than the length of this instance, the method returns a reference to the existing instance.</span></span> <span data-ttu-id="8b8da-2866">Wenn <paramref name="totalWidth" /> gleich der Länge dieser Instanz ist, gibt die Methode eine neue Zeichenfolge zurück, die mit dieser Instanz identisch ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2866">If <paramref name="totalWidth" /> is equal to the length of this instance, the method returns a new string that is identical to this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2867">Ein Unicode-Leerzeichen ist als hexadezimal 0x0020 definiert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2867">A Unicode space is defined as hexadecimal 0x0020.</span></span>

 <span data-ttu-id="8b8da-2868">Die <xref:System.String.PadRight%28System.Int32%29>-Methode füllt das Ende der zurückgegebenen Zeichenfolge auf.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2868">The <xref:System.String.PadRight%28System.Int32%29> method pads the end of the returned string.</span></span> <span data-ttu-id="8b8da-2869">Dies bedeutet, dass bei Verwendung mit rechts-nach-links-Sprachen der linke Teil der Zeichenfolge aufgefüllt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2869">This means that, when used with right-to-left languages, it pads the left portion of the string.</span></span>

> [!NOTE]
>  <span data-ttu-id="8b8da-2870">Wenn die <xref:System.String.PadRight%2A>-Methode die aktuelle-Instanz mit Leerzeichen füllt, ändert diese Methode nicht den Wert der aktuellen Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2870">If the <xref:System.String.PadRight%2A> method pads the current instance with white-space characters, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="8b8da-2871">Stattdessen wird eine neue Zeichenfolge zurückgegeben, die mit nachfolgenden Leerzeichen aufgefüllt wird, sodass die Gesamtlänge `totalWidth` Zeichen ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2871">Instead, it returns a new string that is padded with trailing white space so that its total length is `totalWidth` characters.</span></span>



## Examples
 <span data-ttu-id="8b8da-2872">Das folgende Beispiel veranschaulicht die <xref:System.String.PadRight%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2872">The following example demonstrates the <xref:System.String.PadRight%2A> method.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight Example/CPP/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight Example/cs/source.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight Example/VB/source.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-2873"><paramref name="totalWidth" /> ist kleiner als Null.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2873"><paramref name="totalWidth" /> is less than zero.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int * char -&gt; string" Usage="string.PadRight (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth"><span data-ttu-id="8b8da-2874">Die Anzahl der Zeichen in der resultierenden Zeichenfolge, entsprechend der Anzahl der ursprünglichen Zeichen zuzüglich aller zusätzlichen Füllzeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2874">The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</span></span></param>
        <param name="paddingChar"><span data-ttu-id="8b8da-2875">Ein Unicode-Füllzeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2875">A Unicode padding character.</span></span></param>
        <summary><span data-ttu-id="8b8da-2876">Gibt eine neue Zeichenfolge zurück, deren Zeichen linksbündig ausgerichtet werden, indem die rechte Seite mit einem angegebenen Unicode-Zeichen aufgefüllt wird, um eine angegebene Gesamtlänge zu erreichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2876">Returns a new string that left-aligns the characters in this string by padding them on the right with a specified Unicode character, for a specified total length.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2877">Eine neue Zeichenfolge, die dieser Instanz entspricht, jedoch rechtsbündig ausgerichtet und links mit <paramref name="paddingChar" />-Zeichen aufgefüllt ist, sodass die Länge <paramref name="totalWidth" /> erreicht wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2877">A new string that is equivalent to this instance, but left-aligned and padded on the right with as many <paramref name="paddingChar" /> characters as needed to create a length of <paramref name="totalWidth" />.</span></span> <span data-ttu-id="8b8da-2878">Wenn <paramref name="totalWidth" /> jedoch kleiner als die Länge dieser Instanz ist, gibt die Methode einen Verweis auf die vorhandene Instanz zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2878">However, if <paramref name="totalWidth" /> is less than the length of this instance, the method returns a reference to the existing instance.</span></span> <span data-ttu-id="8b8da-2879">Wenn <paramref name="totalWidth" /> gleich der Länge dieser Instanz ist, gibt die Methode eine neue Zeichenfolge zurück, die mit dieser Instanz identisch ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2879">If <paramref name="totalWidth" /> is equal to the length of this instance, the method returns a new string that is identical to this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2880">Die <xref:System.String.PadRight%28System.Int32%2CSystem.Char%29>-Methode füllt das Ende der zurückgegebenen Zeichenfolge auf.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2880">The <xref:System.String.PadRight%28System.Int32%2CSystem.Char%29> method pads the end of the returned string.</span></span> <span data-ttu-id="8b8da-2881">Dies bedeutet, dass bei Verwendung mit rechts-nach-links-Sprachen der linke Teil der Zeichenfolge aufgefüllt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2881">This means that, when used with right-to-left languages, it pads the left portion of the string.</span></span>

> [!NOTE]
>  <span data-ttu-id="8b8da-2882">Wenn die <xref:System.String.PadRight%2A>-Methode die aktuelle-Instanz mit Leerzeichen füllt, ändert diese Methode nicht den Wert der aktuellen Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2882">If the <xref:System.String.PadRight%2A> method pads the current instance with white-space characters, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="8b8da-2883">Stattdessen wird eine neue Zeichenfolge zurückgegeben, die mit nachfolgenden `paddingChar` Zeichen aufgefüllt wird, sodass die Gesamtlänge `totalWidth` Zeichen ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2883">Instead, it returns a new string that is padded with trailing `paddingChar` characters so that its total length is `totalWidth` characters.</span></span>



## Examples
 <span data-ttu-id="8b8da-2884">Das folgende Beispiel veranschaulicht die <xref:System.String.PadRight%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2884">The following example demonstrates the <xref:System.String.PadRight%2A> method.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/CPP/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/cs/source.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/VB/source.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-2885"><paramref name="totalWidth" /> ist kleiner als Null.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2885"><paramref name="totalWidth" /> is less than zero.</span></span></exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8b8da-2886">Gibt eine neue Zeichenfolge zurück, in der eine angegebene Anzahl von Zeichen aus der aktuellen Zeichenfolge gelöscht wurde.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2886">Returns a new string in which a specified number of characters from the current string are deleted.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Remove : int -&gt; string" Usage="string.Remove startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="startIndex"><span data-ttu-id="8b8da-2887">Die nullbasierte Position, ab der Zeichen gelöscht werden sollen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2887">The zero-based position to begin deleting characters.</span></span></param>
        <summary><span data-ttu-id="8b8da-2888">Gibt eine neue Zeichenfolge zurück, in der alle Zeichen in der aktuellen Instanz, beginnend an einer angegebenen Position und sich über die letzte Position fortsetzend, gelöscht wurden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2888">Returns a new string in which all the characters in the current instance, beginning at a specified position and continuing through the last position, have been deleted.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2889">Eine neue Zeichenfolge, die dieser Zeichenfolge ohne die entfernten Zeichen entspricht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2889">A new string that is equivalent to this string except for the removed characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2890">Im [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]sind Zeichen folgen Null basiert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2890">In the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], strings are zero-based.</span></span> <span data-ttu-id="8b8da-2891">Der Wert des `startIndex`-Parameters kann zwischen null und einem kleiner als der Länge der Zeichen folgen Instanz liegen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2891">The value of the `startIndex` parameter can range from zero to one less than the length of the string instance.</span></span>

> [!NOTE]
>  <span data-ttu-id="8b8da-2892">Diese Methode ändert nicht den Wert der aktuellen Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2892">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="8b8da-2893">Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der alle Zeichen von der Position `startIndex` bis zum Ende der ursprünglichen Zeichenfolge entfernt wurden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2893">Instead, it returns a new string in which all characters from position `startIndex` to the end of the original string have been removed.</span></span>



## Examples
 <span data-ttu-id="8b8da-2894">Das folgende Beispiel veranschaulicht die <xref:System.String.Remove%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2894">The following example demonstrates the <xref:System.String.Remove%2A> method.</span></span> <span data-ttu-id="8b8da-2895">Der nächste Fall entfernt den gesamten Text, beginnend ab dem angegebenen Index bis zum Ende der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2895">The next-to-last case removes all text starting from the specified index through the end of the string.</span></span> <span data-ttu-id="8b8da-2896">Im letzten Fall werden drei Zeichen entfernt, beginnend beim angegebenen Index.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2896">The last case removes three characters starting from the specified index.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.remove/CPP/r.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.remove/CS/r.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.remove/VB/r.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-2897"><paramref name="startIndex" /> ist kleiner als Null.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2897"><paramref name="startIndex" /> is less than zero.</span></span>

<span data-ttu-id="8b8da-2898">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-2898">-or-</span></span>

 <span data-ttu-id="8b8da-2899"><paramref name="startIndex" /> gibt eine Position an, die sich nicht innerhalb der Zeichenfolge befindet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2899"><paramref name="startIndex" /> specifies a position that is not within this string.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; string" Usage="string.Remove (startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex"><span data-ttu-id="8b8da-2900">Die nullbasierte Position, ab der Zeichen gelöscht werden sollen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2900">The zero-based position to begin deleting characters.</span></span></param>
        <param name="count"><span data-ttu-id="8b8da-2901">Die Anzahl der zu löschenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2901">The number of characters to delete.</span></span></param>
        <summary><span data-ttu-id="8b8da-2902">Gibt eine neue Zeichenfolge zurück, in der eine bestimmte Anzahl von Zeichen in er aktuellen Instanz, beginnend an einer angegebenen Position, gelöscht wurden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2902">Returns a new string in which a specified number of characters in the current instance beginning at a specified position have been deleted.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2903">Eine neue Zeichenfolge, die dieser Instanz ohne die entfernten Zeichen entspricht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2903">A new string that is equivalent to this instance except for the removed characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2904">Im [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]sind Zeichen folgen Null basiert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2904">In the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], strings are zero-based.</span></span> <span data-ttu-id="8b8da-2905">Der Wert des `startIndex`-Parameters kann zwischen null und einem kleiner als der Länge der Zeichen folgen Instanz liegen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2905">The value of the `startIndex` parameter can range from zero to one less than the length of the string instance.</span></span>

> [!NOTE]
>  <span data-ttu-id="8b8da-2906">Diese Methode ändert nicht den Wert der aktuellen Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2906">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="8b8da-2907">Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der die durch den `count`-Parameter angegebene Anzahl von Zeichen entfernt wurde.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2907">Instead, it returns a new string in which the number of characters specified by the `count` parameter have been removed.</span></span> <span data-ttu-id="8b8da-2908">Die Zeichen werden an der durch `startIndex`angegebenen Position entfernt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2908">The characters are removed at the position specified by `startIndex`.</span></span>



## Examples
 <span data-ttu-id="8b8da-2909">Im folgenden Beispiel wird veranschaulicht, wie Sie den Vornamen aus einem kompletten Namen entfernen können.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2909">The following example demonstrates how you can remove the middle name from a complete name.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/stringremove/CPP/stringremove.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringremove/CS/stringremove.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringremove/VB/stringremove.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-2910">Entweder <paramref name="startIndex" /> oder <paramref name="count" /> ist kleiner als 0 (null).</span><span class="sxs-lookup"><span data-stu-id="8b8da-2910">Either <paramref name="startIndex" /> or <paramref name="count" /> is less than zero.</span></span>

<span data-ttu-id="8b8da-2911">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-2911">-or-</span></span>

 <span data-ttu-id="8b8da-2912"><paramref name="startIndex" /> plus <paramref name="count" /> bezeichnen eine Position außerhalb dieser Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2912"><paramref name="startIndex" /> plus <paramref name="count" /> specify a position outside this instance.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8b8da-2913">Gibt eine neue Zeichenfolge zurück, in der alle Vorkommen von einem angegebenen Unicode-Zeichen oder <see cref="T:System.String" /> in der aktuellen Zeichenfolge durch ein anderes angegebenes Unicode-Zeichen oder einen anderen <see cref="T:System.String" /> ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2913">Returns a new string in which all occurrences of a specified Unicode character or <see cref="T:System.String" /> in the current string are replaced with another specified Unicode character or <see cref="T:System.String" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; string" Usage="string.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar"><span data-ttu-id="8b8da-2914">Das zu ersetzende Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2914">The Unicode character to be replaced.</span></span></param>
        <param name="newChar"><span data-ttu-id="8b8da-2915">Das Unicode-Zeichen, das jedes Vorkommen von <paramref name="oldChar" /> ersetzen soll.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2915">The Unicode character to replace all occurrences of <paramref name="oldChar" />.</span></span></param>
        <summary><span data-ttu-id="8b8da-2916">Gibt eine neue Zeichenfolge zurück, in der alle Vorkommen eines angegebenen Unicode-Zeichens in dieser Instanz durch ein anderes angegebenes Unicode-Zeichen ersetzt wurden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2916">Returns a new string in which all occurrences of a specified Unicode character in this instance are replaced with another specified Unicode character.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2917">Eine Zeichenfolge, die dieser Instanz entspricht, außer dass alle Instanzen von <paramref name="oldChar" /> durch <paramref name="newChar" /> ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2917">A string that is equivalent to this instance except that all instances of <paramref name="oldChar" /> are replaced with <paramref name="newChar" />.</span></span> <span data-ttu-id="8b8da-2918">Wenn <paramref name="oldChar" /> nicht in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2918">If <paramref name="oldChar" /> is not found in the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2919">Diese Methode führt eine Ordinalsuche (Groß-/Kleinschreibung und Kultur abhängige Suche) durch, um nach `oldChar`zu suchen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2919">This method performs an ordinal (case-sensitive and culture-insensitive) search to find `oldChar`.</span></span>

> [!NOTE]
>  <span data-ttu-id="8b8da-2920">Diese Methode ändert nicht den Wert der aktuellen Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2920">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="8b8da-2921">Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der alle Vorkommen von `oldChar` durch `newChar`ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2921">Instead, it returns a new string in which all occurrences of `oldChar` are replaced by `newChar`.</span></span>

 <span data-ttu-id="8b8da-2922">Da diese Methode die geänderte Zeichenfolge zurückgibt, können Sie aufeinander folgende Aufrufe der <xref:System.String.Replace%2A>-Methode verketten, um mehrere Ersetzungen in der ursprünglichen Zeichenfolge auszuführen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2922">Because this method returns the modified string, you can chain together successive calls to the <xref:System.String.Replace%2A> method to perform multiple replacements on the original string.</span></span> <span data-ttu-id="8b8da-2923">Methodenaufrufe werden von links nach rechts ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2923">Method calls are executed from left to right.</span></span> <span data-ttu-id="8b8da-2924">Dies wird im folgenden Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2924">The following example provides an illustration.</span></span>

 [!code-csharp-interactive[System.String.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace2.cs#2)]
 [!code-vb[System.String.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace2.vb#2)]



## Examples
 <span data-ttu-id="8b8da-2925">Im folgenden Beispiel wird eine durch Kommas getrennte Liste erstellt, indem die Leerzeichen zwischen einer Reihe von Zahlen durch Kommas ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2925">The following example creates a comma separated value list by substituting commas for the blanks between a series of numbers.</span></span>

 [!code-cpp[string.replace1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.replace1/CPP/string.replace1.cpp#1)]
 [!code-csharp-interactive[string.replace1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.replace1/CS/string.replace1.cs#1)]
 [!code-vb[string.replace1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.replace1/VB/string.replace1.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="string.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue"><span data-ttu-id="8b8da-2926">Die zu ersetzende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2926">The string to be replaced.</span></span></param>
        <param name="newValue"><span data-ttu-id="8b8da-2927">Die Zeichenfolge, die jedes Vorkommen von <paramref name="oldValue" /> ersetzen soll.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2927">The string to replace all occurrences of <paramref name="oldValue" />.</span></span></param>
        <summary><span data-ttu-id="8b8da-2928">Gibt eine neue Zeichenfolge zurück, in der alle Vorkommen einer angegebenen Zeichenfolge in der aktuellen Instanz durch eine andere angegebene Zeichenfolge ersetzt wurden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2928">Returns a new string in which all occurrences of a specified string in the current instance are replaced with another specified string.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2929">Eine Zeichenfolge, die der aktuellen Zeichenfolge entspricht, außer dass alle Instanzen von <paramref name="oldValue" /> durch <paramref name="newValue" /> ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2929">A string that is equivalent to the current string except that all instances of <paramref name="oldValue" /> are replaced with <paramref name="newValue" />.</span></span> <span data-ttu-id="8b8da-2930">Wenn <paramref name="oldValue" /> nicht in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2930">If <paramref name="oldValue" /> is not found in the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2931">Wenn `newValue` `null`ist, werden alle Vorkommen von `oldValue` entfernt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2931">If `newValue` is `null`, all occurrences of `oldValue` are removed.</span></span>

> [!NOTE]
>  <span data-ttu-id="8b8da-2932">Diese Methode ändert nicht den Wert der aktuellen Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2932">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="8b8da-2933">Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der alle Vorkommen von `oldValue` durch `newValue`ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2933">Instead, it returns a new string in which all occurrences of `oldValue` are replaced by `newValue`.</span></span>

 <span data-ttu-id="8b8da-2934">Diese Methode führt eine Ordinalsuche (Groß-/Kleinschreibung und Kultur abhängige Suche) durch, um nach `oldValue`zu suchen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2934">This method performs an ordinal (case-sensitive and culture-insensitive) search to find `oldValue`.</span></span>

 <span data-ttu-id="8b8da-2935">Da diese Methode die geänderte Zeichenfolge zurückgibt, können Sie aufeinander folgende Aufrufe der <xref:System.String.Replace%2A>-Methode verketten, um mehrere Ersetzungen in der ursprünglichen Zeichenfolge auszuführen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2935">Because this method returns the modified string, you can chain together successive calls to the <xref:System.String.Replace%2A> method to perform multiple replacements on the original string.</span></span> <span data-ttu-id="8b8da-2936">Methodenaufrufe werden von links nach rechts ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2936">Method calls are executed from left to right.</span></span> <span data-ttu-id="8b8da-2937">Dies wird im folgenden Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2937">The following example provides an illustration.</span></span>

 [!code-csharp-interactive[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
 [!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]



## Examples
 <span data-ttu-id="8b8da-2938">Im folgenden Beispiel wird veranschaulicht, wie Sie mit der <xref:System.String.Replace%2A>-Methode einen Rechtschreibfehler korrigieren können.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2938">The following example demonstrates how you can use the <xref:System.String.Replace%2A> method to correct a spelling error.</span></span>

 [!code-cpp[stringreplace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringreplace/CPP/stringreplace.cpp#1)]
 [!code-csharp-interactive[stringreplace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringreplace/CS/stringreplace.cs#1)]
 [!code-vb[stringreplace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringreplace/VB/stringreplace.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-2939"><paramref name="oldValue" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2939"><paramref name="oldValue" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8b8da-2940"><paramref name="oldValue" /> ist die leere Zeichenfolge („“).</span><span class="sxs-lookup"><span data-stu-id="8b8da-2940"><paramref name="oldValue" /> is the empty string ("").</span></span></exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, comparisonType As StringComparison) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * StringComparison -&gt; string" Usage="string.Replace (oldValue, newValue, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="newValue" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="oldValue"><span data-ttu-id="8b8da-2941">Die zu ersetzende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2941">The string to be replaced.</span></span></param>
        <param name="newValue"><span data-ttu-id="8b8da-2942">Die Zeichenfolge, die jedes Vorkommen von <paramref name="oldValue" /> ersetzen soll.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2942">The string to replace all occurrences of <paramref name="oldValue" />.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="8b8da-2943">Einer der Enumerationswerte, der bestimmt, wie <paramref name="oldValue" /> in dieser Instanz gesucht werden soll.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2943">One of the enumeration values that determines how <paramref name="oldValue" /> is searched within this instance.</span></span></param>
        <summary><span data-ttu-id="8b8da-2944">Gibt mithilfe des bereitgestellten Vergleichstyps eine neue Zeichenfolge zurück, in der alle Vorkommen einer angegebenen Zeichenfolge in der aktuellen Instanz durch eine andere angegebene Zeichenfolge ersetzt wurden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2944">Returns a new string in which all occurrences of a specified string in the current instance are replaced with another specified string, using the provided comparison type.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2945">Eine Zeichenfolge, die der aktuellen Zeichenfolge entspricht, außer dass alle Instanzen von <paramref name="oldValue" /> durch <paramref name="newValue" /> ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2945">A string that is equivalent to the current string except that all instances of <paramref name="oldValue" /> are replaced with <paramref name="newValue" />.</span></span> <span data-ttu-id="8b8da-2946">Wenn <paramref name="oldValue" /> nicht in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2946">If <paramref name="oldValue" /> is not found in the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
<span data-ttu-id="8b8da-2947">Wenn `newValue` `null`ist, werden alle Vorkommen von `oldValue` entfernt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2947">If `newValue` is `null`, all occurrences of `oldValue` are removed.</span></span>

> [!NOTE]
>  <span data-ttu-id="8b8da-2948">Diese Methode ändert nicht den Wert der aktuellen Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2948">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="8b8da-2949">Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der alle Vorkommen von `oldValue` durch `newValue`ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2949">Instead, it returns a new string in which all occurrences of `oldValue` are replaced by `newValue`.</span></span>

<span data-ttu-id="8b8da-2950">Diese Methode führt eine Suche durch, um `oldValue` anhand der Kultur und der Groß-/Kleinschreibung durch `comparisonType`zu finden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2950">This method performs a search to find `oldValue` using the culture and case sensitivity described by `comparisonType`.</span></span>

<span data-ttu-id="8b8da-2951">Da diese Methode die geänderte Zeichenfolge zurückgibt, können Sie aufeinander folgende Aufrufe der <xref:System.String.Replace%2A>-Methode verketten, um mehrere Ersetzungen in der ursprünglichen Zeichenfolge auszuführen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2951">Because this method returns the modified string, you can chain together successive calls to the <xref:System.String.Replace%2A> method to perform multiple replacements on the original string.</span></span> <span data-ttu-id="8b8da-2952">Methodenaufrufe werden von links nach rechts ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2952">Method calls are executed from left to right.</span></span> <span data-ttu-id="8b8da-2953">Dies wird im folgenden Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2953">The following example provides an illustration.</span></span>

[!code-csharp[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
[!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-2954"><paramref name="oldValue" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2954"><paramref name="oldValue" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8b8da-2955"><paramref name="oldValue" /> ist die leere Zeichenfolge („“).</span><span class="sxs-lookup"><span data-stu-id="8b8da-2955"><paramref name="oldValue" /> is the empty string ("").</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, ignoreCase As Boolean, culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * bool * System.Globalization.CultureInfo -&gt; string" Usage="string.Replace (oldValue, newValue, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="newValue" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="oldValue"><span data-ttu-id="8b8da-2956">Die zu ersetzende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2956">The string to be replaced.</span></span></param>
        <param name="newValue"><span data-ttu-id="8b8da-2957">Die Zeichenfolge, die jedes Vorkommen von <paramref name="oldValue" /> ersetzen soll.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2957">The string to replace all occurrences of <paramref name="oldValue" />.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="8b8da-2958"><see langword="true" />, um die Groß-/Kleinschreibung beim Vergleich zu ignorieren, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2958"><see langword="true" /> to ignore casing when comparing; <see langword="false" /> otherwise.</span></span></param>
        <param name="culture"><span data-ttu-id="8b8da-2959">Die Kultur, die beim Vergleich verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2959">The culture to use when comparing.</span></span></param>
        <summary><span data-ttu-id="8b8da-2960">Gibt mithilfe der angegebenen Kultur und der Angabe zur Groß-/Kleinschreibung eine neue Zeichenfolge zurück, in der alle Vorkommen einer angegebenen Zeichenfolge in der aktuellen Instanz durch eine andere angegebene Zeichenfolge ersetzt wurden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2960">Returns a new string in which all occurrences of a specified string in the current instance are replaced with another specified string, using the provided culture and case sensitivity.</span></span></summary>
        <returns><span data-ttu-id="8b8da-2961">Eine Zeichenfolge, die der aktuellen Zeichenfolge entspricht, außer dass alle Instanzen von <paramref name="oldValue" /> durch <paramref name="newValue" /> ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2961">A string that is equivalent to the current string except that all instances of <paramref name="oldValue" /> are replaced with <paramref name="newValue" />.</span></span> <span data-ttu-id="8b8da-2962">Wenn <paramref name="oldValue" /> nicht in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2962">If <paramref name="oldValue" /> is not found in the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
<span data-ttu-id="8b8da-2963">Wenn `newValue` `null`ist, werden alle Vorkommen von `oldValue` entfernt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2963">If `newValue` is `null`, all occurrences of `oldValue` are removed.</span></span>

> [!NOTE]
>  <span data-ttu-id="8b8da-2964">Diese Methode ändert nicht den Wert der aktuellen Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2964">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="8b8da-2965">Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der alle Vorkommen von `oldValue` durch `newValue`ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2965">Instead, it returns a new string in which all occurrences of `oldValue` are replaced by `newValue`.</span></span>

<span data-ttu-id="8b8da-2966">Diese Methode führt eine Suche durch, um `oldValue` mithilfe der angegebenen `culture` und `ignoreCase` Groß-/Kleinschreibung zu suchen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2966">This method performs a search to find `oldValue` using the provided `culture` and `ignoreCase` case sensitivity.</span></span>

<span data-ttu-id="8b8da-2967">Da diese Methode die geänderte Zeichenfolge zurückgibt, können Sie aufeinander folgende Aufrufe der <xref:System.String.Replace%2A>-Methode verketten, um mehrere Ersetzungen in der ursprünglichen Zeichenfolge auszuführen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2967">Because this method returns the modified string, you can chain together successive calls to the <xref:System.String.Replace%2A> method to perform multiple replacements on the original string.</span></span> <span data-ttu-id="8b8da-2968">Methodenaufrufe werden von links nach rechts ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2968">Method calls are executed from left to right.</span></span> <span data-ttu-id="8b8da-2969">Dies wird im folgenden Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2969">The following example provides an illustration.</span></span>

[!code-csharp[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
[!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-2970"><paramref name="oldValue" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2970"><paramref name="oldValue" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8b8da-2971"><paramref name="oldValue" /> ist die leere Zeichenfolge („“).</span><span class="sxs-lookup"><span data-stu-id="8b8da-2971"><paramref name="oldValue" /> is the empty string ("").</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8b8da-2972">Gibt ein Zeichenfolgenarray zurück, das die Teilzeichenfolgen dieser Instanz enthält, die durch Elemente eines angegebenen Zeichenfolgen- oder Unicode-Zeichenarrays getrennt sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2972">Returns a string array that contains the substrings in this instance that are delimited by elements of a specified string or Unicode character array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-2973"><xref:System.String.Split%2A> wird verwendet, um eine Zeichenfolge mit Trennzeichen in Teil Zeichenfolgen zu zerlegen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2973"><xref:System.String.Split%2A> is used to break a delimited string into substrings.</span></span> <span data-ttu-id="8b8da-2974">Sie können entweder ein Zeichen Array verwenden, um 0 (null), ein Zeichen oder mehrere Trennzeichen (die <xref:System.String.Split%28System.Char%5B%5D%29>-Methode) anzugeben, oder Sie können ein Zeichen Array verwenden, um NULL, eine Zeichenfolge oder mehrere Begrenzungs Zeichenfolgen anzugeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2974">You can use either a character array to specify zero, one, or multiple delimiting characters (the <xref:System.String.Split%28System.Char%5B%5D%29> method), or you can use a character array to specify zero, one, or multiple delimiting strings.</span></span> <span data-ttu-id="8b8da-2975">Über Ladungen der <xref:System.String.Split%2A>-Methode ermöglichen es Ihnen, die Anzahl der von der-Methode zurückgegebenen Teil Zeichenfolgen einzuschränken (die <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29>-Methode), um zu bestimmen, ob leere Zeichen folgen in die zurückgegebenen Teil Zeichenfolgen (die <xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29>-und <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29>-Methoden oder beides (die <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29>-und <xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29>-Methoden) eingeschlossen werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2975">Overloads of the <xref:System.String.Split%2A> method allow you to limit the number of substrings returned by the method (the <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29> method), to determine whether empty strings are included in the returned substrings (the <xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29> and <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> methods, or to do both (the <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> and <xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> methods).</span></span>

### <a name="alternatives-to-stringsplit"></a><span data-ttu-id="8b8da-2976">Alternativen zu String. Split</span><span class="sxs-lookup"><span data-stu-id="8b8da-2976">Alternatives to String.Split</span></span>

 <span data-ttu-id="8b8da-2977">Die <xref:System.String.Split%2A>-Methode ist nicht immer die beste Möglichkeit, eine durch Trennzeichen getrennte Zeichenfolge in Teil Zeichenfolgen zu unterteilen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2977">The <xref:System.String.Split%2A> method is not always the best way to break a delimited string into substrings.</span></span> <span data-ttu-id="8b8da-2978">Wenn Sie nicht alle Teil Zeichenfolgen einer durch Trennzeichen getrennten Zeichenfolge extrahieren möchten oder wenn Sie eine Zeichenfolge auf Grundlage eines Musters anstelle eines Satzes von Trennzeichen analysieren möchten, sollten Sie die folgenden Alternativen in Erwägung ziehen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2978">If you don't want to extract all of the substrings of a delimited string, or if you want to parse a string based on a pattern instead of a set of delimiter characters, consider the following alternatives.</span></span>

### <a name="regular-expressions"></a><span data-ttu-id="8b8da-2979">Reguläre Ausdrücke</span><span class="sxs-lookup"><span data-stu-id="8b8da-2979">Regular expressions</span></span>
 <span data-ttu-id="8b8da-2980">Wenn die Zeichen folgen einem festen Muster entsprechen, können Sie einen regulären Ausdruck verwenden, um ihre Elemente zu extrahieren und zu verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2980">If your strings conform to a fixed pattern, you can use a regular expression to extract and handle their elements.</span></span> <span data-ttu-id="8b8da-2981">Wenn Zeichen folgen z. b. die Form "*Number* *Operand* *Number*" haben, können Sie einen [regulären Ausdruck](~/docs/standard/base-types/regular-expressions.md) verwenden, um die Elemente der Zeichenfolge zu extrahieren und zu verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2981">For example, if strings take the form "*number* *operand* *number*" you can use a [regular expression](~/docs/standard/base-types/regular-expressions.md) to extract and handle the string's elements.</span></span> <span data-ttu-id="8b8da-2982">Im Folgenden ein Beispiel:</span><span class="sxs-lookup"><span data-stu-id="8b8da-2982">Here's an example:</span></span>

 [!code-csharp-interactive[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]

 <span data-ttu-id="8b8da-2983">Das Muster für reguläre Ausdrücke `(\d+)\s+([-+*/])\s+(\d+)` wie folgt definiert:</span><span class="sxs-lookup"><span data-stu-id="8b8da-2983">The regular expression pattern `(\d+)\s+([-+*/])\s+(\d+)` is defined like this:</span></span>

|<span data-ttu-id="8b8da-2984">Muster</span><span class="sxs-lookup"><span data-stu-id="8b8da-2984">Pattern</span></span>|<span data-ttu-id="8b8da-2985">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="8b8da-2985">Description</span></span>|
|-------------|-----------------|
|`(\d+)`|<span data-ttu-id="8b8da-2986">Entsprechung für mindestens eine Dezimalstelle finden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2986">Match one or more decimal digits.</span></span> <span data-ttu-id="8b8da-2987">Dies ist die erste Erfassungsgruppe.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2987">This is the first capturing group.</span></span>|
|`\s+`|<span data-ttu-id="8b8da-2988">Entspricht einem oder mehreren Leerzeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2988">Match one or more white-space characters.</span></span>|
|`([-+*/])`|<span data-ttu-id="8b8da-2989">Entsprechung für ein arithmetisches Operator Zeichen (+,-, \* oder/).</span><span class="sxs-lookup"><span data-stu-id="8b8da-2989">Match an arithmetic operator sign (+, -, \*, or /).</span></span> <span data-ttu-id="8b8da-2990">Dies ist die zweite Erfassungsgruppe.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2990">This is the second capturing group.</span></span>|
|`\s+`|<span data-ttu-id="8b8da-2991">Entspricht einem oder mehreren Leerzeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2991">Match one or more white-space characters.</span></span>|
|`(\d+)`|<span data-ttu-id="8b8da-2992">Entsprechung für mindestens eine Dezimalstelle finden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2992">Match one or more decimal digits.</span></span> <span data-ttu-id="8b8da-2993">Dies ist die dritte Erfassungsgruppe.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2993">This is the third capturing group.</span></span>|

 <span data-ttu-id="8b8da-2994">Sie können auch einen regulären Ausdruck verwenden, um Teil Zeichenfolgen auf der Grundlage eines Musters anstelle eines festen Zeichensatzes aus einer Zeichenfolge zu extrahieren.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2994">You can also use a regular expression to extract substrings from a string based on a pattern rather than a fixed set of characters.</span></span> <span data-ttu-id="8b8da-2995">Dies ist ein häufiges Szenario, wenn eine der folgenden Bedingungen zutrifft:</span><span class="sxs-lookup"><span data-stu-id="8b8da-2995">This is a common scenario when either of these conditions occurs:</span></span>

-   <span data-ttu-id="8b8da-2996">Mindestens eines der Trennzeichen dient nicht immer als Trennzeichen in der <xref:System.String> Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2996">One or more of the delimiter characters does not always serve as a delimiter in the <xref:System.String> instance.</span></span>

-   <span data-ttu-id="8b8da-2997">Die Sequenz und die Anzahl der Trennzeichen sind variabel oder unbekannt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2997">The sequence and number of delimiter characters is variable or unknown.</span></span>

 <span data-ttu-id="8b8da-2998">Beispielsweise kann die <xref:System.String.Split%2A>-Methode nicht zum Aufteilen der folgenden Zeichenfolge verwendet werden, da die Anzahl der `\n` C#(in) oder `vbCrLf` (in Visual Basic)-Zeichen variabel ist und nicht immer als Trennzeichen dienen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2998">For example, the <xref:System.String.Split%2A> method cannot be used to split the following string, because the number of `\n` (in C#) or `vbCrLf` (in Visual Basic) characters is variable, and they don't always serve as delimiters.</span></span>

```text
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]
```

 <span data-ttu-id="8b8da-2999">Ein regulärer Ausdruck kann diese Zeichenfolge leicht aufteilen, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-2999">A regular expression can split this string easily, as the following example shows.</span></span>

 [!code-csharp-interactive[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]

 <span data-ttu-id="8b8da-3000">Das Muster für reguläre Ausdrücke `\[([^\[\]]+)\]` wie folgt definiert:</span><span class="sxs-lookup"><span data-stu-id="8b8da-3000">The regular expression pattern `\[([^\[\]]+)\]` is defined like this:</span></span>

|<span data-ttu-id="8b8da-3001">Muster</span><span class="sxs-lookup"><span data-stu-id="8b8da-3001">Pattern</span></span>|<span data-ttu-id="8b8da-3002">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="8b8da-3002">Description</span></span>|
|-------------|-----------------|
|`\[`|<span data-ttu-id="8b8da-3003">Entspricht einer öffnenden Klammer.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3003">Match an opening bracket.</span></span>|
|`([^\[\]]+)`|<span data-ttu-id="8b8da-3004">Entsprechung für ein beliebiges Zeichen, das keine öffnende oder schließende eckige Klammer ist, einmal oder mehrmals.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3004">Match any character that is not an opening or a closing bracket one or more times.</span></span> <span data-ttu-id="8b8da-3005">Dies ist die erste Erfassungsgruppe.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3005">This is the first capturing group.</span></span>|
|`\]`|<span data-ttu-id="8b8da-3006">Entsprechung für eine schließende Klammer.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3006">Match a closing bracket.</span></span>|

 <span data-ttu-id="8b8da-3007">Die <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>-Methode ist nahezu identisch mit <xref:System.String.Split%2A?displayProperty=nameWithType>, mit der Ausnahme, dass Sie eine Zeichenfolge auf Grundlage eines Musters für reguläre Ausdrücke anstelle eines festen Zeichensatzes aufteilt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3007">The <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> method is almost identical to <xref:System.String.Split%2A?displayProperty=nameWithType>, except that it splits a string based on a regular expression pattern instead of a fixed character set.</span></span> <span data-ttu-id="8b8da-3008">Im folgenden Beispiel wird z. b. die <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType>-Methode verwendet, um eine Zeichenfolge aufzuteilen, die Teil Zeichenfolgen enthält, die durch verschiedene Kombinationen von Bindestrichen und anderen Zeichen getrennt sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3008">For example, the following example uses the <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> method to split a string that contains substrings delimited by various combinations of hyphens and other characters.</span></span>

 [!code-csharp-interactive[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]

 <span data-ttu-id="8b8da-3009">Das Muster für reguläre Ausdrücke `\s-\s?[+*]?\s?-\s` wie folgt definiert:</span><span class="sxs-lookup"><span data-stu-id="8b8da-3009">The regular expression pattern `\s-\s?[+*]?\s?-\s` is defined like this:</span></span>

|<span data-ttu-id="8b8da-3010">Muster</span><span class="sxs-lookup"><span data-stu-id="8b8da-3010">Pattern</span></span>|<span data-ttu-id="8b8da-3011">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="8b8da-3011">Description</span></span>|
|-------------|-----------------|
|`\s-`|<span data-ttu-id="8b8da-3012">Entspricht einem Leerzeichen, gefolgt von einem Bindestrich.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3012">Match a white-space character followed by a hyphen.</span></span>|
|`\s?`|<span data-ttu-id="8b8da-3013">Übereinstimmung mit keinem oder einem Leerzeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3013">Match zero or one white-space character.</span></span>|
|`[+*]?`|<span data-ttu-id="8b8da-3014">Entsprechung für NULL oder ein Vorkommen des Zeichens "+" oder "\*".</span><span class="sxs-lookup"><span data-stu-id="8b8da-3014">Match zero or one occurrence of either the + or \* character.</span></span>|
|`\s?`|<span data-ttu-id="8b8da-3015">Übereinstimmung mit keinem oder einem Leerzeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3015">Match zero or one white-space character.</span></span>|
|`-\s`|<span data-ttu-id="8b8da-3016">Entspricht einem Bindestrich, gefolgt von einem Leerzeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3016">Match a hyphen followed by a white-space character.</span></span>|

### <a name="search-methods-and-the-substring-method"></a><span data-ttu-id="8b8da-3017">Suchmethoden und die Substring-Methode</span><span class="sxs-lookup"><span data-stu-id="8b8da-3017">Search methods and the Substring method</span></span>
 <span data-ttu-id="8b8da-3018">Wenn Sie nicht an allen Teil Zeichenfolgen in einer Zeichenfolge interessiert sind, empfiehlt es sich, mit einer der Methoden für den Zeichen folgen Vergleich zu arbeiten, die den Index zurückgibt, bei dem die Überprüfung beginnt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3018">If you aren't interested in all of the substrings in a string, you might prefer to work with one of the string comparison methods that returns the index at which the match begins.</span></span> <span data-ttu-id="8b8da-3019">Sie können dann die <xref:System.String.Substring%2A>-Methode aufzurufen, um die gewünschte Teil Zeichenfolge zu extrahieren.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3019">You can then call the <xref:System.String.Substring%2A> method to extract the substring that you want.</span></span> <span data-ttu-id="8b8da-3020">Die Methoden für den Zeichen folgen Vergleich umfassen Folgendes:</span><span class="sxs-lookup"><span data-stu-id="8b8da-3020">The string comparison methods include:</span></span>

-   <span data-ttu-id="8b8da-3021"><xref:System.String.IndexOf%2A>, der den NULL basierten Index des ersten Vorkommens eines Zeichens oder einer Zeichenfolge in einer Zeichen folgen Instanz zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3021"><xref:System.String.IndexOf%2A>, which returns the zero-based index of the first occurrence of a character or string in a string instance.</span></span>

-   <span data-ttu-id="8b8da-3022"><xref:System.String.IndexOfAny%2A>, der den NULL basierten Index in der aktuellen Zeichen folgen Instanz des ersten Vorkommens eines beliebigen Zeichens in einem Zeichen Array zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3022"><xref:System.String.IndexOfAny%2A>, which returns the zero-based index in the current string instance of the first occurrence of any character in a character array.</span></span>

-   <span data-ttu-id="8b8da-3023"><xref:System.String.LastIndexOf%2A>, der den NULL basierten Index des letzten Vorkommens eines Zeichens oder einer Zeichenfolge in einer Zeichen folgen Instanz zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3023"><xref:System.String.LastIndexOf%2A>, which returns the zero-based index of the last occurrence of a character or string in a string instance.</span></span>

-   <span data-ttu-id="8b8da-3024"><xref:System.String.LastIndexOfAny%2A>, die einen NULL basierten Index in der aktuellen Zeichen folgen Instanz des letzten Vorkommens eines beliebigen Zeichens in einem Zeichen Array zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3024"><xref:System.String.LastIndexOfAny%2A>, which returns a zero-based index in the current string instance of the last occurrence of any character in a character array.</span></span>

 <span data-ttu-id="8b8da-3025">Im folgenden Beispiel wird die <xref:System.String.IndexOf%2A>-Methode verwendet, um die Zeiträume in einer Zeichenfolge zu suchen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3025">The following example uses the <xref:System.String.IndexOf%2A> method to find the periods in a string.</span></span> <span data-ttu-id="8b8da-3026">Anschließend wird die <xref:System.String.Substring%2A>-Methode verwendet, um vollständige Sätze zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3026">It then uses the <xref:System.String.Substring%2A> method to return full sentences.</span></span>

 [!code-csharp-interactive[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (params char[] separator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (ParamArray separator As Char()) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(... cli::array &lt;char&gt; ^ separator);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] -&gt; string[]" Usage="string.Split separator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="8b8da-3027">Ein Zeichenarray, das die Teilzeichenfolgen in dieser Zeichenfolge trennt, ein leeres Array ohne Trennzeichen oder <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3027">A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="8b8da-3028">Unterteilt eine Zeichenfolge anhand der Zeichen im Trennlinienarray in Teilzeichenfolgen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3028">Splits a string into substrings that are based on the characters in the separator array.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3029">Ein Array, dessen Elemente die Teilzeichenfolgen von dieser Instanz enthält, die durch ein oder mehr Zeichen aus <paramref name="separator" /> getrennt sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3029">An array whose elements contain the substrings from this instance that are delimited by one or more characters in <paramref name="separator" />.</span></span> <span data-ttu-id="8b8da-3030">Weitere Informationen finden Sie im Abschnitt "Hinweise".</span><span class="sxs-lookup"><span data-stu-id="8b8da-3030">For more information, see the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-3031">Wenn eine Zeichenfolge durch einen bekannten Zeichensatz begrenzt ist, können Sie die <xref:System.String.Split%28System.Char%5B%5D%29>-Methode verwenden, um Sie in Teil Zeichenfolgen zu trennen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3031">When a string is delimited by a known set of characters, you can use the <xref:System.String.Split%28System.Char%5B%5D%29> method to separate it into substrings.</span></span>

### <a name="return-value-details"></a><span data-ttu-id="8b8da-3032">Rückgabewert Details</span><span class="sxs-lookup"><span data-stu-id="8b8da-3032">Return value details</span></span>
 <span data-ttu-id="8b8da-3033">Trennzeichen sind nicht in den Elementen des zurückgegebenen Arrays enthalten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3033">Delimiter characters are not included in the elements of the returned array.</span></span> <span data-ttu-id="8b8da-3034">Wenn das Trennzeichen Array z. b. das Zeichen "-" enthält und der Wert der aktuellen Zeichen folgen Instanz "AA-BB-CC" ist, gibt die Methode ein Array zurück, das drei Elemente enthält: "AA", "BB" und "CC".</span><span class="sxs-lookup"><span data-stu-id="8b8da-3034">For example, if the separator array includes the character "-" and the value of the current string instance is "aa-bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".</span></span>

 <span data-ttu-id="8b8da-3035">Wenn diese Instanz keines der Zeichen in `separator`enthält, besteht das zurückgegebene Array aus einem einzelnen Element, das diese Instanz enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3035">If this instance does not contain any of the characters in `separator`, the returned array consists of a single element that contains this instance.</span></span>

 <span data-ttu-id="8b8da-3036">Jedes Element von `separator` definiert ein separates Trennzeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3036">Each element of `separator` defines a separate delimiter character.</span></span> <span data-ttu-id="8b8da-3037">Wenn zwei Trennzeichen nebeneinander liegen oder ein Trennzeichen am Anfang oder Ende dieser Instanz gefunden wird, enthält das entsprechende Element im zurückgegebenen Array <xref:System.String.Empty?displayProperty=nameWithtype>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3037">If two delimiters are adjacent, or a delimiter is found at the beginning or end of this instance, the corresponding element in the returned array contains <xref:System.String.Empty?displayProperty=nameWithtype>.</span></span> <span data-ttu-id="8b8da-3038">Hier einige Beispiele:</span><span class="sxs-lookup"><span data-stu-id="8b8da-3038">Here are some examples:</span></span>

|<span data-ttu-id="8b8da-3039">Zeichen folgen Wert</span><span class="sxs-lookup"><span data-stu-id="8b8da-3039">String value</span></span>|<span data-ttu-id="8b8da-3040">Trennzeichen</span><span class="sxs-lookup"><span data-stu-id="8b8da-3040">Separator</span></span>|<span data-ttu-id="8b8da-3041">Zurück gegebenes Array</span><span class="sxs-lookup"><span data-stu-id="8b8da-3041">Returned array</span></span>|
|------------------|---------------|--------------------|
|<span data-ttu-id="8b8da-3042">"42, 12, 19"</span><span class="sxs-lookup"><span data-stu-id="8b8da-3042">"42, 12, 19"</span></span>|<span data-ttu-id="8b8da-3043">New Char [] {', ', ' '} ( C# )</span><span class="sxs-lookup"><span data-stu-id="8b8da-3043">new Char[] {',', ' '} (C#)</span></span><br /><br /> <span data-ttu-id="8b8da-3044">Char () = {"," c "," c} "(Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="8b8da-3044">Char() = {","c, " "c}) (Visual Basic)</span></span>|<span data-ttu-id="8b8da-3045">{"42", "", "12", "", "19"}</span><span class="sxs-lookup"><span data-stu-id="8b8da-3045">{"42", "", "12", "", "19"}</span></span>|
|<span data-ttu-id="8b8da-3046">"42..12..19"</span><span class="sxs-lookup"><span data-stu-id="8b8da-3046">"42..12..19"</span></span>|<span data-ttu-id="8b8da-3047">new Char[] {'.'}</span><span class="sxs-lookup"><span data-stu-id="8b8da-3047">new Char[] {'.'}</span></span> <span data-ttu-id="8b8da-3048">(C#)</span><span class="sxs-lookup"><span data-stu-id="8b8da-3048">(C#)</span></span><br /><br /> <span data-ttu-id="8b8da-3049">Char () = {"." c} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="8b8da-3049">Char() = {"."c} (Visual Basic)</span></span>|<span data-ttu-id="8b8da-3050">{"42", "", "12", "", "19"}</span><span class="sxs-lookup"><span data-stu-id="8b8da-3050">{"42", "", "12", "", "19"}</span></span>|
|<span data-ttu-id="8b8da-3051">Bananen</span><span class="sxs-lookup"><span data-stu-id="8b8da-3051">"Banana"</span></span>|<span data-ttu-id="8b8da-3052">new Char[] {'.'}</span><span class="sxs-lookup"><span data-stu-id="8b8da-3052">new Char[] {'.'}</span></span> <span data-ttu-id="8b8da-3053">(C#)</span><span class="sxs-lookup"><span data-stu-id="8b8da-3053">(C#)</span></span><br /><br /> <span data-ttu-id="8b8da-3054">Char () = {"." c} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="8b8da-3054">Char() = {"."c} (Visual Basic)</span></span>|<span data-ttu-id="8b8da-3055">{"Banana"}</span><span class="sxs-lookup"><span data-stu-id="8b8da-3055">{"Banana"}</span></span>|
|<span data-ttu-id="8b8da-3056">"Darb\nsmarba" (C#)</span><span class="sxs-lookup"><span data-stu-id="8b8da-3056">"Darb\nSmarba" (C#)</span></span><br /><br /> <span data-ttu-id="8b8da-3057">"Darb" & vbLf & "Smarba" (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="8b8da-3057">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|<span data-ttu-id="8b8da-3058">New Char [] {} ( C# )</span><span class="sxs-lookup"><span data-stu-id="8b8da-3058">new Char[] {} (C#)</span></span><br /><br /> <span data-ttu-id="8b8da-3059">Char () = {} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="8b8da-3059">Char() = {} (Visual Basic)</span></span>|<span data-ttu-id="8b8da-3060">{"Darb", "Smarba"}</span><span class="sxs-lookup"><span data-stu-id="8b8da-3060">{"Darb", "Smarba"}</span></span>|
|<span data-ttu-id="8b8da-3061">"Darb\nsmarba" (C#)</span><span class="sxs-lookup"><span data-stu-id="8b8da-3061">"Darb\nSmarba" (C#)</span></span><br /><br /> <span data-ttu-id="8b8da-3062">"Darb" & vbLf & "Smarba" (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="8b8da-3062">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|<span data-ttu-id="8b8da-3063">null (C#)</span><span class="sxs-lookup"><span data-stu-id="8b8da-3063">null (C#)</span></span><br /><br /> <span data-ttu-id="8b8da-3064">Nothing (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="8b8da-3064">Nothing (Visual Basic)</span></span>|<span data-ttu-id="8b8da-3065">{"Darb", "Smarba"}</span><span class="sxs-lookup"><span data-stu-id="8b8da-3065">{"Darb", "Smarba"}</span></span>|

### <a name="the-separator-array"></a><span data-ttu-id="8b8da-3066">Das Trennzeichen Array</span><span class="sxs-lookup"><span data-stu-id="8b8da-3066">The separator array</span></span>
 <span data-ttu-id="8b8da-3067">Jedes Element des Trenn Zeichens definiert ein separates Trennzeichen, das aus einem einzelnen Zeichen besteht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3067">Each element of separator defines a separate delimiter that consists of a single character.</span></span> <span data-ttu-id="8b8da-3068">Wenn das `separator`-Argument `null` ist oder keine Zeichen enthält, behandelt die Methode Leerzeichen als Trennzeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3068">If the `separator` argument is `null` or contains no characters, the method treats white-space characters as the delimiters.</span></span> <span data-ttu-id="8b8da-3069">Leerzeichen werden durch den Unicode-Standard definiert. Sie geben `true` zurück, wenn Sie an die <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>-Methode übermittelt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3069">White-space characters are defined by the Unicode standard; they return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span>

### <a name="stringsplitchar-and-compiler-overload-resolution"></a><span data-ttu-id="8b8da-3070">String. Split (Char []) und compilerüberladungs Auflösung</span><span class="sxs-lookup"><span data-stu-id="8b8da-3070">String.Split(Char[]) and compiler overload resolution</span></span>
 <span data-ttu-id="8b8da-3071">Obwohl der einzige Parameter für diese Überladung von <xref:System.String.Split%2A?displayProperty=nameWithType> ein Zeichen Array ist, können Sie es mit einem einzelnen Zeichen aufrufen, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3071">Although the single parameter for this overload of <xref:System.String.Split%2A?displayProperty=nameWithType> is a character array, you can call it with a single character, as the following example shows.</span></span>

 [!code-csharp-interactive[System.String.Split#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split_CompilerResolution1.cs#12)]
 [!code-vb[System.String.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split_CompilerResolution1.vb#12)]

 <span data-ttu-id="8b8da-3072">Da der `separator`-Parameter mit dem <xref:System.ParamArrayAttribute>-Attribut versehen ist, interpretieren Compiler ein einzelnes Zeichen als ein Zeichen Array mit einem einzelnen Element.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3072">Because the `separator` parameter is decorated  with the <xref:System.ParamArrayAttribute> attribute, compilers will interpret a single character as a single-element character array.</span></span> <span data-ttu-id="8b8da-3073">Dies ist nicht der Fall für andere <xref:System.String.Split%2A?displayProperty=nameWithType> Überladungen, die einen `separator`-Parameter enthalten. Sie müssen diese Überladungen explizit als `separator` Argument übergeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3073">This is not the case for other <xref:System.String.Split%2A?displayProperty=nameWithType> overloads that include a `separator` parameter; you must explicitly pass these overloads a character array as the `separator` argument.</span></span>

### <a name="comparison-details"></a><span data-ttu-id="8b8da-3074">Vergleichs Details</span><span class="sxs-lookup"><span data-stu-id="8b8da-3074">Comparison details</span></span>
 <span data-ttu-id="8b8da-3075">Die <xref:System.String.Split%28System.Char%5B%5D%29>-Methode extrahiert die Teil Zeichenfolgen in dieser Zeichenfolge, die durch ein oder mehrere der Zeichen im `separator` Array getrennt sind, und gibt diese Teil Zeichenfolgen als Elemente eines Arrays zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3075">The <xref:System.String.Split%28System.Char%5B%5D%29> method extracts the substrings in this string that are delimited by one or more of the characters in the `separator` array, and returns those substrings as elements of an array.</span></span>

 <span data-ttu-id="8b8da-3076">Die <xref:System.String.Split%28System.Char%5B%5D%29>-Methode sucht nach Trennzeichen, indem Sie Vergleiche mithilfe von ordinalsortierungs Regeln für die Groß-und Kleinschreibung durchführt</span><span class="sxs-lookup"><span data-stu-id="8b8da-3076">The <xref:System.String.Split%28System.Char%5B%5D%29> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</span></span> <span data-ttu-id="8b8da-3077">Weitere Informationen zu Wort-, Zeichen folgen-und ordinalsortierungen finden Sie in der <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>-Enumeration.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3077">For more information about word, string, and ordinal sorts, see the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeration.</span></span>

### <a name="performance-considerations"></a><span data-ttu-id="8b8da-3078">Überlegungen zur Leistung</span><span class="sxs-lookup"><span data-stu-id="8b8da-3078">Performance Considerations</span></span>
 <span data-ttu-id="8b8da-3079">Die <xref:System.String.Split%2A>-Methoden weisen Speicher für das zurückgegebene Array Objekt und ein <xref:System.String>-Objekt für jedes Array Element zu.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3079">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="8b8da-3080">Wenn Ihre Anwendung eine optimale Leistung erfordert oder wenn die Verwaltung der Speicher Belegung in Ihrer Anwendung wichtig ist, sollten Sie die <xref:System.String.IndexOf%2A>-oder <xref:System.String.IndexOfAny%2A>-Methode verwenden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3080">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method.</span></span> <span data-ttu-id="8b8da-3081">Sie haben auch die Möglichkeit, die <xref:System.String.Compare%2A>-Methode zu verwenden, um eine Teil Zeichenfolge innerhalb einer Zeichenfolge zu suchen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3081">You also have the option of using the <xref:System.String.Compare%2A> method to locate a substring within a string.</span></span>

 <span data-ttu-id="8b8da-3082">Um eine Zeichenfolge mit einem Trennzeichen aufzuteilen, verwenden Sie die <xref:System.String.IndexOf%2A>-oder <xref:System.String.IndexOfAny%2A>-Methode, um ein Trennzeichen in der Zeichenfolge zu suchen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3082">To split a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="8b8da-3083">Um eine Zeichenfolge in eine Trenn Zeichenfolge aufzuteilen, verwenden Sie die <xref:System.String.IndexOf%2A>-oder <xref:System.String.IndexOfAny%2A>-Methode, um das erste Zeichen der Trenn Zeichenfolge zu suchen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3083">To split a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="8b8da-3084">Verwenden Sie dann die <xref:System.String.Compare%2A>-Methode, um zu bestimmen, ob die Zeichen nach dem ersten Zeichen gleich den verbleibenden Zeichen der Trenn Zeichenfolge sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3084">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>

 <span data-ttu-id="8b8da-3085">Wenn außerdem die gleichen Zeichen folgen zum Aufteilen von Zeichen folgen in mehreren <xref:System.String.Split%2A> Methoden aufrufen verwendet werden, sollten Sie in Erwägung gezogen werden, ein einzelnes Array zu erstellen und in jedem Methodenaufruf darauf zu verweisen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3085">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="8b8da-3086">Dadurch wird der zusätzliche mehr Aufwand für die einzelnen Methodenaufrufe erheblich reduziert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3086">This significantly reduces the additional overhead of each method call.</span></span>

## Examples
 <span data-ttu-id="8b8da-3087">Im folgenden Beispiel wird veranschaulicht, wie einzelne Wörter aus einem Textblock extrahiert werden, indem Leerzeichen und Satzzeichen als Trennzeichen behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3087">The following example demonstrates how to extract individual words from a block of text by treating white space and punctuation marks as delimiters.</span></span> <span data-ttu-id="8b8da-3088">Das Zeichen Array, das an den `separator`-Parameter der <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType>-Methode übergeben wird, besteht aus einem Leerzeichen und einem Tabstopp Zeichen sowie einigen allgemeinen Interpunktions Symbolen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3088">The character array passed to the `separator` parameter of the <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> method consists of a space character and a tab character, together with some common punctuation symbols.</span></span>

 [!code-csharp-interactive[System.String.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split2.cs#2)]
 [!code-vb[System.String.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split2.vb#2)]

 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-3089">Wenn in der [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] und früheren Versionen der <see cref="M:System.String.Split(System.Char[])" />-Methode ein <paramref name="separator" /> an <see langword="null" /> oder keine Zeichen enthält, verwendet die-Methode einen etwas anderen Satz von Zeichen, um die Zeichenfolge zu teilen, als die <see cref="M:System.String.Trim(System.Char[])" /> Methode zum Kürzen der Zeichenfolge verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3089">In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string.</span></span> <span data-ttu-id="8b8da-3090">Beginnend mit dem .NET Framework 4 verwenden beide Methoden einen identischen Satz von Unicode-Leerzeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3090">Starting with the .NET Framework 4, both methods use an identical set of Unicode white-space characters.</span></span></para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="8b8da-3091">Ein Zeichen, das die Teilzeichenfolgen in dieser Zeichenfolge trennt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3091">A character that delimits the substrings in this string.</span></span></param>
        <param name="options"><span data-ttu-id="8b8da-3092">Einer der Enumerationswerte, der bestimmt, ob beim SPLIT-Vorgang leere Teilzeichenfolgen im Rückgabewert weggelassen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3092">One of the enumeration values that determines whether the split operation should omit empty substrings from the return value.</span></span></param>
        <summary><span data-ttu-id="8b8da-3093">Unterteilt eine Zeichenfolge anhand der angegebenen Zeichentrennlinie in Teilzeichenfolgen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3093">Splits a string into substrings based on the provided character separator.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3094">Ein Array, dessen Elemente die Teilzeichenfolgen von dieser Instanz enthält, die durch <paramref name="separator" /> getrennt sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3094">An array whose elements contain the substrings from this instance that are delimited by <paramref name="separator" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int -&gt; string[]" Usage="string.Split (separator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="8b8da-3095">Ein Zeichenarray, das die Teilzeichenfolgen in dieser Zeichenfolge trennt, ein leeres Array ohne Trennzeichen oder <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3095">A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span></span></param>
        <param name="count"><span data-ttu-id="8b8da-3096">Die maximale Anzahl der zurückzugebenden Teilzeichenfolgen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3096">The maximum number of substrings to return.</span></span></param>
        <summary><span data-ttu-id="8b8da-3097">Unterteilt eine Zeichenfolge anhand der Zeichen in einem Array in eine maximale Anzahl von Teilzeichenfolgen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3097">Splits a string into a maximum number of substrings based on the characters in an array.</span></span> <span data-ttu-id="8b8da-3098">Sie geben außerdem die maximale Anzahl der zurückzugebenden Teilzeichenfolgen an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3098">You also specify the maximum number of substrings to return.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3099">Ein Array, dessen Elemente die Teilzeichenfolgen in dieser Instanz enthält, die durch ein oder mehr Zeichen aus <paramref name="separator" /> getrennt sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3099">An array whose elements contain the substrings in this instance that are delimited by one or more characters in <paramref name="separator" />.</span></span> <span data-ttu-id="8b8da-3100">Weitere Informationen finden Sie im Abschnitt "Hinweise".</span><span class="sxs-lookup"><span data-stu-id="8b8da-3100">For more information, see the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-3101">Trennzeichen sind nicht in den Elementen des zurückgegebenen Arrays enthalten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3101">Delimiter characters are not included in the elements of the returned array.</span></span>

 <span data-ttu-id="8b8da-3102">Wenn diese Instanz keines der Zeichen in `separator`enthält, besteht das zurückgegebene Array aus einem einzelnen Element, das diese Instanz enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3102">If this instance does not contain any of the characters in `separator`, the returned array consists of a single element that contains this instance.</span></span> <span data-ttu-id="8b8da-3103">Wenn `count` NULL ist, wird ein leeres Array zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3103">If `count` is zero, an empty array is returned.</span></span>

 <span data-ttu-id="8b8da-3104">Wenn der `separator`-Parameter `null` ist oder keine Zeichen enthält, wird davon ausgegangen, dass Leerzeichen als Trennzeichen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3104">If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters.</span></span> <span data-ttu-id="8b8da-3105">Leerzeichen werden durch den Unicode-Standard definiert und geben `true` zurück, wenn Sie an die <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>-Methode übermittelt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3105">White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span>

 <span data-ttu-id="8b8da-3106">Jedes Element von `separator` definiert ein separates Trennzeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3106">Each element of `separator` defines a separate delimiter character.</span></span> <span data-ttu-id="8b8da-3107">Wenn zwei Trennzeichen nebeneinander liegen oder ein Trennzeichen am Anfang oder Ende dieser Instanz gefunden wird, enthält das entsprechende Array Element <xref:System.String.Empty?displayProperty=nameWithtype>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3107">If two delimiters are adjacent, or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty?displayProperty=nameWithtype>.</span></span>

 <span data-ttu-id="8b8da-3108">Wenn in dieser Instanz mehr als `count` Teil Zeichenfolgen vorhanden sind, werden die ersten `count` minus 1 Teil Zeichenfolgen in den ersten `count` minus 1 Elementen des Rückgabewerts zurückgegeben, und die restlichen Zeichen in dieser Instanz werden im letzten Element des Rückgabewerts zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3108">If there are more than `count` substrings in this instance, the first `count` minus 1 substrings are returned in the first `count` minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</span></span>

 <span data-ttu-id="8b8da-3109">Wenn `count` größer als die Anzahl der Teil Zeichenfolgen ist, werden die verfügbaren Teil Zeichenfolgen zurückgegeben, und es wird keine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3109">If `count` is greater than the number of substrings, the available substrings are returned and no exception is thrown.</span></span>

 <span data-ttu-id="8b8da-3110">In der folgenden Tabelle finden Sie Beispiele.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3110">The following table provides examples.</span></span>

|<span data-ttu-id="8b8da-3111">Zeichen folgen Wert</span><span class="sxs-lookup"><span data-stu-id="8b8da-3111">String value</span></span>|<span data-ttu-id="8b8da-3112">Trennzeichen</span><span class="sxs-lookup"><span data-stu-id="8b8da-3112">Separator</span></span>|<span data-ttu-id="8b8da-3113">Anzahl</span><span class="sxs-lookup"><span data-stu-id="8b8da-3113">Count</span></span>|<span data-ttu-id="8b8da-3114">Zurück gegebenes Array</span><span class="sxs-lookup"><span data-stu-id="8b8da-3114">Returned array</span></span>|
|------------------|---------------|-----------|--------------------|
|<span data-ttu-id="8b8da-3115">"42, 12, 19"</span><span class="sxs-lookup"><span data-stu-id="8b8da-3115">"42, 12, 19"</span></span>|<span data-ttu-id="8b8da-3116">New Char [] {', ', ' '} ( C# )</span><span class="sxs-lookup"><span data-stu-id="8b8da-3116">new Char[] {',', ' '} (C#)</span></span><br /><br /> <span data-ttu-id="8b8da-3117">Char () = {"," c "," c} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="8b8da-3117">Char() = {","c, " "c} (Visual Basic)</span></span>|<span data-ttu-id="8b8da-3118">2</span><span class="sxs-lookup"><span data-stu-id="8b8da-3118">2</span></span>|<span data-ttu-id="8b8da-3119">{"42", " 12, 19"}</span><span class="sxs-lookup"><span data-stu-id="8b8da-3119">{"42", " 12, 19"}</span></span>|
|<span data-ttu-id="8b8da-3120">"42..12..19"</span><span class="sxs-lookup"><span data-stu-id="8b8da-3120">"42..12..19"</span></span>|<span data-ttu-id="8b8da-3121">new Char[] {'.'}</span><span class="sxs-lookup"><span data-stu-id="8b8da-3121">new Char[] {'.'}</span></span> <span data-ttu-id="8b8da-3122">(C#)</span><span class="sxs-lookup"><span data-stu-id="8b8da-3122">(C#)</span></span><br /><br /> <span data-ttu-id="8b8da-3123">Char () = {"." c} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="8b8da-3123">Char() = {"."c} (Visual Basic)</span></span>|<span data-ttu-id="8b8da-3124">4</span><span class="sxs-lookup"><span data-stu-id="8b8da-3124">4</span></span>|<span data-ttu-id="8b8da-3125">{"42", "", "12", ".19"}</span><span class="sxs-lookup"><span data-stu-id="8b8da-3125">{"42", "", "12", ".19"}</span></span>|
|<span data-ttu-id="8b8da-3126">Bananen</span><span class="sxs-lookup"><span data-stu-id="8b8da-3126">"Banana"</span></span>|<span data-ttu-id="8b8da-3127">new Char[] {'.'}</span><span class="sxs-lookup"><span data-stu-id="8b8da-3127">new Char[] {'.'}</span></span> <span data-ttu-id="8b8da-3128">(C#)</span><span class="sxs-lookup"><span data-stu-id="8b8da-3128">(C#)</span></span><br /><br /> <span data-ttu-id="8b8da-3129">Char () = {"." c} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="8b8da-3129">Char() = {"."c} (Visual Basic)</span></span>|<span data-ttu-id="8b8da-3130">2</span><span class="sxs-lookup"><span data-stu-id="8b8da-3130">2</span></span>|<span data-ttu-id="8b8da-3131">{"Banana"}</span><span class="sxs-lookup"><span data-stu-id="8b8da-3131">{"Banana"}</span></span>|
|<span data-ttu-id="8b8da-3132">"Darb\nsmarba" (C#)</span><span class="sxs-lookup"><span data-stu-id="8b8da-3132">"Darb\nSmarba" (C#)</span></span><br /><br /> <span data-ttu-id="8b8da-3133">"Darb" & vbLf & "Smarba" (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="8b8da-3133">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|<span data-ttu-id="8b8da-3134">New Char [] {} ( C# )</span><span class="sxs-lookup"><span data-stu-id="8b8da-3134">new Char[] {} (C#)</span></span><br /><br /> <span data-ttu-id="8b8da-3135">Char () = {} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="8b8da-3135">Char() = {} (Visual Basic)</span></span>|<span data-ttu-id="8b8da-3136">1</span><span class="sxs-lookup"><span data-stu-id="8b8da-3136">1</span></span>|<span data-ttu-id="8b8da-3137">{"Darb\nsmarba"} (C#)</span><span class="sxs-lookup"><span data-stu-id="8b8da-3137">{"Darb\nSmarba"} (C#)</span></span><br /><br /> <span data-ttu-id="8b8da-3138">"Darb" & vbLf & "Smarba" (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="8b8da-3138">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|
|<span data-ttu-id="8b8da-3139">"Darb\nsmarba" (C#)</span><span class="sxs-lookup"><span data-stu-id="8b8da-3139">"Darb\nSmarba" (C#)</span></span><br /><br /> <span data-ttu-id="8b8da-3140">"Darb" & vbLf & "Smarba" (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="8b8da-3140">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|<span data-ttu-id="8b8da-3141">New Char [] NULL ( C# )</span><span class="sxs-lookup"><span data-stu-id="8b8da-3141">new Char[] null (C#)</span></span><br /><br /> <span data-ttu-id="8b8da-3142">Char () = Nothing</span><span class="sxs-lookup"><span data-stu-id="8b8da-3142">Char() = Nothing</span></span>|<span data-ttu-id="8b8da-3143">2</span><span class="sxs-lookup"><span data-stu-id="8b8da-3143">2</span></span>|<span data-ttu-id="8b8da-3144">{"Darb", "Smarba"}</span><span class="sxs-lookup"><span data-stu-id="8b8da-3144">{"Darb", "Smarba"}</span></span>|
|<span data-ttu-id="8b8da-3145">"Darb\nsmarba" (C#)</span><span class="sxs-lookup"><span data-stu-id="8b8da-3145">"Darb\nSmarba" (C#)</span></span><br /><br /> <span data-ttu-id="8b8da-3146">"Darb" & vbLf & "Smarba" (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="8b8da-3146">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|<span data-ttu-id="8b8da-3147">New Char [] NULL ( C# )</span><span class="sxs-lookup"><span data-stu-id="8b8da-3147">new Char[] null (C#)</span></span><br /><br /> <span data-ttu-id="8b8da-3148">Char () = Nothing</span><span class="sxs-lookup"><span data-stu-id="8b8da-3148">Char() = Nothing</span></span>|<span data-ttu-id="8b8da-3149">100</span><span class="sxs-lookup"><span data-stu-id="8b8da-3149">100</span></span>|<span data-ttu-id="8b8da-3150">{"Darb", "Smarba"}</span><span class="sxs-lookup"><span data-stu-id="8b8da-3150">{"Darb", "Smarba"}</span></span>|

### <a name="performance-considerations"></a><span data-ttu-id="8b8da-3151">Überlegungen zur Leistung</span><span class="sxs-lookup"><span data-stu-id="8b8da-3151">Performance Considerations</span></span>
 <span data-ttu-id="8b8da-3152">Die <xref:System.String.Split%2A>-Methoden weisen Speicher für das zurückgegebene Array Objekt und ein <xref:System.String>-Objekt für jedes Array Element zu.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3152">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="8b8da-3153">Wenn Ihre Anwendung eine optimale Leistung erfordert oder wenn die Verwaltung der Speicher Belegung in der Anwendung wichtig ist, sollten Sie die <xref:System.String.IndexOf%2A>-oder <xref:System.String.IndexOfAny%2A> Methode und optional die <xref:System.String.Compare%2A>-Methode verwenden, um eine Teil Zeichenfolge innerhalb einer Zeichenfolge zu suchen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3153">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.</span></span>

 <span data-ttu-id="8b8da-3154">Wenn Sie eine Zeichenfolge mit einem Trennzeichen teilen, verwenden Sie die <xref:System.String.IndexOf%2A>-oder <xref:System.String.IndexOfAny%2A>-Methode, um ein Trennzeichen in der Zeichenfolge zu suchen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3154">If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="8b8da-3155">Wenn Sie eine Zeichenfolge in eine Trenn Zeichenfolge aufteilen, verwenden Sie die <xref:System.String.IndexOf%2A>-oder <xref:System.String.IndexOfAny%2A>-Methode, um das erste Zeichen der Trenn Zeichenfolge zu suchen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3155">If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="8b8da-3156">Verwenden Sie dann die <xref:System.String.Compare%2A>-Methode, um zu bestimmen, ob die Zeichen nach dem ersten Zeichen gleich den verbleibenden Zeichen der Trenn Zeichenfolge sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3156">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>

 <span data-ttu-id="8b8da-3157">Wenn außerdem die gleichen Zeichen folgen zum Aufteilen von Zeichen folgen in mehreren <xref:System.String.Split%2A> Methoden aufrufen verwendet werden, sollten Sie in Erwägung gezogen werden, ein einzelnes Array zu erstellen und in jedem Methodenaufruf darauf zu verweisen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3157">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="8b8da-3158">Dadurch wird der zusätzliche mehr Aufwand für die einzelnen Methodenaufrufe erheblich reduziert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3158">This significantly reduces the additional overhead of each method call.</span></span>



## Examples
 <span data-ttu-id="8b8da-3159">Im folgenden Beispiel wird veranschaulicht, wie `count` die Anzahl der von <xref:System.String.Split%2A>zurückgegebenen Zeichen folgen beeinflusst.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3159">The following example demonstrates how `count` affects the number of strings returned by <xref:System.String.Split%2A>.</span></span>

 [!code-csharp-interactive[StringSplit2#10](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/StringSplit10.cs#10)]
 [!code-vb[StringSplit2#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit10.vb#10)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-3160"><paramref name="count" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3160"><paramref name="count" /> is negative.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-3161">Wenn in der [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] und früheren Versionen der <see cref="M:System.String.Split(System.Char[])" />-Methode ein <paramref name="separator" /> an <see langword="null" /> oder keine Zeichen enthält, verwendet die-Methode einen etwas anderen Satz von Zeichen, um die Zeichenfolge zu teilen, als die <see cref="M:System.String.Trim(System.Char[])" /> Methode zum Kürzen der Zeichenfolge verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3161">In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string.</span></span> <span data-ttu-id="8b8da-3162">Beginnend mit dem .NET Framework 4 verwenden beide Methoden einen identischen Satz von Unicode-Leerzeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3162">Starting with the .NET Framework 4, both methods use an identical set of Unicode white-space characters.</span></span></para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="8b8da-3163">Ein Zeichenarray, das die Teilzeichenfolgen in dieser Zeichenfolge trennt, ein leeres Array ohne Trennzeichen oder <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3163">A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span></span></param>
        <param name="options"><span data-ttu-id="8b8da-3164"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />, wenn leere Arrayelemente aus dem zurückgegebenen Array ausgelassen werden sollen, oder <see cref="F:System.StringSplitOptions.None" />, wenn leere Arrayelemente in das zurückgegebene Array eingeschlossen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3164"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements from the array returned; or <see cref="F:System.StringSplitOptions.None" /> to include empty array elements in the array returned.</span></span></param>
        <summary><span data-ttu-id="8b8da-3165">Unterteilt eine Zeichenfolge anhand der Zeichen in einem Array in Teilzeichenfolgen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3165">Splits a string into substrings based on the characters in an array.</span></span> <span data-ttu-id="8b8da-3166">Sie können angeben, ob die Teilzeichenfolgen auch leere Arrayelemente umfassen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3166">You can specify whether the substrings include empty array elements.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3167">Ein Array, dessen Elemente die Teilzeichenfolgen in dieser Zeichenfolge enthält, die durch ein oder mehr Zeichen aus <paramref name="separator" /> getrennt sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3167">An array whose elements contain the substrings in this string that are delimited by one or more characters in <paramref name="separator" />.</span></span> <span data-ttu-id="8b8da-3168">Weitere Informationen finden Sie im Abschnitt "Hinweise".</span><span class="sxs-lookup"><span data-stu-id="8b8da-3168">For more information, see the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

### <a name="return-value-details"></a><span data-ttu-id="8b8da-3169">Rückgabewert Details</span><span class="sxs-lookup"><span data-stu-id="8b8da-3169">Return value details</span></span>
 <span data-ttu-id="8b8da-3170">Trennzeichen (die Zeichen im `separator` Array) sind nicht in den Elementen des zurückgegebenen Arrays enthalten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3170">Delimiter characters (the characters in the `separator` array) are not included in the elements of the returned array.</span></span> <span data-ttu-id="8b8da-3171">Wenn das `separator` Array z. b. das Zeichen "-" enthält und der Wert der aktuellen Zeichen folgen Instanz "AA-BB-CC" ist, gibt die Methode ein Array zurück, das drei Elemente enthält: "AA", "BB" und "CC".</span><span class="sxs-lookup"><span data-stu-id="8b8da-3171">For example, if the `separator` array includes the character "-" and the value of the current string instance is "aa-bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".</span></span>

 <span data-ttu-id="8b8da-3172">Wenn diese Instanz keines der Zeichen in `separator`enthält, besteht das zurückgegebene Array aus einem einzelnen Element, das diese Instanz enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3172">If this instance does not contain any of the characters in `separator`, the returned array consists of a single element that contains this instance.</span></span>

 <span data-ttu-id="8b8da-3173">Wenn der `options`-Parameter <xref:System.StringSplitOptions.RemoveEmptyEntries> ist und die Länge dieser Instanz 0 (null) ist, gibt die Methode ein leeres Array zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3173">If the `options` parameter is <xref:System.StringSplitOptions.RemoveEmptyEntries> and the length of this instance is zero, the method returns an empty array.</span></span>

 <span data-ttu-id="8b8da-3174">Jedes Element von `separator` definiert ein separates Trennzeichen, das aus einem einzelnen Zeichen besteht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3174">Each element of `separator` defines a separate delimiter that consists of a single character.</span></span> <span data-ttu-id="8b8da-3175">Wenn das `options`-Argument <xref:System.StringSplitOptions.None>ist und zwei Trennzeichen nebeneinander liegen oder ein Trennzeichen am Anfang oder Ende dieser Instanz gefunden wird, enthält das entsprechende Array Element <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3175">If the `options` argument is <xref:System.StringSplitOptions.None>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8b8da-3176">Wenn `separator` z. b. zwei Elemente enthält: "-" und "\_", ist der Wert der Zeichen folgen Instanz "-\_AA-\_", und der Wert des `options` Arguments ist <xref:System.StringSplitOptions.None>. die Methode gibt ein Zeichen folgen Array mit den folgenden fünf Elementen zurück:</span><span class="sxs-lookup"><span data-stu-id="8b8da-3176">For example, if `separator` includes  two elements, "-" and "\_", the value of the string instance is "-\_aa-\_", and the value of   the `options` argument is <xref:System.StringSplitOptions.None>, the method returns a string array with the following five elements:</span></span>

1.  <span data-ttu-id="8b8da-3177"><xref:System.String.Empty?displayProperty=nameWithType>, die die leere Zeichenfolge darstellt, die dem Zeichen "-" am Index 0 vorangestellt ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3177"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that precedes the "-" character at index 0.</span></span>

2.  <span data-ttu-id="8b8da-3178"><xref:System.String.Empty?displayProperty=nameWithType>, das die leere Zeichenfolge zwischen dem Zeichen "-" bei Index 0 und dem Zeichen "_" bei Index 1 darstellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3178"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string between the "-" character at index 0 and the "_" character at index 1.</span></span>

3.  <span data-ttu-id="8b8da-3179">"aa",</span><span class="sxs-lookup"><span data-stu-id="8b8da-3179">"aa",</span></span>

4.  <span data-ttu-id="8b8da-3180"><xref:System.String.Empty?displayProperty=nameWithType>, die die leere Zeichenfolge darstellt, die auf das Zeichen "_" bei Index 4 folgt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3180"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that follows the "_" character at index 4.</span></span>

5.  <span data-ttu-id="8b8da-3181"><xref:System.String.Empty?displayProperty=nameWithType>, die die leere Zeichenfolge darstellt, die auf das Zeichen "-" am Index 5 folgt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3181"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that follows the "-" character at index 5.</span></span>

### <a name="the-separator-array"></a><span data-ttu-id="8b8da-3182">Das Trennzeichen Array</span><span class="sxs-lookup"><span data-stu-id="8b8da-3182">The separator array</span></span>
 <span data-ttu-id="8b8da-3183">Wenn der `separator`-Parameter `null` ist oder keine Zeichen enthält, wird davon ausgegangen, dass Leerzeichen als Trennzeichen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3183">If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters.</span></span> <span data-ttu-id="8b8da-3184">Leerzeichen werden durch den Unicode-Standard definiert und geben `true` zurück, wenn Sie an die <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>-Methode übermittelt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3184">White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span>

 <span data-ttu-id="8b8da-3185">Wenn der `separator`-Parameter im Aufrufen dieser Methoden Überladung `null`ist, misslingt die compilerüberladungs Auflösung.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3185">If the `separator` parameter in the call to this method overload is `null`, compiler overload resolution fails.</span></span> <span data-ttu-id="8b8da-3186">Um die aufgerufene Methode eindeutig zu identifizieren, muss der Code den Typ des `null`angeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3186">To unambiguously identify the called method, your code must indicate the type of the `null`.</span></span> <span data-ttu-id="8b8da-3187">Im folgenden Beispiel werden mehrere Möglichkeiten zum eindeutigen Identifizieren dieser Überladung veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3187">The following example shows several ways to unambiguously identify this overload.</span></span>

 [!code-csharp[System.String.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#5)]
 [!code-vb[System.String.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#5)]

### <a name="comparison-details"></a><span data-ttu-id="8b8da-3188">Vergleichs Details</span><span class="sxs-lookup"><span data-stu-id="8b8da-3188">Comparison details</span></span>
 <span data-ttu-id="8b8da-3189">Die <xref:System.String.Split%2A>-Methode extrahiert die Teil Zeichenfolgen in dieser Zeichenfolge, die durch ein oder mehrere der Zeichen im Parameter `separator` getrennt sind, und gibt diese Teil Zeichenfolgen als Elemente eines Arrays zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3189">The <xref:System.String.Split%2A> method extracts the substrings in this string that are delimited by one or more of the characters in the `separator` parameter, and returns those substrings as elements of an array.</span></span>

 <span data-ttu-id="8b8da-3190">Die <xref:System.String.Split%2A>-Methode sucht nach Trennzeichen, indem Sie Vergleiche mithilfe von ordinalsortierungs Regeln für die Groß-und Kleinschreibung durchführt</span><span class="sxs-lookup"><span data-stu-id="8b8da-3190">The <xref:System.String.Split%2A> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</span></span> <span data-ttu-id="8b8da-3191">Weitere Informationen zu Wort-, Zeichen folgen-und ordinalsortierungen finden Sie in der <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>-Enumeration.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3191">For more information about word, string, and ordinal sorts, see the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeration.</span></span>

### <a name="performance-considerations"></a><span data-ttu-id="8b8da-3192">Überlegungen zur Leistung</span><span class="sxs-lookup"><span data-stu-id="8b8da-3192">Performance Considerations</span></span>
 <span data-ttu-id="8b8da-3193">Die <xref:System.String.Split%2A>-Methoden weisen Speicher für das zurückgegebene Array Objekt und ein <xref:System.String>-Objekt für jedes Array Element zu.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3193">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="8b8da-3194">Wenn Ihre Anwendung eine optimale Leistung erfordert oder wenn die Verwaltung der Speicher Belegung in der Anwendung wichtig ist, sollten Sie die <xref:System.String.IndexOf%2A>-oder <xref:System.String.IndexOfAny%2A> Methode und optional die <xref:System.String.Compare%2A>-Methode verwenden, um eine Teil Zeichenfolge innerhalb einer Zeichenfolge zu suchen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3194">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.</span></span>

 <span data-ttu-id="8b8da-3195">Wenn Sie eine Zeichenfolge mit einem Trennzeichen teilen, verwenden Sie die <xref:System.String.IndexOf%2A>-oder <xref:System.String.IndexOfAny%2A>-Methode, um ein Trennzeichen in der Zeichenfolge zu suchen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3195">If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="8b8da-3196">Wenn Sie eine Zeichenfolge in eine Trenn Zeichenfolge aufteilen, verwenden Sie die <xref:System.String.IndexOf%2A>-oder <xref:System.String.IndexOfAny%2A>-Methode, um das erste Zeichen der Trenn Zeichenfolge zu suchen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3196">If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="8b8da-3197">Verwenden Sie dann die <xref:System.String.Compare%2A>-Methode, um zu bestimmen, ob die Zeichen nach dem ersten Zeichen gleich den verbleibenden Zeichen der Trenn Zeichenfolge sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3197">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>

 <span data-ttu-id="8b8da-3198">Wenn außerdem die gleichen Zeichen folgen zum Aufteilen von Zeichen folgen in mehreren <xref:System.String.Split%2A> Methoden aufrufen verwendet werden, sollten Sie in Erwägung gezogen werden, ein einzelnes Array zu erstellen und in jedem Methodenaufruf darauf zu verweisen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3198">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="8b8da-3199">Dadurch wird der zusätzliche mehr Aufwand für die einzelnen Methodenaufrufe erheblich reduziert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3199">This significantly reduces the additional overhead of each method call.</span></span>



## Examples
 <span data-ttu-id="8b8da-3200">Im folgenden Beispiel wird die <xref:System.StringSplitOptions>-Enumeration verwendet, um von der <xref:System.String.Split%2A>-Methode generierte Teil Zeichenfolgen einzuschließen oder auszuschließen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3200">The following example uses the <xref:System.StringSplitOptions> enumeration to include or exclude substrings generated by the <xref:System.String.Split%2A> method.</span></span>

 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8b8da-3201"><paramref name="options" /> ist keiner der <see cref="T:System.StringSplitOptions" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3201"><paramref name="options" /> is not one of the <see cref="T:System.StringSplitOptions" /> values.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-3202">Wenn in der [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] und früheren Versionen der <see cref="M:System.String.Split(System.Char[])" />-Methode ein <paramref name="separator" /> an <see langword="null" /> oder keine Zeichen enthält, verwendet die-Methode einen etwas anderen Satz von Zeichen, um die Zeichenfolge zu teilen, als die <see cref="M:System.String.Trim(System.Char[])" /> Methode zum Kürzen der Zeichenfolge verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3202">In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string.</span></span> <span data-ttu-id="8b8da-3203">Beginnend mit dem .NET Framework 4 verwenden beide Methoden einen identischen Satz von Unicode-Leerzeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3203">Starting with the .NET Framework 4, both methods use an identical set of Unicode white-space characters.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="8b8da-3204">Eine Zeichenfolge, die die Teilzeichenfolgen in dieser Zeichenfolge trennt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3204">A string that delimits the substrings in this string.</span></span></param>
        <param name="options"><span data-ttu-id="8b8da-3205">Einer der Enumerationswerte, der bestimmt, ob beim SPLIT-Vorgang leere Teilzeichenfolgen im Rückgabewert weggelassen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3205">One of the enumeration values that determines whether the split operation should omit empty substrings from the return value.</span></span></param>
        <summary><span data-ttu-id="8b8da-3206">Unterteilt eine Zeichenfolge anhand der angegebenen Zeichenfolgentrennlinie in Teilzeichenfolgen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3206">Splits a string into substrings that are based on the provided string separator.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3207">Ein Array, dessen Elemente die Teilzeichenfolgen von dieser Instanz enthält, die durch <paramref name="separator" /> getrennt sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3207">An array whose elements contain the substrings from this instance that are delimited by <paramref name="separator" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="8b8da-3208">Ein Array mit Zeichenfolgen, die die Teilzeichenfolgen in dieser Zeichenfolge trennen, ein leeres Array ohne Trennzeichen oder <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3208">A string array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span></span></param>
        <param name="options"><span data-ttu-id="8b8da-3209"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />, wenn leere Arrayelemente aus dem zurückgegebenen Array ausgelassen werden sollen, oder <see cref="F:System.StringSplitOptions.None" />, wenn leere Arrayelemente in das zurückgegebene Array eingeschlossen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3209"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements from the array returned; or <see cref="F:System.StringSplitOptions.None" /> to include empty array elements in the array returned.</span></span></param>
        <summary><span data-ttu-id="8b8da-3210">Unterteilt eine Zeichenfolge anhand der Zeichenfolgen in einem Array in Teilzeichenfolgen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3210">Splits a string into substrings based on the strings in an array.</span></span> <span data-ttu-id="8b8da-3211">Sie können angeben, ob die Teilzeichenfolgen auch leere Arrayelemente umfassen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3211">You can specify whether the substrings include empty array elements.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3212">Ein Array, dessen Elemente die Teilzeichenfolgen in dieser Zeichenfolge enthält, die durch ein oder mehr Zeichenfolgen aus <paramref name="separator" /> getrennt sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3212">An array whose elements contain the substrings in this string that are delimited by one or more strings in <paramref name="separator" />.</span></span> <span data-ttu-id="8b8da-3213">Weitere Informationen finden Sie im Abschnitt "Hinweise".</span><span class="sxs-lookup"><span data-stu-id="8b8da-3213">For more information, see the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-3214">Wenn eine Zeichenfolge durch einen bekannten Satz von Zeichen folgen getrennt ist, können Sie die <xref:System.String.Split%2A>-Methode verwenden, um Sie in Teil Zeichenfolgen zu trennen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3214">When a string is delimited by a known set of strings, you can use the <xref:System.String.Split%2A> method to separate it into substrings.</span></span>

### <a name="return-value-details"></a><span data-ttu-id="8b8da-3215">Rückgabewert Details</span><span class="sxs-lookup"><span data-stu-id="8b8da-3215">Return value details</span></span>
 <span data-ttu-id="8b8da-3216">Trennzeichen-Zeichen folgen sind nicht in den Elementen des zurückgegebenen Arrays enthalten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3216">Delimiter strings are not included in the elements of the returned array.</span></span> <span data-ttu-id="8b8da-3217">Wenn das `separator` Array z. b. die Zeichenfolge "--" enthält und der Wert der aktuellen Zeichen folgen Instanz "AA--BB-CC" ist, gibt die Methode ein Array zurück, das drei Elemente enthält: "AA", "BB" und "CC".</span><span class="sxs-lookup"><span data-stu-id="8b8da-3217">For example, if the `separator` array includes the string "--" and the value of the current string instance is "aa--bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".</span></span>

 <span data-ttu-id="8b8da-3218">Wenn diese Instanz keine der Zeichen folgen in `separator`enthält, besteht das zurückgegebene Array aus einem einzelnen Element, das diese Instanz enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3218">If this instance does not contain any of the strings in `separator`, the returned array consists of a single element that contains this instance.</span></span>

 <span data-ttu-id="8b8da-3219">Wenn der `options`-Parameter <xref:System.StringSplitOptions.RemoveEmptyEntries> ist und die Länge dieser Instanz 0 (null) ist, gibt die Methode ein leeres Array zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3219">If the `options` parameter is <xref:System.StringSplitOptions.RemoveEmptyEntries> and the length of this instance is zero, the method returns an empty array.</span></span>

 <span data-ttu-id="8b8da-3220">Jedes Element von `separator` definiert ein separates Trennzeichen, das aus einem oder mehreren Zeichen besteht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3220">Each element of `separator` defines a separate delimiter that consists of one or more characters.</span></span> <span data-ttu-id="8b8da-3221">Wenn das `options`-Argument <xref:System.StringSplitOptions.None>ist und zwei Trennzeichen nebeneinander liegen oder ein Trennzeichen am Anfang oder Ende dieser Instanz gefunden wird, enthält das entsprechende Array Element <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3221">If the `options` argument is <xref:System.StringSplitOptions.None>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8b8da-3222">Wenn `separator` z. b. zwei Elemente enthält: "-" und "\_", ist der Wert der Zeichen folgen Instanz "-\_AA-\_", und der Wert des `options` Arguments ist <xref:System.StringSplitOptions.None>. die Methode gibt ein Sting-Array mit den folgenden fünf Elementen zurück:</span><span class="sxs-lookup"><span data-stu-id="8b8da-3222">For example, if `separator` includes  two elements, "-" and "\_", the value of the string instance is "-\_aa-\_", and the value of   the `options` argument is <xref:System.StringSplitOptions.None>, the method returns a sting array with the following five elements:</span></span>

1.  <span data-ttu-id="8b8da-3223"><xref:System.String.Empty?displayProperty=nameWithType>, die die leere Zeichenfolge darstellt, die der "-"-Teil Zeichenfolge bei Index 0 vorangestellt ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3223"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that precedes the "-" substring at index 0.</span></span>

2.  <span data-ttu-id="8b8da-3224"><xref:System.String.Empty?displayProperty=nameWithType>, das die leere Zeichenfolge zwischen der "-"-Teil Zeichenfolge bei Index 0 und der Teil Zeichenfolge "_" bei Index 1 darstellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3224"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string between the "-" substring at index 0 and the "_" substring at index 1.</span></span>

3.  <span data-ttu-id="8b8da-3225">"aa",</span><span class="sxs-lookup"><span data-stu-id="8b8da-3225">"aa",</span></span>

4.  <span data-ttu-id="8b8da-3226"><xref:System.String.Empty?displayProperty=nameWithType>, die die leere Zeichenfolge darstellt, die auf die Teil Zeichenfolge "_" bei Index 4 folgt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3226"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that follows the "_" substring at index 4.</span></span>

5.  <span data-ttu-id="8b8da-3227"><xref:System.String.Empty?displayProperty=nameWithType>, die die leere Zeichenfolge darstellt, die auf die Teil Zeichenfolge "-" bei Index 5 folgt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3227"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that follows the "-" substring at index 5.</span></span>

### <a name="the-separator-array"></a><span data-ttu-id="8b8da-3228">Das Trennzeichen Array</span><span class="sxs-lookup"><span data-stu-id="8b8da-3228">The separator array</span></span>
 <span data-ttu-id="8b8da-3229">Wenn eines der Elemente in `separator` aus mehreren Zeichen besteht, gilt die gesamte Teil Zeichenfolge als Trennzeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3229">If any of the elements in `separator` consists of multiple characters, the entire substring is considered a delimiter.</span></span> <span data-ttu-id="8b8da-3230">Wenn eines der Elemente in `separator` z. b. "10" ist, wird versucht, die Zeichenfolge "This10is10a10string" aufzuteilen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3230">For example, if one of the elements in `separator` is "10", attempting to split the string "This10is10a10string."</span></span> <span data-ttu-id="8b8da-3231">Gibt das folgende Array von vier Elementen zurück: {"This", "is", "a", "String".</span><span class="sxs-lookup"><span data-stu-id="8b8da-3231">returns the following four-element array: { "This", "is", "a", "string."</span></span> <span data-ttu-id="8b8da-3232">}.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3232">}.</span></span>

 <span data-ttu-id="8b8da-3233">Wenn der `separator`-Parameter `null` ist oder keine Zeichen enthält, wird davon ausgegangen, dass Leerzeichen als Trennzeichen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3233">If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters.</span></span> <span data-ttu-id="8b8da-3234">Leerzeichen werden durch den Unicode-Standard definiert und geben `true` zurück, wenn Sie an die <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>-Methode übermittelt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3234">White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span>

 <span data-ttu-id="8b8da-3235">Wenn der `separator`-Parameter im Aufrufen dieser Methoden Überladung `null`ist, misslingt die compilerüberladungs Auflösung.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3235">If the `separator` parameter in the call to this method overload is `null`, compiler overload resolution fails.</span></span> <span data-ttu-id="8b8da-3236">Um die aufgerufene Methode eindeutig zu identifizieren, muss der Code den Typ des `null`angeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3236">To unambiguously identify the called method, your code must indicate the type of the `null`.</span></span> <span data-ttu-id="8b8da-3237">Im folgenden Beispiel werden mehrere Möglichkeiten zum eindeutigen Identifizieren dieser Überladung veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3237">The following example shows several ways to unambiguously identify this overload.</span></span>

 [!code-csharp[System.String.Split#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#6)]
 [!code-vb[System.String.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#6)]

### <a name="comparison-details"></a><span data-ttu-id="8b8da-3238">Vergleichs Details</span><span class="sxs-lookup"><span data-stu-id="8b8da-3238">Comparison details</span></span>
 <span data-ttu-id="8b8da-3239">Die <xref:System.String.Split%2A>-Methode extrahiert die Teil Zeichenfolgen in dieser Zeichenfolge, die durch eine oder mehrere der Zeichen folgen im `separator`-Parameter getrennt sind, und gibt diese Teil Zeichenfolgen als Elemente eines Arrays zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3239">The <xref:System.String.Split%2A> method extracts the substrings in this string that are delimited by one or more of the strings in the `separator` parameter, and returns those substrings as elements of an array.</span></span>

 <span data-ttu-id="8b8da-3240">Die <xref:System.String.Split%2A>-Methode sucht nach Trennzeichen, indem Sie Vergleiche mithilfe von ordinalsortierungs Regeln für die Groß-und Kleinschreibung durchführt</span><span class="sxs-lookup"><span data-stu-id="8b8da-3240">The <xref:System.String.Split%2A> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</span></span> <span data-ttu-id="8b8da-3241">Weitere Informationen zu Wort-, Zeichen folgen-und ordinalsortierungen finden Sie in der <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>-Enumeration.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3241">For more information about word, string, and ordinal sorts, see the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeration.</span></span>

 <span data-ttu-id="8b8da-3242">Die <xref:System.String.Split%2A>-Methode ignoriert jedes Element `separator`, dessen Wert `null` oder die leere Zeichenfolge ("") ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3242">The <xref:System.String.Split%2A> method ignores any element of `separator` whose value is `null` or the empty string ("").</span></span>

 <span data-ttu-id="8b8da-3243">Um mehrdeutige Ergebnisse zu vermeiden, wenn Zeichen folgen in `separator` Zeichen gemeinsam haben, wird der <xref:System.String.Split%2A> Vorgang von Anfang bis zum Ende des Werts der-Instanz fortgesetzt und entspricht dem ersten Element in `separator`, das gleich einem Trennzeichen in der-Instanz ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3243">To avoid ambiguous results when strings in `separator` have characters in common, the <xref:System.String.Split%2A> operation proceeds from the beginning to the end of the value of the instance, and matches the first element in `separator` that is equal to a delimiter in the instance.</span></span> <span data-ttu-id="8b8da-3244">Die Reihenfolge, in der Teil Zeichenfolgen in der Instanz gefunden werden, hat Vorrang vor der Reihenfolge der Elemente in `separator`.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3244">The order in which substrings are encountered in the instance takes precedence over the order of elements in `separator`.</span></span>

 <span data-ttu-id="8b8da-3245">Stellen Sie sich z. b. eine Instanz vor, deren Wert "abcdef" ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3245">For example, consider an instance whose value is "abcdef".</span></span> <span data-ttu-id="8b8da-3246">Wenn das erste Element in `separator` "EF" und das zweite Element "bcde" war, wäre das Ergebnis des Split-Vorgangs ein Zeichen folgen Array, das zwei Elemente enthält: "a" und "f".</span><span class="sxs-lookup"><span data-stu-id="8b8da-3246">If the first element in `separator` was "ef" and the second element was "bcde", the result of the split operation would be a string array that contains two elements, "a" and "f".</span></span> <span data-ttu-id="8b8da-3247">Dies liegt daran, dass die Teil Zeichenfolge in der-Instanz, "bcde", gefunden wird und mit einem Element in `separator` übereinstimmt, bevor die Teil Zeichenfolge "f" gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3247">This is because the substring in the instance, "bcde", is encountered and matches an element in `separator` before the substring "f" is encountered.</span></span>

 <span data-ttu-id="8b8da-3248">Wenn das erste Element von `separator` jedoch "BCD" und das zweite Element "BC" war, wäre das Ergebnis des Split-Vorgangs ein Zeichen folgen Array, das zwei Elemente enthält: "a" und "EF".</span><span class="sxs-lookup"><span data-stu-id="8b8da-3248">However, if the first element of `separator` was "bcd" and the second element was "bc", the result of the split operation would be a string array that contains two elements, "a" and "ef".</span></span> <span data-ttu-id="8b8da-3249">Dies liegt daran, dass "BCD" das erste Trennzeichen in `separator` ist, das mit einem Trennzeichen in der-Instanz übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3249">This is because "bcd" is the first delimiter in `separator` that matches a delimiter in the instance.</span></span> <span data-ttu-id="8b8da-3250">Wenn die Reihenfolge der Trennzeichen umgekehrt wurde, sodass das erste Element "BC" und das zweite Element "BCD" war, wäre das Ergebnis ein Zeichen folgen Array, das zwei Elemente enthält: "a" und "Def".</span><span class="sxs-lookup"><span data-stu-id="8b8da-3250">If the order of the separators was reversed so the first element was "bc" and the second element was "bcd", the result would be a string array that contains two elements,  "a" and "def".</span></span>

### <a name="performance-considerations"></a><span data-ttu-id="8b8da-3251">Überlegungen zur Leistung</span><span class="sxs-lookup"><span data-stu-id="8b8da-3251">Performance considerations</span></span>
 <span data-ttu-id="8b8da-3252">Die <xref:System.String.Split%2A>-Methoden weisen Speicher für das zurückgegebene Array Objekt und ein <xref:System.String>-Objekt für jedes Array Element zu.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3252">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="8b8da-3253">Wenn Ihre Anwendung eine optimale Leistung erfordert oder wenn die Verwaltung der Speicher Belegung in der Anwendung wichtig ist, sollten Sie die <xref:System.String.IndexOf%2A>-oder <xref:System.String.IndexOfAny%2A> Methode und optional die <xref:System.String.Compare%2A>-Methode verwenden, um eine Teil Zeichenfolge innerhalb einer Zeichenfolge zu suchen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3253">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.</span></span>

 <span data-ttu-id="8b8da-3254">Wenn Sie eine Zeichenfolge mit einem Trennzeichen teilen, verwenden Sie die <xref:System.String.IndexOf%2A>-oder <xref:System.String.IndexOfAny%2A>-Methode, um ein Trennzeichen in der Zeichenfolge zu suchen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3254">If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="8b8da-3255">Wenn Sie eine Zeichenfolge in eine Trenn Zeichenfolge aufteilen, verwenden Sie die <xref:System.String.IndexOf%2A>-oder <xref:System.String.IndexOfAny%2A>-Methode, um das erste Zeichen der Trenn Zeichenfolge zu suchen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3255">If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="8b8da-3256">Verwenden Sie dann die <xref:System.String.Compare%2A>-Methode, um zu bestimmen, ob die Zeichen nach dem ersten Zeichen gleich den verbleibenden Zeichen der Trenn Zeichenfolge sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3256">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>

 <span data-ttu-id="8b8da-3257">Wenn außerdem die gleichen Zeichen folgen zum Aufteilen von Zeichen folgen in mehreren <xref:System.String.Split%2A> Methoden aufrufen verwendet werden, sollten Sie in Erwägung gezogen werden, ein einzelnes Array zu erstellen und in jedem Methodenaufruf darauf zu verweisen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3257">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="8b8da-3258">Dadurch wird der zusätzliche mehr Aufwand für die einzelnen Methodenaufrufe erheblich reduziert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3258">This significantly reduces the additional overhead of each method call.</span></span>



## Examples
 <span data-ttu-id="8b8da-3259">Im folgenden Beispiel wird der Unterschied in den Arrays veranschaulicht, die durch Aufrufen der <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType>-Methode einer Zeichenfolge zurückgegeben werden, deren `options`-Parameter gleich <xref:System.StringSplitOptions.None?displayProperty=nameWithType> und <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3259">The following example illustrates the difference in the arrays returned by calling a string's <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType> method with its `options` parameter equal to <xref:System.StringSplitOptions.None?displayProperty=nameWithType> and <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>.</span></span>

 [!code-csharp-interactive[System.String.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split.cs#1)]
 [!code-vb[System.String.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split.vb#1)]

 <span data-ttu-id="8b8da-3260">Im folgenden Beispiel wird ein Array von Trennzeichen definiert, das Interpunktions-und Leerzeichen enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3260">The following example defines an array of separators that include punctuation and white-space characters.</span></span> <span data-ttu-id="8b8da-3261">Wenn Sie dieses Array zusammen mit dem Wert <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType> an die <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> Methode übergeben, wird ein Array zurückgegeben, das aus den einzelnen Wörtern aus der Zeichenfolge besteht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3261">Passing this array along with a value of <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType> to the <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> method returns an array that consists of the individual words from the string.</span></span>

 [!code-csharp-interactive[System.String.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split7.cs#7)]
 [!code-vb[System.String.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split7.vb#7)]

 <span data-ttu-id="8b8da-3262">Beachten Sie, dass die-Methode aufgerufen wird, wobei das `options` Argument auf <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3262">Note that the method is called with the `options` argument set to <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8b8da-3263">Dadurch wird verhindert, dass das zurückgegebene Array <xref:System.String.Empty?displayProperty=nameWithType> Werte einschließt, die leere Teil Zeichenfolgen-Übereinstimmungen zwischen Interpunktions Zeichen und Leerzeichen darstellen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3263">This prevents the returned array from including <xref:System.String.Empty?displayProperty=nameWithType> values that represent empty substring matches between punctuation marks and white-space characters.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8b8da-3264"><paramref name="options" /> ist keiner der <see cref="T:System.StringSplitOptions" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3264"><paramref name="options" /> is not one of the <see cref="T:System.StringSplitOptions" /> values.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-3265">Wenn in der [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] und früheren Versionen der <see cref="M:System.String.Split(System.Char[])" />-Methode ein <paramref name="separator" /> an <see langword="null" /> oder keine Zeichen enthält, verwendet die-Methode einen etwas anderen Satz von Zeichen, um die Zeichenfolge zu teilen, als die <see cref="M:System.String.Trim(System.Char[])" /> Methode zum Kürzen der Zeichenfolge verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3265">In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string.</span></span> <span data-ttu-id="8b8da-3266">Beginnend mit dem .NET Framework 4 verwenden beide Methoden einen identischen Satz von Unicode-Leerzeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3266">Starting with the .NET Framework 4, both methods use an identical set of Unicode white-space characters.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="8b8da-3267">Ein Zeichen, das die Teilzeichenfolgen in dieser Instanz trennt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3267">A character that delimits the substrings in this instance.</span></span></param>
        <param name="count"><span data-ttu-id="8b8da-3268">Die maximale Anzahl der im Array erwarteten Elemente.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3268">The maximum number of elements expected in the array.</span></span></param>
        <param name="options"><span data-ttu-id="8b8da-3269">Einer der Enumerationswerte, der bestimmt, ob beim SPLIT-Vorgang leere Teilzeichenfolgen im Rückgabewert weggelassen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3269">One of the enumeration values that determines whether the split operation should omit empty substrings from the return value.</span></span></param>
        <summary><span data-ttu-id="8b8da-3270">Unterteilt eine Zeichenfolge anhand der angegebenen Zeichentrennlinie in eine maximale Anzahl von Teilzeichenfolgen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3270">Splits a string into a maximum number substrings based on the provided character separator.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3271">Ein Array, dessen Elemente maximal <paramref name="count" /> Teilzeichenfolgen von dieser Instanz enthält, die durch <paramref name="separator" /> getrennt sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3271">An array whose elements contain at most <paramref name="count" /> substrings from this instance that are delimited by <paramref name="separator" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="8b8da-3272">Wenn die Zeichenfolge bereits `count`-1-mal geteilt wurde, das Ende der Zeichenfolge aber nicht erreicht wurde, enthält die letzte Zeichenfolge im zurückgegebenen Array die verbleibende nachfolgende Teil Zeichenfolge dieser Instanz unverändert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3272">If the string has already been split `count` - 1 times, but the end of the string has not been reached, then the last string in the returned array will contain this instance's remaining trailing substring, untouched.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="8b8da-3273">Ein Zeichenarray, das die Teilzeichenfolgen in dieser Zeichenfolge trennt, ein leeres Array ohne Trennzeichen oder <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3273">A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span></span></param>
        <param name="count"><span data-ttu-id="8b8da-3274">Die maximale Anzahl der zurückzugebenden Teilzeichenfolgen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3274">The maximum number of substrings to return.</span></span></param>
        <param name="options"><span data-ttu-id="8b8da-3275"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />, wenn leere Arrayelemente aus dem zurückgegebenen Array ausgelassen werden sollen, oder <see cref="F:System.StringSplitOptions.None" />, wenn leere Arrayelemente in das zurückgegebene Array eingeschlossen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3275"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements from the array returned; or <see cref="F:System.StringSplitOptions.None" /> to include empty array elements in the array returned.</span></span></param>
        <summary><span data-ttu-id="8b8da-3276">Unterteilt eine Zeichenfolge anhand der Zeichen in einem Array in eine maximale Anzahl von Teilzeichenfolgen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3276">Splits a string into a maximum number of substrings based on the characters in an array.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3277">Ein Array, dessen Elemente die Teilzeichenfolgen in dieser Zeichenfolge enthält, die durch ein oder mehr Zeichen aus <paramref name="separator" /> getrennt sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3277">An array whose elements contain the substrings in this string that are delimited by one or more characters in <paramref name="separator" />.</span></span> <span data-ttu-id="8b8da-3278">Weitere Informationen finden Sie im Abschnitt "Hinweise".</span><span class="sxs-lookup"><span data-stu-id="8b8da-3278">For more information, see the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-3279">Trennzeichen sind nicht in den Elementen des zurückgegebenen Arrays enthalten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3279">Delimiter characters are not included in the elements of the returned array.</span></span>

 <span data-ttu-id="8b8da-3280">Wenn diese Instanz keines der Zeichen in `separator`enthält oder der `count` Parameter 1 ist, besteht das zurückgegebene Array aus einem einzelnen Element, das diese Instanz enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3280">If this instance does not contain any of the characters in `separator`, or the `count` parameter is 1, the returned array consists of a single element that contains this instance.</span></span> <span data-ttu-id="8b8da-3281">Wenn der `separator`-Parameter `null` ist oder keine Zeichen enthält, wird davon ausgegangen, dass Leerzeichen als Trennzeichen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3281">If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters.</span></span> <span data-ttu-id="8b8da-3282">Leerzeichen werden durch den Unicode-Standard definiert und geben `true` zurück, wenn Sie an die <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>-Methode übermittelt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3282">White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="8b8da-3283">Wenn der `separator`-Parameter im Aufrufen dieser Methoden Überladung jedoch `null`ist, misslingt die compilerüberladungs Auflösung.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3283">However, if the `separator` parameter in the call to this method overload is `null`, compiler overload resolution fails.</span></span> <span data-ttu-id="8b8da-3284">Um die aufgerufene Methode eindeutig zu identifizieren, muss der Code den Typ der NULL angeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3284">To unambiguously identify the called method, your code must indicate the type of the null.</span></span> <span data-ttu-id="8b8da-3285">Im folgenden Beispiel werden mehrere Möglichkeiten zum eindeutigen Identifizieren dieser Überladung veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3285">The following example shows several ways to unambiguously identify this overload.</span></span>

 [!code-csharp[System.String.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#3)]
 [!code-vb[System.String.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#3)]

 <span data-ttu-id="8b8da-3286">Wenn der `count`-Parameter 0 (null) ist, oder wenn der `options`-Parameter <xref:System.StringSplitOptions.RemoveEmptyEntries> ist und die Länge dieser Instanz 0 (null) ist, wird ein leeres Array zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3286">If the `count` parameter is zero, or the `options` parameter is <xref:System.StringSplitOptions.RemoveEmptyEntries> and the length of this instance is zero, an empty array is returned.</span></span>

 <span data-ttu-id="8b8da-3287">Jedes Element von `separator` definiert ein separates Trennzeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3287">Each element of `separator` defines a separate delimiter character.</span></span> <span data-ttu-id="8b8da-3288">Wenn der `options`-Parameter <xref:System.StringSplitOptions.None>ist und zwei Trennzeichen nebeneinander liegen oder ein Trennzeichen am Anfang oder Ende dieser Instanz gefunden wird, enthält das entsprechende Array Element <xref:System.String.Empty?displayProperty=nameWithtype>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3288">If the `options` parameter is <xref:System.StringSplitOptions.None>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty?displayProperty=nameWithtype>.</span></span>

 <span data-ttu-id="8b8da-3289">Wenn in dieser Instanz mehr als `count` Teil Zeichenfolgen vorhanden sind, werden die ersten `count` minus 1 Teil Zeichenfolgen in den ersten `count` minus 1 Elementen des Rückgabewerts zurückgegeben, und die restlichen Zeichen in dieser Instanz werden im letzten Element des Rückgabewerts zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3289">If there are more than `count` substrings in this instance, the first `count` minus 1 substrings are returned in the first `count` minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</span></span>

 <span data-ttu-id="8b8da-3290">Wenn `count` größer als die Anzahl der Teil Zeichenfolgen ist, werden die verfügbaren Teil Zeichenfolgen zurückgegeben, und es wird keine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3290">If `count` is greater than the number of substrings, the available substrings are returned and no exception is thrown.</span></span>

### <a name="performance-considerations"></a><span data-ttu-id="8b8da-3291">Überlegungen zur Leistung</span><span class="sxs-lookup"><span data-stu-id="8b8da-3291">Performance Considerations</span></span>
 <span data-ttu-id="8b8da-3292">Die <xref:System.String.Split%2A>-Methoden weisen Speicher für das zurückgegebene Array Objekt und ein <xref:System.String>-Objekt für jedes Array Element zu.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3292">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="8b8da-3293">Wenn Ihre Anwendung eine optimale Leistung erfordert oder wenn die Verwaltung der Speicher Belegung in der Anwendung wichtig ist, sollten Sie die <xref:System.String.IndexOf%2A>-oder <xref:System.String.IndexOfAny%2A> Methode und optional die <xref:System.String.Compare%2A>-Methode verwenden, um eine Teil Zeichenfolge innerhalb einer Zeichenfolge zu suchen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3293">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.</span></span>

 <span data-ttu-id="8b8da-3294">Wenn Sie eine Zeichenfolge mit einem Trennzeichen teilen, verwenden Sie die <xref:System.String.IndexOf%2A>-oder <xref:System.String.IndexOfAny%2A>-Methode, um ein Trennzeichen in der Zeichenfolge zu suchen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3294">If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="8b8da-3295">Wenn Sie eine Zeichenfolge in eine Trenn Zeichenfolge aufteilen, verwenden Sie die <xref:System.String.IndexOf%2A>-oder <xref:System.String.IndexOfAny%2A>-Methode, um das erste Zeichen der Trenn Zeichenfolge zu suchen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3295">If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="8b8da-3296">Verwenden Sie dann die <xref:System.String.Compare%2A>-Methode, um zu bestimmen, ob die Zeichen nach dem ersten Zeichen gleich den verbleibenden Zeichen der Trenn Zeichenfolge sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3296">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>

 <span data-ttu-id="8b8da-3297">Wenn außerdem die gleichen Zeichen folgen zum Aufteilen von Zeichen folgen in mehreren <xref:System.String.Split%2A> Methoden aufrufen verwendet werden, sollten Sie in Erwägung gezogen werden, ein einzelnes Array zu erstellen und in jedem Methodenaufruf darauf zu verweisen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3297">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="8b8da-3298">Dadurch wird der zusätzliche mehr Aufwand für die einzelnen Methodenaufrufe erheblich reduziert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3298">This significantly reduces the additional overhead of each method call.</span></span>



## Examples
 <span data-ttu-id="8b8da-3299">Im folgenden Beispiel wird die <xref:System.StringSplitOptions>-Enumeration verwendet, um von der <xref:System.String.Split%2A>-Methode generierte Teil Zeichenfolgen einzuschließen oder auszuschließen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3299">The following example uses the <xref:System.StringSplitOptions> enumeration to include or exclude substrings generated by the <xref:System.String.Split%2A> method.</span></span>

 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-3300"><paramref name="count" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3300"><paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8b8da-3301"><paramref name="options" /> ist keiner der <see cref="T:System.StringSplitOptions" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3301"><paramref name="options" /> is not one of the <see cref="T:System.StringSplitOptions" /> values.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-3302">Wenn in der [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] und früheren Versionen der <see cref="M:System.String.Split(System.Char[])" />-Methode ein <paramref name="separator" /> an <see langword="null" /> oder keine Zeichen enthält, verwendet die-Methode einen etwas anderen Satz von Zeichen, um die Zeichenfolge zu teilen, als die <see cref="M:System.String.Trim(System.Char[])" /> Methode zum Kürzen der Zeichenfolge verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3302">In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string.</span></span> <span data-ttu-id="8b8da-3303">Beginnend mit dem .NET Framework 4 verwenden beide Methoden einen identischen Satz von Unicode-Leerzeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3303">Starting with the .NET Framework 4, both methods use an identical set of Unicode white-space characters.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="8b8da-3304">Eine Zeichenfolge, die die Teilzeichenfolgen in dieser Instanz trennt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3304">A string that delimits the substrings in this instance.</span></span></param>
        <param name="count"><span data-ttu-id="8b8da-3305">Die maximale Anzahl der im Array erwarteten Elemente.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3305">The maximum number of elements expected in the array.</span></span></param>
        <param name="options"><span data-ttu-id="8b8da-3306">Einer der Enumerationswerte, der bestimmt, ob beim SPLIT-Vorgang leere Teilzeichenfolgen im Rückgabewert weggelassen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3306">One of the enumeration values that determines whether the split operation should omit empty substrings from the return value.</span></span></param>
        <summary><span data-ttu-id="8b8da-3307">Unterteilt eine Zeichenfolge anhand der angegebenen Zeichenfolgentrennlinie in eine maximale Anzahl von Teilzeichenfolgen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3307">Splits a string into a maximum number of substrings based on the provided string separator.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3308">Ein Array, dessen Elemente maximal <paramref name="count" /> Teilzeichenfolgen von dieser Instanz enthält, die durch <paramref name="separator" /> getrennt sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3308">An array whose elements contain at most <paramref name="count" /> substrings from this instance that are delimited by <paramref name="separator" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="8b8da-3309">Wenn die Zeichenfolge bereits `count`-1-mal geteilt wurde, das Ende der Zeichenfolge aber nicht erreicht wurde, enthält die letzte Zeichenfolge im zurückgegebenen Array die verbleibende nachfolgende Teil Zeichenfolge dieser Instanz unverändert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3309">If the string has already been split `count` - 1 times, but the end of the string has not been reached, then the last string in the returned array will contain this instance's remaining trailing substring, untouched.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator"><span data-ttu-id="8b8da-3310">Ein Array mit Zeichenfolgen, die die Teilzeichenfolgen in dieser Zeichenfolge trennen, ein leeres Array ohne Trennzeichen oder <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3310">A string array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span></span></param>
        <param name="count"><span data-ttu-id="8b8da-3311">Die maximale Anzahl der zurückzugebenden Teilzeichenfolgen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3311">The maximum number of substrings to return.</span></span></param>
        <param name="options"><span data-ttu-id="8b8da-3312"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />, wenn leere Arrayelemente aus dem zurückgegebenen Array ausgelassen werden sollen, oder <see cref="F:System.StringSplitOptions.None" />, wenn leere Arrayelemente in das zurückgegebene Array eingeschlossen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3312"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements from the array returned; or <see cref="F:System.StringSplitOptions.None" /> to include empty array elements in the array returned.</span></span></param>
        <summary><span data-ttu-id="8b8da-3313">Unterteilt eine Zeichenfolge anhand der Zeichenfolgen in einem Array in eine maximale Anzahl von Teilzeichenfolgen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3313">Splits a string into a maximum number of substrings based on the strings in an array.</span></span> <span data-ttu-id="8b8da-3314">Sie können angeben, ob die Teilzeichenfolgen auch leere Arrayelemente umfassen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3314">You can specify whether the substrings include empty array elements.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3315">Ein Array, dessen Elemente die Teilzeichenfolgen in dieser Zeichenfolge enthält, die durch ein oder mehr Zeichenfolgen aus <paramref name="separator" /> getrennt sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3315">An array whose elements contain the substrings in this string that are delimited by one or more strings in <paramref name="separator" />.</span></span> <span data-ttu-id="8b8da-3316">Weitere Informationen finden Sie im Abschnitt "Hinweise".</span><span class="sxs-lookup"><span data-stu-id="8b8da-3316">For more information, see the Remarks section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

### <a name="return-value-details"></a><span data-ttu-id="8b8da-3317">Rückgabewert Details</span><span class="sxs-lookup"><span data-stu-id="8b8da-3317">Return value details</span></span>
 <span data-ttu-id="8b8da-3318">Trennzeichen-Zeichen folgen sind nicht in den Elementen des zurückgegebenen Arrays enthalten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3318">Delimiter strings are not included in the elements of the returned array.</span></span>

 <span data-ttu-id="8b8da-3319">Wenn diese Instanz keine der Zeichen folgen in `separator`enthält oder der `count` Parameter 1 ist, besteht das zurückgegebene Array aus einem einzelnen Element, das diese Instanz enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3319">If this instance does not contain any of the strings in `separator`, or the `count` parameter is 1, the returned array consists of a single element that contains this instance.</span></span> <span data-ttu-id="8b8da-3320">Wenn der `separator`-Parameter `null` ist oder keine Zeichen enthält, wird davon ausgegangen, dass Leerzeichen als Trennzeichen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3320">If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters.</span></span> <span data-ttu-id="8b8da-3321">Leerzeichen werden durch den Unicode-Standard definiert und geben `true` zurück, wenn Sie an die <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>-Methode übermittelt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3321">White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="8b8da-3322">Wenn der `separator`-Parameter im Aufrufen dieser Methoden Überladung jedoch `null`ist, misslingt die compilerüberladungs Auflösung.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3322">However, if the `separator` parameter in the call to this method overload is `null`, compiler overload resolution fails.</span></span> <span data-ttu-id="8b8da-3323">Um die aufgerufene Methode eindeutig zu identifizieren, muss der Code den Typ des `null`angeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3323">To unambiguously identify the called method, your code must indicate the type of the `null`.</span></span> <span data-ttu-id="8b8da-3324">Im folgenden Beispiel werden mehrere Möglichkeiten zum eindeutigen Identifizieren dieser Überladung veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3324">The following example shows several ways to unambiguously identify this overload.</span></span>

 [!code-csharp[System.String.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#4)]
 [!code-vb[System.String.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#4)]

 <span data-ttu-id="8b8da-3325">Wenn der `count`-Parameter 0 (null) ist, oder wenn der `options`-Parameter <xref:System.StringSplitOptions.RemoveEmptyEntries> ist und die Länge dieser Instanz 0 (null) ist, wird ein leeres Array zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3325">If the `count` parameter is zero, or the `options` parameter is <xref:System.StringSplitOptions.RemoveEmptyEntries> and the length of this instance is zero, an empty array is returned.</span></span>

 <span data-ttu-id="8b8da-3326">Jedes Element von `separator` definiert ein separates Trennzeichen, das aus einem oder mehreren Zeichen besteht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3326">Each element of `separator` defines a separate delimiter that consists of one or more characters.</span></span> <span data-ttu-id="8b8da-3327">Wenn der `options`-Parameter <xref:System.StringSplitOptions.None>ist und zwei Trennzeichen nebeneinander liegen oder ein Trennzeichen am Anfang oder Ende dieser Instanz gefunden wird, enthält das entsprechende Array Element <xref:System.String.Empty?displayProperty=nameWithtype>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3327">If the `options` parameter is <xref:System.StringSplitOptions.None>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty?displayProperty=nameWithtype>.</span></span>

 <span data-ttu-id="8b8da-3328">Wenn in dieser Instanz mehr als `count` Teil Zeichenfolgen vorhanden sind, werden die ersten `count` minus 1 Teil Zeichenfolgen in den ersten `count` minus 1 Elementen des Rückgabewerts zurückgegeben, und die restlichen Zeichen in dieser Instanz werden im letzten Element des Rückgabewerts zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3328">If there are more than `count` substrings in this instance, the first `count` minus 1 substrings are returned in the first `count` minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</span></span>

 <span data-ttu-id="8b8da-3329">Wenn `count` größer als die Anzahl der Teil Zeichenfolgen ist, werden die verfügbaren Teil Zeichenfolgen zurückgegeben, und es wird keine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3329">If `count` is greater than the number of substrings, the available substrings are returned and no exception is thrown.</span></span>

### <a name="the-separator-array"></a><span data-ttu-id="8b8da-3330">Das Trennzeichen Array</span><span class="sxs-lookup"><span data-stu-id="8b8da-3330">The separator array</span></span>
 <span data-ttu-id="8b8da-3331">Wenn eines der Elemente in `separator` aus mehreren Zeichen besteht, gilt die gesamte Teil Zeichenfolge als Trennzeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3331">If any of the elements in `separator` consists of multiple characters, the entire substring is considered a delimiter.</span></span> <span data-ttu-id="8b8da-3332">Wenn eines der Elemente in `separator` z. b. "10" ist, wird versucht, die Zeichenfolge "This10is10a10string" aufzuteilen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3332">For example, if one of the elements in `separator` is "10", attempting to split the string "This10is10a10string."</span></span> <span data-ttu-id="8b8da-3333">gibt dieses Array mit vier Elementen zurück: {"This", "is", "a", "String".</span><span class="sxs-lookup"><span data-stu-id="8b8da-3333">returns this four-element array: { "This", "is", "a", "string."</span></span> <span data-ttu-id="8b8da-3334">}.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3334">}.</span></span>

### <a name="comparison-details"></a><span data-ttu-id="8b8da-3335">Vergleichs Details</span><span class="sxs-lookup"><span data-stu-id="8b8da-3335">Comparison details</span></span>
 <span data-ttu-id="8b8da-3336">Die <xref:System.String.Split%2A>-Methode extrahiert die Teil Zeichenfolgen in dieser Zeichenfolge, die durch eine oder mehrere der Zeichen folgen im `separator`-Parameter getrennt sind, und gibt diese Teil Zeichenfolgen als Elemente eines Arrays zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3336">The <xref:System.String.Split%2A> method extracts the substrings in this string that are delimited by one or more of the strings in the `separator` parameter, and returns those substrings as elements of an array.</span></span>

 <span data-ttu-id="8b8da-3337">Die <xref:System.String.Split%2A>-Methode sucht nach Trennzeichen, indem Sie Vergleiche mithilfe von ordinalsortierungs Regeln für die Groß-und Kleinschreibung durchführt</span><span class="sxs-lookup"><span data-stu-id="8b8da-3337">The <xref:System.String.Split%2A> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</span></span> <span data-ttu-id="8b8da-3338">Weitere Informationen zu Wort-, Zeichen folgen-und ordinalsortierungen finden Sie in der <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>-Enumeration.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3338">For more information about word, string, and ordinal sorts, see the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeration.</span></span>

 <span data-ttu-id="8b8da-3339">Die <xref:System.String.Split%2A>-Methode ignoriert jedes Element `separator`, dessen Wert `null` oder die leere Zeichenfolge ("") ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3339">The <xref:System.String.Split%2A> method ignores any element of `separator` whose value is `null` or the empty string ("").</span></span>

 <span data-ttu-id="8b8da-3340">Um mehrdeutige Ergebnisse zu vermeiden, wenn Zeichen folgen in `separator` Zeichen gemeinsam haben, fährt die <xref:System.String.Split%2A>-Methode von Anfang bis Ende des Werts der-Instanz fort und entspricht dem ersten Element in `separator`, das gleich einem Trennzeichen in der-Instanz ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3340">To avoid ambiguous results when strings in `separator` have characters in common, the <xref:System.String.Split%2A> method proceeds from the beginning to the end of the value of the instance, and matches the first element in `separator` that is equal to a delimiter in the instance.</span></span> <span data-ttu-id="8b8da-3341">Die Reihenfolge, in der Teil Zeichenfolgen in der Instanz gefunden werden, hat Vorrang vor der Reihenfolge der Elemente in `separator`.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3341">The order in which substrings are encountered in the instance takes precedence over the order of elements in `separator`.</span></span>

 <span data-ttu-id="8b8da-3342">Stellen Sie sich z. b. eine Instanz vor, deren Wert "abcdef" ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3342">For example, consider an instance whose value is "abcdef".</span></span> <span data-ttu-id="8b8da-3343">Wenn das erste Element in `separator` "EF" und das zweite Element "bcde" war, wäre das Ergebnis des Split-Vorgangs "a" und "f".</span><span class="sxs-lookup"><span data-stu-id="8b8da-3343">If the first element in `separator` was "ef" and the second element was "bcde", the result of the split operation would be "a" and "f".</span></span> <span data-ttu-id="8b8da-3344">Dies liegt daran, dass die Teil Zeichenfolge in der-Instanz, "bcde", gefunden wird und mit einem Element in `separator` übereinstimmt, bevor die Teil Zeichenfolge "f" gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3344">This is because the substring in the instance, "bcde", is encountered and matches an element in `separator` before the substring "f" is encountered.</span></span>

 <span data-ttu-id="8b8da-3345">Wenn das erste Element von `separator` jedoch "BCD" und das zweite Element "BC" war, würde das Ergebnis des Split-Vorgangs "a" und "EF" lauten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3345">However, if the first element of `separator` was "bcd" and the second element was "bc", the result of the split operation would be "a" and "ef".</span></span> <span data-ttu-id="8b8da-3346">Dies liegt daran, dass "BCD" das erste Trennzeichen in `separator` ist, das mit einem Trennzeichen in der-Instanz übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3346">This is because "bcd" is the first delimiter in `separator` that matches a delimiter in the instance.</span></span> <span data-ttu-id="8b8da-3347">Wenn die Reihenfolge der Trennzeichen umgekehrt wurde, sodass das erste Element "BC" und das zweite Element "BCD" war, wäre das Ergebnis "a" und "Def".</span><span class="sxs-lookup"><span data-stu-id="8b8da-3347">If the order of the separators was reversed so the first element was "bc" and the second element was "bcd", the result would be "a" and "def".</span></span>

### <a name="performance-considerations"></a><span data-ttu-id="8b8da-3348">Überlegungen zur Leistung</span><span class="sxs-lookup"><span data-stu-id="8b8da-3348">Performance considerations</span></span>
 <span data-ttu-id="8b8da-3349">Die <xref:System.String.Split%2A>-Methoden weisen Speicher für das zurückgegebene Array Objekt und ein <xref:System.String>-Objekt für jedes Array Element zu.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3349">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="8b8da-3350">Wenn Ihre Anwendung eine optimale Leistung erfordert oder wenn die Verwaltung der Speicher Belegung in der Anwendung wichtig ist, sollten Sie die <xref:System.String.IndexOf%2A>-oder <xref:System.String.IndexOfAny%2A> Methode und optional die <xref:System.String.Compare%2A>-Methode verwenden, um eine Teil Zeichenfolge innerhalb einer Zeichenfolge zu suchen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3350">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.</span></span>

 <span data-ttu-id="8b8da-3351">Wenn Sie eine Zeichenfolge mit einem Trennzeichen teilen, verwenden Sie die <xref:System.String.IndexOf%2A>-oder <xref:System.String.IndexOfAny%2A>-Methode, um ein Trennzeichen in der Zeichenfolge zu suchen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3351">If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="8b8da-3352">Wenn Sie eine Zeichenfolge in eine Trenn Zeichenfolge aufteilen, verwenden Sie die <xref:System.String.IndexOf%2A>-oder <xref:System.String.IndexOfAny%2A>-Methode, um das erste Zeichen der Trenn Zeichenfolge zu suchen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3352">If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="8b8da-3353">Verwenden Sie dann die <xref:System.String.Compare%2A>-Methode, um zu bestimmen, ob die Zeichen nach dem ersten Zeichen gleich den verbleibenden Zeichen der Trenn Zeichenfolge sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3353">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>

 <span data-ttu-id="8b8da-3354">Wenn außerdem die gleichen Zeichen folgen zum Aufteilen von Zeichen folgen in mehreren <xref:System.String.Split%2A> Methoden aufrufen verwendet werden, sollten Sie in Erwägung gezogen werden, ein einzelnes Array zu erstellen und in jedem Methodenaufruf darauf zu verweisen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3354">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="8b8da-3355">Dadurch wird der zusätzliche mehr Aufwand für die einzelnen Methodenaufrufe erheblich reduziert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3355">This significantly reduces the additional overhead of each method call.</span></span>



## Examples
 <span data-ttu-id="8b8da-3356">Im folgenden Beispiel wird die <xref:System.StringSplitOptions>-Enumeration verwendet, um von der <xref:System.String.Split%2A>-Methode generierte Teil Zeichenfolgen einzuschließen oder auszuschließen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3356">The following example uses the <xref:System.StringSplitOptions> enumeration to include or exclude substrings generated by the <xref:System.String.Split%2A> method.</span></span>

 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-3357"><paramref name="count" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3357"><paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8b8da-3358"><paramref name="options" /> ist keiner der <see cref="T:System.StringSplitOptions" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3358"><paramref name="options" /> is not one of the <see cref="T:System.StringSplitOptions" /> values.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-3359">Wenn in der [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] und früheren Versionen der <see cref="M:System.String.Split(System.Char[])" />-Methode ein <paramref name="separator" /> an <see langword="null" /> oder keine Zeichen enthält, verwendet die-Methode einen etwas anderen Satz von Zeichen, um die Zeichenfolge zu teilen, als die <see cref="M:System.String.Trim(System.Char[])" /> Methode zum Kürzen der Zeichenfolge verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3359">In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string.</span></span> <span data-ttu-id="8b8da-3360">Beginnend mit dem .NET Framework 4 verwenden beide Methoden einen identischen Satz von Unicode-Leerzeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3360">Starting with the .NET Framework 4, both methods use an identical set of Unicode white-space characters.</span></span></para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8b8da-3361">Bestimmt, ob der Anfang dieser Zeichenfolgeninstanz mit einer angegebenen Zeichenfolge übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3361">Determines whether the beginning of this string instance matches a specified string.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : char -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-3362">Das zu vergleichende Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3362">The character to compare.</span></span></param>
        <summary><span data-ttu-id="8b8da-3363">Bestimmt, ob diese Zeichenfolgeninstanz mit dem angegebenen Zeichen beginnt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3363">Determines whether this string instance starts with the specified character.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3364"><see langword="true" />, wenn <paramref name="value" /> mit dem Anfang dieser Zeichenfolge übereinstimmt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3364"><see langword="true" /> if <paramref name="value" /> matches the beginning of this string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="8b8da-3365">Diese Methode führt einen Vergleich mit der aktuellen Kultur durch (Unterscheidung nach Groß-/Kleinschreibung und Kultur sensitiv).</span><span class="sxs-lookup"><span data-stu-id="8b8da-3365">This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-3366">Die zu vergleichende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3366">The string to compare.</span></span></param>
        <summary><span data-ttu-id="8b8da-3367">Bestimmt, ob der Anfang dieser Zeichenfolgeninstanz mit der angegebenen Zeichenfolge übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3367">Determines whether the beginning of this string instance matches the specified string.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3368"><see langword="true" />, wenn <paramref name="value" /> mit dem Anfang dieser Zeichenfolge übereinstimmt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3368"><see langword="true" /> if <paramref name="value" /> matches the beginning of this string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="8b8da-3369">Diese Methode vergleicht `value` mit der Teil Zeichenfolge am Anfang dieser Instanz, die dieselbe Länge wie `value`hat, und gibt eine Angabe darüber zurück, ob Sie gleich sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3369">This method compares `value` to the substring at the beginning of this instance that is the same length as `value`, and returns an indication whether they are equal.</span></span> <span data-ttu-id="8b8da-3370">Um gleich zu sein, muss `value` eine leere Zeichenfolge (<xref:System.String.Empty?displayProperty=nameWithType>) sein, muss ein Verweis auf dieselbe Instanz sein oder mit dem Anfang dieser Instanz übereinstimmen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3370">To be equal, `value` must be an empty string (<xref:System.String.Empty?displayProperty=nameWithType>), must be a reference to this same instance, or must match the beginning of this instance.</span></span>

<span data-ttu-id="8b8da-3371">Diese Methode führt einen Vergleich mit der aktuellen Kultur durch (Unterscheidung nach Groß-/Kleinschreibung und Kultur sensitiv).</span><span class="sxs-lookup"><span data-stu-id="8b8da-3371">This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</span></span>

## Examples

<span data-ttu-id="8b8da-3372">Im folgenden Beispiel wird eine `StripStartTags`-Methode definiert, die die <xref:System.String.StartsWith%28System.String%29>-Methode verwendet, um HTML-Start Tags vom Anfang einer Zeichenfolge zu entfernen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3372">The following example defines a `StripStartTags` method that uses the <xref:System.String.StartsWith%28System.String%29> method to remove HTML start tags from the beginning of a string.</span></span> <span data-ttu-id="8b8da-3373">Beachten Sie, dass die `StripStartTags`-Methode rekursiv aufgerufen wird, um sicherzustellen, dass mehrere HTML-Starttags am Zeilen Anfang entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3373">Note that the `StripStartTags` method is called recursively to ensure that multiple HTML start tags at the beginning of the line are removed.</span></span> <span data-ttu-id="8b8da-3374">In diesem Beispiel werden keine in eine Zeichenfolge eingebetteten HTML-Tags entfernt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3374">The example does not remove HTML tags embedded in a string.</span></span>

:::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/stringstartswith/CPP/stringstartswith.cpp" id="Snippet1":::
:::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringstartswith/CS/stringstartswith.cs" interactive="try-dotnet" id="Snippet1":::
:::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringstartswith/VB/stringstartswith.vb" id="Snippet1":::

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-3375"><paramref name="value" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3375"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-3376">Wie in [bewährte Methoden für die Verwendung von](~/docs/standard/base-types/best-practices-strings.md)Zeichen folgen erläutert, empfiehlt es sich, den Aufruf von Zeichen folgen Vergleichsmethoden zu vermeiden, die Standardwerte ersetzen, und stattdessen Methoden aufzurufen, für die Parameter explizit angegeben werden müssen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3376">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="8b8da-3377">Um zu ermitteln, ob eine Zeichenfolge mit einer bestimmten Teil Zeichenfolge beginnt, indem Sie die Regeln für den Zeichen folgen Vergleich der aktuellen Kultur verwenden, müssen Sie die <see cref="M:System.String.StartsWith(System.String,System.StringComparison)" />-Methoden Überladung mit dem Wert <see cref="F:System.StringComparison.CurrentCulture" /> für den <paramref name="comparisonType" /> Parameter aufrufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3377">To determine whether a string begins with a particular substring by using the string comparison rules of the current culture, call the <see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</span></span></para></block>
        <altmember cref="M:System.String.EndsWith(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * StringComparison -&gt; bool" Usage="string.StartsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-3378">Die zu vergleichende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3378">The string to compare.</span></span></param>
        <param name="comparisonType"><span data-ttu-id="8b8da-3379">Einer der Enumerationswerte, die bestimmen, wie diese Zeichenfolge und <paramref name="value" /> verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3379">One of the enumeration values that determines how this string and <paramref name="value" /> are compared.</span></span></param>
        <summary><span data-ttu-id="8b8da-3380">Bestimmt, ob der Anfang dieser Zeichenfolgeninstanz bei einem Vergleich unter Verwendung der angegebenen Vergleichsoption mit der angegebenen Zeichenfolge übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3380">Determines whether the beginning of this string instance matches the specified string when compared using the specified comparison option.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3381"><see langword="true" />, wenn diese Instanz mit <paramref name="value" /> beginnt; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3381"><see langword="true" /> if this instance begins with <paramref name="value" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-3382">Die <xref:System.String.StartsWith%2A>-Methode vergleicht den `value`-Parameter mit der Teil Zeichenfolge am Anfang dieser Zeichenfolge und gibt einen Wert zurück, der angibt, ob Sie gleich sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3382">The <xref:System.String.StartsWith%2A> method compares the `value` parameter to the substring at the beginning of this string and returns a value that indicates whether they are equal.</span></span> <span data-ttu-id="8b8da-3383">Um gleich zu sein, muss `value` ein Verweis auf dieselbe Zeichenfolge sein, muss eine leere Zeichenfolge ("") sein oder mit dem Anfang dieser Zeichenfolge übereinstimmen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3383">To be equal, `value` must be a reference to this same string, must be the empty string (""), or must match the beginning of this string.</span></span> <span data-ttu-id="8b8da-3384">Der Typ des Vergleichs, der von der <xref:System.String.StartsWith%2A>-Methode ausgeführt wird, hängt vom Wert des `comparisonType`-Parameters ab.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3384">The type of comparison performed by the <xref:System.String.StartsWith%2A> method depends on the value of the `comparisonType` parameter.</span></span> <span data-ttu-id="8b8da-3385">Beim Vergleich können die Konventionen der aktuellen Kultur (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> und <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>) oder die invariante Kultur (<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> und <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>) verwendet werden, oder Sie können aus einem Zeichen Weise Vergleich von Code Punkten (<xref:System.StringComparison.Ordinal?displayProperty=nameWithType> oder <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>) bestehen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3385">The comparison can use the conventions of the current culture (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> and <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>) or the invariant culture (<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> and <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>), or it can consist of a character-by-character comparison of code points (<xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>).</span></span> <span data-ttu-id="8b8da-3386">Beim Vergleich kann auch die Groß-/Kleinschreibung beachtet werden (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>oder <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>), oder die Groß-/Kleinschreibung (<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>) kann ignoriert werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3386">The comparison can also be case-sensitive (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>, or <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>), or it can ignore case (<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>).</span></span>



## Examples
 <span data-ttu-id="8b8da-3387">Im folgenden Beispiel wird eine Suche nach der Zeichenfolge "The" am Anfang einer längeren Zeichenfolge durchzuführen, die mit dem Wort "The" beginnt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3387">The following example searches for the string "the" at the beginning of a longer string that begins with the word "The".</span></span> <span data-ttu-id="8b8da-3388">Wie die Ausgabe des Beispiels zeigt, kann ein Aufrufder <xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29>-Methode, die einen Kultur abhängigen Vergleich durchführt, aber die Groß-/Kleinschreibung nicht beachtet, nicht mit der Zeichenfolge übereinstimmen</span><span class="sxs-lookup"><span data-stu-id="8b8da-3388">As the output from the example shows, a call to the <xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29> method that performs a culture-insensitive but case-sensitive comparison fails to match the string, while a call that performs a culture- and case-insensitive comparison matches the string.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/StartsWith2.cpp" id="Snippet2":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/StartsWith2.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/StartsWith2.vb" id="Snippet2":::

 <span data-ttu-id="8b8da-3389">Im folgenden Beispiel wird bestimmt, ob eine Zeichenfolge mit einer bestimmten Teil Zeichenfolge beginnt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3389">The following example determines whether a string starts with a particular substring.</span></span> <span data-ttu-id="8b8da-3390">Ein zweidimensionales Zeichen folgen Array wird initialisiert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3390">It initializes a two-dimensional string array.</span></span> <span data-ttu-id="8b8da-3391">Das erste Element in der zweiten Dimension enthält eine Zeichenfolge, und das zweite Element enthält die Zeichenfolge, nach der am Anfang der ersten Zeichenfolge gesucht werden soll.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3391">The first element in the second dimension contains a string, and the second element contains the string to search for at the start of the first string.</span></span> <span data-ttu-id="8b8da-3392">Die Ergebnisse sind von der Auswahl der Kultur betroffen, unabhängig davon, ob die Groß-/Kleinschreibung ignoriert wird und ob ein Ordinalvergleich durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3392">The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed.</span></span> <span data-ttu-id="8b8da-3393">Beachten Sie Folgendes: Wenn die Zeichen folgen Instanz eine LIGATURE enthält, Stimmen Kultur abhängige Vergleiche mit den aufeinander folgenden Zeichen erfolgreich ab.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3393">Note that when the string instance contains a ligature, culture-sensitive comparisons with its consecutive characters successfully match.</span></span>

 [!code-cpp[System.String.StartsWith#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/startswith1.cpp#1)]
 [!code-csharp[System.String.StartsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/startswith1.cs#1)]
 [!code-vb[System.String.StartsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/startswith1.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-3394"><paramref name="value" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3394"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8b8da-3395"><paramref name="comparisonType" /> ist kein <see cref="T:System.StringComparison" />-Wert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3395"><paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span></span></exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.StartsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-3396">Die zu vergleichende Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3396">The string to compare.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="8b8da-3397"><see langword="true" />, wenn die Groß-/Kleinschreibung beim Vergleich ignoriert werden soll, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3397"><see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span></span></param>
        <param name="culture"><span data-ttu-id="8b8da-3398">Kulturinformationen, die bestimmen, wie diese Instanz und <paramref name="value" /> verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3398">Cultural information that determines how this string and <paramref name="value" /> are compared.</span></span> <span data-ttu-id="8b8da-3399">Wenn <paramref name="culture" /><see langword="null" /> ist, wird die aktuelle Kultur verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3399">If <paramref name="culture" /> is <see langword="null" />, the current culture is used.</span></span></param>
        <summary><span data-ttu-id="8b8da-3400">Bestimmt, ob der Anfang dieser Zeichenfolgeninstanz bei einem Vergleich unter Verwendung der angegebenen Kultur mit der angegebenen Zeichenfolge übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3400">Determines whether the beginning of this string instance matches the specified string when compared using the specified culture.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3401"><see langword="true" />, wenn der <paramref name="value" />-Parameter mit dem Anfang dieser Zeichenfolge übereinstimmt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3401"><see langword="true" /> if the <paramref name="value" /> parameter matches the beginning of this string; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-3402">Diese Methode vergleicht den `value`-Parameter mit der Teil Zeichenfolge am Anfang dieser Zeichenfolge, die mit der gleichen Länge wie `value`identisch ist, und gibt einen Wert zurück, der angibt, ob Sie gleich sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3402">This method compares the `value` parameter to the substring at the beginning of this string that is the same length as `value`, and returns a value that indicates whether they are equal.</span></span> <span data-ttu-id="8b8da-3403">Um gleich zu sein, muss `value` eine leere Zeichenfolge (<xref:System.String.Empty?displayProperty=nameWithType>) sein, muss ein Verweis auf dieselbe Instanz sein oder mit dem Anfang dieser Instanz übereinstimmen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3403">To be equal, `value` must be an empty string (<xref:System.String.Empty?displayProperty=nameWithType>), must be a reference to this same instance, or must match the beginning of this instance.</span></span>

 <span data-ttu-id="8b8da-3404">Diese Methode führt einen Vergleich mit der angegebenen Groß-und Kleinschreibung durch.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3404">This method performs a comparison using the specified casing and culture.</span></span>



## Examples
 <span data-ttu-id="8b8da-3405">Im folgenden Beispiel wird bestimmt, ob eine Zeichenfolge am Anfang einer anderen Zeichenfolge auftritt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3405">The following example determines whether a string occurs at the beginning of another string.</span></span> <span data-ttu-id="8b8da-3406">Die <xref:System.String.StartsWith%2A>-Methode wird mehrmals mit Berücksichtigung von Groß-/Kleinschreibung, Unterscheidung nach Groß-/Kleinschreibung und unterschiedlichen Kulturen aufgerufen, die die Suchergebnisse beeinflussen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3406">The <xref:System.String.StartsWith%2A> method is called several times using case sensitivity, case insensitivity, and different cultures that influence the results of the search.</span></span>

 [!code-csharp[system.string.StartsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.StartsWithCI/cs/swci.cs#1)]
 [!code-vb[system.string.StartsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.StartsWithCI/vb/swci.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-3407"><paramref name="value" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3407"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Substring">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8b8da-3408">Ruft eine Teilzeichenfolge dieser Instanz ab.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3408">Retrieves a substring from this instance.</span></span>

 <span data-ttu-id="8b8da-3409">Dieser Member wird überladen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3409">This member is overloaded.</span></span> <span data-ttu-id="8b8da-3410">Klicken Sie auf einen Namen in der Überladungsliste, um vollständige Informationen zu diesem Member sowie zu Syntax, Nutzung und Beispielen zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3410">For complete information about this member, including syntax, usage, and examples, click a name in the overload list.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Substring : int -&gt; string" Usage="string.Substring startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex"><span data-ttu-id="8b8da-3411">Die nullbasierte Anfangsposition einer Teilzeichenfolge innerhalb dieser Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3411">The zero-based starting character position of a substring in this instance.</span></span></param>
        <summary><span data-ttu-id="8b8da-3412">Ruft eine Teilzeichenfolge dieser Instanz ab.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3412">Retrieves a substring from this instance.</span></span> <span data-ttu-id="8b8da-3413">Die untergeordnete Zeichenfolge beginnt in einer angegebenen Zeichenposition und wird an das Ende der Zeichenfolge fortgesetzt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3413">The substring starts at a specified character position and continues to the end of the string.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3414">Eine Zeichenfolge, die der Teilzeichenfolge ab <paramref name="startIndex" /> in dieser Instanz entspricht, oder <see cref="F:System.String.Empty" />, wenn <paramref name="startIndex" /> gleich der Länge dieser Instanz ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3414">A string that is equivalent to the substring that begins at <paramref name="startIndex" /> in this instance, or <see cref="F:System.String.Empty" /> if <paramref name="startIndex" /> is equal to the length of this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-3415">Sie können die <xref:System.String.Substring%28System.Int32%29>-Methode aufzurufen, um eine Teil Zeichenfolge aus einer Zeichenfolge zu extrahieren, die an einer angegebenen Zeichenposition beginnt und am Ende der Zeichenfolge endet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3415">You call the <xref:System.String.Substring%28System.Int32%29> method to extract a substring from a string that begins at a specified character position and ends at the end of the string.</span></span> <span data-ttu-id="8b8da-3416">Die Anfangs Zeichenposition ist ein NULL basiertes; Anders ausgedrückt: das erste Zeichen in der Zeichenfolge hat den Index 0 (nicht Index 1).</span><span class="sxs-lookup"><span data-stu-id="8b8da-3416">The starting character position is a zero-based; in other words, the first character in the string is at index 0, not index 1.</span></span> <span data-ttu-id="8b8da-3417">Um eine Teil Zeichenfolge zu extrahieren, die an einer angegebenen Zeichenposition beginnt und vor dem Ende der Zeichenfolge endet, wird die <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>-Methode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3417">To extract a substring that begins at a specified character position and ends before the end of the string, call the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method.</span></span>

> [!NOTE]
>  <span data-ttu-id="8b8da-3418">Diese Methode ändert nicht den Wert der aktuellen Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3418">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="8b8da-3419">Stattdessen wird eine neue Zeichenfolge zurückgegeben, die an der `startIndex` Position in der aktuellen Zeichenfolge beginnt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3419">Instead, it returns a new string that begins at the `startIndex` position in the current string.</span></span>

 <span data-ttu-id="8b8da-3420">Um eine Teil Zeichenfolge zu extrahieren, die mit einem bestimmten Zeichen oder einer Zeichenfolge beginnt, müssen Sie eine Methode wie <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOf%2A> abrufen, um den Wert von `startIndex`abzurufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3420">To extract a substring that begins with a particular character or character sequence, call a method such as  <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOf%2A> to get the value of `startIndex`.</span></span> <span data-ttu-id="8b8da-3421">Das zweite Beispiel veranschaulicht dies: Es extrahiert einen Schlüsselwert, der eine Zeichenposition nach dem Zeichen "=" beginnt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3421">The second example illustrates this; it extracts a key value that begins one character position after the "=" character.</span></span>

 <span data-ttu-id="8b8da-3422">Wenn `startIndex` gleich 0 (null) ist, gibt die Methode die ursprüngliche Zeichenfolge unverändert zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3422">If `startIndex` is equal to zero, the method returns the original string unchanged.</span></span>


## Examples
 <span data-ttu-id="8b8da-3423">Das folgende Beispiel veranschaulicht das Abrufen einer Teil Zeichenfolge aus einer Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3423">The following example demonstrates obtaining a substring from a string.</span></span>

 [!code-cpp[System.String.Substring#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.String.Substring/cpp/Substring10.cpp#10)]
 [!code-csharp-interactive[System.String.Substring#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring10.cs#10)]
 [!code-vb[System.String.Substring#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring10.vb#10)]

 <span data-ttu-id="8b8da-3424">Im folgenden Beispiel werden die Schlüssel-Wert-Paare, die durch ein Gleichheitszeichen ("=") getrennt sind, mithilfe der <xref:System.String.Substring%2A>-Methode getrennt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3424">The following example uses the <xref:System.String.Substring%2A> method to separate key/value pairs that are delimited by an equals ("=") character.</span></span>

 [!code-csharp-interactive[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]

 <span data-ttu-id="8b8da-3425">Die <xref:System.String.IndexOf%2A>-Methode wird verwendet, um die Position des Gleichheitszeichens in der Zeichenfolge zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3425">The <xref:System.String.IndexOf%2A> method is used to get the position of the equals character in the string.</span></span> <span data-ttu-id="8b8da-3426">Der-Befehl der <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>-Methode extrahiert den Schlüsselnamen, der mit dem ersten Zeichen in der Zeichenfolge beginnt und die Anzahl der Zeichen erweitert, die durch den Aufrufder <xref:System.String.IndexOf%2A>-Methode zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3426">The call to the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method extracts the key name, which starts from the first character in the string and extends for the number of characters returned by the call to the <xref:System.String.IndexOf%2A> method.</span></span> <span data-ttu-id="8b8da-3427">Der <xref:System.String.Substring%28System.Int32%29>-Methode aufzurufende Wert extrahiert dann den Wert, der dem Schlüssel zugewiesen ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3427">The call to the <xref:System.String.Substring%28System.Int32%29> method then extracts the value assigned to the key.</span></span> <span data-ttu-id="8b8da-3428">Er beginnt an einer Zeichenposition hinter dem Gleichheitszeichen und erstreckt sich bis zum Ende der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3428">It starts at one character position beyond the equals character and extends to the end of the string.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-3429"><paramref name="startIndex" /> ist kleiner als 0 (null) oder größer als die Länge dieser Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3429"><paramref name="startIndex" /> is less than zero or greater than the length of this instance.</span></span></exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Substring : int * int -&gt; string" Usage="string.Substring (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex"><span data-ttu-id="8b8da-3430">Die nullbasierte Anfangsposition einer Teilzeichenfolge innerhalb dieser Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3430">The zero-based starting character position of a substring in this instance.</span></span></param>
        <param name="length"><span data-ttu-id="8b8da-3431">Die Anzahl der Zeichen in der Teilzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3431">The number of characters in the substring.</span></span></param>
        <summary><span data-ttu-id="8b8da-3432">Ruft eine Teilzeichenfolge dieser Instanz ab.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3432">Retrieves a substring from this instance.</span></span> <span data-ttu-id="8b8da-3433">Die Teilzeichenfolge beginnt an einer angegebenen Zeichenposition und hat eine angegebene Länge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3433">The substring starts at a specified character position and has a specified length.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3434">Eine Zeichenfolge, die der Teilzeichenfolge mit der Länge <paramref name="length" /> ab <paramref name="startIndex" /> in dieser Instanz entspricht, oder <see cref="F:System.String.Empty" />, wenn <paramref name="startIndex" /> gleich der Länge dieser Instanz und <paramref name="length" /> 0 (null) ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3434">A string that is equivalent to the substring of length <paramref name="length" /> that begins at <paramref name="startIndex" /> in this instance, or <see cref="F:System.String.Empty" /> if <paramref name="startIndex" /> is equal to the length of this instance and <paramref name="length" /> is zero.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-3435">Sie können die <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>-Methode aufzurufen, um eine Teil Zeichenfolge aus einer Zeichenfolge zu extrahieren, die an einer angegebenen Zeichenposition beginnt und vor dem Ende der Zeichenfolge endet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3435">You call the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method to extract a substring from a string that begins at a specified character position and ends before the end of the string.</span></span> <span data-ttu-id="8b8da-3436">Die Anfangs Zeichenposition ist ein NULL basiertes; Anders ausgedrückt: das erste Zeichen in der Zeichenfolge hat den Index 0 (nicht Index 1).</span><span class="sxs-lookup"><span data-stu-id="8b8da-3436">The starting character position is a zero-based; in other words, the first character in the string is at index 0, not index 1.</span></span> <span data-ttu-id="8b8da-3437">Um eine Teil Zeichenfolge zu extrahieren, die an einer angegebenen Zeichenposition beginnt und am Ende der Zeichenfolge fortgesetzt wird, müssen Sie die <xref:System.String.Substring%28System.Int32%29>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3437">To extract a substring that begins at a specified character position and continues to the end of the string, call the <xref:System.String.Substring%28System.Int32%29> method.</span></span>

> [!NOTE]
>  <span data-ttu-id="8b8da-3438">Diese Methode ändert nicht den Wert der aktuellen Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3438">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="8b8da-3439">Stattdessen wird eine neue Zeichenfolge mit `length` Zeichen zurückgegeben, beginnend mit der `startIndex` Position in der aktuellen Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3439">Instead, it returns a new string with `length` characters starting from the `startIndex` position in the current string.</span></span>

 <span data-ttu-id="8b8da-3440">Der `length`-Parameter stellt die Gesamtzahl der Zeichen dar, die aus der aktuellen Zeichen folgen Instanz extrahiert werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3440">The `length` parameter represents the total number of characters to extract from the current string instance.</span></span> <span data-ttu-id="8b8da-3441">Dies schließt das Startzeichen ein, das bei der Index `startIndex`gefunden wurde.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3441">This includes the starting character found at index  `startIndex`.</span></span>  <span data-ttu-id="8b8da-3442">Mit anderen Worten: die <xref:System.String.Substring%2A>-Methode versucht, Zeichen aus der Index `startIndex` zu extrahieren `startIndex` + `length`-1.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3442">In other words, the <xref:System.String.Substring%2A> method attempts to extract characters from index `startIndex` to index `startIndex` + `length` - 1.</span></span>

 <span data-ttu-id="8b8da-3443">Um eine Teil Zeichenfolge zu extrahieren, die mit einem bestimmten Zeichen oder einer Zeichenfolge beginnt, müssen Sie eine Methode wie <xref:System.String.IndexOf%2A> oder <xref:System.String.LastIndexOf%2A> abrufen, um den Wert von `startIndex`abzurufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3443">To extract a substring that begins with a particular character or character sequence, call a method such as  <xref:System.String.IndexOf%2A> or <xref:System.String.LastIndexOf%2A> to get the value of `startIndex`.</span></span>

 <span data-ttu-id="8b8da-3444">Wenn die Teil Zeichenfolge von `startIndex` auf eine angegebene Zeichen Sequenz erweitert wird, können Sie eine Methode wie <xref:System.String.IndexOf%2A> oder <xref:System.String.LastIndexOf%2A> abrufen, um den Index des Endzeichens oder der Zeichenfolge zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3444">If the substring extends from `startIndex` to a specified character sequence, you can call a method such as  <xref:System.String.IndexOf%2A> or <xref:System.String.LastIndexOf%2A> to get the index of the ending character or character sequence.</span></span>  <span data-ttu-id="8b8da-3445">Anschließend können Sie diesen Wert wie folgt in eine Indexposition in der Zeichenfolge konvertieren:</span><span class="sxs-lookup"><span data-stu-id="8b8da-3445">You can then convert that value to an index position in the string as follows:</span></span>

-   <span data-ttu-id="8b8da-3446">Wenn Sie nach einem einzelnen Zeichen gesucht haben, das das Ende der Teil Zeichenfolge kennzeichnet, entspricht der `length` Parameter `endIndex` - `startIndex` + 1, wobei `endIndex` der Rückgabewert der <xref:System.String.IndexOf%2A>-Methode oder der <xref:System.String.IndexOf%2A>-Methode ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3446">If you've searched for a single character that is to mark the end of the substring, the `length` parameter equals  `endIndex` - `startIndex` + 1, where `endIndex` is the return value of the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOf%2A> method.</span></span> <span data-ttu-id="8b8da-3447">Im folgenden Beispiel wird ein fortlaufender Block von "b"-Zeichen aus einer Zeichenfolge extrahiert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3447">The following example extracts a continuous block of "b" characters from a string.</span></span>

     [!code-csharp-interactive[System.String.Substring#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring2.cs#2)]
     [!code-vb[System.String.Substring#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring2.vb#2)]

-   <span data-ttu-id="8b8da-3448">Wenn Sie mehrere Zeichen durchsucht haben, die das Ende der Teil Zeichenfolge markieren, entspricht der `length` Parameter `endIndex` + `endMatchLength` - `startIndex`, wobei `endIndex` der Rückgabewert der <xref:System.String.IndexOf%2A>-Methode oder <xref:System.String.IndexOf%2A>-Methode und `endMatchLength` die Länge der Zeichenfolge ist, die das Ende der Teil Zeichenfolge markiert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3448">If you've searched for multiple characters that are to mark the end of the substring, the `length` parameter equals  `endIndex` + `endMatchLength` - `startIndex`, where `endIndex` is the return value of the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOf%2A> method, and `endMatchLength` is the length of the character sequence that marks the end of the substring.</span></span> <span data-ttu-id="8b8da-3449">Im folgenden Beispiel wird ein Textblock extrahiert, der ein XML-`<definition>` Element enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3449">The following example extracts a block of text that contains an XML `<definition>` element.</span></span>

     [!code-csharp-interactive[System.String.Substring#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring3.cs#3)]
     [!code-vb[System.String.Substring#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring3.vb#3)]

-   <span data-ttu-id="8b8da-3450">Wenn das Zeichen oder die Zeichenfolge nicht am Ende der Teil Zeichenfolge enthalten ist, entspricht der `length`-Parameter `endIndex` - `startIndex`, wobei `endIndex` der Rückgabewert der <xref:System.String.IndexOf%2A>-Methode oder der <xref:System.String.IndexOf%2A>-Methode ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3450">If the character or character sequence is not included in the end of the substring, the `length` parameter equals `endIndex` - `startIndex`, where `endIndex` is the return value of the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOf%2A> method.</span></span>

 <span data-ttu-id="8b8da-3451">Wenn `startIndex` gleich 0 (null) ist und der Länge der aktuellen Zeichenfolge entspricht, gibt die Methode die ursprüngliche Zeichenfolge unverändert zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3451">If `startIndex` is equal to zero and  equals the length of the current string, the method returns the original string unchanged.</span></span>



## Examples
 <span data-ttu-id="8b8da-3452">Im folgenden Beispiel wird ein einfacher Aufrufder <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>-Methode veranschaulicht, die zwei Zeichen aus einer Zeichenfolge extrahiert, beginnend bei der sechsten Zeichenposition (d. h. bei Index fünf).</span><span class="sxs-lookup"><span data-stu-id="8b8da-3452">The following example illustrates a simple call to the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method that extracts two characters from a string starting at the sixth character position (that is, at index five).</span></span>

 [!code-csharp-interactive[System.String.Substring#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring4.cs#4)]
 [!code-vb[System.String.Substring#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring4.vb#4)]

 <span data-ttu-id="8b8da-3453">Im folgenden Beispiel wird die <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>-Methode in den folgenden drei Fällen verwendet, um Teil Zeichenfolgen in einer Zeichenfolge zu isolieren.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3453">The following example uses the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method in the following three cases to isolate substrings within a string.</span></span> <span data-ttu-id="8b8da-3454">In zwei Fällen werden die Teil Zeichenfolgen in Vergleichen verwendet, und im dritten Fall wird eine Ausnahme ausgelöst, weil ungültige Parameter angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3454">In two cases the substrings are used in comparisons, and in the third case an exception is thrown because invalid parameters are specified.</span></span>

-   <span data-ttu-id="8b8da-3455">Es extrahiert das einzelne Zeichen und die dritte Position in der Zeichenfolge (bei Index 2) und vergleicht es mit einem "c".</span><span class="sxs-lookup"><span data-stu-id="8b8da-3455">It extracts the single character and the third position in the string (at index 2) and compares it with a "c".</span></span> <span data-ttu-id="8b8da-3456">Bei diesem Vergleich wird `true`zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3456">This comparison returns `true`.</span></span>

-   <span data-ttu-id="8b8da-3457">Er extrahiert NULL Zeichen beginnend an der vierten Position in der Zeichenfolge (bei Index 3) und übergibt sie an die <xref:System.String.IsNullOrEmpty%2A>-Methode.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3457">It extracts zero characters starting at the fourth position in the string (at index 3) and passes it to the <xref:System.String.IsNullOrEmpty%2A> method.</span></span> <span data-ttu-id="8b8da-3458">Dies gibt true zurück, da der aufzurufende <xref:System.String.Substring%2A> Methode <xref:System.String.Empty?displayProperty=nameWithType>zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3458">This returns true because the call to the <xref:System.String.Substring%2A> method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>

-   <span data-ttu-id="8b8da-3459">Es wird versucht, ein Zeichen zu extrahieren, beginnend an der vierten Position in der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3459">It attempts to extract one character starting at the fourth position in the string.</span></span> <span data-ttu-id="8b8da-3460">Da an dieser Position kein Zeichen vorhanden ist, löst der Methodenaufrufe eine <xref:System.ArgumentOutOfRangeException> Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3460">Because there is no character at that position, the method call throws an <xref:System.ArgumentOutOfRangeException> exception.</span></span>

 [!code-csharp-interactive[Classic String.Substring1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.Substring1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.Substring1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.Substring1 Example/VB/source.vb#1)]

 <span data-ttu-id="8b8da-3461">Im folgenden Beispiel werden die Schlüssel-Wert-Paare, die durch ein Gleichheitszeichen ("=") getrennt sind, mithilfe der <xref:System.String.Substring%2A>-Methode getrennt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3461">The following example uses the <xref:System.String.Substring%2A> method to separate key/value pairs that are delimited by an equals ("=") character.</span></span>

 [!code-csharp-interactive[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]

 <span data-ttu-id="8b8da-3462">Die <xref:System.String.IndexOf%2A>-Methode wird verwendet, um die Position des Gleichheitszeichens in der Zeichenfolge zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3462">The <xref:System.String.IndexOf%2A> method is used to get the position of the equals character in the string.</span></span> <span data-ttu-id="8b8da-3463">Der-Befehl der <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29>-Methode extrahiert den Schlüsselnamen, der mit dem ersten Zeichen in der Zeichenfolge beginnt und die Anzahl der Zeichen erweitert, die durch den Aufrufder <xref:System.String.IndexOf%2A>-Methode zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3463">The call to the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method extracts the key name, which starts from the first character in the string and extends for the number of characters returned by the call to the <xref:System.String.IndexOf%2A> method.</span></span> <span data-ttu-id="8b8da-3464">Der <xref:System.String.Substring%28System.Int32%29>-Methode aufzurufende Wert extrahiert dann den Wert, der dem Schlüssel zugewiesen ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3464">The call to the <xref:System.String.Substring%28System.Int32%29> method then extracts the value assigned to the key.</span></span> <span data-ttu-id="8b8da-3465">Er beginnt an einer Zeichenposition hinter dem Gleichheitszeichen und erstreckt sich bis zum Ende der Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3465">It starts at one character position beyond the equals character and extends to the end of the string.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-3466"><paramref name="startIndex" /> plus <paramref name="length" /> gibt eine Position außerhalb dieser Instanz an.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3466"><paramref name="startIndex" /> plus <paramref name="length" /> indicates a position not within this instance.</span></span>

<span data-ttu-id="8b8da-3467">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-3467">-or-</span></span>

 <span data-ttu-id="8b8da-3468"><paramref name="startIndex" /> oder <paramref name="length" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3468"><paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</span></span></exception>
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Char&gt;.GetEnumerator" ExplicitInterfaceMemberName="System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;char&gt; IEnumerable&lt;char&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;char&gt; System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#Generic#IEnumerable&lt;char&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of Char) Implements IEnumerable(Of Char).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;char&gt; ^ System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;char&gt;::GetEnumerator;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;char&gt;&#xA;override this.System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;char&gt;" Usage="string.System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8b8da-3469">Gibt einen Enumerator zurück, der das aktuelle <see cref="T:System.String" />-Objekt durchläuft.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3469">Returns an enumerator that iterates through the current <see cref="T:System.String" /> object.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3470">Ein stark typisierter Enumerator, der zum Durchlaufen des aktuellen <see cref="T:System.String" />-Objekts verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3470">A strongly-typed enumerator that can be used to iterate through the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-3471">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3471">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="8b8da-3472">Sie kann nur verwendet werden, wenn die <xref:System.String>-Instanz in ein <xref:System.Collections.Generic.IEnumerable%601> Interface-Objekt umgewandelt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3472">It can be used only when the <xref:System.String> instance is cast to an <xref:System.Collections.Generic.IEnumerable%601> interface object.</span></span> <span data-ttu-id="8b8da-3473">Weitere Informationen finden Sie unter der Methode <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3473">For more information, see the <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> method.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IEnumerable.GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.System.Collections.IEnumerable.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="string.System.Collections.IEnumerable.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8b8da-3474">Gibt einen Enumerator zurück, der das aktuelle <see cref="T:System.String" />-Objekt durchläuft.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3474">Returns an enumerator that iterates through the current <see cref="T:System.String" /> object.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3475">Ein Enumerator, mit dem die Elemente in der aktuellen Zeichenfolge durchlaufen werden können.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3475">An enumerator that can be used to iterate through the current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-3476">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3476">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="8b8da-3477">Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.Collections.IEnumerable>-Schnittstelle umgewandelt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3477">It can be used only when the <xref:System.String> instance is cast to an <xref:System.Collections.IEnumerable> interface.</span></span> <span data-ttu-id="8b8da-3478">Weitere Informationen finden Sie unter der Methode <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3478">For more information, see the <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> method.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberSignature Language="F#" Value="abstract member System.IComparable.CompareTo : obj -&gt; int&#xA;override this.System.IComparable.CompareTo : obj -&gt; int" Usage="string.System.IComparable.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8b8da-3479">Ein Objekt, das als <see cref="T:System.String" /> ausgewertet wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3479">An object that evaluates to a <see cref="T:System.String" />.</span></span></param>
        <summary><span data-ttu-id="8b8da-3480">Vergleicht diese Instanz mit einem angegebenen <see cref="T:System.Object" /> und gibt an, ob diese Instanz in der Sortierreihenfolge an einer früheren, späteren oder derselben Position wie das angegebene <see cref="T:System.Object" /> aufgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3480">Compares this instance with a specified <see cref="T:System.Object" /> and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified <see cref="T:System.Object" />.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3481">Eine 32-Bit-Ganzzahl mit Vorzeichen, die angibt, ob diese Instanz in der Sortierreihenfolge an einer früheren, späteren oder derselben Position wie der <paramref name="value" />-Parameter aufgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3481">A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <paramref name="value" /> parameter.</span></span>

<list type="table"><listheader><term><span data-ttu-id="8b8da-3482">Wert</span><span class="sxs-lookup"><span data-stu-id="8b8da-3482">Value</span></span></term><description><span data-ttu-id="8b8da-3483">Bedingung</span><span class="sxs-lookup"><span data-stu-id="8b8da-3483">Condition</span></span></description></listheader><item><term><span data-ttu-id="8b8da-3484">Kleiner als 0 (null)</span><span class="sxs-lookup"><span data-stu-id="8b8da-3484">Less than zero</span></span></term><description><span data-ttu-id="8b8da-3485">Diese Instanz geht <paramref name="value" /> voran.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3485">This instance precedes <paramref name="value" />.</span></span></description></item><item><term><span data-ttu-id="8b8da-3486">Zero</span><span class="sxs-lookup"><span data-stu-id="8b8da-3486">Zero</span></span></term><description><span data-ttu-id="8b8da-3487">Diese Instanz hat in der Sortierreihenfolge dieselbe Position wie <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3487">This instance has the same position in the sort order as <paramref name="value" />.</span></span></description></item><item><term><span data-ttu-id="8b8da-3488">Größer als 0 (null)</span><span class="sxs-lookup"><span data-stu-id="8b8da-3488">Greater than zero</span></span></term><description><span data-ttu-id="8b8da-3489">Diese Instanz folgt <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3489">This instance follows <paramref name="value" />.</span></span>

<span data-ttu-id="8b8da-3490">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-3490">-or-</span></span>

<span data-ttu-id="8b8da-3491"><paramref name="value" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3491"><paramref name="value" /> is <see langword="null" />.</span></span></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="8b8da-3492">`value` muss ein <xref:System.String> Objekt sein.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3492">`value` must be a <xref:System.String> object.</span></span>

> [!CAUTION]
>  <span data-ttu-id="8b8da-3493">Die <xref:System.String.CompareTo%2A>-Methode wurde hauptsächlich für die Verwendung in Sortier-oder alphabetisierungsvorgängen entwickelt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3493">The <xref:System.String.CompareTo%2A> method was designed primarily for use in sorting or alphabetizing operations.</span></span> <span data-ttu-id="8b8da-3494">Er sollte nicht verwendet werden, wenn der primäre Zweck des Methoden Aufrufes ist, zu bestimmen, ob zwei Zeichen folgen äquivalent sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3494">It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent.</span></span> <span data-ttu-id="8b8da-3495">Um zu ermitteln, ob zwei Zeichen folgen äquivalent sind, müssen Sie die <xref:System.String.Equals%2A>-Methode abrufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3495">To determine whether two strings are equivalent, call the <xref:System.String.Equals%2A> method.</span></span>

<span data-ttu-id="8b8da-3496">Diese Methode führt einen Vergleich mit der aktuellen Kultur durch (Unterscheidung nach Groß-/Kleinschreibung und Kultur sensitiv).</span><span class="sxs-lookup"><span data-stu-id="8b8da-3496">This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</span></span> <span data-ttu-id="8b8da-3497">Weitere Informationen zu Wort-, Zeichen folgen-und ordinalsortierungen finden Sie unter <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3497">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="8b8da-3498">Weitere Informationen zum Verhalten dieser Methode finden Sie im Abschnitt "Hinweise" der <xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType>-Methode.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3498">For more information about the behavior of this method, see the Remarks section of the <xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType> method.</span></span>

## Examples

<span data-ttu-id="8b8da-3499">Im folgenden Beispiel wird die <xref:System.String.CompareTo%2A>-Methode mit einem-<xref:System.Object>verwendet.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3499">The following example uses the <xref:System.String.CompareTo%2A> method with an <xref:System.Object>.</span></span> <span data-ttu-id="8b8da-3500">Da versucht wird, eine <xref:System.String> Instanz mit einem `TestClass`-Objekt zu vergleichen, löst die Methode eine <xref:System.ArgumentException>aus.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3500">Because it attempts to compare a <xref:System.String> instance to a `TestClass` object, the method throws an <xref:System.ArgumentException>.</span></span>

[!code-cpp[ExToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ExToString/CPP/extostring.cpp#1)]
[!code-csharp[ExToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ExToString/CS/extostring.cs#1)]
[!code-vb[ExToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ExToString/VB/extostring.vb#1)]

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8b8da-3501"><paramref name="value" /> ist keine <see cref="T:System.String" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3501"><paramref name="value" /> is not a <see cref="T:System.String" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.GetTypeCode : unit -&gt; TypeCode&#xA;override this.System.IConvertible.GetTypeCode : unit -&gt; TypeCode" Usage="string.System.IConvertible.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8b8da-3502">Gibt <see cref="T:System.TypeCode" /> für die <see cref="T:System.String" />-Klasse zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3502">Returns the <see cref="T:System.TypeCode" /> for the <see cref="T:System.String" /> class.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3503">Die Enumerationskonstante <see cref="F:System.TypeCode.String" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3503">The enumerated constant, <see cref="F:System.TypeCode.String" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples

<span data-ttu-id="8b8da-3504">Im folgenden Beispiel wird die <xref:System.TypeCode> Enumerationskonstante für den <xref:System.String>-Typ angezeigt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3504">The following example displays the <xref:System.TypeCode> enumerated constant for the <xref:System.String> type.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.gettypecode/CPP/gtc.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.gettypecode/CS/gtc.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.gettypecode/VB/gtc.vb" id="Snippet1":::

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToBoolean : IFormatProvider -&gt; bool&#xA;override this.System.IConvertible.ToBoolean : IFormatProvider -&gt; bool" Usage="string.System.IConvertible.ToBoolean provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="8b8da-3505">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3505">This parameter is ignored.</span></span></param>
        <summary><span data-ttu-id="8b8da-3506">Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3506">For a description of this member, see <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3507"><see langword="true" />, wenn der Wert der aktuellen Zeichenfolge <see cref="F:System.Boolean.TrueString" /> ist. <see langword="false" />, wenn der Wert der aktuellen Zeichenfolge <see cref="F:System.Boolean.FalseString" /> ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3507"><see langword="true" /> if the value of the current string is <see cref="F:System.Boolean.TrueString" />; <see langword="false" /> if the value of the current string is <see cref="F:System.Boolean.FalseString" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-3508">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3508">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="8b8da-3509">Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3509">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="8b8da-3510">Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3510">The recommended alternative is to call the <xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType> method.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="8b8da-3511">Der Wert der aktuellen Zeichenfolge ist weder <see cref="F:System.Boolean.TrueString" /> noch <see cref="F:System.Boolean.FalseString" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3511">The value of the current string is not <see cref="F:System.Boolean.TrueString" /> or <see cref="F:System.Boolean.FalseString" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToByte : IFormatProvider -&gt; byte&#xA;override this.System.IConvertible.ToByte : IFormatProvider -&gt; byte" Usage="string.System.IConvertible.ToByte provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="8b8da-3512">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3512">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="8b8da-3513">Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3513">For a description of this member, see <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3514">Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3514">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-3515">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3515">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="8b8da-3516">Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3516">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="8b8da-3517">Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3517">The recommended alternative is to call the <xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="8b8da-3518">Der Wert des aktuellen <see cref="T:System.String" />-Objekts kann nicht analysiert werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3518">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="8b8da-3519">Der Wert des aktuellen <see cref="T:System.String" />-Objekts ist eine Zahl größer als <see cref="F:System.Byte.MaxValue" /> oder kleiner als <see cref="F:System.Byte.MinValue" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3519">The value of the current <see cref="T:System.String" /> object is a number greater than <see cref="F:System.Byte.MaxValue" /> or less than <see cref="F:System.Byte.MinValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToChar : IFormatProvider -&gt; char&#xA;override this.System.IConvertible.ToChar : IFormatProvider -&gt; char" Usage="string.System.IConvertible.ToChar provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="8b8da-3520">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3520">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="8b8da-3521">Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3521">For a description of this member, see <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3522">Das Zeichen am Index 0 im aktuellen <see cref="T:System.String" />-Objekt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3522">The character at index 0 in the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-3523">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3523">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="8b8da-3524">Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3524">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="8b8da-3525">Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3525">The recommended alternative is to call the <xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToDateTime : IFormatProvider -&gt; DateTime&#xA;override this.System.IConvertible.ToDateTime : IFormatProvider -&gt; DateTime" Usage="string.System.IConvertible.ToDateTime provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="8b8da-3526">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3526">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="8b8da-3527">Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3527">For a description of this member, see <see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3528">Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3528">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-3529">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3529">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="8b8da-3530">Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3530">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="8b8da-3531">Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3531">The recommended alternative is to call the <xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToDecimal : IFormatProvider -&gt; decimal&#xA;override this.System.IConvertible.ToDecimal : IFormatProvider -&gt; decimal" Usage="string.System.IConvertible.ToDecimal provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="8b8da-3532">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3532">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="8b8da-3533">Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3533">For a description of this member, see <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3534">Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3534">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-3535">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3535">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="8b8da-3536">Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3536">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="8b8da-3537">Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3537">The recommended alternative is to call the <xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="8b8da-3538">Der Wert des aktuellen <see cref="T:System.String" />-Objekts kann nicht analysiert werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3538">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="8b8da-3539">Der Wert des aktuellen <see cref="T:System.String" />-Objekts ist eine Zahl kleiner als <see cref="F:System.Decimal.MinValue" /> oder größer als <see cref="F:System.Decimal.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3539">The value of the current <see cref="T:System.String" /> object is a number less than <see cref="F:System.Decimal.MinValue" /> or than <see cref="F:System.Decimal.MaxValue" /> greater.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToDouble : IFormatProvider -&gt; double&#xA;override this.System.IConvertible.ToDouble : IFormatProvider -&gt; double" Usage="string.System.IConvertible.ToDouble provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="8b8da-3540">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3540">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="8b8da-3541">Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3541">For a description of this member, see <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3542">Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3542">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-3543">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3543">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="8b8da-3544">Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3544">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="8b8da-3545">Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3545">The recommended alternative is to call the <xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="8b8da-3546">Der Wert des aktuellen <see cref="T:System.String" />-Objekts kann nicht analysiert werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3546">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="8b8da-3547">Der Wert des aktuellen <see cref="T:System.String" />-Objekts ist eine Zahl kleiner als <see cref="F:System.Double.MinValue" /> oder größer als <see cref="F:System.Double.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3547">The value of the current <see cref="T:System.String" /> object is a number less than <see cref="F:System.Double.MinValue" /> or greater than <see cref="F:System.Double.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToInt16 : IFormatProvider -&gt; int16&#xA;override this.System.IConvertible.ToInt16 : IFormatProvider -&gt; int16" Usage="string.System.IConvertible.ToInt16 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="8b8da-3548">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3548">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="8b8da-3549">Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3549">For a description of this member, see <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3550">Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3550">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-3551">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3551">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="8b8da-3552">Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3552">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="8b8da-3553">Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3553">The recommended alternative is to call the <xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="8b8da-3554">Der Wert des aktuellen <see cref="T:System.String" />-Objekts kann nicht analysiert werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3554">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="8b8da-3555">Der Wert des aktuellen <see cref="T:System.String" />-Objekts ist eine Zahl größer als <see cref="F:System.Int16.MaxValue" /> oder kleiner als <see cref="F:System.Int16.MinValue" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3555">The value of the current <see cref="T:System.String" /> object is a number greater than <see cref="F:System.Int16.MaxValue" /> or less than <see cref="F:System.Int16.MinValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToInt32 : IFormatProvider -&gt; int&#xA;override this.System.IConvertible.ToInt32 : IFormatProvider -&gt; int" Usage="string.System.IConvertible.ToInt32 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="8b8da-3556">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3556">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="8b8da-3557">Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3557">For a description of this member, see <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3558">Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3558">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-3559">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3559">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="8b8da-3560">Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3560">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="8b8da-3561">Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3561">The recommended alternative is to call the <xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToInt64 : IFormatProvider -&gt; int64&#xA;override this.System.IConvertible.ToInt64 : IFormatProvider -&gt; int64" Usage="string.System.IConvertible.ToInt64 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="8b8da-3562">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3562">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="8b8da-3563">Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3563">For a description of this member, see <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3564">Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3564">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-3565">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3565">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="8b8da-3566">Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3566">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="8b8da-3567">Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3567">The recommended alternative is to call the <xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToSByte : IFormatProvider -&gt; sbyte&#xA;override this.System.IConvertible.ToSByte : IFormatProvider -&gt; sbyte" Usage="string.System.IConvertible.ToSByte provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="8b8da-3568">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3568">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="8b8da-3569">Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3569">For a description of this member, see <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3570">Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3570">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-3571">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3571">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="8b8da-3572">Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3572">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="8b8da-3573">Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3573">The recommended alternative is to call the <xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="8b8da-3574">Der Wert des aktuellen <see cref="T:System.String" />-Objekts kann nicht analysiert werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3574">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="8b8da-3575">Der Wert des aktuellen <see cref="T:System.String" />-Objekts ist eine Zahl größer als <see cref="F:System.SByte.MaxValue" /> oder kleiner als <see cref="F:System.SByte.MinValue" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3575">The value of the current <see cref="T:System.String" /> object is a number greater than <see cref="F:System.SByte.MaxValue" /> or less than <see cref="F:System.SByte.MinValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToSingle : IFormatProvider -&gt; single&#xA;override this.System.IConvertible.ToSingle : IFormatProvider -&gt; single" Usage="string.System.IConvertible.ToSingle provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="8b8da-3576">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3576">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="8b8da-3577">Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3577">For a description of this member, see <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3578">Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3578">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-3579">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3579">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="8b8da-3580">Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3580">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="8b8da-3581">Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3581">The recommended alternative is to call the <xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (provider As IFormatProvider) As String Implements IConvertible.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IConvertible.ToString(IFormatProvider ^ provider) = IConvertible::ToString;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToString : IFormatProvider -&gt; string&#xA;override this.System.IConvertible.ToString : IFormatProvider -&gt; string" Usage="string.System.IConvertible.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="8b8da-3582">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3582">An object that supplies culture-specific formatting information.</span></span>

<span data-ttu-id="8b8da-3583">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-3583">-or-</span></span>

<span data-ttu-id="8b8da-3584"><see langword="null" /> zur Verwendung der Formatierungskonventionen der jeweiligen Kultur.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3584"><see langword="null" /> to use the formatting conventions of the current culture.</span></span></param>
        <summary><span data-ttu-id="8b8da-3585">Eine Beschreibung dieses Members finden Sie unter <see cref="T:System.IConvertible.ToString(System.IFormatProvider)" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3585">For a description of this member, see <see cref="T:System.IConvertible.ToString(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3586">Eine <see cref="T:System.String" />-Instanz, die dem Wert dieser Instanz entspricht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3586">A <see cref="T:System.String" /> instance equivalent to the value of this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="8b8da-3587">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3587">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="8b8da-3588">Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3588">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToType (type As Type, provider As IFormatProvider) As Object Implements IConvertible.ToType" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToType : Type * IFormatProvider -&gt; obj&#xA;override this.System.IConvertible.ToType : Type * IFormatProvider -&gt; obj" Usage="string.System.IConvertible.ToType (type, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="8b8da-3589">Der Typ des zurückgegebenen Objekts.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3589">The type of the returned object.</span></span></param>
        <param name="provider"><span data-ttu-id="8b8da-3590">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3590">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="8b8da-3591">Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3591">For a description of this member, see <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3592">Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3592">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-3593">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3593">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="8b8da-3594">Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3594">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="8b8da-3595">Die empfohlene Alternative besteht darin, die <xref:System.Convert.ChangeType%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3595">The recommended alternative is to call the <xref:System.Convert.ChangeType%2A> method.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-3596"><paramref name="type" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3596"><paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="8b8da-3597">Der Wert des aktuellen <see cref="T:System.String" />-Objekts kann nicht in den vom <paramref name="type" />-Parameter angegebenen Typ konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3597">The value of the current <see cref="T:System.String" /> object cannot be converted to the type specified by the <paramref name="type" /> parameter.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToUInt16 : IFormatProvider -&gt; uint16&#xA;override this.System.IConvertible.ToUInt16 : IFormatProvider -&gt; uint16" Usage="string.System.IConvertible.ToUInt16 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="8b8da-3598">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3598">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="8b8da-3599">Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3599">For a description of this member, see <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3600">Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3600">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-3601">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3601">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="8b8da-3602">Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3602">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="8b8da-3603">Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3603">The recommended alternative is to call the <xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="8b8da-3604">Der Wert des aktuellen <see cref="T:System.String" />-Objekts kann nicht analysiert werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3604">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="8b8da-3605">Der Wert des aktuellen <see cref="T:System.String" />-Objekts ist eine Zahl größer als <see cref="F:System.UInt16.MaxValue" /> oder kleiner als <see cref="F:System.UInt16.MinValue" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3605">The value of the current <see cref="T:System.String" /> object is a number greater than <see cref="F:System.UInt16.MaxValue" /> or less than <see cref="F:System.UInt16.MinValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToUInt32 : IFormatProvider -&gt; uint32&#xA;override this.System.IConvertible.ToUInt32 : IFormatProvider -&gt; uint32" Usage="string.System.IConvertible.ToUInt32 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="8b8da-3606">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3606">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="8b8da-3607">Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3607">For a description of this member, see <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3608">Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3608">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-3609">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3609">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="8b8da-3610">Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3610">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="8b8da-3611">Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3611">The recommended alternative is to call the <xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="8b8da-3612">Der Wert des aktuellen <see cref="T:System.String" />-Objekts kann nicht analysiert werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3612">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="8b8da-3613">Der Wert des aktuellen <see cref="T:System.String" />-Objekts ist eine Zahl größer als <see cref="F:System.UInt32.MaxValue" /> oder kleiner als <see cref="F:System.UInt32.MinValue" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3613">The value of the current <see cref="T:System.String" /> object is a number greater <see cref="F:System.UInt32.MaxValue" /> or less than <see cref="F:System.UInt32.MinValue" /></span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToUInt64 : IFormatProvider -&gt; uint64&#xA;override this.System.IConvertible.ToUInt64 : IFormatProvider -&gt; uint64" Usage="string.System.IConvertible.ToUInt64 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="8b8da-3614">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3614">An object that provides culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="8b8da-3615">Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3615">For a description of this member, see <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3616">Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3616">The converted value of the current <see cref="T:System.String" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-3617">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3617">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="8b8da-3618">Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3618">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="8b8da-3619">Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3619">The recommended alternative is to call the <xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToCharArray">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8b8da-3620">Kopiert die Zeichen dieser Instanz in ein Array von Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3620">Copies the characters in this instance to a Unicode character array.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray();" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : unit -&gt; char[]" Usage="string.ToCharArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8b8da-3621">Kopiert die Zeichen dieser Instanz in ein Array von Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3621">Copies the characters in this instance to a Unicode character array.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3622">Ein Array von Unicode-Zeichen, dessen Elemente die einzelnen Zeichen dieser Instanz darstellen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3622">A Unicode character array whose elements are the individual characters of this instance.</span></span> <span data-ttu-id="8b8da-3623">Wenn diese Instanz eine leere Zeichenfolge ist, ist das zurückgegebene Array leer und hat die Länge 0.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3623">If this instance is an empty string, the returned array is empty and has a zero length.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-3624">Diese Methode kopiert jedes Zeichen (d. h. jedes <xref:System.Char> Objekt) in einer Zeichenfolge in ein Zeichen Array.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3624">This method copies each character (that is, each <xref:System.Char> object) in a string to a character array.</span></span> <span data-ttu-id="8b8da-3625">Das erste kopierte Zeichen weist den Index NULL des zurückgegebenen Zeichen Arrays auf. das letzte kopierte Zeichen befindet sich am Index <xref:System.Array.Length%2A?displayProperty=nameWithType>-1.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3625">The first character copied is at index zero of the returned character array; the last character copied is at index <xref:System.Array.Length%2A?displayProperty=nameWithType> - 1.</span></span>

 <span data-ttu-id="8b8da-3626">Um eine Zeichenfolge aus den Zeichen in einem Zeichen Array zu erstellen, rufen Sie den <xref:System.String.%23ctor%28System.Char%5B%5D%29>-Konstruktor auf.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3626">To create a string from the characters in a character array, call the <xref:System.String.%23ctor%28System.Char%5B%5D%29> constructor.</span></span>

 <span data-ttu-id="8b8da-3627">Um ein Bytearray zu erstellen, das die codierten Zeichen in einer Zeichenfolge enthält, instanziieren Sie das entsprechende <xref:System.Text.Encoding> Objekt, und rufen Sie dessen <xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType> Methode auf.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3627">To create a byte array that contains the encoded characters in a string, instantiate the appropriate <xref:System.Text.Encoding> object and call its <xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="8b8da-3628">Einige der in .NET verfügbaren Standard Codierungen umfassen Folgendes:</span><span class="sxs-lookup"><span data-stu-id="8b8da-3628">Some of the standard encodings available in .NET include the following:</span></span>

|<span data-ttu-id="8b8da-3629">Codierung</span><span class="sxs-lookup"><span data-stu-id="8b8da-3629">Encoding</span></span>|<span data-ttu-id="8b8da-3630">Object</span><span class="sxs-lookup"><span data-stu-id="8b8da-3630">Object</span></span>|
|--------------|------------|
|<span data-ttu-id="8b8da-3631">ASCII</span><span class="sxs-lookup"><span data-stu-id="8b8da-3631">ASCII</span></span>|<xref:System.Text.ASCIIEncoding>|
|<span data-ttu-id="8b8da-3632">UTF-7</span><span class="sxs-lookup"><span data-stu-id="8b8da-3632">UTF-7</span></span>|<xref:System.Text.UTF7Encoding>|
|<span data-ttu-id="8b8da-3633">UTF-8</span><span class="sxs-lookup"><span data-stu-id="8b8da-3633">UTF-8</span></span>|<xref:System.Text.UTF8Encoding>|
|<span data-ttu-id="8b8da-3634">UTF-16</span><span class="sxs-lookup"><span data-stu-id="8b8da-3634">UTF-16</span></span>|<xref:System.Text.UnicodeEncoding>|
|<span data-ttu-id="8b8da-3635">UTF-32</span><span class="sxs-lookup"><span data-stu-id="8b8da-3635">UTF-32</span></span>|<xref:System.Text.UTF32Encoding>|

 <span data-ttu-id="8b8da-3636">Weitere Informationen finden Sie unter [Zeichencodierung in .net](~/docs/standard/base-types/character-encoding.md).</span><span class="sxs-lookup"><span data-stu-id="8b8da-3636">For more information, see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md).</span></span>



## Examples
 <span data-ttu-id="8b8da-3637">Im folgenden Beispiel wird die <xref:System.String.ToCharArray%2A>-Methode aufgerufen, um die Zeichen in einer Zeichenfolge in ein Zeichen Array zu extrahieren.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3637">The following example calls the <xref:System.String.ToCharArray%2A> method to extract the characters in a string to a character array.</span></span> <span data-ttu-id="8b8da-3638">Anschließend werden die Original Zeichenfolge und die Elemente im Array angezeigt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3638">It then displays the original string and the elements in the array.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tochararray/cs/ToCharArray1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tochararray/vb/ToCharArray1.vb" id="Snippet1":::

 <span data-ttu-id="8b8da-3639">Im folgenden Beispiel wird eine Zeichenfolge definiert, die die Zeichen enthält, die in einer durch Trennzeichen getrennten Zeichenfolge als Trennzeichen fungieren.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3639">The following example defines a string containing the characters that serve as delimiters in a delimited string.</span></span> <span data-ttu-id="8b8da-3640">Anschließend wird die <xref:System.String.ToCharArray%2A>-Methode aufgerufen, um ein Zeichen Array zu erstellen, das an die <xref:System.String.Split%28System.Char%5B%5D%29>-Methode weitergegeben werden kann, um die Zeichenfolge in die einzelnen Teil Zeichenfolgen zu trennen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3640">It then calls the <xref:System.String.ToCharArray%2A> method to create a character array that can be passed to the <xref:System.String.Split%28System.Char%5B%5D%29> method to separate the delimited string into its individual substrings.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/StringSplit2/CPP/stringsplit2.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/stringsplit2.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit2.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
      </Docs>
    </Member>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray (startIndex As Integer, length As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : int * int -&gt; char[]" Usage="string.ToCharArray (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex"><span data-ttu-id="8b8da-3641">Die Anfangsposition einer Teilzeichenfolge innerhalb dieser Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3641">The starting position of a substring in this instance.</span></span></param>
        <param name="length"><span data-ttu-id="8b8da-3642">Die Länge einer Teilzeichenfolge innerhalb dieser Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3642">The length of the substring in this instance.</span></span></param>
        <summary><span data-ttu-id="8b8da-3643">Kopiert die Zeichen einer angegebenen Teilzeichenfolge dieser Instanz in ein Array von Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3643">Copies the characters in a specified substring in this instance to a Unicode character array.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3644">Ein Array von Unicode-Zeichen, dessen Elemente die <paramref name="length" />-Zeichen dieser Instanz ab Zeichenposition <paramref name="startIndex" /> sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3644">A Unicode character array whose elements are the <paramref name="length" /> number of characters in this instance starting from character position <paramref name="startIndex" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-3645">Diese Methode kopiert die Zeichen in einem Teil einer Zeichenfolge in ein Zeichen Array.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3645">This method copies the characters in a portion of a string to a character array.</span></span> <span data-ttu-id="8b8da-3646">Um eine Zeichenfolge aus einem Zeichenbereich in einem Zeichen Array zu erstellen, rufen Sie den <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>-Konstruktor auf.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3646">To create a string from a range of characters in a character array, call the  <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructor.</span></span>

 <span data-ttu-id="8b8da-3647">Der `startIndex`-Parameter ist NULL basiert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3647">The `startIndex` parameter is zero-based.</span></span> <span data-ttu-id="8b8da-3648">Das heißt, der Index des ersten Zeichens in der Zeichen folgen Instanz ist 0 (null).</span><span class="sxs-lookup"><span data-stu-id="8b8da-3648">That is, the index of the first character in the string instance is zero.</span></span>

 <span data-ttu-id="8b8da-3649">Wenn `length` 0 (null) ist, ist das zurückgegebene Array leer und hat die Länge 0 (null).</span><span class="sxs-lookup"><span data-stu-id="8b8da-3649">If `length` is zero, the returned array is empty and has a zero length.</span></span> <span data-ttu-id="8b8da-3650">Wenn diese Instanz `null` oder eine leere Zeichenfolge ("") ist, ist das zurückgegebene Array leer und hat eine Länge von 0 (null).</span><span class="sxs-lookup"><span data-stu-id="8b8da-3650">If this instance is `null` or an empty string (""), the returned array is empty and has a zero length.</span></span>

 <span data-ttu-id="8b8da-3651">Um ein Bytearray zu erstellen, das die codierten Zeichen in einem Teil einer Zeichenfolge enthält, instanziieren Sie das entsprechende <xref:System.Text.Encoding> Objekt, und rufen Sie dessen <xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29>-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3651">To create a byte array that contains the encoded characters in a portion of a string, instantiate the appropriate <xref:System.Text.Encoding> object and call its <xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29> method.</span></span> <span data-ttu-id="8b8da-3652">Zu den in .NET verfügbaren Standard Codierungen gehören:</span><span class="sxs-lookup"><span data-stu-id="8b8da-3652">Some of the standard encodings available in .NET include:</span></span>

|<span data-ttu-id="8b8da-3653">Codierung</span><span class="sxs-lookup"><span data-stu-id="8b8da-3653">Encoding</span></span>|<span data-ttu-id="8b8da-3654">Object</span><span class="sxs-lookup"><span data-stu-id="8b8da-3654">Object</span></span>|
|--------------|------------|
|<span data-ttu-id="8b8da-3655">ASCII</span><span class="sxs-lookup"><span data-stu-id="8b8da-3655">ASCII</span></span>|<xref:System.Text.ASCIIEncoding>|
|<span data-ttu-id="8b8da-3656">UTF-7</span><span class="sxs-lookup"><span data-stu-id="8b8da-3656">UTF-7</span></span>|<xref:System.Text.UTF7Encoding>|
|<span data-ttu-id="8b8da-3657">UTF-8</span><span class="sxs-lookup"><span data-stu-id="8b8da-3657">UTF-8</span></span>|<xref:System.Text.UTF8Encoding>|
|<span data-ttu-id="8b8da-3658">UTF-16</span><span class="sxs-lookup"><span data-stu-id="8b8da-3658">UTF-16</span></span>|<xref:System.Text.UnicodeEncoding>|
|<span data-ttu-id="8b8da-3659">UTF-32</span><span class="sxs-lookup"><span data-stu-id="8b8da-3659">UTF-32</span></span>|<xref:System.Text.UTF32Encoding>|

 <span data-ttu-id="8b8da-3660">Weitere Informationen finden Sie unter [Zeichencodierung in .net](~/docs/standard/base-types/character-encoding.md).</span><span class="sxs-lookup"><span data-stu-id="8b8da-3660">For more information, see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md).</span></span>



## Examples
 <span data-ttu-id="8b8da-3661">Im folgenden Beispiel wird eine Teil Zeichenfolge innerhalb einer Zeichenfolge in ein Zeichen Array konvertiert. Anschließend werden die Elemente des Arrays aufgelistet und angezeigt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3661">The following example converts a substring within a string to an array of characters, then enumerates and displays the elements of the array.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.ToCharArray1/CPP/tocharry1.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.ToCharArray1/CS/tocharry1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.ToCharArray1/VB/tocharry1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8b8da-3662"><paramref name="startIndex" /> oder <paramref name="length" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3662"><paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</span></span>

<span data-ttu-id="8b8da-3663">- oder -</span><span class="sxs-lookup"><span data-stu-id="8b8da-3663">-or-</span></span>

 <span data-ttu-id="8b8da-3664"><paramref name="startIndex" /> plus <paramref name="length" /> ist größer als die Länge dieser Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3664"><paramref name="startIndex" /> plus <paramref name="length" /> is greater than the length of this instance.</span></span></exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8b8da-3665">Gibt eine in Kleinbuchstaben konvertierte Kopie dieser Zeichenfolge zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3665">Returns a copy of this string converted to lowercase.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower();" />
      <MemberSignature Language="F#" Value="member this.ToLower : unit -&gt; string" Usage="string.ToLower " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8b8da-3666">Gibt eine in Kleinbuchstaben konvertierte Kopie dieser Zeichenfolge zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3666">Returns a copy of this string converted to lowercase.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3667">Eine Zeichenfolge aus Kleinbuchstaben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3667">A string in lowercase.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-3668">Diese Methode berücksichtigt die Regeln der Groß-und Kleinschreibung der aktuellen Kultur.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3668">This method takes into account the casing rules of the current culture.</span></span>

> [!NOTE]
>  <span data-ttu-id="8b8da-3669">Diese Methode ändert nicht den Wert der aktuellen Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3669">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="8b8da-3670">Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der alle Zeichen in der aktuellen Instanz in Kleinbuchstaben konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3670">Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</span></span>

## <a name="security-considerations"></a><span data-ttu-id="8b8da-3671">Sicherheitsüberlegungen</span><span class="sxs-lookup"><span data-stu-id="8b8da-3671">Security Considerations</span></span>
 <span data-ttu-id="8b8da-3672">Der Schreibvorgang, der sich aus dem Aufruf der <xref:System.String.ToLower>-Methode ergibt, übernimmt die Groß-/Kleinschreibungskonventionen der aktuellen Kultur.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3672">The casing operation that results from calling the <xref:System.String.ToLower> method takes the casing conventions of the current culture into account.</span></span> <span data-ttu-id="8b8da-3673">Wenn Sie die Groß-oder Kleinbuchstaben Version eines Betriebssystem Bezeichners benötigen, z. b. einen Dateinamen, Named Pipe oder einen Registrierungsschlüssel, verwenden Sie die Methoden <xref:System.String.ToLowerInvariant%2A> oder <xref:System.String.ToUpperInvariant%2A>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3673">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> methods.</span></span> <span data-ttu-id="8b8da-3674">Dies erzeugt dasselbe Ergebnis in jeder Kultur (im Gegensatz zur <xref:System.String.ToLower>-Methode) und führt zu einer effizienteren Leistung.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3674">This produces the same result in every culture (unlike the <xref:System.String.ToLower> method) and performs more efficiently.</span></span>



## Examples
 <span data-ttu-id="8b8da-3675">Im folgenden Beispiel werden mehrere gemischte Case-Zeichen folgen in Kleinbuchstaben konvertiert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3675">The following example converts several mixed case strings to lowercase.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/stringlowerupper/CPP/stringtolower.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/stringlowerupper/CS/stringtolower.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/stringlowerupper/VB/stringtolower.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-3676">Wie in [bewährte Methoden für die Verwendung von](~/docs/standard/base-types/best-practices-strings.md)Zeichen folgen erläutert, empfiehlt es sich, Methoden zum Schreiben von Zeichen folgen nicht aufzurufen, die Standardwerte ersetzen, und stattdessen Methoden aufzurufen, für die Parameter explizit angegeben werden müssen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3676">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string casing methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="8b8da-3677">Um ein Zeichen in Kleinbuchstaben zu konvertieren, indem Sie die Groß-/Kleinschreibungskonventionen der aktuellen Kultur verwenden, müssen Sie die <see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" />-Methoden Überladung mit dem Wert <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> für den <paramref name="culture" /> Parameter aufrufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3677">To convert a character to lowercase by using the casing conventions of the current culture, call the <see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /> method overload with a value of <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> for its <paramref name="culture" /> parameter.</span></span></para></block>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToLower : System.Globalization.CultureInfo -&gt; string" Usage="string.ToLower culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="culture"><span data-ttu-id="8b8da-3678">Ein Objekt, das kulturspezifische Regeln zur Groß- und Kleinschreibung bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3678">An object that supplies culture-specific casing rules.</span></span></param>
        <summary><span data-ttu-id="8b8da-3679">Gibt eine in Kleinbuchstaben konvertierte Kopie dieser Zeichenfolge zurück, wobei die Regeln der Groß- und Kleinschreibung der angegebenen Kultur verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3679">Returns a copy of this string converted to lowercase, using the casing rules of the specified culture.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3680">Die Entsprechung der aktuellen Zeichenfolge in Kleinbuchstaben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3680">The lowercase equivalent of the current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-3681">Die Regeln für die Groß-und Kleinschreibung der durch den `culture`-Parameter angegebenen Kultur bestimmen, wie der Fall der Zeichenfolge geändert wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3681">The casing rules of the culture specified by the `culture` parameter determine the way the case of the string is changed.</span></span>

> [!NOTE]
>  <span data-ttu-id="8b8da-3682">Diese Methode ändert nicht den Wert der aktuellen Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3682">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="8b8da-3683">Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der alle Zeichen in der aktuellen Instanz in Kleinbuchstaben konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3683">Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</span></span>

## <a name="security-considerations"></a><span data-ttu-id="8b8da-3684">Sicherheitsüberlegungen</span><span class="sxs-lookup"><span data-stu-id="8b8da-3684">Security Considerations</span></span>
 <span data-ttu-id="8b8da-3685">Wenn Sie die <xref:System.String.ToLower%28System.Globalization.CultureInfo%29>-Methode einem anderen <xref:System.Globalization.CultureInfo>-Objekt als <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>übergeben, werden bei der groß-/kleinschreibungsweise kulturspezifische Regeln berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3685">If you pass the <xref:System.String.ToLower%28System.Globalization.CultureInfo%29> method a <xref:System.Globalization.CultureInfo> object other than <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, the casing operation will take culture-specific rules into account.</span></span> <span data-ttu-id="8b8da-3686">Wenn Sie die Groß-oder Kleinbuchstaben Version eines Betriebssystem Bezeichners benötigen, z. b. einen Dateinamen, Named Pipe oder einen Registrierungsschlüssel, verwenden Sie die Methode <xref:System.String.ToLowerInvariant%2A> oder <xref:System.String.ToUpperInvariant%2A>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3686">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> method.</span></span> <span data-ttu-id="8b8da-3687">Dies führt in jeder Kultur zu demselben Ergebnis und führt zu einer effizienteren Leistung.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3687">This produces the same result in every culture and performs more efficiently.</span></span>



## Examples
 <span data-ttu-id="8b8da-3688">Im folgenden Beispiel werden zwei Zeichen folgen von Großbuchstaben in Kleinbuchstaben konvertiert, indem die Kulturen English-USA und Turkish-Türkei verwendet werden. Anschließend werden die Zeichen folgen in Kleinbuchstaben verglichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3688">The following example converts two strings of uppercase characters to lowercase characters using the English-United States and Turkish-Turkey cultures, then compares the lowercase strings.</span></span> <span data-ttu-id="8b8da-3689">Die Zeichen folgen in Großbuchstaben sind beinahe identisch, mit der Ausnahme, dass für jedes Vorkommen des Unicode-lateinischen Großbuchstaben i in einer Zeichenfolge die andere Zeichenfolge den lateinischen Großbuchstaben i mit einem vorangehenden Punkt enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3689">The uppercase strings are identical except that for each occurrence of the Unicode LATIN CAPITAL LETTER I in one string, the other string contains LATIN CAPITAL LETTER I WITH DOT ABOVE.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.tolower1/CPP/tolower.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.tolower1/CS/tolower.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tolower1/VB/tolower.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-3690"><paramref name="culture" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3690"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.ToUpper" />
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public string ToLowerInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLowerInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLowerInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLowerInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLowerInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToLowerInvariant : unit -&gt; string" Usage="string.ToLowerInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8b8da-3691">Gibt eine in Kleinbuchstaben konvertierte Kopie dieses <see cref="T:System.String" />-Objekts zurück, wobei die Regeln der Groß- und Kleinschreibung der invarianten Kultur verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3691">Returns a copy of this <see cref="T:System.String" /> object converted to lowercase using the casing rules of the invariant culture.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3692">Die Entsprechung der aktuellen Zeichenfolge in Kleinbuchstaben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3692">The lowercase equivalent of the current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-3693">Die invariante Kultur stellt eine Kultur dar, die Kultur unabhängig ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3693">The invariant culture represents a culture that is culture-insensitive.</span></span> <span data-ttu-id="8b8da-3694">Sie ist mit der englischen Sprache verknüpft, jedoch nicht mit einem bestimmten Land oder einer bestimmten Region.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3694">It is associated with the English language but not with a specific country or region.</span></span> <span data-ttu-id="8b8da-3695">Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3695">For more information, see the <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> property.</span></span>

 <span data-ttu-id="8b8da-3696">Wenn Ihre Anwendung von der Groß-und Kleinschreibung einer Zeichenfolge abhängig ist, die von der aktuellen Kultur nicht betroffen ist, verwenden Sie die <xref:System.String.ToLowerInvariant%2A>-Methode.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3696">If your application depends on the case of a string changing in a predictable way that is unaffected by the current culture, use the <xref:System.String.ToLowerInvariant%2A> method.</span></span> <span data-ttu-id="8b8da-3697">Die <xref:System.String.ToLowerInvariant%2A>-Methode entspricht `ToLower(CultureInfo.InvariantCulture)`.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3697">The <xref:System.String.ToLowerInvariant%2A> method is equivalent to `ToLower(CultureInfo.InvariantCulture)`.</span></span> <span data-ttu-id="8b8da-3698">Die-Methode wird empfohlen, wenn eine Auflistung von Zeichen folgen in einer vorhersagbaren Reihenfolge in einem Benutzeroberflächen Steuerelement angezeigt werden muss.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3698">The method is recommended when a collection of strings must appear in a predictable order in a user interface control.</span></span>

> [!NOTE]
>  <span data-ttu-id="8b8da-3699">Diese Methode ändert nicht den Wert der aktuellen Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3699">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="8b8da-3700">Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der alle Zeichen in der aktuellen Instanz in Kleinbuchstaben konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3700">Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</span></span>

## <a name="security-considerations"></a><span data-ttu-id="8b8da-3701">Sicherheitsüberlegungen</span><span class="sxs-lookup"><span data-stu-id="8b8da-3701">Security Considerations</span></span>
 <span data-ttu-id="8b8da-3702">Wenn Sie die Groß-oder Kleinbuchstaben Version eines Betriebssystem Bezeichners benötigen, z. b. einen Dateinamen, Named Pipe oder einen Registrierungsschlüssel, verwenden Sie die Methoden <xref:System.String.ToLowerInvariant%2A> oder <xref:System.String.ToUpperInvariant%2A>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3702">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> methods.</span></span>



## Examples
 <span data-ttu-id="8b8da-3703">Im folgenden Beispiel wird ein Zeichen folgen Array definiert, das ein einzelnes Wort in einer Reihe von Sprachen enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3703">The following example defines a string array that contains a single word in a number of languages.</span></span> <span data-ttu-id="8b8da-3704">Die <xref:System.String.ToLowerInvariant%2A>-Methode wird verwendet, um die Elemente eines parallelen Arrays mit der Unterscheidung nach Groß-/Kleinschreibung der einzelnen Word-Elemente aufzufüllen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3704">The <xref:System.String.ToLowerInvariant%2A> method is used to populate the elements of a parallel array with the case-insensitive version of each word.</span></span> <span data-ttu-id="8b8da-3705">Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType>-Methode wird verwendet, um das Array mit Berücksichtigung der Groß-/Kleinschreibung basierend auf der Reihenfolge der Elemente im Array für Kleinbuchstaben zu sortieren, um sicherzustellen, dass Elemente unabhängig von der Sprache in derselben Reihenfolge</span><span class="sxs-lookup"><span data-stu-id="8b8da-3705">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> method is used to sort the case-sensitive array based on the order of elements in the lowercase array to ensure that elements appear in the same order regardless of language.</span></span>

 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tolowerinvariant/cs/tolowerinvariant.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tolowerinvariant/vb/tolowerinvariant.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToUpperInvariant" />
        <altmember cref="M:System.String.ToLower(System.Globalization.CultureInfo)" />
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8b8da-3706">Konvertiert den Wert dieser Instanz in einen <see cref="T:System.String" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3706">Converts the value of this instance to a <see cref="T:System.String" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="string.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8b8da-3707">Gibt diese Instanz von <see cref="T:System.String" /> zurück. Es wird keine wirkliche Konvertierung durchgeführt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3707">Returns this instance of <see cref="T:System.String" />; no actual conversion is performed.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3708">Die aktuelle Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3708">The current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-3709">Da diese Methode die aktuelle Zeichenfolge einfach unverändert zurückgibt, ist es nicht erforderlich, Sie direkt aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3709">Because this method simply returns the current string unchanged, there is no need to call it directly.</span></span> <span data-ttu-id="8b8da-3710">Sie wird in der Regel implizit in einem zusammengesetzten Formatierungs Vorgang aufgerufen, wie im Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3710">It is usually called implicitly in a composite formatting operation, as the example shows.</span></span>



## Examples
 <span data-ttu-id="8b8da-3711">Im folgenden Beispiel wird die <xref:System.String.ToString%2A>-Methode veranschaulicht. Beachten Sie, dass im Beispiel nicht explizit die <xref:System.String.ToString%2A>-Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3711">The following example demonstrates the <xref:System.String.ToString%2A> method.Note that the example does not explicitly call the <xref:System.String.ToString%2A> method.</span></span> <span data-ttu-id="8b8da-3712">Stattdessen wird die-Methode implizit von der Funktion für die [kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3712">Instead, the method is called implicitly by the [composite formatting](~/docs/standard/base-types/composite-formatting.md) feature.</span></span>

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/string.tostring/CPP/string.tostring.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/string.tostring/CS/string.tostring.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tostring/VB/string.tostring.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Clone" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="string.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="8b8da-3713">(Reserviert) Ein Objekt, das kulturabhängige Formatierungsinformationen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3713">(Reserved) An object that supplies culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="8b8da-3714">Gibt diese Instanz von <see cref="T:System.String" /> zurück. Es wird keine wirkliche Konvertierung durchgeführt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3714">Returns this instance of <see cref="T:System.String" />; no actual conversion is performed.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3715">Die aktuelle Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3715">The current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-3716">`provider` ist reserviert und ist zurzeit nicht an diesem Vorgang beteiligt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3716">`provider` is reserved, and does not currently participate in this operation.</span></span>

 <span data-ttu-id="8b8da-3717">Da diese Methode die aktuelle Zeichenfolge einfach unverändert zurückgibt, ist es nicht erforderlich, Sie direkt aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3717">Because this method simply returns the current string unchanged, there is no need to call it directly.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8b8da-3718">Gibt eine in Großbuchstaben konvertierte Kopie dieser Zeichenfolge zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3718">Returns a copy of this string converted to uppercase.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper();" />
      <MemberSignature Language="F#" Value="member this.ToUpper : unit -&gt; string" Usage="string.ToUpper " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8b8da-3719">Gibt eine in Großbuchstaben konvertierte Kopie dieser Zeichenfolge zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3719">Returns a copy of this string converted to uppercase.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3720">Die Entsprechung der aktuellen Zeichenfolge in Großbuchstaben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3720">The uppercase equivalent of the current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-3721">Diese Methode verwendet die Regeln der Groß-/Kleinschreibung der aktuellen Kultur, um jedes Zeichen in der aktuellen-Instanz in den entsprechenden Großbuchstaben zu konvertieren.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3721">This method uses the casing rules of the current culture to convert each character in the current instance to its uppercase equivalent.</span></span> <span data-ttu-id="8b8da-3722">Wenn ein Zeichen nicht über eine Entsprechung in Großbuchstaben verfügt, ist es in der zurückgegebenen Zeichenfolge unverändert enthalten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3722">If a character does not have an uppercase equivalent, it is included unchanged in the returned string.</span></span>

> [!NOTE]
>  <span data-ttu-id="8b8da-3723">Diese Methode ändert nicht den Wert der aktuellen Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3723">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="8b8da-3724">Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der alle Zeichen in der aktuellen Instanz in Großbuchstaben konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3724">Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</span></span>

 <span data-ttu-id="8b8da-3725">Die <xref:System.String.ToUpper%2A>-Methode wird häufig verwendet, um eine Zeichenfolge in Großbuchstaben zu konvertieren, sodass Sie bei einem Vergleich ohne Beachtung der Groß-/Kleinschreibung verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3725">The <xref:System.String.ToUpper%2A> method is often used to convert a string to uppercase so that it can be used in a case-insensitive comparison.</span></span> <span data-ttu-id="8b8da-3726">Eine bessere Methode, Vergleiche ohne Berücksichtigung der Groß-/Kleinschreibung durchzuführen, besteht darin, eine Zeichen folgen Vergleichsmethode mit einem <xref:System.StringComparison>-Parameter aufzurufen, dessen Wert Sie für einen Kultur abhängigen, Groß-/Kleinschreibung-Vergleich <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType> festlegen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3726">A better method to perform case-insensitive comparison is to call a string comparison method that has a <xref:System.StringComparison> parameter whose value you set to <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType> for a culture-sensitive, case-insensitive comparison.</span></span>

## <a name="security-considerations"></a><span data-ttu-id="8b8da-3727">Sicherheitsüberlegungen</span><span class="sxs-lookup"><span data-stu-id="8b8da-3727">Security Considerations</span></span>
 <span data-ttu-id="8b8da-3728">Der Schreibvorgang, der sich aus dem Aufruf der <xref:System.String.ToUpper>-Methode ergibt, übernimmt die Groß-/Kleinschreibungskonventionen der aktuellen Kultur.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3728">The casing operation that results from calling the <xref:System.String.ToUpper> method takes the casing conventions of the current culture into account.</span></span> <span data-ttu-id="8b8da-3729">Wenn Sie die Groß-oder Kleinbuchstaben Version eines Betriebssystem Bezeichners benötigen, z. b. einen Dateinamen, Named Pipe oder einen Registrierungsschlüssel, verwenden Sie die Methode <xref:System.String.ToLowerInvariant%2A> oder <xref:System.String.ToUpperInvariant%2A>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3729">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> method.</span></span> <span data-ttu-id="8b8da-3730">Dies erzeugt dasselbe Ergebnis in jeder Kultur (im Gegensatz zur <xref:System.String.ToUpper>-Methode) und führt zu einer effizienteren Leistung.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3730">This produces the same result in every culture (unlike the <xref:System.String.ToUpper> method) and performs more efficiently.</span></span>



## Examples
 <span data-ttu-id="8b8da-3731">Im folgenden Beispiel wird die <xref:System.String.ToUpper%2A>-Methode aufgerufen, um eine Reihe von Zeichen folgen mit einer Zeichenfolge zu konvertieren, die jedes Zeichen in den grundlegenden lateinischen, lateinischen und lateinischen Zeichensätzen und lateinischen Zeichensätzen enthalten.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3731">The following example calls the <xref:System.String.ToUpper%2A> method to convert a series of one-character strings that contain each character in the Basic Latin, Latin-1 Supplement, and Latin Extended-A character sets.</span></span> <span data-ttu-id="8b8da-3732">Anschließend wird jede Zeichenfolge angezeigt, deren Großbuchstabe von Ihrem Kleinbuchstaben abweicht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3732">It then displays each string whose uppercase character is different from its lowercase character.</span></span>

 [!code-cpp[System.String.ToUpper#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.ToUpper/cpp/ToUpperEx.cpp#1)]
 [!code-csharp[System.String.ToUpper#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.ToUpper/cs/ToUpperEx.cs#1)]
 [!code-vb[System.String.ToUpper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.ToUpper/vb/ToUpperEx.vb#1)]

 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-3733">Wie in [bewährte Methoden für die Verwendung von](~/docs/standard/base-types/best-practices-strings.md)Zeichen folgen erläutert, empfiehlt es sich, Methoden zum Schreiben von Zeichen folgen nicht aufzurufen, die Standardwerte ersetzen, und stattdessen Methoden aufzurufen, für die Parameter explizit angegeben werden müssen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3733">As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string casing methods that substitute default values and instead call methods that require parameters to be explicitly specified.</span></span> <span data-ttu-id="8b8da-3734">Um eine Zeichenfolge mithilfe der groß-/Kleinschreibungskonventionen der aktuellen Kultur in Großbuchstaben zu konvertieren, müssen Sie die <see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" />-Methoden Überladung mit dem Wert <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> für den <paramref name="culture" />-Parameter aufrufen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3734">To convert a string to uppercase by using the casing conventions of the current culture, call the <see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /> method overload with a value of <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> for its <paramref name="culture" /> parameter.</span></span></para></block>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToUpper : System.Globalization.CultureInfo -&gt; string" Usage="string.ToUpper culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="culture"><span data-ttu-id="8b8da-3735">Ein Objekt, das kulturspezifische Regeln zur Groß- und Kleinschreibung bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3735">An object that supplies culture-specific casing rules.</span></span></param>
        <summary><span data-ttu-id="8b8da-3736">Gibt eine in Großbuchstaben konvertierte Kopie dieser Zeichenfolge zurück, wobei die Regeln der Groß- und Kleinschreibung der angegebenen Kultur verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3736">Returns a copy of this string converted to uppercase, using the casing rules of the specified culture.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3737">Die Entsprechung der aktuellen Zeichenfolge in Großbuchstaben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3737">The uppercase equivalent of the current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-3738">Die Regeln für die Groß-und Kleinschreibung der durch den `culture`-Parameter angegebenen Kultur bestimmen, wie die Groß-und Kleinschreibung einer Zeichenfolge geändert</span><span class="sxs-lookup"><span data-stu-id="8b8da-3738">The casing rules of the culture specified by the `culture` parameter determine the way the case of a string is changed.</span></span>

> [!NOTE]
>  <span data-ttu-id="8b8da-3739">Diese Methode ändert nicht den Wert der aktuellen Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3739">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="8b8da-3740">Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der alle Zeichen in der aktuellen Instanz in Großbuchstaben konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3740">Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</span></span>

## <a name="security-considerations"></a><span data-ttu-id="8b8da-3741">Sicherheitsüberlegungen</span><span class="sxs-lookup"><span data-stu-id="8b8da-3741">Security Considerations</span></span>
 <span data-ttu-id="8b8da-3742">Wenn Sie die <xref:System.String.ToUpper%28System.Globalization.CultureInfo%29>-Methode einem anderen <xref:System.Globalization.CultureInfo>-Objekt als <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>übergeben, werden bei der groß-/kleinschreibungsweise kulturspezifische Regeln berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3742">If you pass the <xref:System.String.ToUpper%28System.Globalization.CultureInfo%29> method a <xref:System.Globalization.CultureInfo> object other than <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, the casing operation will take culture-specific rules into account.</span></span> <span data-ttu-id="8b8da-3743">Wenn Sie die Groß-oder Kleinbuchstaben Version eines Betriebssystem Bezeichners benötigen, z. b. einen Dateinamen, Named Pipe oder einen Registrierungsschlüssel, verwenden Sie die Methode <xref:System.String.ToLowerInvariant%2A> oder <xref:System.String.ToUpperInvariant%2A>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3743">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> method.</span></span> <span data-ttu-id="8b8da-3744">Dies führt in jeder Kultur zu demselben Ergebnis und führt zu einer effizienteren Leistung.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3744">This produces the same result in every culture and performs more efficiently.</span></span>



## Examples
 <span data-ttu-id="8b8da-3745">Im folgenden Beispiel wird eine Zeichenfolge aus Kleinbuchstaben mithilfe der Kulturen Englisch-USA und Türkisch-Türkei in zwei Zeichen folgen von Großbuchstaben konvertiert. Anschließend werden die Zeichen folgen in Großbuchstaben verglichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3745">The following example converts a string of lowercase characters to two strings of uppercase characters using the English-United States and Turkish-Turkey cultures, then compares the uppercase strings.</span></span> <span data-ttu-id="8b8da-3746">Die Zeichen folgen in Großbuchstaben sind beinahe identisch, mit der Ausnahme, dass für jedes Vorkommen des Unicode-lateinischen Großbuchstaben i in einer Zeichenfolge die andere Zeichenfolge den lateinischen Großbuchstaben i mit einem vorangehenden Punkt enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3746">The uppercase strings are identical except that for each occurrence of the Unicode LATIN CAPITAL LETTER I in one string, the other string contains LATIN CAPITAL LETTER I WITH DOT ABOVE.</span></span>

 [!code-csharp[string.toupper1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.toupper1/CS/toupper.cs#1)]
 [!code-vb[string.toupper1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.toupper1/VB/toupper.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8b8da-3747"><paramref name="culture" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3747"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public string ToUpperInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpperInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpperInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpperInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpperInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToUpperInvariant : unit -&gt; string" Usage="string.ToUpperInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8b8da-3748">Gibt eine in Großbuchstaben konvertierte Kopie dieses <see cref="T:System.String" />-Objekts zurück, wobei die Regeln der Groß- und Kleinschreibung der invarianten Kultur verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3748">Returns a copy of this <see cref="T:System.String" /> object converted to uppercase using the casing rules of the invariant culture.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3749">Die Entsprechung der aktuellen Zeichenfolge in Großbuchstaben.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3749">The uppercase equivalent of the current string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="8b8da-3750">Die invariante Kultur stellt eine Kultur dar, die Kultur unabhängig ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3750">The invariant culture represents a culture that is culture-insensitive.</span></span> <span data-ttu-id="8b8da-3751">Sie ist mit der englischen Sprache verknüpft, jedoch nicht mit einem bestimmten Land oder einer bestimmten Region.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3751">It is associated with the English language but not with a specific country or region.</span></span> <span data-ttu-id="8b8da-3752">Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3752">For more information, see the <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> property.</span></span>

 <span data-ttu-id="8b8da-3753">Wenn Ihre Anwendung von der Groß-und Kleinschreibung einer Zeichenfolge abhängig ist, die von der aktuellen Kultur nicht betroffen ist, verwenden Sie die <xref:System.String.ToUpperInvariant%2A>-Methode.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3753">If your application depends on the case of a string changing in a predictable way that is unaffected by the current culture, use the <xref:System.String.ToUpperInvariant%2A> method.</span></span> <span data-ttu-id="8b8da-3754">Die <xref:System.String.ToUpperInvariant%2A>-Methode entspricht `ToUpper(CultureInfo.InvariantCulture)`.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3754">The <xref:System.String.ToUpperInvariant%2A> method is equivalent to `ToUpper(CultureInfo.InvariantCulture)`.</span></span> <span data-ttu-id="8b8da-3755">Die-Methode wird empfohlen, wenn eine Auflistung von Zeichen folgen in einer vorhersagbaren Reihenfolge in einem Benutzeroberflächen Steuerelement angezeigt werden muss.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3755">The method is recommended when a collection of strings must appear in a predictable order in a user interface control.</span></span>

> [!NOTE]
>  <span data-ttu-id="8b8da-3756">Diese Methode ändert nicht den Wert der aktuellen Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3756">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="8b8da-3757">Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der alle Zeichen in der aktuellen Instanz in Großbuchstaben konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3757">Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</span></span>

## <a name="security-considerations"></a><span data-ttu-id="8b8da-3758">Sicherheitsüberlegungen</span><span class="sxs-lookup"><span data-stu-id="8b8da-3758">Security Considerations</span></span>
 <span data-ttu-id="8b8da-3759">Wenn Sie die Groß-oder Kleinbuchstaben Version eines Betriebssystem Bezeichners benötigen, z. b. einen Dateinamen, Named Pipe oder einen Registrierungsschlüssel, verwenden Sie die Methoden <xref:System.String.ToLowerInvariant%2A> oder <xref:System.String.ToUpperInvariant%2A>.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3759">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> methods.</span></span>



## Examples
 <span data-ttu-id="8b8da-3760">Im folgenden Beispiel wird ein Zeichen folgen Array definiert, das ein einzelnes Wort in einer Reihe von Sprachen enthält.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3760">The following example defines a string array that contains a single word in a number of languages.</span></span> <span data-ttu-id="8b8da-3761">Die <xref:System.String.ToUpperInvariant%2A>-Methode wird verwendet, um die Elemente eines parallelen Arrays mit der Unterscheidung nach Groß-/Kleinschreibung der einzelnen Word-Elemente aufzufüllen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3761">The <xref:System.String.ToUpperInvariant%2A> method is used to populate the elements of a parallel array with the case-insensitive version of each word.</span></span> <span data-ttu-id="8b8da-3762">Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType>-Methode wird verwendet, um das Array mit Berücksichtigung der Groß-/Kleinschreibung basierend auf der Reihenfolge der Elemente im Array Großbuchstaben zu sortieren, um sicherzustellen, dass Elemente unabhängig von der Sprache in derselben Reihenfolge vorkommen</span><span class="sxs-lookup"><span data-stu-id="8b8da-3762">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> method is used to sort the case-sensitive array based on the order of elements in the uppercase array to ensure that elements appear in the same order regardless of language.</span></span>

 [!code-csharp[System.String.ToUpperInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.toupperinvariant/cs/toupperinvariant.cs#1)]
 [!code-vb[System.String.ToUpperInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.toupperinvariant/vb/toupperinvariant.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Trim">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8b8da-3763">Gibt eine neue Zeichenfolge zurück, in der alle führenden und nachgestellten Vorkommen einer Gruppe von angegebenen Zeichen aus der aktuellen Zeichenfolge entfernt wurden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3763">Returns a new string in which all leading and trailing occurrences of a set of specified characters from the current string are removed.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim();" />
      <MemberSignature Language="F#" Value="member this.Trim : unit -&gt; string" Usage="string.Trim " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8b8da-3764">Entfernt alle führenden und nachgestellten Leerraumzeichen aus der aktuellen Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3764">Removes all leading and trailing white-space characters from the current string.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3765">Die resultierende Zeichenfolge nach dem Entfernen alle Leerraumzeichen am Anfang und Ende der aktuellen Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3765">The string that remains after all white-space characters are removed from the start and end of the current string.</span></span> <span data-ttu-id="8b8da-3766">Wenn keine Zeichen in der aktuellen Instanz gekürzt werden können, gibt die Methode die aktuelle Instanz unverändert zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3766">If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="8b8da-3767">Die `Trim`-Methode entfernt alle führenden und nachfolgenden Leerzeichen aus der aktuellen Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3767">The `Trim` method removes from the current string all leading and trailing white-space characters.</span></span> <span data-ttu-id="8b8da-3768">Jeder führende und nachfolgende Trim-Vorgang wird beendet, wenn ein nicht-Leerzeichen auftritt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3768">Each leading and trailing trim operation stops when a non-white-space character is encountered.</span></span> <span data-ttu-id="8b8da-3769">Wenn die aktuelle Zeichenfolge z. b. "abc xyz" ist, gibt die `Trim`-Methode "abc xyz" zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3769">For example, if the current string is "   abc   xyz    ", the `Trim` method returns "abc   xyz".</span></span> <span data-ttu-id="8b8da-3770">Verwenden Sie [reguläre .net-Ausdrücke](~/docs/standard/base-types/regular-expressions.md), um Leerzeichen zwischen Wörtern in einer Zeichenfolge zu entfernen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3770">To remove white-space characters between words in a string, use [.NET Regular Expressions](~/docs/standard/base-types/regular-expressions.md).</span></span>

> [!NOTE]
>  <span data-ttu-id="8b8da-3771">Wenn die `Trim`-Methode alle Zeichen aus der aktuellen Instanz entfernt, ändert diese Methode nicht den Wert der aktuellen Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3771">If the `Trim` method removes any characters from the current instance, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="8b8da-3772">Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der alle führenden und nachfolgenden Leerzeichen, die in der aktuellen Instanz gefunden werden, entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3772">Instead, it returns a new string in which all leading and trailing white space characters found in the current instance are removed.</span></span>

<span data-ttu-id="8b8da-3773">Wenn die aktuelle Zeichenfolge <xref:System.String.Empty?displayProperty=nameWithtype> ist oder alle Zeichen in der aktuellen Instanz aus Leerzeichen bestehen, gibt die Methode <xref:System.String.Empty?displayProperty=nameWithtype>zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3773">If the current string equals <xref:System.String.Empty?displayProperty=nameWithtype> or all the characters in the current instance consist of white-space characters, the method returns <xref:System.String.Empty?displayProperty=nameWithtype>.</span></span>

<span data-ttu-id="8b8da-3774">Leerzeichen werden durch den Unicode-Standard definiert.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3774">White-space characters are defined by the Unicode standard.</span></span> <span data-ttu-id="8b8da-3775">Die `Trim`-Methode entfernt alle führenden und nachfolgenden Zeichen, die einen Rückgabewert von `true` ergeben, wenn Sie an die <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>-Methode übermittelt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3775">The `Trim` method removes any leading and trailing characters that produce a return value of `true` when they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span>

## Examples

<span data-ttu-id="8b8da-3776">Im folgenden Beispiel wird die <xref:System.String.Trim?displayProperty=nameWithType>-Methode verwendet, um zusätzliche Leerräume aus Zeichen folgen zu entfernen, die vom Benutzer eingegeben wurden, bevor Sie verkettet werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3776">The following example uses the <xref:System.String.Trim?displayProperty=nameWithType> method to remove any extra white space from strings entered by the user before concatenating them.</span></span>

[!code-cpp[System.String.Trim#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim2.cpp#2)]
[!code-csharp[System.String.Trim#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim2.cs#2)]
[!code-vb[System.String.Trim#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim2.vb#2)]

          ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-3777">In der-[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und früheren Versionen wird eine interne Liste von leer Raum Zeichen beibehalten, die von dieser Methode fest sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3777">The [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions maintain an internal list of white-space characters that this method trims.</span></span> <span data-ttu-id="8b8da-3778">Beginnend mit dem [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]werden alle Unicode-Leerzeichen (d. h. Zeichen, die einen <see langword="true" /> Rückgabewert ergeben, wenn Sie an die <see cref="M:System.Char.IsWhiteSpace(System.Char)" />-Methode übermittelt werden).</span><span class="sxs-lookup"><span data-stu-id="8b8da-3778">Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the method trims all Unicode white-space characters (that is, characters that produce a <see langword="true" /> return value when they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method).</span></span> <span data-ttu-id="8b8da-3779">Aufgrund dieser Änderung werden durch die <see cref="M:System.String.Trim" />-Methode in der [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und früheren Versionen zwei Zeichen entfernt, d. &amp; # 160; 200 &amp; # 160; 200 &amp; # 160; 200 &amp; # 160; null &amp; gt; NULL-Breite, nicht Umbruch Bereich (u + FEFF), dass die <see cref="M:System.String.Trim" />-Methode in der [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]und höheren Versionen</span><span class="sxs-lookup"><span data-stu-id="8b8da-3779">Because of this change, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]and later versions does not remove.</span></span> <span data-ttu-id="8b8da-3780">Außerdem werden durch die <see cref="M:System.String.Trim" />-Methode in der [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und früheren Versionen nicht drei Unicode-leer Raum Zeichen entfernt: Mongolisch vowel Separator (u + 180E), Narrow No-Break Space (u + 202F) und mittlerer mathematischer Raum (u + 205f).</span><span class="sxs-lookup"><span data-stu-id="8b8da-3780">In addition, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</span></span></para></block>
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.Trim : char -&gt; string" Usage="string.Trim trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="trimChar"><span data-ttu-id="8b8da-3781">Ein zu entfernendes Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3781">A Unicode character to remove.</span></span></param>
        <summary><span data-ttu-id="8b8da-3782">Entfernt alle führenden und nachgestellten Instanzen eines Zeichens aus der aktuellen Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3782">Removes all leading and trailing instances of a character from the current string.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3783">Die resultierende Zeichenfolge nach dem Entfernen aller Instanzen des Zeichen <paramref name="trimChar" /> am Anfang und Ende der aktuellen Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3783">The string that remains after all instances of the <paramref name="trimChar" /> character are removed from the start and end of the current string.</span></span> <span data-ttu-id="8b8da-3784">Wenn keine Zeichen in der aktuellen Instanz gekürzt werden können, gibt die Methode die aktuelle Instanz unverändert zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3784">If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="8b8da-3785">Die `Trim(System.Char)`-Methode entfernt alle führenden und nachfolgenden Instanzen des `trimChar` Zeichens aus der aktuellen Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3785">The `Trim(System.Char)` method removes from the current string all leading and trailing instances of the `trimChar` character.</span></span> <span data-ttu-id="8b8da-3786">Jeder führende und nachfolgende Trim-Vorgang wird beendet, wenn ein anderes Zeichen als `trimChar` auftritt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3786">Each leading and trailing trim operation stops when a character different from `trimChar` is encountered.</span></span> <span data-ttu-id="8b8da-3787">Wenn `trimChar` beispielsweise `-` ist und die aktuelle Zeichenfolge "---abc---xyz----" ist, gibt die `Trim(System.Char)`-Methode "abc---xyz" zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3787">For example, if `trimChar` is `-` and the current string is "---abc---xyz----", the `Trim(System.Char)` method returns "abc---xyz".</span></span> <span data-ttu-id="8b8da-3788">Verwenden Sie [reguläre .net-Ausdrücke](~/docs/standard/base-types/regular-expressions.md), um Zeichen zwischen Wörtern in einer Zeichenfolge zu entfernen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3788">To remove characters between words in a string, use [.NET Regular Expressions](~/docs/standard/base-types/regular-expressions.md).</span></span>

> [!NOTE]
>  <span data-ttu-id="8b8da-3789">Wenn die `Trim(System.Char)`-Methode alle Zeichen aus der aktuellen Instanz entfernt, ändert diese Methode nicht den Wert der aktuellen Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3789">If the `Trim(System.Char)` method removes any characters from the current instance, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="8b8da-3790">Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der alle führenden und nachfolgenden `trimChar` Zeichen, die in der aktuellen Instanz gefunden werden, entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3790">Instead, it returns a new string in which all leading and trailing `trimChar` characters found in the current instance are removed.</span></span>

<span data-ttu-id="8b8da-3791">Wenn die aktuelle Zeichenfolge <xref:System.String.Empty?displayProperty=nameWithtype> ist oder alle Zeichen in der aktuellen Instanz aus `trimChar` Zeichen bestehen, gibt die Methode <xref:System.String.Empty?displayProperty=nameWithtype>zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3791">If the current string equals <xref:System.String.Empty?displayProperty=nameWithtype> or all the characters in the current instance consist of `trimChar` characters, the method returns <xref:System.String.Empty?displayProperty=nameWithtype>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.Trim : char[] -&gt; string" Usage="string.Trim trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars"><span data-ttu-id="8b8da-3792">Ein Array mit den zu entfernenden Unicode-Zeichen oder <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3792">An array of Unicode characters to remove, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="8b8da-3793">Entfernt alle führenden und nachgestellten Vorkommen der Zeichen im angegebenen Array aus der aktuellen Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3793">Removes all leading and trailing occurrences of a set of characters specified in an array from the current string.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3794">Die resultierende Zeichenfolge, nachdem alle im <paramref name="trimChars" />-Parameter übergebenen Zeichen am Anfang und Ende der aktuellen Zeichenfolge entfernt wurden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3794">The string that remains after all occurrences of the characters in the <paramref name="trimChars" /> parameter are removed from the start and end of the current string.</span></span> <span data-ttu-id="8b8da-3795">Wenn <paramref name="trimChars" /><see langword="null" /> oder ein leeres Array ist, werden stattdessen Leerzeichen entfernt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3795">If <paramref name="trimChars" /> is <see langword="null" /> or an empty array, white-space characters are removed instead.</span></span> <span data-ttu-id="8b8da-3796">Wenn keine Zeichen in der aktuellen Instanz gekürzt werden können, gibt die Methode die aktuelle Instanz unverändert zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3796">If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="8b8da-3797">Die `Trim(System.Char[])`-Methode entfernt alle führenden und nachfolgenden Zeichen aus der aktuellen Zeichenfolge, die im `trimChars`-Parameter enthalten sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3797">The `Trim(System.Char[])` method removes from the current string all leading and trailing characters that are in the `trimChars` parameter.</span></span> <span data-ttu-id="8b8da-3798">Jeder führende und nachfolgende Trim-Vorgang wird beendet, wenn ein Zeichen, das sich nicht in `trimChars` befindet, gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3798">Each leading and trailing trim operation stops when a character that is not in `trimChars` is encountered.</span></span> <span data-ttu-id="8b8da-3799">Wenn die aktuelle Zeichenfolge z. b. "123abc456xyz789" ist und `trimChars` die Ziffern von "1" bis "9" enthält, gibt die `Trim(System.Char[])`-Methode "abc456xyz" zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3799">For example, if the current string is "123abc456xyz789" and `trimChars` contains the digits from "1" through "9", the `Trim(System.Char[])` method returns "abc456xyz".</span></span>

> [!NOTE]
>  <span data-ttu-id="8b8da-3800">Wenn die `Trim(System.Char[])`-Methode alle Zeichen aus der aktuellen Instanz entfernt, ändert diese Methode nicht den Wert der aktuellen Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3800">If the `Trim(System.Char[])` method removes any characters from the current instance, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="8b8da-3801">Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der alle führenden und nachfolgenden `trimChars` Zeichen, die in der aktuellen Instanz gefunden werden, entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3801">Instead, it returns a new string in which all leading and trailing `trimChars` characters found in the current instance are removed.</span></span>

<span data-ttu-id="8b8da-3802">Wenn die aktuelle Zeichenfolge <xref:System.String.Empty?displayProperty=nameWithtype> ist oder alle Zeichen in der aktuellen Instanz aus Zeichen im `trimChars` Array bestehen, gibt die Methode <xref:System.String.Empty?displayProperty=nameWithtype>zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3802">If the current string equals <xref:System.String.Empty?displayProperty=nameWithtype> or all the characters in the current instance consist of characters in the `trimChars` array, the method returns <xref:System.String.Empty?displayProperty=nameWithtype>.</span></span>

<span data-ttu-id="8b8da-3803">Wenn `trimChars` `null` oder ein leeres Array ist, entfernt diese Methode alle führenden oder nachfolgenden Zeichen, die dazu führen, dass die Methode `true` zurückgibt, wenn Sie an die <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>-Methode übermittelt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3803">If `trimChars` is `null` or an empty array, this method removes any leading or trailing characters that result in the method returning `true` when they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span>

## Examples

<span data-ttu-id="8b8da-3804">Im folgenden Beispiel werden die `Trim(System.Char[])`-Methode verwendet, um Leerzeichen, Sternchen (\*) und Apostroph (') aus einer Zeichenfolge zu entfernen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3804">The following example uses the `Trim(System.Char[])` method to remove space, asterisk (\*), and apostrophe (') characters from a string.</span></span>

[!code-cpp[System.String.Trim#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim1.cpp#1)]
[!code-csharp-interactive[System.String.Trim#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim1.cs#1)]
[!code-vb[System.String.Trim#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim1.vb#1)]

          ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-3805">In der-[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und früheren Versionen wird eine interne Liste von leer Raum Zeichen verwaltet, die von dieser Methode nur dann, wenn <paramref name="trimChars" /> <see langword="null" /> ist, oder ein leeres Array.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3805">The [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions maintains an internal list of white-space characters that this method trims if <paramref name="trimChars" /> is <see langword="null" /> or an empty array.</span></span> <span data-ttu-id="8b8da-3806">Beginnend mit der [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], wenn <paramref name="trimChars" /> <see langword="null" /> oder ein leeres Array ist, schneidet die-Methode alle Unicode-Leerzeichen (d. h. Zeichen, die einen <see langword="true" /> Rückgabewert ergeben, wenn Sie an die <see cref="M:System.Char.IsWhiteSpace(System.Char)" />-Methode übermittelt werden).</span><span class="sxs-lookup"><span data-stu-id="8b8da-3806">Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], if <paramref name="trimChars" /> is <see langword="null" /> or an empty array, the method trims all Unicode white-space characters (that is, characters that produce a <see langword="true" /> return value when they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method).</span></span> <span data-ttu-id="8b8da-3807">Aufgrund dieser Änderung werden durch die <see cref="M:System.String.Trim" />-Methode in der [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und früheren Versionen zwei Zeichen entfernt, d. &amp; # 160; 200 &amp; # 160; 200 &amp; # 160; 200 &amp; # 160; null &amp; gt; NULL-Breite, nicht Umbruch Bereich (u + FEFF), dass die <see cref="M:System.String.Trim" />-Methode in der [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]und höheren Versionen</span><span class="sxs-lookup"><span data-stu-id="8b8da-3807">Because of this change, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]and later versions does not remove.</span></span> <span data-ttu-id="8b8da-3808">Außerdem werden durch die <see cref="M:System.String.Trim" />-Methode in der [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und früheren Versionen nicht drei Unicode-leer Raum Zeichen entfernt: Mongolisch vowel Separator (u + 180E), Narrow No-Break Space (u + 202F) und mittlerer mathematischer Raum (u + 205f).</span><span class="sxs-lookup"><span data-stu-id="8b8da-3808">In addition, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</span></span></para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd();" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : unit -&gt; string" Usage="string.TrimEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8b8da-3809">Entfernt alle nachgestellten Leerraumzeichen aus der aktuellen Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3809">Removes all the trailing white-space characters from the current string.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3810">Die resultierende Zeichenfolge nach dem Entfernen alle Leerraumzeichen am Ende der aktuellen Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3810">The string that remains after all white-space characters are removed from the end of the current string.</span></span> <span data-ttu-id="8b8da-3811">Wenn keine Zeichen in der aktuellen Instanz gekürzt werden können, gibt die Methode die aktuelle Instanz unverändert zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3811">If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="8b8da-3812">Die `TrimEnd`-Methode entfernt alle nachfolgenden Leerzeichen aus der aktuellen Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3812">The `TrimEnd` method removes from the current string all trailing white-space characters.</span></span> <span data-ttu-id="8b8da-3813">Der Trim-Vorgang wird beendet, wenn das erste Zeichen, das kein Leerzeichen ist, am Ende der Zeichenfolge gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3813">The trim operation stops when the first non white-space character is encountered at the end of the string.</span></span> <span data-ttu-id="8b8da-3814">Wenn die aktuelle Zeichenfolge z. b. "abc xyz" ist, gibt die `TrimEnd`-Methode "abc xyz" zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3814">For example, if the current string is "   abc   xyz    ", the `TrimEnd` method returns "   abc   xyz".</span></span>

> [!NOTE]
>  <span data-ttu-id="8b8da-3815">Wenn die `TrimEnd`-Methode alle Zeichen aus der aktuellen Instanz entfernt, ändert diese Methode nicht den Wert der aktuellen Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3815">If the `TrimEnd` method removes any characters from the current instance, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="8b8da-3816">Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der alle nachfolgenden Leerzeichen aus der aktuellen Zeichenfolge entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3816">Instead, it returns a new string in which all trailing white-space characters are removed from the current string.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char -&gt; string" Usage="string.TrimEnd trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="trimChar"><span data-ttu-id="8b8da-3817">Ein zu entfernendes Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3817">A Unicode character to remove.</span></span></param>
        <summary><span data-ttu-id="8b8da-3818">Entfernt alle nachgestellten Vorkommen eines Zeichens aus der aktuellen Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3818">Removes all the trailing occurrences of a character from the current string.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3819">Die resultierende Zeichenfolge, nachdem alle Vorkommen des Zeichens <paramref name="trimChar" /> am Ende der aktuellen Zeichenfolge entfernt wurden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3819">The string that remains after all occurrences of the <paramref name="trimChar" /> character are removed from the end of the current string.</span></span> <span data-ttu-id="8b8da-3820">Wenn keine Zeichen in der aktuellen Instanz gekürzt werden können, gibt die Methode die aktuelle Instanz unverändert zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3820">If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="8b8da-3821">Die `TrimEnd(System.Char)`-Methode entfernt alle nachfolgenden `trimChar` Zeichen aus der aktuellen Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3821">The `TrimEnd(System.Char)` method removes from the current string all trailing `trimChar` characters.</span></span> <span data-ttu-id="8b8da-3822">Der Trim-Vorgang wird beendet, wenn das erste Zeichen, das nicht `trimChar` ist, am Ende der Zeichenfolge gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3822">The trim operation stops when the first character that is not `trimChar` is encountered at the end of the string.</span></span> <span data-ttu-id="8b8da-3823">Wenn `trimChar` beispielsweise `-` ist und die aktuelle Zeichenfolge "---abc---xyz----" ist, gibt die `TrimEnd(System.Char)`-Methode "---abc---xyz" zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3823">For example, if `trimChar` is `-` and the current string is "---abc---xyz----", the `TrimEnd(System.Char)` method returns "---abc---xyz".</span></span>

> [!NOTE]
>  <span data-ttu-id="8b8da-3824">Wenn die `TrimEnd(System.Char)`-Methode alle Zeichen aus der aktuellen Instanz entfernt, ändert diese Methode nicht den Wert der aktuellen Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3824">If the `TrimEnd(System.Char)` method removes any characters from the current instance, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="8b8da-3825">Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der alle nachfolgenden `trimChar` Zeichen aus der aktuellen Zeichenfolge entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3825">Instead, it returns a new string in which all trailing `trimChar` characters are removed from the current string.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char[] -&gt; string" Usage="string.TrimEnd trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars"><span data-ttu-id="8b8da-3826">Ein Array mit den zu entfernenden Unicode-Zeichen oder <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3826">An array of Unicode characters to remove, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="8b8da-3827">Entfernt alle nachgestellten Vorkommen der Zeichen im angegebenen Array aus der aktuellen Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3827">Removes all the trailing occurrences of a set of characters specified in an array from the current string.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3828">Die resultierende Zeichenfolge, nachdem alle im <paramref name="trimChars" />-Parameter übergebenen Zeichen am Ende der aktuellen Zeichenfolge entfernt wurden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3828">The string that remains after all occurrences of the characters in the <paramref name="trimChars" /> parameter are removed from the end of the current string.</span></span> <span data-ttu-id="8b8da-3829">Wenn <paramref name="trimChars" /><see langword="null" /> oder ein leeres Array ist, werden stattdessen Leerzeichen entfernt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3829">If <paramref name="trimChars" /> is <see langword="null" /> or an empty array, Unicode white-space characters are removed instead.</span></span> <span data-ttu-id="8b8da-3830">Wenn keine Zeichen in der aktuellen Instanz gekürzt werden können, gibt die Methode die aktuelle Instanz unverändert zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3830">If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="8b8da-3831">Die `TrimEnd(System.Char[])`-Methode entfernt alle nachfolgenden Zeichen aus der aktuellen Zeichenfolge, die im `trimChars`-Parameter enthalten sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3831">The `TrimEnd(System.Char[])` method removes from the current string all trailing characters that are in the `trimChars` parameter.</span></span> <span data-ttu-id="8b8da-3832">Der Trim-Vorgang wird beendet, wenn das erste Zeichen, das sich nicht in `trimChars` befindet, am Ende der Zeichenfolge gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3832">The trim operation stops when the first character that is not in `trimChars` is encountered at the end of the string.</span></span> <span data-ttu-id="8b8da-3833">Wenn z. b. die aktuelle Zeichenfolge "123abc456xyz789" ist und `trimChars` die Ziffern von "1" bis "9" enthält, gibt die `TrimEnd(System.Char[])`-Methode "123abc456xyz" zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3833">For example, if the current string is "123abc456xyz789" and `trimChars` contains the digits from "1" through "9", the `TrimEnd(System.Char[])` method returns "123abc456xyz".</span></span>

> [!NOTE]
>  <span data-ttu-id="8b8da-3834">Wenn die `TrimEnd(System.Char[])`-Methode alle Zeichen aus der aktuellen Instanz entfernt, ändert diese Methode nicht den Wert der aktuellen Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3834">If the `TrimEnd(System.Char[])` method removes any characters from the current instance, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="8b8da-3835">Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der alle nachfolgenden Zeichen, die in `trimChars` gefunden werden, aus der aktuellen Zeichenfolge entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3835">Instead, it returns a new string in which all trailing characters found in `trimChars` are removed from the current string.</span></span>

## Examples

<span data-ttu-id="8b8da-3836">Im folgenden Beispiel wird veranschaulicht, wie Sie mit der `TrimEnd(System.Char[])`-Methode Leerzeichen oder Satzzeichen am Ende einer Zeichenfolge Kürzen können.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3836">The following example demonstrates how you can use the `TrimEnd(System.Char[])` method to trim white space or punctuation marks from the end of a string.</span></span>

[!code-csharp-interactive[System.String.TrimEnd#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimEnd/cs/sample2.cs#2)]
[!code-vb[System.String.TrimEnd#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimEnd/vb/Sample2.vb#2)]

          ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-3837">In der-[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und früheren Versionen wird eine interne Liste von leer Raum Zeichen verwaltet, die von dieser Methode nur dann, wenn <paramref name="trimChars" /> <see langword="null" /> ist, oder ein leeres Array.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3837">The [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions maintains an internal list of white-space characters that this method trims if <paramref name="trimChars" /> is <see langword="null" /> or an empty array.</span></span> <span data-ttu-id="8b8da-3838">Beginnend mit der [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], wenn <paramref name="trimChars" /> <see langword="null" /> oder ein leeres Array ist, schneidet die-Methode alle Unicode-Leerzeichen (d. h. Zeichen, die einen <see langword="true" /> Rückgabewert ergeben, wenn Sie an die <see cref="M:System.Char.IsWhiteSpace(System.Char)" />-Methode übermittelt werden).</span><span class="sxs-lookup"><span data-stu-id="8b8da-3838">Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], if <paramref name="trimChars" /> is <see langword="null" /> or an empty array, the method trims all Unicode white-space characters (that is, characters that produce a <see langword="true" /> return value when they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method).</span></span> <span data-ttu-id="8b8da-3839">Aufgrund dieser Änderung werden durch die <see cref="M:System.String.Trim" />-Methode in der [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und früheren Versionen zwei Zeichen entfernt, d. &amp; # 160; 200 &amp; # 160; 200 &amp; # 160; 200 &amp; # 160; null &amp; gt; NULL-Breite, nicht Umbruch Bereich (u + FEFF), dass die <see cref="M:System.String.Trim" />-Methode in der [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] und höheren Versionen</span><span class="sxs-lookup"><span data-stu-id="8b8da-3839">Because of this change, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and later versions does not remove.</span></span> <span data-ttu-id="8b8da-3840">Außerdem werden durch die <see cref="M:System.String.Trim" />-Methode in der [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und früheren Versionen nicht drei Unicode-leer Raum Zeichen entfernt: Mongolisch vowel Separator (u + 180E), Narrow No-Break Space (u + 202F) und mittlerer mathematischer Raum (u + 205f).</span><span class="sxs-lookup"><span data-stu-id="8b8da-3840">In addition, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</span></span></para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart();" />
      <MemberSignature Language="F#" Value="member this.TrimStart : unit -&gt; string" Usage="string.TrimStart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8b8da-3841">Entfernt alle führenden Leerraumzeichen aus der aktuellen Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3841">Removes all the leading white-space characters from the current string.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3842">Die resultierende Zeichenfolge nach dem Entfernen alle Leerraumzeichen am Anfang der aktuellen Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3842">The string that remains after all white-space characters are removed from the start of the current string.</span></span> <span data-ttu-id="8b8da-3843">Wenn keine Zeichen in der aktuellen Instanz gekürzt werden können, gibt die Methode die aktuelle Instanz unverändert zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3843">If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="8b8da-3844">Die `TrimStart`-Methode entfernt alle führenden Leerzeichen aus der aktuellen Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3844">The `TrimStart` method removes from the current string all leading white-space characters.</span></span> <span data-ttu-id="8b8da-3845">Der Trim-Vorgang wird beendet, wenn ein nicht-Leerzeichen auftritt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3845">The trim operation stops when a non white-space character is encountered.</span></span> <span data-ttu-id="8b8da-3846">Wenn die aktuelle Zeichenfolge z. b. "abc xyz" ist, gibt die `TrimStart`-Methode "abc xyz" zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3846">For example, if the current string is "   abc   xyz    ", the `TrimStart` method returns "abc   xyz    ".</span></span>

> [!NOTE]
>  <span data-ttu-id="8b8da-3847">Wenn die `TrimStart`-Methode alle Zeichen aus der aktuellen Instanz entfernt, ändert diese Methode nicht den Wert der aktuellen Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3847">If the `TrimStart` method removes any characters from the current instance, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="8b8da-3848">Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der alle in der aktuellen Instanz gefundenen führenden Leerzeichen entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3848">Instead, it returns a new string in which all leading white space characters found in the current instance are removed.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char -&gt; string" Usage="string.TrimStart trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="trimChar"><span data-ttu-id="8b8da-3849">Das zu entfernende Unicode-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3849">The Unicode character to remove.</span></span></param>
        <summary><span data-ttu-id="8b8da-3850">Entfernt alle führenden Vorkommen eines bestimmten Zeichens aus der aktuellen Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3850">Removes all the leading occurrences of a specified character from the current string.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3851">Die resultierende Zeichenfolge, nachdem alle Vorkommen des Zeichens <paramref name="trimChar" /> am Anfang der aktuellen Zeichenfolge entfernt wurden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3851">The string that remains after all occurrences of the <paramref name="trimChar" /> character are removed from the start of the current string.</span></span> <span data-ttu-id="8b8da-3852">Wenn keine Zeichen in der aktuellen Instanz gekürzt werden können, gibt die Methode die aktuelle Instanz unverändert zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3852">If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="8b8da-3853">Die `TrimStart(System.Char)`-Methode entfernt alle führenden `trimChar` Zeichen aus der aktuellen Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3853">The `TrimStart(System.Char)` method removes from the current string all leading `trimChar` characters.</span></span> <span data-ttu-id="8b8da-3854">Der Trim-Vorgang wird beendet, wenn ein Zeichen, das nicht `trimChar` wird, gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3854">The trim operation stops when a character that is not `trimChar` is encountered.</span></span> <span data-ttu-id="8b8da-3855">Wenn `trimChar` beispielsweise `-` ist und die aktuelle Zeichenfolge "---abc---xyz----" ist, gibt die `TrimStart(System.Char)`-Methode "abc---xyz----" zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3855">For example, if `trimChar` is `-` and the current string is "---abc---xyz----", the `TrimStart(System.Char)` method returns "abc---xyz----".</span></span>

> [!NOTE]
>  <span data-ttu-id="8b8da-3856">Wenn die `TrimStart(System.Char)`-Methode alle Zeichen aus der aktuellen Instanz entfernt, ändert diese Methode nicht den Wert der aktuellen Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3856">If the `TrimStart(System.Char)` method removes any characters from the current instance, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="8b8da-3857">Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der alle in der aktuellen Instanz gefundenen führenden `trimChar` Zeichen entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3857">Instead, it returns a new string in which all leading `trimChar` characters found in the current instance are removed.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char[] -&gt; string" Usage="string.TrimStart trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars"><span data-ttu-id="8b8da-3858">Ein Array mit den zu entfernenden Unicode-Zeichen oder <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3858">An array of Unicode characters to remove, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="8b8da-3859">Entfernt alle führenden Vorkommen der Zeichen im angegebenen Array aus der aktuellen Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3859">Removes all the leading occurrences of a set of characters specified in an array from the current string.</span></span></summary>
        <returns><span data-ttu-id="8b8da-3860">Die resultierende Zeichenfolge, nachdem alle im <paramref name="trimChars" />-Parameter übergebenen Zeichen am Anfang der aktuellen Zeichenfolge entfernt wurden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3860">The string that remains after all occurrences of characters in the <paramref name="trimChars" /> parameter are removed from the start of the current string.</span></span> <span data-ttu-id="8b8da-3861">Wenn <paramref name="trimChars" /><see langword="null" /> oder ein leeres Array ist, werden stattdessen Leerzeichen entfernt.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3861">If <paramref name="trimChars" /> is <see langword="null" /> or an empty array, white-space characters are removed instead.</span></span> <span data-ttu-id="8b8da-3862">Wenn keine Zeichen in der aktuellen Instanz gekürzt werden können, gibt die Methode die aktuelle Instanz unverändert zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3862">If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="8b8da-3863">Die `TrimStart(System.Char[])`-Methode entfernt alle führenden Zeichen aus der aktuellen Zeichenfolge, die im `trimChars`-Parameter enthalten sind.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3863">The `TrimStart(System.Char[])` method removes from the current string all leading characters that are in the `trimChars` parameter.</span></span> <span data-ttu-id="8b8da-3864">Der Trim-Vorgang wird beendet, wenn ein Zeichen, das sich nicht in `trimChars` befindet, gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3864">The trim operation stops when a character that is not in `trimChars` is encountered.</span></span> <span data-ttu-id="8b8da-3865">Wenn die aktuelle Zeichenfolge z. b. "123abc456xyz789" ist und `trimChars` die Ziffern von "1" bis "9" enthält, gibt die `TrimStart(System.Char[])`-Methode "abc456xyz789" zurück.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3865">For example, if the current string is "123abc456xyz789" and `trimChars` contains the digits from "1" through "9", the `TrimStart(System.Char[])` method returns "abc456xyz789".</span></span>

> [!NOTE]
>  <span data-ttu-id="8b8da-3866">Wenn die `TrimStart(System.Char[])`-Methode alle Zeichen aus der aktuellen Instanz entfernt, ändert diese Methode nicht den Wert der aktuellen Instanz.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3866">If the `TrimStart(System.Char[])` method removes any characters from the current instance, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="8b8da-3867">Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der alle führenden Zeichen, die im `trimChars`-Parameter in der aktuellen Instanz enthalten sind, entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3867">Instead, it returns a new string in which all leading characters that are in the `trimChars` parameter found in the current instance are removed.</span></span>

## Examples

<span data-ttu-id="8b8da-3868">Im folgenden Beispiel werden die grundlegenden Funktionen der <xref:System.String.TrimStart%2A>-Methode veranschaulicht:</span><span class="sxs-lookup"><span data-stu-id="8b8da-3868">The following example demonstrates the basic functionality of the <xref:System.String.TrimStart%2A> method:</span></span>

:::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs" id="Snippet1":::
:::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb" id="Snippet1":::

<span data-ttu-id="8b8da-3869">Im folgenden Beispiel wird die <xref:System.String.TrimStart%2A>-Methode verwendet, um Leerzeichen und Kommentarzeichen aus Zeilen des Quellcodes zu kürzen.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3869">The following example uses the <xref:System.String.TrimStart%2A> method to trim white space and comment characters from lines of source code.</span></span> <span data-ttu-id="8b8da-3870">Die `StripComments`-Methode umschließt einen aufzurufenden <xref:System.String.TrimStart%2A> und übergibt ein Zeichen Array mit einem Leerzeichen und dem Kommentarzeichen, das ein Apostroph (') in Visual Basic und ein Schrägstrich ( C#/) in ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3870">The `StripComments` method wraps a call to <xref:System.String.TrimStart%2A> and passes it a character array that contains a space and the comment character, which is an apostrophe ( ' ) in Visual Basic and a slash ( / ) in C#.</span></span> <span data-ttu-id="8b8da-3871">Die <xref:System.String.TrimStart%2A>-Methode wird auch aufgerufen, um führende Leerzeichen zu entfernen, wenn ausgewertet wird, ob eine Zeichenfolge ein Kommentar ist.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3871">The <xref:System.String.TrimStart%2A> method is also called to remove leading white space when evaluating whether a string is a comment.</span></span>

[!code-csharp[System.String.TrimStart#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#2)]
[!code-vb[System.String.TrimStart#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#2)]

<span data-ttu-id="8b8da-3872">Im folgenden Beispiel wird ein Aufruf der `StripComments`-Methode veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3872">The following example then illustrates a call to the `StripComments` method.</span></span>

[!code-csharp[System.String.TrimStart#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#3)]
[!code-vb[System.String.TrimStart#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#3)]

          ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="8b8da-3873">In der-[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und früheren Versionen wird eine interne Liste von leer Raum Zeichen verwaltet, die von dieser Methode nur dann, wenn <paramref name="trimChars" /> <see langword="null" /> ist, oder ein leeres Array.</span><span class="sxs-lookup"><span data-stu-id="8b8da-3873">The [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions maintains an internal list of white-space characters that this method trims if <paramref name="trimChars" /> is <see langword="null" /> or an empty array.</span></span> <span data-ttu-id="8b8da-3874">Beginnend mit der [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], wenn <paramref name="trimChars" /> <see langword="null" /> oder ein leeres Array ist, schneidet die-Methode alle Unicode-Leerzeichen (d. h. Zeichen, die einen <see langword="true" /> Rückgabewert ergeben, wenn Sie an die <see cref="M:System.Char.IsWhiteSpace(System.Char)" />-Methode übermittelt werden).</span><span class="sxs-lookup"><span data-stu-id="8b8da-3874">Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], if <paramref name="trimChars" /> is <see langword="null" /> or an empty array, the method trims all Unicode white-space characters (that is, characters that produce a <see langword="true" /> return value when they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method).</span></span> <span data-ttu-id="8b8da-3875">Aufgrund dieser Änderung werden durch die <see cref="M:System.String.Trim" />-Methode in der [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und früheren Versionen zwei Zeichen entfernt, d. &amp; # 160; 200 &amp; # 160; 200 &amp; # 160; 200 &amp; # 160; null &amp; gt; NULL-Breite, nicht Umbruch Bereich (u + FEFF), dass die <see cref="M:System.String.Trim" />-Methode in der [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] und höheren Versionen</span><span class="sxs-lookup"><span data-stu-id="8b8da-3875">Because of this change, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and later versions does not remove.</span></span> <span data-ttu-id="8b8da-3876">Außerdem werden durch die <see cref="M:System.String.Trim" />-Methode in der [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und früheren Versionen nicht drei Unicode-leer Raum Zeichen entfernt: Mongolisch vowel Separator (u + 180E), Narrow No-Break Space (u + 202F) und mittlerer mathematischer Raum (u + 205f).</span><span class="sxs-lookup"><span data-stu-id="8b8da-3876">In addition, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</span></span></para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
  </Members>
</Type>
