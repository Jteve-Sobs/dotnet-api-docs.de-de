<Type Name="String" FullName="System.String">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3fbec8c0fcf563ab30ecbc348178bf7a367febf5" /><Meta Name="ms.sourcegitcommit" Value="adc8598fd19d91438cacaa8fa7ce613e28c8218e" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/11/2018" /><Meta Name="ms.locfileid" Value="53233704" /></Metadata><TypeSignature Language="C#" Value="public sealed class String : ICloneable, IComparable, IComparable&lt;string&gt;, IConvertible, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" />
  <TypeSignature Language="DocId" Value="T:System.String" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements ICloneable, IComparable, IComparable(Of String), IConvertible, IEnumerable(Of Char), IEquatable(Of String)" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : ICloneable, IComparable, IComparable&lt;System::String ^&gt;, IConvertible, IEquatable&lt;System::String ^&gt;, System::Collections::Generic::IEnumerable&lt;char&gt;" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface IComparable&#xA;    interface ICloneable&#xA;    interface IConvertible&#xA;    interface IEnumerable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface seq&lt;char&gt;&#xA;    interface IEquatable&lt;string&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.String&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt Text als Sequenz von UTF-16-Codeeinheiten dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 Eine Zeichenfolge ist eine sequenzielle Auflistung von Zeichen, die zur Darstellung von Text verwendet wird. Ein <xref:System.String> Objekt ist eine sequenzielle Auflistung von <xref:System.Char?displayProperty=nameWithType> Objekte, die darstellen, eine Zeichenfolge, ein <xref:System.Char?displayProperty=nameWithType> -Objekt entspricht einer Codeeinheit UTF-16. Der Wert des der <xref:System.String> Objekt ist der Inhalt der sequenziellen Auflistung von <xref:System.Char?displayProperty=nameWithType> Objekte und unveränderlichen Wert (d.h., sie ist schreibgeschützt). Weitere Informationen über die Unveränderlichkeit von Zeichenfolgen finden Sie unter den [Unveränderlichkeit und der StringBuilder-Klasse](#Immutability) weiter unten in diesem Thema. Die maximale Größe einer <xref:System.String> Objekt im Arbeitsspeicher ist 2 GB oder etwa 1 Milliarde Zeichen.  
  
 In diesem Abschnitt  
  
 [Instanziieren ein String-Objekt](#Instantiation)   
 [Char-Objekten und Unicode-Zeichen](#Characters)   
 [Zeichenfolgen und Unicode-Standard](#Unicode)   
 [Zeichenfolgen und eingebettete Null-Zeichen](#EmbeddedNulls)   
 [Zeichenfolgen und Indizes](#Indexes)   
 [NULL-Zeichenfolgen und leere Zeichenfolgen](#Nulls)   
 [Unveränderlichkeit von und der StringBuilder-Klasse](#Immutability)   
 [Ordnungszahl im Vergleich zu kulturabhängige Operationen](#CultureSensitive)   
 [Normalisierung](#Normalization)   
 [Zeichenfolgenoperationen nach Kategorie](#ByCategory)  
  
<a name="Instantiation"></a>   
## <a name="instantiating-a-string-object"></a>Instanziieren ein String-Objekt  
 Instanziieren Sie ein <xref:System.String> Objekt auf folgende Weise:  
  
-   Durch Zuweisen eines Zeichenfolgenliterals zu einem <xref:System.String> Variable. Dies ist die am häufigsten verwendete Methode zum Erstellen einer Zeichenfolge. Im folgende Beispiel wird eine Zuweisung zum Erstellen von mehreren Zeichenfolgen verwendet. Beachten Sie, dass in c#, da der umgekehrte Schrägstrich (\\) ist ein Escapezeichen, Literale umgekehrte Schrägstriche in einer Zeichenfolge muss mit Escapezeichen versehen werden, oder die gesamte Zeichenfolge muss @-quoted.  
  
     [!code-cpp[System.String.Class.Instantiate#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate1.cpp#1)]
     [!code-csharp[System.String.Class.Instantiate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#1)]
     [!code-vb[System.String.Class.Instantiate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#1)]  
  
-   Durch Aufrufen einer <xref:System.String> Klassenkonstruktor. Im folgende Beispiel wird die Zeichenfolgen durch Aufrufen von Konstruktoren für verschiedene Klassen instanziiert. Beachten Sie, dass einige der Konstruktoren Zeiger auf Zeichenarrays oder Byte mit Vorzeichen von Arrays als Parameter. Visual Basic unterstützt keine Aufrufe dieser Konstruktoren. Ausführliche Informationen zu <xref:System.String> Konstruktoren finden Sie unter den <xref:System.String.%23ctor%2A> Konstruktor Zusammenfassung.  
  
     [!code-cpp[System.String.Class.Instantiate#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate2.cpp#2)]
     [!code-csharp[System.String.Class.Instantiate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#2)]
     [!code-vb[System.String.Class.Instantiate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#2)]  
  
-   Mithilfe des Operators für zeichenfolgenverkettung (+ in C# geschrieben und & oder + in Visual Basic) zum Erstellen einer einzelnen Zeichenfolge aus einer beliebigen Kombination <xref:System.String> Instanzen und Zeichenfolgenliterale. Das folgende Beispiel veranschaulicht die Verwendung der der Operator für zeichenfolgenverkettung.  
  
     [!code-cpp[System.String.Class.Instantiate#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#3)]
     [!code-csharp[System.String.Class.Instantiate#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#3)]
     [!code-vb[System.String.Class.Instantiate#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#3)]  
  
-   Zum Abrufen einer Eigenschaft oder Aufrufen einer Methode, die eine Zeichenfolge zurückgibt. Im folgenden Beispiel wird die Methoden der <xref:System.String> Klasse, um eine Teilzeichenfolge aus einer größeren Zeichenfolge zu extrahieren.  
  
     [!code-cpp[System.String.Class.Instantiate#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#4)]
     [!code-csharp[System.String.Class.Instantiate#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#4)]
     [!code-vb[System.String.Class.Instantiate#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#4)]  
  
-   Durch Aufrufen einer Formatierungsmethode auf, um einen Wert oder Objekt in seine Zeichenfolgendarstellung zu konvertieren. Im folgenden Beispiel wird die [kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) Funktion, um die Zeichenfolgendarstellung von zwei Objekten in eine Zeichenfolge einzubetten.  
  
     [!code-cpp[System.String.Class.Instantiate#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#5)]
     [!code-csharp[System.String.Class.Instantiate#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#5)]
     [!code-vb[System.String.Class.Instantiate#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#5)]  
  
<a name="Characters"></a>   
## <a name="char-objects-and-unicode-characters"></a>Char-Objekten und Unicode-Zeichen  
 Jedes Zeichen in einer Zeichenfolge wird durch eine Unicode-Skalarwert, die auch als Unicode-Codepunkt oder den Ordinalwert des Unicode-Zeichens (numerischen) definiert. Jeder Codepunkt mithilfe von UTF-16-Codierung codiert ist und der numerische Wert der einzelnen Elemente der Codierung wird dargestellt, indem eine <xref:System.Char> Objekt.  
  
> [!NOTE]
>  Beachten Sie, dass da ein <xref:System.String> Instanz besteht aus einer sequenziellen Auflistung von UTF-16-Codeeinheiten, es ist möglich, erstellen Sie eine <xref:System.String> -Objekt, das keine Unicode-Zeichenfolge wohlgeformt ist. Beispielsweise ist es möglich, eine Zeichenfolge zu erstellen, die ein niedriges Ersatzzeichen ohne entsprechende hohes Ersatzzeichen ist. Obwohl einige Methoden, z. B. die Methoden der Codierung und Decodierung von Objekten in der <xref:System.Text> Namespace kann überprüft, stellen Sie sicher, dass die Zeichenfolgen wohlgeformt sind <xref:System.String> Klassenmember ist nicht sichergestellt, dass eine Zeichenfolge wohlgeformt ist.  
  
 Ein einzelnes <xref:System.Char> Objekt in der Regel stellt einen einzelnen Codepunkt, d. h., der numerische Wert des der <xref:System.Char> Codepunkt entspricht. Z. B. den Codepunkt für das Zeichen "a" ist U + 0061 ist. Erfordert jedoch ein Codepunkt möglicherweise mehr als ein codiertes-Element (mehr als eine <xref:System.Char> Objekt). Der Unicode-Standard definiert zwei Arten von Zeichen, die entsprechen mehreren <xref:System.Char> Objekte: Graphemes und zusätzliche Unicode-Codepunkten, die den zusätzlichen Ebenen der Unicode-Zeichen entsprechen.  
  
-   Eine zwischen graphemgruppen wird durch ein Basiszeichen, gefolgt von einem oder mehreren Kombination von Zeichen dargestellt. Beispielsweise wird das Zeichen "ä" dargestellt, durch ein <xref:System.Char> Objekt, dessen Codepunkt U + 0061 ist gefolgt von einem <xref:System.Char> Objekt, dessen Codepunkt U + 0308. Dieses Zeichen auch definiert werden, indem ein einzelnes <xref:System.Char> Objekt, das einen Codepunkt U + 00E4 verfügt. Wie im folgenden Beispiel wird gezeigt, gibt ein kulturabhängigen Vergleich, Gleichheit, dass diese beiden datendarstellungen gleich, und sind zwar ein Ordinalvergleich durch gewöhnlicher nicht der Fall ist. Wenn die beiden Zeichenfolgen normalisiert sind, gibt hingegen ein ordinalen Vergleich auch, dass sie gleich sind. (Weitere Informationen zum Normalisieren von Zeichenfolgen finden Sie unter den [Normalisierung](#Normalization) Abschnitt.)  
  
     [!code-cpp[System.String.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char1.cpp#2)]
     [!code-csharp[System.String.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/grapheme1.cs#2)]
     [!code-vb[System.String.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/grapheme1.vb#2)]  
  
-   Unicode zusätzliche Codepunkt (ein Ersatzzeichenpaar) wird durch eine <xref:System.Char> Objekt, dessen Code ein hohes Ersatzzeichen ist, gefolgt von einer <xref:System.Char> -Objekt, dessen Codepunkt ein niedriges Ersatzzeichen ist. Die Codeeinheiten der hohe Ersatzzeichen-Bereich von U + D800 bis U + DBFF liegt. Die Codeeinheiten der niedrige Ersatzzeichen liegen zwischen U + DC00 und U + DFFF. Ersatzzeichenpaare werden verwendet, um Zeichen in den 16 zusätzlichen Unicode-Ebenen darstellen. Das folgende Beispiel erstellt ein Ersatzzeichen und übergibt es an der <xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType> Methode, um zu bestimmen, ob es sich um ein Ersatzzeichenpaar ist.  
  
     [!code-cpp[System.String.Class#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char2.cpp#3)]
     [!code-csharp[System.String.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/surrogate1.cs#3)]
     [!code-vb[System.String.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/surrogate1.vb#3)]  
  
<a name="Unicode"></a>   
## <a name="strings-and-the-unicode-standard"></a>Zeichenfolgen und Unicode-Standard  
 Werden die Zeichen in einer Zeichenfolge von UTF-16-codierte Codeeinheiten, die den entsprechen dargestellt <xref:System.Char> Werte.  
  
 Jedes Zeichen in einer Zeichenfolge verfügt über eine zugeordnete Unicode-Zeichenkategorie, die in .NET von dargestellt ist die <xref:System.Globalization.UnicodeCategory> Enumeration. Die Kategorie eines Zeichens oder ein Ersatzzeichenpaar kann bestimmt werden, indem die <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType> Methode.  

[!INCLUDE[character-categories](~/includes/unicode-categories.md)]
  
 Darüber hinaus .NET unterstützt Zeichenfolgenvergleich und Sortierung basierend auf den Unicode-Standard. In Versionen von .NET Framework durch die [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], .NET Framework verwaltet eine eigene Tabelle von Zeichenfolgendaten. Dies gilt auch für Versionen von .NET Framework ab, mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)] auf Windows 7 ausgeführt wird. Beginnend mit der [!INCLUDE[net_v45](~/includes/net-v45-md.md)] auf Windows 8 und höheren Versionen des Windows-Betriebssystems ausgeführt werden, die die Common Language Runtime-Delegaten Zeichenfolge Vergleichs- und Sortiervorgänge für das Betriebssystem. Zeichenfolgenvergleich in .NET Core, und Sortieren von Informationen über [International Components for Unicode](http://site.icu-project.org/) Bibliotheken. Die folgende Tabelle enthält die Versionen von .NET und die Versionen von Unicode-Standard auf, welches Zeichen als Vergleich und Sortierung basieren.  
  
|.NET-Version|Version des Unicode-Standards|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[The Unicode Standard, Version 4.0.0 (Der Unicode-Standard, Version 4.0.0)](https://www.unicode.org/versions/Unicode4.0.0/)|  
|.NET Framework 2.0|[The Unicode Standard, Version 5.0.0 (Der Unicode-Standard, Version 5.0.0)](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[The Unicode Standard, Version 5.0.0 (Der Unicode-Standard, Version 5.0.0)](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[The Unicode Standard, Version 5.0.0 (Der Unicode-Standard, Version 5.0.0)](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] und höher unter Windows 7|[The Unicode Standard, Version 5.0.0 (Der Unicode-Standard, Version 5.0.0)](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] und höher unter Windows 8 und späteren Windows-Betriebssystemen|[The Unicode Standard, Version 6.3.0 (Der Unicode-Standard, Version 6.3.0)](https://www.unicode.org/versions/Unicode6.3.0/)|  
|.NET Core (alle Versionen)|Hängt von der Version des Unicode-Standards, die von dem zugrunde liegenden Betriebssystem unterstützt werden.|

<a name="EmbeddedNulls"></a>   
## <a name="strings-and-embedded-null-characters"></a>Zeichenfolgen und eingebettete Null-Zeichen  
 In .NET eine <xref:System.String> Objekt kann eingebetteten Null-Zeichen, die Anzahl der im Rahmen der die Länge der Zeichenfolge enthalten. In einigen Sprachen wie C und C++ gibt ein Null-Zeichen jedoch an das Ende einer Zeichenfolge; Es ist nicht Teil der Zeichenfolge berücksichtigt und zählt nicht als Teil der die Länge der Zeichenfolge. Dies bedeutet, dass die folgenden allgemeinen Annahmen, die in C oder C++ geschriebene Bibliotheken oder C- und C++-Programmierer über Zeichenfolgen, die möglicherweise nicht unbedingt gültig, wenn Sie zugewiesen sind <xref:System.String> Objekte:  
  
-   Der Rückgabewert von der `strlen` oder `wcslen` Funktionen ist nicht unbedingt gleich <xref:System.String.Length%2A?displayProperty=nameWithType>.  
  
-   Die Zeichenfolge, die erstellt werden, indem Sie die `strcpy_s` oder `wcscpy_s` Funktionen ist nicht unbedingt identisch, mit der Zeichenfolge, die erstellt werden, indem die <xref:System.String.Copy%2A?displayProperty=nameWithType> Methode.  
  
 Sie sollten sicherstellen, dass diese systemeigene C- und C++-Code, der instanziiert <xref:System.String> Objekte und Code, der übergeben wird <xref:System.String> Objekte über Platform aufrufen, nicht davon ausgehen, dass ein Null-Zeichen am Ende der Zeichenfolge kennzeichnet.  
  
 Eingebettete Null-Zeichen in einer Zeichenfolge werden auch anders behandelt werden, wenn eine Zeichenfolge sortiert (bzw. im Vergleich) und eine Zeichenfolge gesucht wird. NULL-Zeichen werden ignoriert, wenn kulturabhängige Vergleiche zwischen zwei Zeichenfolgen, einschließlich vergleichen, die mit der invarianten Kultur ausgeführt wird. Diese sind nur für die Ordinalvergleiche, bei Ordnungszahl oder Groß-/Kleinschreibung berücksichtigt. Auf der anderen Seite eingebettete Null-Zeichen werden immer berücksichtigt, wenn eine Zeichenfolge mit Methoden wie z. B. Suche <xref:System.String.Contains%2A>, <xref:System.String.StartsWith%2A>, und <xref:System.String.IndexOf%2A>.  
  
<a name="Indexes"></a>   
## <a name="strings-and-indexes"></a>Zeichenfolgen und Indizes  
 Ein Index ist die Position des ein <xref:System.Char> Objekt (nicht in ein Unicode-Zeichen) in einem <xref:System.String>. Ein Index ist eine nullbasierte, nicht negative Zahl, die von der ersten Position in der Zeichenfolge, beginnt die Indexposition 0 (null) ist. Eine Reihe von Suchmethoden z. B. <xref:System.String.IndexOf%2A> und <xref:System.String.LastIndexOf%2A>, den Index eines Zeichens zurück, oder in der Zeichenfolgeninstanz Teilzeichenfolge.  
  
 Die <xref:System.String.Chars%2A> Eigenschaft ermöglicht den Zugriff auf einzelne <xref:System.Char> Objekte durch ihre Indexposition in der Zeichenfolge. Da die <xref:System.String.Chars%2A> -Eigenschaft ist die Standardeigenschaft (in Visual Basic) oder der Indexer (in c#), es stehen die einzelnen <xref:System.Char> Objekte in einer Zeichenfolge durch folgenden Code verwenden. Dieser Code sucht nach Leerzeichen oder Satzzeichen in eine Zeichenfolge, um zu bestimmen, wie viele Wörter der Zeichenfolge enthält.  
  
 [!code-cpp[System.String.Class#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index1.cpp#4)]
 [!code-csharp[System.String.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index1.cs#4)]
 [!code-vb[System.String.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index1.vb#4)]  
  
 Da die <xref:System.String> -Klasse implementiert die <xref:System.Collections.IEnumerable> -Schnittstelle, Sie können auch durchlaufen die <xref:System.Char> Objekte in eine Zeichenfolge mit einer `foreach` Konstrukt, wie im folgenden Beispiel gezeigt.  
  
 [!code-cpp[System.String.Class#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index2.cpp#5)]
 [!code-csharp[System.String.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index2.cs#5)]
 [!code-vb[System.String.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index2.vb#5)]  
  
 Aufeinander folgende Indexwerte entspricht möglicherweise nicht aufeinander folgende Unicode-Zeichen, da Unicode Zeichen möglicherweise als mehr als ein codiert <xref:System.Char> Objekt. Insbesondere kann eine Zeichenfolge mit mehreren Zeichen Texteinheiten enthalten, die von einem Basiszeichen gefolgt durch eine oder mehrere Kombinationszeichen oder Ersatzzeichenpaare gebildet werden. Arbeiten mit Unicode-Zeichen anstelle von <xref:System.Char> Objekte zu verwenden, die <xref:System.Globalization.StringInfo?displayProperty=nameWithType> und <xref:System.Globalization.TextElementEnumerator> Klassen. Das folgende Beispiel veranschaulicht den Unterschied zwischen Code, mit der Funktionsweise <xref:System.Char> Benutzerobjekten und Code, die mit Unicode-Zeichen. Die Anzahl der Zeichen oder Text-Elemente in jedem Wort im Satz verglichen. Die Zeichenfolge enthält zwei Sequenzen aus einem Basiszeichen, gefolgt von einer Kombination von Zeichen.  
  
 [!code-cpp[System.String.Class#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index3.cpp#6)]
 [!code-csharp[System.String.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index3.cs#6)]
 [!code-vb[System.String.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index3.vb#6)]  
  
 Dieses Beispiel funktioniert mit Textelemente mithilfe der <xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType> Methode und die <xref:System.Globalization.TextElementEnumerator> Klasse alle Textelemente in einer Zeichenfolge aufgelistet werden. Sie können auch ein Array, das durch den Aufruf der Startindex für jedes Textelement enthält Abrufen der <xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType> Methode.  
  
 Weitere Informationen zum Arbeiten mit Einheiten von eher Text als einzelnen <xref:System.Char> -Werte finden Sie in der <xref:System.Globalization.StringInfo> Klasse.  
  
<a name="Nulls"></a>   
## <a name="null-strings-and-empty-strings"></a>NULL-Zeichenfolgen und leere Zeichenfolgen  
 Eine Zeichenfolge, die deklariert wurde, jedoch wurde kein Wert zugewiesen ist `null`. Es wird versucht, das Aufrufen von Methoden für diese Zeichenfolge löst eine <xref:System.NullReferenceException>. Eine null-Zeichenfolge unterscheidet sich von der eine leere Zeichenfolge ist, d. h. eine Zeichenfolge, deren Wert "" oder <xref:System.String.Empty?displayProperty=nameWithType>. In einigen Fällen löst eine Ausnahme aus, wenn Sie eine null-Zeichenfolge oder eine leere Zeichenfolge als Argument in einem Methodenaufruf übergeben. Übergeben Sie z. B. eine null-Zeichenfolge, die <xref:System.Int32.Parse%2A?displayProperty=nameWithType> -Methode löst eine <xref:System.ArgumentNullException>, und übergeben eine leere Zeichenfolge löst eine <xref:System.FormatException>. In anderen Fällen kann ein Methodenargument entweder eine null-Zeichenfolge oder eine leere Zeichenfolge sein. Wenn Sie bereit sind z. B. eine <xref:System.IFormattable> Implementierung für eine Klasse, mit der allgemeine Formatbezeichner ("G") sowohl eine null-Zeichenfolge und eine leere Zeichenfolge entsprechen sollen.  
  
 Die <xref:System.String> Klasse enthält die folgenden zwei Hilfsmethoden, mit denen Sie überprüfen, ob eine Zeichenfolge ist `null` oder leer sein:  
  
-   <xref:System.String.IsNullOrEmpty%2A>, der angibt, ob eine Zeichenfolge, die eine ist `null` oder gleich <xref:System.String.Empty?displayProperty=nameWithType>. Diese Methode entfällt das Code wie den folgenden verwenden:  
  
     [!code-cpp[System.String.Class.Null#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#1)]
     [!code-csharp[System.String.Class.Null#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#1)]
     [!code-vb[System.String.Class.Null#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#1)]  
  
-   <xref:System.String.IsNullOrWhiteSpace%2A>, der angibt, ob eine Zeichenfolge ist `null`, gleich <xref:System.String.Empty?displayProperty=nameWithType>, oder ausschließlich aus Leerzeichen besteht. Diese Methode entfällt das Code wie den folgenden verwenden:  
  
     [!code-cpp[System.String.Class.Null#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#2)]
     [!code-csharp[System.String.Class.Null#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#2)]
     [!code-vb[System.String.Class.Null#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#2)]  
  
 Im folgenden Beispiel wird die <xref:System.String.IsNullOrEmpty%2A> -Methode in der die <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> Implementierung eines benutzerdefinierten `Temperature` Klasse. Die Methode unterstützt die Formatzeichenfolgen "G", "C", "F" und "K". Wenn eine leere Zeichenfolge oder ein Format, deren Wert eine Zeichenfolge ist `null` übergeben an die Methode wird der Wert mit der Formatzeichenfolge "G" geändert.  
  
 [!code-cpp[System.String.Class.Null#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#3)]
 [!code-csharp[System.String.Class.Null#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#3)]
 [!code-vb[System.String.Class.Null#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#3)]  
  
<a name="Immutability"></a>   
## <a name="immutability-and-the-stringbuilder-class"></a>Unveränderlichkeit von und der StringBuilder-Klasse  
 Ein <xref:System.String> Objekt wird als unveränderlich (schreibgeschützt), da der Wert kann nicht geändert werden, nachdem es erstellt wurde. Methoden, die angezeigt werden, so ändern Sie eine <xref:System.String> Objekt tatsächlich ein neues zurückzugeben <xref:System.String> Objekt, das die Änderung enthält.  
  
 Da Zeichenfolgen unveränderlich sind, wiederholt Zeichenfolge-manipulationsroutinen, die ausgeführt werden, Hinzufügungen oder löschungen von aussieht, dass eine einzelne Zeichenfolge beträchtliche Leistungseinbußen genauer kann. Der folgende Code verwendet beispielsweise eine Zufallszahlen-Generators zum Erstellen einer Zeichenfolge mit 1000 Zeichen im Bereich von 0 x 0001, 0x052F. Obwohl der Code angezeigt, zum Verketten von Zeichenfolgen zu verwenden wird, um ein neues Zeichen an die vorhandene Zeichenfolge, die mit dem Namen Anfügen `str`, tatsächlich wird ein neuer <xref:System.String> Objekt für jeden Verkettungsvorgang.  
  
 [!code-cpp[System.String.Class#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder1.cpp#15)]
 [!code-csharp[System.String.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable.cs#15)]
 [!code-vb[System.String.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable.vb#15)]  
  
 Können Sie die <xref:System.Text.StringBuilder> -Klasse anstelle der <xref:System.String> -Klasse für Vorgänge, die mehrere Änderungen an den Wert einer Zeichenfolge vornehmen. Im Gegensatz zu Instanzen der <xref:System.String> -Klasse, <xref:System.Text.StringBuilder> Objekte sind änderbar, wenn Sie verketten, Anfügen oder Löschen von untergeordneten Zeichenfolgen aus einer Zeichenfolge, die Vorgänge werden für eine einzelne Zeichenfolge. Sobald Sie abgeschlossen haben, Ändern des Werts einer <xref:System.Text.StringBuilder> Objekt, rufen Sie die <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> Methode in eine Zeichenfolge zu konvertieren. Im folgenden Beispiel ersetzt die <xref:System.String> im vorherigen Beispiel zum Verketten von 1000 zufällige Zeichen im Bereich von 0 x 0001 bis 0x052F mit verwendet eine <xref:System.Text.StringBuilder> Objekt.  
  
 [!code-cpp[System.String.Class#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder2.cpp#16)]
 [!code-csharp[System.String.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable1.cs#16)]
 [!code-vb[System.String.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable1.vb#16)]  
  
<a name="CultureSensitive"></a>   
## <a name="ordinal-vs-culture-sensitive-operations"></a>Ordnungszahl im Vergleich zu kulturabhängige Operationen  
 Mitglieder der <xref:System.String> Klasse entweder Ordnungszahl- oder kulturabhängige (linguistische) Vorgänge ausführen, auf eine <xref:System.String> Objekt. Ein ordinaler-Vorgang ausgeführt wird, nach dem numerischen Wert der einzelnen <xref:System.Char> Objekt. Eine kulturabhängige Operation wird der Wert, der die <xref:System.String> -Objekt, und nimmt kulturspezifische Groß-/Kleinschreibung, Sortierung, Formatierung, und Analyseregeln berücksichtigen. Führen Sie kulturabhängige Operationen im Kontext einer explizit deklarierten Kultur oder implizite der aktuellen Kultur. Die beiden Arten von Vorgängen können sehr unterschiedliche Ergebnisse erzeugen, wenn sie auf die gleiche Zeichenfolge ausgeführt werden.  
  
.NET unterstützt auch kulturunabhängige linguistische Zeichenfolgenoperationen mit der invarianten Kultur (<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>), die lose basiert auf den kultureinstellungen der englischen Sprache unabhängig von der Region. Im Gegensatz zu anderen <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> Einstellungen, die Einstellungen der invarianten Kultur sind garantiert auf einem einzelnen Computer, vom System System und für Versionen von .NET konsistent bleiben. Die invariante Kultur kann als eine Art von Blackbox, die gewährleistet die Stabilität von Zeichenfolgenvergleichen betrieben und Bestellungen sein, in allen Kulturen.  
  
> [!IMPORTANT]
>  Wenn die Anwendung eine sicherheitsentscheidung zu einen symbolischen Bezeichner wie z. B. ein Dateiname macht oder die named Pipe oder über persistente Daten wie z. B. die textbasierte Daten in eine XML-Datei, sollte der Vorgang einen Ordinalvergleich anstelle einen kulturabhängigen Vergleich verwenden. Grund hierfür ist ein kulturabhängiger Vergleich zu anderen Ergebnissen je nach Kultur aktiviert ist, führen kann hingegen ein Ordinalvergleich ausschließlich auf den binären Wert der verglichenen Zeichen abhängt.  
  
> [!IMPORTANT]
>  Die meisten Methoden, die Zeichenfolgenvorgänge umfassen eine Überladung, die einen vom Typ Parameter <xref:System.StringComparison>, können Sie angeben, ob die Methode eine Ordnungszahl oder kulturabhängige Operation ausführt. Im Allgemeinen sollten Sie diese Überladung, um den Zweck der Methode eindeutig zu machen aufrufen. Best Practices und Anleitungen zur Verwendung von Ordnungszahlen und kulturabhängige Vorgänge auf Zeichenfolgen, finden Sie unter [bewährte Methoden für die Verwendung von Zeichenfolgen](~/docs/standard/base-types/best-practices-strings.md).  
  
 Vorgänge für [Schreibweise](#casing), [Analyse und Formatierung](#parsing), [Vergleich und Sortierung](#comparison), und [Testen auf Gleichheit](#equality) kann entweder Ordnungszahl oder kulturabhängig. Den folgenden Abschnitten werden die einzelnen Kategorien des Vorgangs.  
  
> [!TIP]
>  Sie sollten immer eine methodenüberladung aufrufen, die den Zweck der Methode eindeutig macht. Z. B. statt der <xref:System.String.Compare%28System.String%2CSystem.String%29> Methode, um einen kulturabhängigen Vergleich von zwei Zeichenfolgen mithilfe der Konventionen der aktuellen Kultur ausführen rufen Sie die <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> Methode mit einem Wert von <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> für die `comparisonType` Argument. Weitere Informationen finden Sie unter [Empfohlene Vorgehensweisen für die Verwendung von Zeichenfolgen in .NET Framework](~/docs/standard/base-types/best-practices-strings.md).  

Sie können die aus mehreren Textdateien bestehenden [Sorting Weight Tables](https://www.microsoft.com/en-us/download/details.aspx?id=10921) herunterladen. Diese Textdateien enthalten Informationen zur Gewichtung der Zeichen, die bei Sortier- und Vergleichsvorgängen unter Windows-Betriebssystemen verwendet werden, sowie die [Default Unicode Collation Element Table](https://www.unicode.org/Public/UCA/latest/allkeys.txt), die Sortiergewichtungstabelle für Linux und macOS.

<a name="casing"></a>   
### <a name="casing"></a>Schreibweise  
 Groß-/ Kleinschreibregeln bestimmen, wie die Groß-/Kleinschreibung von einem Unicode-Zeichen ändern wird. z. B. von Kleinbuchstaben in Großbuchstaben. Häufig wird ein Vorgang zur Groß-und Kleinschreibung vor einen Zeichenfolgenvergleich durchgeführt. Beispielsweise kann eine Zeichenfolge in Großbuchstaben konvertiert werden, damit er mit einer anderen Großbuchstaben Zeichenfolge verglichen werden kann. Sie können die Zeichen in eine Zeichenfolge, die durch den Aufruf in Kleinbuchstaben konvertieren die <xref:System.String.ToLower%2A> oder <xref:System.String.ToLowerInvariant%2A> Methode, und Sie können sie durch den Aufruf in Großbuchstaben konvertieren die <xref:System.String.ToUpper%2A> oder <xref:System.String.ToUpperInvariant%2A> Methode. Darüber hinaus können Sie die <xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType> Methode zum Konvertieren einer Zeichenfolge in titelschreibung.  
  
 Schreibweise Vorgänge können auf die Regeln für die aktuelle Kultur, einer angegebenen Kultur oder der invarianten Kultur basieren. Da schreibungszuordnungen abhängig von der verwendeten Kultur variieren können, kann das Ergebnis der Schreibweise Vorgänge basierend auf Kultur variieren. Die tatsächlichen Unterschiede in Groß-/Kleinschreibung gibt es drei Arten:  
  
-   Unterschiede in der Zuordnung der Schreibweise des LATIN CAPITAL LETTER I (U + 0049), kleinen Buchstaben LATEINISCH I (U + 0069), LATIN CAPITAL LETTER I mit Punkt oben (U + 0130) und LATIN kleine Buchstaben ohne Punkte I (U + 0131). In die Latn-Verfügbarkeitszonenübergreifende (Aserbaidschan, Lateinisch)-Kulturen und tr-TR (Türkisch (Türkei)) und in der tr az und az-Latn neutrale Kulturen die kleinbuchstabenentsprechung von LATIN CAPITAL LETTER I ist LATIN kleine Buchstaben ohne Punkte I und ist der entsprechende Großbuchstabe LATIN kleine Buchstaben I LATIN CAPITAL LETTER ICH MIT PUNKT OBEN. In allen anderen Kulturen einschließlich der invarianten Kultur, kleine Buchstaben LATEINISCH I und LATIN CAPITAL LETTER ich die Groß- und Kleinbuchstaben Entsprechungen sind.  
  
     Im folgenden Beispiel wird veranschaulicht, wie einen Zeichenfolgenvergleich entwickelt zu Dateisystemzugriff zu verhindern, dass durchgeführt werden können, wenn es auf einem Vergleich kulturabhängig Groß-/Kleinschreibung verwendet. (Die Groß-/ Kleinschreibungskonventionen der invarianten Kultur sollte verwendet werden.)  
  
     [!code-csharp[System.String.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case2.cs#17)]
     [!code-vb[System.String.Class#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case2.vb#17)]  
  
-   Unterschiede in der Groß-/Kleinschreibung Zuordnungen zwischen der invarianten Kultur und alle anderen Kulturen. In diesen Fällen gibt das gleiche Zeichen zurück, wenn Sie mit der Groß-/ Kleinschreibregeln der invarianten Kultur, um ein Zeichen in Groß-oder Kleinbuchstaben zu ändern. Für alle anderen Kulturen wird ein anderes Zeichen zurückgegeben. Einige der betroffenen Zeichen sind in der folgenden Tabelle aufgeführt.  
  
    |Zeichen|Wenn in geändert|Rückgabe|  
    |---------------|-------------------|-------------|  
    |NM-ANMELDUNG (U + 00B5)|Großbuchstaben|GRIECHISCHEN GROSSBUCHSTABEN MU (U +-39C)|  
    |LATIN CAPITAL LETTER ICH PUNKT OBEN (U + 0130)|Kleinbuchstaben|LATEINISCHE KLEINE BUCHSTABE I (U + 0069)|  
    |KLEINES LATEINISCHES DOTLESS ICH (U + 0131)|Großbuchstaben|LATIN CAPITAL LETTER ICH (U + 0049)|  
    |KLEINES LATEINISCHES LANGE S (U + 017F)|Großbuchstaben|LATIN CAPITAL LETTER S (U + 0053)|  
    |LATEINISCHE GROSSBUCHSTABEN D MIT KLEINEN BUCHSTABEN Z MIT HÄKCHEN (U + 01C 5)|Kleinbuchstaben|KLEINES LATEINISCHES DZ MIT HÄKCHEN (U + 01C 6)|  
    |KOMBINIEREN VON YPOGRAMMENI (U + 0345)|Großbuchstaben|GRIECHISCHEN GROSSBUCHSTABEN IOTA (U + 0399)|  
  
-   Unterschiede in der Groß-/Kleinschreibung Zuordnungen von zwei Buchstaben bestehenden gemischter-Paare im ASCII-Zeichenbereich. In den meisten Kulturen ist ein kleingeschriebener zweibuchstabiger-gemischter-Paar gleich an das entsprechende Paar aus zwei Buchstaben bestehenden Groß- oder Kleinbuchstaben. Dies gilt nicht für die folgenden Paare aus zwei Buchstaben in den folgenden Kulturen, da in jedem Fall sie nicht auf einen Digraph verglichen werden:  
  
    -   "lJ" und "nJ", in die Kultur hr-HR (Kroatisch (Kroatien)).  
  
    -   "cH" in der Cs-CZ (Tschechisch (Tschechische Republik)) und Kulturen der sk-SK (Slowakisch (Slowakei)).  
  
    -   "aA" in der Kultur da-DK (Dänisch (Dänemark)).  
  
    -   "cS", "dZ", "dZS", "nY", "sZ", "tY" und "zS" in der Kultur Hu-HU (Ungarisch (Ungarn)).  
  
    -   "cH" und "lL" in der Kultur es-ES_tradnl (Spanisch (Spanien, Traditionelle Sortierung)).  
  
    -   "cH", "gI", "kH", "nG" "Notification Hub", "pH", "qU", "tH" und "tR" in der Kultur des vi-VN (Vietnamesisch (Vietnam)).  
  
     Es ist jedoch ungewöhnlich, die eine Situation, in der ein kulturabhängiger Vergleich dieser Paare Probleme erstellt, auftreten, da diese Paare feste Zeichenfolgen oder Bezeichner selten auftreten.  
  
 Das folgende Beispiel veranschaulicht einige der Unterschiede in der Groß-/ Kleinschreibregeln zwischen Kulturen, die beim Konvertieren von Zeichenfolgen in Großbuchstaben.  
  
 [!code-cpp[System.String.Class#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.casing.cpp#7)]
 [!code-csharp[System.String.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case1.cs#7)]
 [!code-vb[System.String.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case1.vb#7)]  
  
<a name="parsing"></a>   
### <a name="parsing-and-formatting"></a>Analyse und Formatierung  
 Formatierung und Analyse sind umgekehrte Vorgänge. Formatierungsregeln bestimmen Sie, wie einen Wert, z. B. ein Datum und Uhrzeit oder eine Zahl ist, in seine zeichenfolgenentsprechung konvertiert während Analyseregeln Gewusst wie: Konvertieren einer Zeichenfolgendarstellung in einen Wert wie z. B. Datum und Uhrzeit bestimmen. Kulturelle Konventionen hängen sowohl Formatierung und Analyse für Regeln. Das folgende Beispiel veranschaulicht die Mehrdeutigkeit, die auftreten kann, wenn eine kulturspezifische Datumszeichenfolge zu interpretieren. Ohne Kenntnis der Konventionen der Kultur, die verwendet wurde, um eine Datumszeichenfolge zu erzeugen, ist es nicht möglich, um herauszufinden, ob 03/01/2011, 3/1/2011 und 01/03/2011 3. Januar 2011 oder 1. März 2011 darstellen.  
  
 [!code-cpp[System.String.Class#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.format1.cpp#8)]
 [!code-csharp[System.String.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/format1.cs#8)]
 [!code-vb[System.String.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/format1.vb#8)]  
  
 Auf ähnliche Weise wie im folgenden Beispiel wird gezeigt, kann eine einzelne Zeichenfolge unterschiedliche Daten je nach Kultur erstellen, dessen Konventionen in den Analysevorgang verwendet werden.  
  
 [!code-cpp[System.String.Class#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.parse1.cpp#9)]
 [!code-csharp[System.String.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/parse1.cs#9)]
 [!code-vb[System.String.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/parse1.vb#9)]  
  
<a name="comparison"></a>   
### <a name="string-comparison-and-sorting"></a>Zeichenfolgenvergleich und-Sortierung  
 Konventionen für die vergleichenden und sortierenden Zeichenfolgen variieren Kultur. Beispielsweise kann die Sortierreihenfolge auf der Phonetik oder der visuellen Darstellung von Zeichen basieren. In ostasiatischen Sprachen werden Zeichen anhand der Anzahl der Striche und der Radikale der Ideogramme sortiert. Die Sortierung hängt außerdem von der Reihenfolge ab, die das Alphabet der jeweiligen Sprache bzw. Kultur aufweist. Im Dänischen gibt es beispielsweise das Zeichen "Æ", das im Alphabet nach dem Zeichen "Z" einsortiert ist. Darüber hinaus können es sich bei Vergleichen Groß-/Kleinschreibung oder Groß-/Kleinschreibung, und in einigen Fällen Regeln Groß-und Kleinschreibung unterscheiden sich auch nach Kultur. Ordinalvergleich, verwendet die Unicode-Codepunkte einzelner Zeichen auf der anderen Seite in einer Zeichenfolge, die beim Vergleichen und Sortieren von Zeichenfolgen.  
  
 Sortierregeln bestimmen, dass die alphabetische Reihenfolge der Unicode-Zeichen und wie Zeichenfolgen miteinander vergleichen. Z. B. die <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> Methode vergleicht zwei Zeichenfolgen, die auf der Grundlage der <xref:System.StringComparison> Parameter. Wenn der Parameterwert ist <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, die Methode führt einen linguistischen Vergleich, der die Konventionen der aktuellen Kultur; verwendet, wenn der Parameterwert ist <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>, die Methode führt einen Ordinalvergleich. Folglich, wie das folgende Beispiel zeigt, wenn die aktuelle Kultur Englisch Englisch, der erste Aufruf der <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> (mithilfe von kulturabhängigen Vergleich) Methode betrachtet, "a" kleiner als "A", aber der zweite Aufruf (mit Ordinalvergleich) derselben Methode betrachtet "a" größer als "A".  
  
 [!code-cpp[System.String.Class#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare1.cpp#10)]
 [!code-csharp[System.String.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare1.cs#10)]
 [!code-vb[System.String.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare1.vb#10)]  
  
 .NET unterstützt Wort-, Zeichenfolgen- und Ordinalsortierregeln:  
  
-   Bei einer Wortsortierung wird ein kulturabhängiger Vergleich von Zeichenfolgen durchgeführt, bei dem bestimmten nicht alphanumerischen Unicode-Zeichen u. U. bestimmte Gewichtungen zugeordnet sind. Z. B. der Bindestrich (-) möglicherweise eine sehr geringe Gewichtung zugeordnet, sodass "Coop" und "coop" in einer sortierten Liste nebeneinander angezeigt werden. Eine Liste mit den <xref:System.String> Methoden, Vergleichen von zwei Zeichenfolgen mithilfe der Word-Sortierregeln, finden Sie unter der [Zeichenfolgenoperationen nach Kategorie](#ByCategory) Abschnitt.  
  
-   Eine führt auch einen kulturabhängigen Vergleich. Es ähnelt einer wortsortierung, außer dass es keine Sonderfälle gibt und alle nicht alphanumerischen Symbole vor allen alphanumerischen Unicode-Zeichen sind. Zwei Zeichenfolgen können verglichen werden, mithilfe von Zeichenfolge-Sortierregeln durch Aufrufen der <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType> Überladungen der Methode, die eine `options` Parameter bereitgestellte Wert <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>. Beachten Sie, dass dies nur eine Methode enthält, die .NET zum Vergleichen von zwei Zeichenfolgen mithilfe von Zeichenfolge-Sortierregeln bereitstellt.  
  
-   Eine Ordinalsortierung vergleicht Zeichenfolgen anhand des numerischen Werts jedes <xref:System.Char>-Objekts in der Zeichenfolge. Ein ordinalen Vergleich ist automatisch die Groß-/Kleinschreibung beachtet, da die Groß- und Kleinbuchstaben Versionen eines Zeichens verschiedene Codepunkte aufweisen. Wenn Fall nicht wichtig ist, können Sie jedoch einen ordinalen Vergleich angeben, der Groß-und Kleinschreibung ignoriert. Dies entspricht dem Konvertieren der Zeichenfolge in Großbuchstaben unter Verwendung der invarianten Kultur, und klicken Sie dann einen Ordinalvergleich ausführen, auf dem Ergebnis. Eine Liste mit den <xref:System.String> Methoden, Vergleichen von zwei Zeichenfolgen mithilfe der ordinalen Sortierregeln, finden Sie unter der [Zeichenfolgenoperationen nach Kategorie](#ByCategory) Abschnitt.  
  
 Ein kulturabhängiger Vergleich ist ein Vergleich, explizit oder implizit verwendet, eine <xref:System.Globalization.CultureInfo> -Objekts, einschließlich der invarianten Kultur, die angegeben wird die <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> Eigenschaft. Die implizite Kultur ist die aktuelle Kultur, die von angegeben wird die <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> und <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> Eigenschaften. Ist es beträchtliche Abweichung in der Sortierreihenfolge von alphabetischen Zeichen (d. h. Zeichen für die die <xref:System.Char.IsLetter%2A?displayProperty=nameWithType> -Eigenschaft gibt `true`) über Kulturen hinweg. Sie können angeben, dass einen kulturabhängiger Vergleich, der die Konventionen einer bestimmten Kultur durch Angabe verwendet eine <xref:System.Globalization.CultureInfo> Objekt auf einer Zeichenfolgenvergleichsmethode wie <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>. Können Sie angeben, einen kulturabhängigen Vergleich, der die Konventionen der aktuellen Kultur durch Angabe verwendet <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, oder ein Mitglied der <xref:System.Globalization.CompareOptions> Enumeration außer <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> oder <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> auf einen entsprechenden Überladen von der <xref:System.String.Compare%2A> Methode. Ein kulturabhängiger Vergleich ist im Allgemeinen gut geeignet für die Sortierung während ein ordinalen Vergleich nicht ist. Ein ordinalen Vergleich ist im Allgemeinen gut geeignet, um zu bestimmen, ob zwei Zeichenfolgen gleich sind (d. h. bei der identitätsbestimmung) dagegen ein kulturabhängigen Vergleich nicht ist.  
  
 Das folgende Beispiel veranschaulicht den Unterschied zwischen kulturabhängige und ordinalen Vergleich. Im Beispiel, das ausgewertet wird, drei Zeichenfolgen, "Apple", "Æble" und "AEble", die mithilfe von ordinalen Vergleich und die Konventionen der Kulturen da-DK "und" En-US (von denen jeder ist die Standardkultur, zum Zeitpunkt der <xref:System.String.Compare%2A> Methode wird aufgerufen). Da die dänische Sprache das Zeichen "Æ" als einzelner Buchstabe wird und sie nach "Z" im Alphabet beginnen sortiert, ist die Zeichenfolge "Æble" größer als "Apple". "Æble" ist jedoch nicht äquivalent zu "AEble", angesehen, ist die "Æble" auch größer als "AEble". Die Kultur En-US interpretiert als Entsprechung zu "AE", die erklärt, warum "Æble" kleiner als "Apple", aber gleich "AEble" ist jedoch nicht der Buchstabe "Æ" enthalten. Ordinalvergleich, berücksichtigt dagegen auf "Apple" kleiner als "Æble" und "Æble" größer als "AEble" sein.  
  
 [!code-csharp[System.String.Class#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare4.cs#21)]
 [!code-vb[System.String.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare4.vb#21)]  
  
 Verwenden Sie die folgenden allgemeinen Richtlinien, um eine entsprechende Sortierung oder Zeichenfolge Vergleichsmethode auszuwählen:  
  
-   Wenn Sie die Zeichenfolgen sortiert werden basierend auf der Kultur des Benutzers möchten, müssen Sie basierend auf der die Konventionen der aktuellen Kultur Reihenfolge. Wenn die Kultur des Benutzers ändert, wird die Reihenfolge der sortierten Zeichenfolgen auch entsprechend geändert. Beispielsweise sollte eine Thesaurus-Anwendung immer Wörter, die basierend auf der Kultur des Benutzers sortieren.  
  
-   Gegebenenfalls die Zeichenfolgen, die bestellt werden basierend auf den Konventionen einer bestimmten Kultur bestellen Sie sie durch Angabe einer <xref:System.Globalization.CultureInfo> -Objekt, das die Kultur für eine Vergleichsmethode darstellt. Beispielsweise sollen in einer Anwendung entwickelt, um Schüler und Studenten mit eine bestimmte Sprache zu unterrichten, Zeichenfolgen, die bestellt werden basierend auf den Konventionen der eine der Kulturen, die diese Sprache spricht.  
  
-   Wenn Sie die Reihenfolge der Zeichenfolgen über Kulturen hinweg unverändert bleiben möchten, sollten Sie in beliebiger Reihenfolge basierend auf den Konventionen der invarianten Kultur oder verwenden einen Ordinalvergleich durch. Beispielsweise würde eine Ordinalsortierung verwenden, um die Namen der Dateien, Prozesse, Mutexe zu organisieren oder named Pipes.  
  
-   Einen Vergleich, der eine sicherheitsentscheidung (z. B., ob ein Benutzername gültig ist) umfasst, sollten Sie immer einen Ordnungszahlen Test auf Gleichheit durch Aufruf einer Überladung der Ausführen der <xref:System.String.Equals%2A> Methode.  
  
> [!NOTE]
>  Der kulturabhängige Sortierung und Groß-/Kleinschreibung beim Zeichenfolgenvergleich verwendete Regeln, abhängig von der Version von .NET ab. In der .NET Framework 4.5 und höheren Versionen, die unter der [!INCLUDE[win8](~/includes/win8-md.md)] operating System, Sortierung, die Groß-/Kleinschreibung, Normalisierung und Unicode-Zeichen-Informationen für den Standard Unicode 6.0 entspricht. Bei anderen Windows-Betriebssystemen entspricht es der standard Unicode 5.0. In .NET Core hängt die Version des Unicode-Standards, die von dem zugrunde liegenden Betriebssystem unterstützt werden. 
  
 Weitere Informationen über Wort-, Zeichenfolgen- und Ordinalsortierregeln finden Sie unter den <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> Thema. Zusätzliche Empfehlungen zur Verwendung für jede Regel finden Sie unter [bewährte Methoden für die Verwendung von Zeichenfolgen](~/docs/standard/base-types/best-practices-strings.md).  
  
 Normalerweise Sie keine Vergleichsmethoden aufrufen, Zeichenfolge wie z. B. <xref:System.String.Compare%2A> direkt auf die Sortierreihenfolge von Zeichenfolgen bestimmt. Stattdessen werden die Methoden zum Zeichenfolgenvergleich durch Methoden wie z. B. sortieren aufgerufen <xref:System.Array.Sort%2A?displayProperty=nameWithType> oder <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>. Im folgenden Beispiel wird die vier verschiedenen Sortieroperationen (Word-Sortierung mit der aktuellen Kultur, wortsortierung mit der invarianten Kultur, Ordinalsortierung und String-Sortierung, die mit der invarianten Kultur) ohne den expliziten Aufruf einer Methode zum Zeichenfolgenvergleich, Obwohl sie den Typ des Vergleichs mit angeben. Beachten Sie, dass jede Art von Sortierreihenfolge erzeugt eine eindeutige Sortierung der Zeichenfolgen im Array.  
  
 [!code-cpp[System.String.Class#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare2.cpp#12)]
 [!code-csharp[System.String.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare2.cs#12)]
 [!code-vb[System.String.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare2.vb#12)]  
  
> [!TIP]
>  Intern verwendet .NET Sortierschlüssel zur Unterstützung kulturabhängiger Zeichenfolgenvergleich. Jedem Zeichen in einer Zeichenfolge sind mehrere Sortiergewichtungskategorien zugeordnet, darunter nach Skript, alphabetischer Folge, Groß-/Kleinschreibung und diakritischer Gewichtung. Ein Sortierschlüssel, dargestellt durch die <xref:System.Globalization.SortKey> Klasse, ein Repository für diese Gewichtungen für eine bestimmte Zeichenfolge enthält. Wenn eine große Anzahl von Suche und Sortiervorgänge in der gleichen Gruppe von Zeichenfolgen in Ihre app ausgeführt wird, können Sie die Leistung verbessern, indem generieren und speichern die Sortierschlüssel für alle Zeichenfolgen, die verwendet wird. Wenn eine Sortierung oder ein Vergleich erforderlich ist, verwenden Sie die Sortierschlüssel anstelle der Zeichenfolgen. Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Globalization.SortKey>-Klasse.  
  
 Wenn Sie nicht, dass eine Zeichenfolge Vergleich-Konvention angeben, Sortierfunktionen, z. B. <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> eine Kultur, Unterscheidung nach Groß-/Kleinschreibung beachtet die Sortierung für Zeichenfolgen durchführen. Im folgende Beispiel wird veranschaulicht, wie das Ändern der aktuellen Kultur die Reihenfolge der sortierten Zeichenfolgen in einem Array wirkt sich auf. Es wird ein Array von drei Zeichenfolgen erstellt. Zuerst wird die `System.Threading.Thread.CurrentThread.CurrentCulture`-Eigenschaft auf "en-US" festgelegt, und die <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType>-Methode wird aufgerufen. Die sich daraus ergebende Sortierreihenfolge basiert auf den Sortierkonventionen für die Kultur Englisch (USA). Als Nächstes wird die `System.Threading.Thread.CurrentThread.CurrentCulture`-Eigenschaft auf "da-DK" festgelegt und die <xref:System.Array.Sort%2A?displayProperty=nameWithType>-Methode erneut aufgerufen. Die sich daraus ergebende Sortierreihenfolge unterscheidet sich von den Ergebnissen für "en-US", da die Sortierkonventionen für "Dänisch (Dänemark)" verwendet werden.  
  
 [!code-csharp[Conceptual.Strings.Comparing#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.comparing/cs/sort1.cs#3)]
 [!code-vb[Conceptual.Strings.Comparing#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.comparing/vb/sort1.vb#3)]  
  
> [!WARNING]
>  Wenn das primäre Ziel Vergleichen von Zeichenfolgen ist, um zu bestimmen, ob sie gleich sind, rufen Sie die <xref:System.String.Equals%2A?displayProperty=nameWithType> Methode. Verwenden Sie in der Regel <xref:System.String.Equals%2A> einen Ordinalvergleich ausführen. Die <xref:System.String.Compare%2A?displayProperty=nameWithType> -Methode dient in erster Linie zum Sortieren von Zeichenfolgen.  
  
 Zeichenfolgensuchmethoden, z. B. <xref:System.String.StartsWith%2A?displayProperty=nameWithType> und <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, auch können kulturabhängig oder Ordinalzahl Zeichenfolgenvergleiche ausführen. Das folgende Beispiel veranschaulicht die Unterschiede zwischen der Ordinalzahl und kulturabhängige Vergleiche mit der <xref:System.String.IndexOf%2A> Methode. Eine kulturabhängige Suche in der die aktuelle Kultur Englisch (Vereinigte Staaten) ist, berücksichtigt die Teilzeichenfolge "Oe" entsprechend der Ligatur "œ". Da Sie ein bedingten Bindestrich (U + 00AD) eine Breite von NULL-Zeichen ist, behandelt die Suche der bedingten Bindestrich als Entsprechung zu <xref:System.String.Empty> und findet eine Übereinstimmung am Anfang der Zeichenfolge. Eine Ordinalsuche, wird eine Übereinstimmung in beiden Fällen auf der anderen Seite nicht gefunden.  
  
 [!code-cpp[System.String.Class#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare3.cpp#13)]
 [!code-csharp[System.String.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare3.cs#13)]
 [!code-vb[System.String.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare3.vb#13)]  
  
### <a name="searching-strings"></a>Suchen von Zeichenfolgen  
 Zeichenfolgensuchmethoden, z. B. <xref:System.String.StartsWith%2A?displayProperty=nameWithType> und <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, auch Aktualisierungsoption kulturabhängig oder ordinalen Vergleich von Zeichenfolgen zu bestimmen, ob ein Zeichen oder eine Teilzeichenfolge in einer angegebenen Zeichenfolge gefunden wird.  
  
 Die Search-Methoden in der <xref:System.String> -Klasse, die für ein einzelnes Zeichen, z. B. Suchen der <xref:System.String.IndexOf%2A> Methode oder zu einem Satz von Zeichen, z. B. die <xref:System.String.IndexOfAny%2A> -Methode, alle eine ordinale Suche ausführen. Um eine kulturabhängige Suche nach einem Zeichen auszuführen, rufen Sie eine <xref:System.Globalization.CompareInfo> Methode, z. B. <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> oder <xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>. Beachten Sie, dass die Ergebnisse der Suche nach einem Zeichen, die mithilfe von Ordnungszahlen und kulturabhängige Vergleich sehr unterschiedlich sein können. Beispielsweise könnte eine Suche für ein zusammengesetztes Unicodezeichen, z. B. die Ligatur "Æ" (U + 00 C 6) entspricht jedem Vorkommen der Komponenten in der richtigen Reihenfolge, z. B. "AE" (U + 041U + 0045), je nach Kultur. Das folgende Beispiel veranschaulicht den Unterschied zwischen der <xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType> und <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> Methoden bei der Suche nach der ein einzelnes Zeichen. Die Ligatur "Æ" (U + 00E6) wurde in der Zeichenfolge "Luftbild" bei Verwendung der Konventionen der Kultur En-US, jedoch nicht, wenn die Konventionen der Kultur da-DK verwendet oder wenn Sie einen Ordinalvergleich ausführen gefunden.  
  
 [!code-csharp[System.String.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/search1.cs#22)]
 [!code-vb[System.String.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/search1.vb#22)]  
  
 Auf der anderen Seite <xref:System.String> -Klassenmethoden, die Suche nach einer Zeichenfolge anstelle eines Zeichens eine kulturabhängige Suche durchführen, wenn Suchoptionen durch einen Parameter vom Typ nicht explizit angegeben werden <xref:System.StringComparison>. Die einzige Ausnahme ist <xref:System.String.Contains%2A>, die eine ordinale Suche durchführt.  
  
<a name="equality"></a>   
### <a name="testing-for-equality"></a>Testen auf Gleichheit  
 Verwenden der <xref:System.String.Compare%2A?displayProperty=nameWithType> Methode, um die Beziehung zwischen zwei Zeichenfolgen in der Sortierreihenfolge festzulegen. Dies ist normalerweise eine kulturabhängige Operation. Im Gegensatz dazu rufen Sie die <xref:System.String.Equals%2A?displayProperty=nameWithType> Methode zum Testen auf Gleichheit. Da der Test auf Gleichheit in der Regel der Benutzereingabe mit einer bekannten Zeichenfolge, z. B. einen gültigen Benutzernamen ein, ein Kennwort oder einen Dateisystempfad, vergleicht wird er in der Regel eine Ordnungszahl Vorgang.  
  
> [!WARNING]
>  Es ist möglich, Testen auf Gleichheit durch Aufrufen der <xref:System.String.Compare%2A?displayProperty=nameWithType> -Methode und bestimmen, ob der Rückgabewert 0 (null) ist. Diese Vorgehensweise ist jedoch nicht empfohlen. Um zu bestimmen, ob zwei Zeichenfolgen gleich sind, sollten Sie eine der Überladungen von Aufrufen der <xref:System.String.Equals%2A?displayProperty=nameWithType> Methode. Die bevorzugte Überladung aufrufen, ist entweder wird die Instanz <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> oder die statische <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> -Methode, da beide Methoden enthalten eine <xref:System.StringComparison?displayProperty=nameWithType> Parameter, der explizit den Typ des Vergleichs angibt.  
  
 Das folgende Beispiel zeigt die Gefahr der Ausführung eines kulturabhängigen Vergleichs, Gleichheit, wenn eine Ordinalzahl, die eine stattdessen verwendet werden soll. Die Absicht des Codes werden in diesem Fall den Dateisystemzugriff von URLs zu verhindern, die mit "FILE://" oder "file://" beginnen, Groß-/Kleinschreibung Vergleich des Anfangs einer URL mit der Zeichenfolge "FILE://" ausgeführt. Jedoch, wenn ein kulturabhängiger Vergleich ausgeführt wird, mit der Türkisch (Türkei)-Kultur in einer URL, die mit "file://" beginnt, schlägt fehl der Vergleich für Gleichheit, weil Türkisch Großbuchstaben den Kleinbuchstaben "i" "İ" anstelle von "I" entspricht. Daher wird der Dateisystemzugriff versehentlich zulässig. Andererseits, wenn ein ordinalen Vergleich ausgeführt wird, wird der Vergleich für Gleichheit ist erfolgreich, und Dateisystemzugriff verweigert wird.  
  
 [!code-cpp[System.String.Class#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.equals.cpp#11)]
 [!code-csharp[System.String.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/equality1.cs#11)]
 [!code-vb[System.String.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/equality1.vb#11)]  
  
<a name="Normalization"></a>   
## <a name="normalization"></a>Normalisierung  
 Einige Unicode-Zeichen umfassen mehrere Darstellungen. Beispielsweise kann eine der folgenden Code verweist den Buchstaben "ắ" darstellen:  
  
-   U + 1EAF  
  
-   U + 0103 U + 0301  
  
-   U + 0061 U + 0306 U + 0301  
  
 Mehrere Darstellungen für ein einzelnes Zeichen suchen, sortieren, Abgleich und andere Zeichenfolgenoperationen verkompliziert werden.  
  
 Die Unicode-standard definiert einen Prozess namens Normalisierung, die eine binäre Darstellung eines Unicode-Zeichens für jede der entsprechende binäre Darstellung zurückgibt. Normalisierung können mehrere Algorithmen, so genannte Normalisierungsformen, die verschiedene Regeln einhalten. .NET unterstützt Unicode-Normalisierungsformen C, D, KC und KD. Wenn Sie Zeichenfolgen in die gleiche Normalisierungsform normalisiert wurden, können sie mithilfe von ordinalen Vergleich verglichen werden.  
  
 Ein ordinalen Vergleich ist ein binärer Vergleich von der Unicode-Skalarwert des entsprechenden <xref:System.Char> Objekte in jeder Zeichenfolge. Die <xref:System.String> Klasse enthält eine Reihe von Methoden, die einen Ordinalvergleich durch, einschließlich der folgenden ausführen können:  
  
-   Überladung von der <xref:System.String.Compare%2A>, <xref:System.String.Equals%2A>, <xref:System.String.StartsWith%2A>, <xref:System.String.EndsWith%2A>, <xref:System.String.IndexOf%2A>, und <xref:System.String.LastIndexOf%2A> Methoden, die umfasst eine <xref:System.StringComparison> Parameter. Die Methode führt einen ordinalen Vergleich aus, wenn Sie angeben, dass der Wert <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> oder <xref:System.StringComparison.OrdinalIgnoreCase> für diesen Parameter.  
  
-   Die Überladungen der <xref:System.String.CompareOrdinal%2A> Methode.  
  
-   Methoden, mit denen Ordinalvergleich standardmäßig wie z. B. <xref:System.String.Contains%2A>, <xref:System.String.Replace%2A>, und <xref:System.String.Split%2A>.  
  
-   Methoden, die für die Suche eine <xref:System.Char> Wert oder für die Elemente in einem <xref:System.Char> Arrays in einer Zeichenfolgeninstanz. Diese Methoden umfassen <xref:System.String.IndexOf%28System.Char%29> und <xref:System.String.Split%28System.Char%5B%5D%29>.  
  
 Können Sie bestimmen, ob eine Zeichenfolge in der Normalisierungsform C, durch den Aufruf normalisiert wird der <xref:System.String.IsNormalized?displayProperty=nameWithType> -Methode, oder Sie rufen die <xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType> Methode, um zu bestimmen, ob eine Zeichenfolge in eine angegebene Normalisierungsform normalisiert wurde. Sie können auch aufrufen, die <xref:System.String.Normalize?displayProperty=nameWithType> Methode zum Konvertieren einer Zeichenfolge in der Normalisierungsform C, oder Sie können Aufrufen der <xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType> Methode zum Konvertieren einer Zeichenfolge in eine angegebene Normalisierungsform. Detaillierte Informationen zu normalisieren, und Vergleichen von Zeichenfolgen finden Sie die <xref:System.String.Normalize> und <xref:System.String.Normalize%28System.Text.NormalizationForm%29> Methoden.  
  
 Das folgende einfache Beispiel veranschaulicht die Normalisierung von Zeichenfolgen. Er definiert den Buchstaben "ố" auf drei verschiedene Arten in drei verschiedenen Zeichenfolgen und verwendet einen ordinalen Vergleich, Gleichheit, um zu bestimmen, dass jede Zeichenfolge von den anderen beiden Zeichenfolgen unterscheidet. Es konvertiert dann jede Zeichenfolge in den unterstützten Normalisierungsformen und führt erneut einen Ordinalvergleich von jeder Zeichenfolge in einer angegebenen Normalisierungsform. In jedem Fall zeigt der zweite Test auf Gleichheit an, dass die Zeichenfolgen gleich sind.  
  
 [!code-cpp[System.String.Class#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.normalize.cpp#14)]
 [!code-csharp[System.String.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/normalize1.cs#14)]
 [!code-vb[System.String.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/normalize1.vb#14)]  
  
 Weitere Informationen zu Normalisierung und Normalisierungsformen, finden Sie unter <xref:System.Text.NormalizationForm?displayProperty=nameWithType>, als auch [Unicode Standard Annex #15: Unicode Normalization Forms](https://unicode.org/reports/tr15/) und [Normalisierung – häufig gestellte Fragen](https://www.unicode.org/faq/normalization.html) auf der Website unicode.org.  
  
<a name="ByCategory"></a>   
## <a name="string-operations-by-category"></a>Zeichenfolgenoperationen nach Kategorie  
 Die <xref:System.String> Klasse enthält Elemente zum Vergleichen von Zeichenfolgen, das Testen von Zeichenfolgen auf Gleichheit überprüfen, Suchen nach Zeichen oder Teilzeichenfolgen in einer Zeichenfolge, die Änderung einer Zeichenfolge, und Extrahieren von Teilzeichenfolgen aus einer Zeichenfolge, die Zeichenfolgen, Formatieren von Werten, das Kopieren einer Zeichenfolge kombiniert und normalisiert eine Zeichenfolge an.  
  
### <a name="comparing-strings"></a>Vergleichen von Zeichenfolgen  
 Sie können Zeichenfolgen vergleichen, um ihre relative Position in der Sortierreihenfolge bestimmen mithilfe der Folgendes <xref:System.String> Methoden:  
  
-   <xref:System.String.Compare%2A> Gibt eine Ganzzahl, die die Beziehung aus einer Zeichenfolge in eine zweite Zeichenfolge in der Sortierreihenfolge angibt.  
  
-   <xref:System.String.CompareOrdinal%2A> Gibt eine Ganzzahl, die die Beziehung aus einer Zeichenfolge in eine zweite Zeichenfolge auf Basis eines Wertevergleichs der die Codepunkte angibt.  
  
-   <xref:System.String.CompareTo%2A> Gibt eine Ganzzahl, die die Beziehung des die aktuelle Zeichenfolgeninstanz mit einer zweiten Zeichenfolge in der Sortierreihenfolge angibt. Die <xref:System.String.CompareTo%28System.String%29> Methode bietet die <xref:System.IComparable> und <xref:System.IComparable%601> Implementierungen für die <xref:System.String> Klasse.  
  
### <a name="testing-strings-for-equality"></a>Testen von Zeichenfolgen auf Gleichheit  
 Rufen Sie die <xref:System.String.Equals%2A> Methode, um zu bestimmen, ob zwei Zeichenfolgen gleich sind. Die Instanz <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> und der statischen <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> Überladungen können Sie angeben, ob der Vergleich kulturabhängig oder Ordinalzahl ist, und gibt an, ob Fall berücksichtigt oder ignoriert wird. Die meisten Tests für Gleichheit die Ordinalvergleiche darstellen, und Vergleiche auf Gleichheit, die bestimmen, den Zugriff auf eine Systemressource (z. B. ein Dateisystemobjekt) sollten immer ordinal sein.  
  
### <a name="finding-characters-in-a-string"></a>Suchen von Zeichen in einer Zeichenfolge  
 Die <xref:System.String> Klasse enthält zwei verschiedene Suchmethoden:  
  
-   Methoden, die Zurückgeben einer <xref:System.Boolean> Wert, der angibt, ob eine bestimmte Teilzeichenfolge in einer Zeichenfolgeninstanz vorhanden ist. Dazu gehören die <xref:System.String.Contains%2A>, <xref:System.String.EndsWith%2A>, und <xref:System.String.StartsWith%2A> Methoden.  
  
-   Methoden, die die Anfangsposition einer Teilzeichenfolge in einer Zeichenfolgeninstanz anzugeben. Dazu gehören die <xref:System.String.IndexOf%2A>, <xref:System.String.IndexOfAny%2A>, <xref:System.String.LastIndexOf%2A>, und <xref:System.String.LastIndexOfAny%2A> Methoden.  
  
> [!WARNING]
>  Wenn Sie eine Zeichenfolge für eine bestimmte Teilzeichenfolge, anstatt einem bestimmten Muster suchen möchten, sollten Sie reguläre Ausdrücke verwenden. Weitere Informationen finden Sie unter [reguläre Ausdrücke von .NET](~/docs/standard/base-types/regular-expressions.md).  
  
### <a name="modifying-a-string"></a>Ändern einer Zeichenfolge  
 Die <xref:System.String> Klasse enthält die folgenden Methoden, die zum Ändern des Werts einer Zeichenfolge angezeigt werden:  
  
-   <xref:System.String.Insert%2A> Fügt eine Zeichenfolge mit dem aktuellen <xref:System.String> Instanz.  
  
-   <xref:System.String.PadLeft%2A> Fügt einem oder mehreren Vorkommen eines angegebenen Zeichens am Anfang einer Zeichenfolge.  
  
-   <xref:System.String.PadRight%2A> Fügt einem oder mehreren Vorkommen eines angegebenen Zeichens am Ende einer Zeichenfolge.  
  
-   <xref:System.String.Remove%2A> Löscht eine Teilzeichenfolge aus dem aktuellen <xref:System.String> Instanz.  
  
-   <xref:System.String.Replace%2A> ersetzt eine Teilzeichenfolge durch eine andere Teilzeichenfolge in der aktuellen <xref:System.String> Instanz.  
  
-   <xref:System.String.ToLower%2A> und <xref:System.String.ToLowerInvariant%2A> alle Zeichen in einer Zeichenfolge in Kleinbuchstaben zu konvertieren.  
  
-   <xref:System.String.ToUpper%2A> und <xref:System.String.ToUpperInvariant%2A> alle Zeichen in einer Zeichenfolge in Großbuchstaben zu konvertieren.  
  
-   <xref:System.String.Trim%2A> Entfernt alle Vorkommen von einem Zeichen am Anfang und Ende einer Zeichenfolge.  
  
-   <xref:System.String.TrimEnd%2A> Entfernt alle Vorkommen eines Zeichens vom Ende einer Zeichenfolge.  
  
-   <xref:System.String.TrimStart%2A> Entfernt alle Vorkommen eines Zeichens vom Anfang einer Zeichenfolge.  
  
> [!IMPORTANT]
>  Alle Änderungen von Zeichenfolgenmethoden zurück auf ein neues <xref:System.String> Objekt. Ändern sie nicht den Wert der aktuellen Instanz.  
  
### <a name="extracting-substrings-from-a-string"></a>Extrahieren von untergeordneten Zeichenfolgen aus einer Zeichenfolge  
 Die <xref:System.String.Split%2A?displayProperty=nameWithType> Methode trennt eine einzelne Zeichenfolge in mehrere Zeichenfolgen. Überladungen der Methode können Sie angeben, mehrere Trennzeichen, um die maximale Anzahl von Teilzeichenfolgen zu bestimmen, die die Methode extrahiert, und um zu bestimmen, ob leere Zeichenfolgen (die auftreten, wenn die Trennzeichen aneinandergrenzen) für die zurückgegebenen Zeichenfolgen enthalten sind.  
  
### <a name="combining-strings"></a>Kombinieren von Zeichenfolgen  
 Die folgenden <xref:System.String> können Methoden für die zeichenfolgenverkettung verwendet werden:  
  
-   <xref:System.String.Concat%2A> werden ein oder mehrere Teilzeichenfolgen in einer einzelnen Zeichenfolge kombiniert.  
  
-   <xref:System.String.Join%2A> verkettet eine oder mehrere Teilzeichenfolgen in ein einzelnes Element und fügt ein Trennzeichen zwischen den Teilzeichenfolgen.  
  
### <a name="formatting-values"></a>Formatieren von Werten  
 Die <xref:System.String.Format%2A?displayProperty=nameWithType> Methode, die Funktion für kombinierte Formatierung verwendet, um einen oder mehrere Platzhalter in einer Zeichenfolge durch die Zeichenfolgendarstellung von einigen Objekt oder den Wert zu ersetzen. Die <xref:System.String.Format%2A> Methode wird häufig verwendet, um Folgendes auszuführen:  
  
-   Um die Zeichenfolgendarstellung eines numerischen Werts in einer Zeichenfolge einzubetten.  
  
-   Die Zeichenfolgendarstellung eines Werts für Datum und Uhrzeit in eine Zeichenfolge einzubetten.  
  
-   Die Zeichenfolgendarstellung eines Enumerationswerts in eine Zeichenfolge einzubetten.  
  
-   Die Zeichenfolgendarstellung von einem Objekt eingebettet, die unterstützt die <xref:System.IFormattable> Schnittstelle in einer Zeichenfolge.  
  
-   Rechtsbündig oder linksbündig einer Teilzeichenfolge in ein Feld innerhalb einer größeren Zeichenfolge.  
  
 Ausführliche Informationen zur Formatierung, Vorgänge und Beispiele finden Sie unter den <xref:System.String.Format%2A> Zusammenfassung überladen.  
  
### <a name="copying-a-string"></a>Kopieren einer Zeichenfolge  
 Sie können den folgenden Aufruf <xref:System.String> Methoden, um eine Kopie einer Zeichenfolge zu erstellen:  
  
-   <xref:System.String.Clone%2A> Gibt einen Verweis auf ein vorhandenes <xref:System.String> Objekt.  
  
-   <xref:System.String.Copy%2A> erstellt eine Kopie einer vorhandenen Zeichenfolge.  
  
-   <xref:System.String.CopyTo%2A> Kopiert einen Teil einer Zeichenfolge in ein Zeichenarray.  
  
### <a name="normalizing-a-string"></a>Eine Zeichenfolge normalisieren  
 Im Unicode-Format kann ein einzelnes Zeichen über mehrere Codepunkte haben. Normalisierung konvertiert diese entsprechende Zeichen in der gleichen binäre Darstellung. Die <xref:System.String.Normalize%2A?displayProperty=nameWithType> Methode führt die Normalisierung aus, und die <xref:System.String.IsNormalized%2A?displayProperty=nameWithType> Methode bestimmt, ob eine Zeichenfolge normalisiert wurde.  
  
 Weitere Informationen und ein Beispiel finden Sie unter den [Normalisierung](#Normalization) weiter oben in diesem Thema.  

 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://www.microsoft.com/en-us/download/details.aspx?id=10921">Sortieren die Gewichtung Tabellen für die Windows-Betriebssysteme</related>
    <related type="ExternalDocumentation" href="https://www.unicode.org/Public/UCA/latest/allkeys.txt">Unicode-Sortierung Elemeent Standardtabelle, für Linux und macOS</related>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.ICloneable" />
    <altmember cref="T:System.IConvertible" />
    <altmember cref="T:System.Collections.IEnumerable" />
    <altmember cref="T:System.Text.StringBuilder" />
    <altmember cref="T:System.Globalization.CultureInfo" />
    <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
    <related type="Article" href="https://msdn.microsoft.com/library/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7">Empfohlene Vorgehensweisen für die Verwendung von Zeichenfolgen in .NET Framework</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.String" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In diesem Abschnitt  
  
 [Der überladene Konstruktor-syntax](#Syntax)   
 [Parameter](#Params)   
 [Ausnahmen](#Exceptions)   
 [Welche Methode rufe ich?](#Tasks)   
 [Erstellen von Zeichenfolgen](#Creating_Strings)   
 [Behandlung von Zeichenfolgen](#Repetitive)   
 Beispiele für Zeichenfolgen mit instanziieren:   
 [Mit der Zeichenfolge-Zuweisung](#Ctor1_Example)  
 [Verwenden ein Array von Zeichen](#Ctor2_Example)  
 [Verwenden einen Teil eines Arrays von Zeichen, und wiederholen ein einzelnes Zeichen](#Ctor3_Example)  
 [Mithilfe eines Zeigers auf ein Array von Zeichen](#Ctor4_Example)  
 [Verwenden einen Zeiger und einen Bereich eines Arrays](#Ctor5_Example)  
 [Mithilfe eines Zeigers auf ein Bytearray mit Vorzeichen](#Ctor6_Example)  
[Versionsinformationen](#Versions)  
  
<a name="Syntax"></a>   
## <a name="overloaded-constructor-syntax"></a>Der überladene Konstruktor-syntax  
 Konstruktoren für Zeichenfolge in zwei Kategorien unterteilen: ohne Zeigerparameter an, und die mit Zeigerparameter. Die Konstruktoren, die Zeiger verwenden, sind nicht CLS-kompatibel. Darüber hinaus Visual Basic unterstützt nicht die Verwendung von Zeigern und in c# muss Code, der Zeiger verwendet wird, um in einem unsicheren Kontext auszuführen. Weitere Informationen finden Sie unter [unsafe](~/docs/csharp/language-reference/keywords/unsafe.md).  
  
 Weitere Anleitungen zum Auswählen einer Überladung finden Sie unter [welche Methode rufe ich?](#Tasks)  
  
 `String(Char[] value)`  
 Initialisiert die neue Instanz mit dem Wert durch ein Array von Unicode-Zeichen. Dieser Konstruktor kopiert die Unicode-Zeichen ([Beispiel](#Ctor2_Example)).  
  
 `String(Char[] value, Int32 startIndex, Int32 length)`  
 Initialisiert die neue Instanz mit dem Wert durch ein Array von Unicode-Zeichen, die Position des ersten Zeichens innerhalb dieses Arrays, und die Länge ([Beispiel](#Ctor3_Example)).  
  
 `String(Char c, Int32 count)`  
 Eine angegebene Anzahl von Malen wiederholt, initialisiert die neue Instanz mit dem Wert angegeben wird, durch ein angegebenes Unicodezeichen ([Beispiel](#Ctor3_Example)).  
  
 `String(char* value)`  
 **(Nicht CLS-kompatibel)**  Initialisiert die neue Instanz mit dem Wert durch einen Zeiger auf ein Array von Unicode-Zeichen, die durch ein Null-Zeichen beendet wird (U + 0000 oder '\0'). ([Beispiel](#Ctor4_Example)).  
  
 Berechtigung: <xref:System.Security.SecurityCriticalAttribute>, erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.  
  
 `String(char* value, Int32 startIndex, Int32 length)`  
 **(Nicht CLS-kompatibel)**  Initialisiert die neue Instanz mit dem Wert durch einen Zeiger auf ein Array von Unicode-Zeichen, die Position des ersten Zeichens innerhalb dieses Arrays und eine Länge angegeben. Der Konstruktor kopiert die Unicode-Zeichen von `value` beginnend am Index `startIndex` und endet am Index `startIndex`  +  `length` - 1 ([Beispiel](#Ctor5_Example)).  
  
 Berechtigung: <xref:System.Security.SecurityCriticalAttribute>, erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.  
  
 `String(SByte* value)`  
 **(Nicht CLS-kompatibel)**  Initialisiert die neue Instanz mit dem Wert durch einen Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen. Das Array wird davon ausgegangen, dass zur Darstellung einer Zeichenfolge, die mit der aktuellen Codepage des Systems codiert (d. h. durch angegebene Codierung <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>). Der Konstruktor verarbeitet die Zeichen aus `value` beginnend an der vom Zeiger angegeben werden, bis ein Null-Zeichen (0 x 00) erreicht ist ([Beispiel](#Ctor6_Example)).  
  
 Berechtigung: <xref:System.Security.SecurityCriticalAttribute>, erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.  
  
 `String(SByte* value, Int32 startIndex, Int32 length)`  
 **(Nicht CLS-kompatibel)**  Initialisiert die neue Instanz auf den Wert durch einen Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen, die Startposition innerhalb dieses Arrays und eine Länge angegeben.  Das Array wird davon ausgegangen, dass zur Darstellung einer Zeichenfolge, die mit der aktuellen Codepage des Systems codiert (d. h. durch angegebene Codierung <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>). Der Konstruktor verarbeitet Zeichen aus beginnend mit Wert `startIndex` und endet um `startIndex`  +  `length` - 1 ([Beispiel](#Ctor6_Example)).  
  
 Berechtigung: <xref:System.Security.SecurityCriticalAttribute>, erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.  
  
 `String(SByte* value, Int32 startIndex, Int32 length, Encoding enc)`  
 **(Nicht CLS-kompatibel)**  Initialisiert die neue Instanz mit dem Wert durch einen Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen, Startposition innerhalb dieses Arrays, eine Länge und ein <xref:System.Text.Encoding> Objekt.  
  
 Berechtigung: <xref:System.Security.SecurityCriticalAttribute>, erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.  
  
<a name="Params"></a>   
## <a name="parameters"></a>Parameter  
 Hier ist eine vollständige Liste der von verwendeten Parameter <xref:System.String> Konstruktoren, die einen Zeigerparameter nicht enthalten. Die Parameter, die von jeder Überladung verwendet wird finden Sie unter die oben stehende Syntax Überladung.  
  
|Parameter|Typ|Beschreibung |  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>[]|Ein Array von Unicode-Zeichen.|  
|`c`|<xref:System.Char>|Ein Unicode-Zeichen.|  
|`startIndex`|<xref:System.Int32>|Die Anfangsposition in `value` des ersten Zeichens in der neuen Zeichenfolge.<br /><br /> Standardwert: 0|  
|`length`|<xref:System.Int32>|Die Anzahl der Zeichen in `value` in der neuen Zeichenfolge eingeschlossen werden sollen.<br /><br /> Standardwert: <xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`count`|<xref:System.Int32>|Die Häufigkeit, mit des Zeichens `c` wird in der neuen Zeichenfolge wiederholt. Wenn `count` NULL ist, wird der Wert des neuen Objekts <xref:System.String.Empty?displayProperty=nameWithType>.|  
  
 Hier ist eine vollständige Liste der von verwendeten Parameter <xref:System.String> Konstruktoren, die einen Zeigerparameter enthalten. Die Parameter, die von jeder Überladung verwendet wird finden Sie unter die oben stehende Syntax Überladung.  
  
|Parameter|Typ|Beschreibung |  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>*<br /><br /> - oder - <br /><br /> <xref:System.SByte>\*|Ein Zeiger auf eine mit Null endendes Array von Unicode-Zeichen oder ein Array von 8-Bit-Ganzzahlen mit Vorzeichen. Wenn `value` ist `null` oder ein leeres Array ist der Wert der neuen Zeichenfolge <xref:System.String.Empty?displayProperty=nameWithType>.|  
|`startIndex`|<xref:System.Int32>|Der Index des Arrayelements dar, der das erste Zeichen in der neuen Zeichenfolge definiert.<br /><br /> Standardwert: 0|  
|`length`|<xref:System.Int32>|Die Anzahl der Elemente des Arrays zu verwenden, um die neue Zeichenfolge zu erstellen. Wenn die Länge 0 (null) ist, wird der Konstruktor erstellt eine Zeichenfolge, deren Wert <xref:System.String.Empty?displayProperty=nameWithType>.<br /><br /> Standardwert: <xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`enc`|<xref:System.Text.Encoding>|Ein Objekt, der angibt, wie die `value` Array codiert ist.<br /><br /> Standardwert: <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>, oder der aktuellen ANSI-Codepage des Systems|  
  
<a name="Exceptions"></a>   
## <a name="exceptions"></a>Ausnahmen  
 Hier ist eine Liste der Ausnahmen, die von den Konstruktoren, die keine Zeigerparameter enthalten.  
  
|Ausnahme|Bedingung|Ausgelöst durch|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentNullException>|`value` ist `null`.|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
|<xref:System.ArgumentOutOfRangeException>|`startIndex`,`length`, oder `count` ist kleiner als 0 (null).<br /><br /> - oder - <br /><br /> Die Summe von `startIndex` und `length` ist größer als die Anzahl von Elementen in `value`.<br /><br /> - oder - <br /><br /> `count` ist kleiner als Null.|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
  
 Hier ist eine Liste der Ausnahmen, die von den Konstruktoren, die Zeigerparameter enthalten.  
  
|Ausnahme|Bedingung|Ausgelöst durch|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentException>|`value` Gibt ein Array, das ein ungültiges Unicodezeichen enthält.<br /><br /> - oder - <br /><br /> `value` oder `value`  +  `startIndex` gibt an, eine Adresse kleiner als 64K.<br /><br /> - oder - <br /><br /> Ein neues <xref:System.String> Instanz konnte nicht initialisiert werden, aus der `value` Bytearray da `value` verwendet nicht die standardmäßige Systemcodeseiten-Codierung.|Alle Konstruktoren mit Zeigern.|  
|<xref:System.ArgumentNullException>|`value` ist NULL.|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|<xref:System.ArgumentOutOfRangeException>|Der aktuelle Prozess hat keinen Lesezugriff auf alle adressierten Zeichen.<br /><br /> - oder - <br /><br /> `startIndex` oder `length` ist kleiner als 0 (null), `value` + `startIndex` verursacht einen Zeigerüberlauf oder der aktuelle Prozess hat keinen Lesezugriff auf alle adressierten Zeichen.<br /><br /> - oder - <br /><br /> Die Länge der neuen Zeichenfolge ist zu groß für die Zuordnung.|Alle Konstruktoren mit Zeigern.|  
|<xref:System.AccessViolationException>|`value`, oder `value`  +  `startIndex`  +  `length` -1, gibt eine ungültige Adresse.|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
  
<a name="Tasks"></a>   
## <a name="which-method-do-i-call"></a>Welche Methode rufe ich?  
  
|Beschreibung|Aufruf, oder verwenden|  
|--------|-----------------|  
|Eine Zeichenfolge zu erstellen.|Zuweisung von einem Zeichenfolgenliteral oder eine vorhandene Zeichenfolge ([Beispiel](#Ctor1_Example))|  
|Erstellen Sie eine Zeichenfolge aus einem Array ganze Zeichen ein.|<xref:System.String.%23ctor%28System.Char%5B%5D%29> ([Beispiel](#Ctor2_Example))|  
|Erstellen Sie eine Zeichenfolge aus einem Abschnitt eines Arrays von Zeichen an.|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> ([Beispiel](#Ctor3_Example))|  
|Erstellen Sie eine Zeichenfolge, die das gleiche Zeichen mehrere Male wiederholt.|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> ([Beispiel](#Ctor3_Example))|  
|Erstellen Sie eine Zeichenfolge von einem Zeiger auf eine Unicode- oder ein Array mit Breitzeichen.|<xref:System.String.%23ctor%28System.Char%2A%29>|  
|Erstellen Sie eine Zeichenfolge mithilfe der Zeiger aus einem Abschnitt eine Unicode-oder ein Array mit Breitzeichen.|<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>|  
|Erstellen Sie eine Zeichenfolge aus einer C++ `char` Array.|<xref:System.String.%23ctor%28System.SByte%2A%29>, <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> - oder - <br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|Erstellen Sie eine Zeichenfolge, aus ASCII-Zeichen.|<xref:System.Text.ASCIIEncoding.GetString%2A?displayProperty=nameWithType>|  
  
<a name="Creating_Strings"></a>   
## <a name="creating-strings"></a>Erstellen von Zeichenfolgen  
 Die am häufigsten verwendeten Verfahren für programmgesteuerte Erstellung von Zeichenfolgen einfache Zuweisung, siehe [in diesem Beispiel](#Ctor1_Example). Die <xref:System.String> -Klasse enthält auch vier Typen von überladene Konstruktoren verfügbar, mit denen Sie die Zeichenfolgen aus den folgenden Werten zu erstellen:  
  
-   Aus einem Array mit Zeichen (ein Array von UTF-16-codierte Zeichen). Sie können ein neues erstellen <xref:System.String> Objekt aus der Zeichen in das gesamte Array oder einen Teil davon. Die <xref:System.String.%23ctor%28System.Char%5B%5D%29> Konstruktor kopiert alle Zeichen im Array, in die neue Zeichenfolge. Die <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Konstruktor kopiert die Zeichen aus dem Index `startIndex` Index `startIndex`  +  `length` -1, um die neue Zeichenfolge. Wenn `length` NULL ist, wird der Wert der neuen Zeichenfolge <xref:System.String.Empty?displayProperty=nameWithType>.  
  
     Wenn Ihr Code wiederholt Zeichenfolgen, die den gleichen Wert verfügen instanziiert, können Sie die Anwendungsleistung verbessern, mit der eine alternative Möglichkeit für das Erstellen von Zeichenfolgen. Weitere Informationen finden Sie unter [Behandlung von Zeichenfolgen](#Repetitive).  
  
-   Von einem einzelnen Zeichen, das doppelte 0 (null), einen oder mehrere Male, mit der <xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> Konstruktor. Wenn `count` NULL ist, wird der Wert der neuen Zeichenfolge <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Mithilfe von einem Zeiger auf ein Null-terminierte Zeichenarray, das <xref:System.String.%23ctor%28System.Char%2A%29> oder <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> Konstruktor. Entweder das gesamte Array oder einem angegebenen Bereich kann verwendet werden, um die Zeichenfolge zu initialisieren. Der Konstruktor kopiert eine Sequenz von Unicode-Zeichen ab, aus dem angegebenen Zeiger oder der angegebene Zeiger plus `startIndex` und bis zum Ende des Arrays oder für `length` Zeichen. Wenn `value` ist ein null-Zeiger oder `length` 0 (null), wird der Konstruktor erstellt eine Zeichenfolge, deren Wert <xref:System.String.Empty?displayProperty=nameWithType>. Wenn der Kopiervorgang wird, bis zum Ende des Arrays fortgesetzt, und das Array ist nicht für die Null-terminiert, ist das Verhalten der Konstruktor System abhängig. Eine solche Bedingung kann eine zugriffsverletzung verursachen.  
  
     Wenn das Array eingebetteten Null-Zeichen enthält (U + 0000 oder '\0') und die <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> Überladung aufgerufen wird, wird die Zeichenfolgeninstanz enthält `length` Zeichen einschließlich aller eingebettete NULL-Werte. Das folgende Beispiel zeigt, was geschieht, wenn ein Zeiger auf ein Array aus 10 Elementen, die zwei Null-Zeichen enthält, übergeben, wird die <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> Methode. Da die Adresse der Anfang des Arrays ist und alle Elemente im Array der Zeichenfolge hinzugefügt werden, instanziiert der Konstruktor eine Zeichenfolge mit zehn Zeichen, einschließlich der zwei eingebettete NULL-Werte. Andererseits, wenn dasselbe Array übergeben wird, um die <xref:System.String.%23ctor%28System.Char%2A%29> -Konstruktor, der das Ergebnis ist eine vier-Zeichenfolge, die keine erste Null-Zeichen enthält.  
  
     [!code-cpp[System.String.ctor#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/chptrctor_null.cpp#5)]
     [!code-csharp[System.String.ctor#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/chptrctor_null.cs#5)]  
  
     Das Array muss es sich um Unicode-Zeichen enthalten. In C++ ist dies bedeutet, dass das Zeichenarray muss entweder als die verwaltete definiert <xref:System.Char>[]-Typ oder die nicht verwaltete`wchar_t`[]-Typ.  
  
     Wenn die <xref:System.String.%23ctor%28System.Char%2A%29> -Überladung aufgerufen wird und das Array ist nicht für die Null-terminiert ist, oder wenn die <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> -Überladung aufgerufen wird und `startIndex`  +  `length`-1 umfasst eine Reihe, die sie außerhalb des Speichers für die Sequenz von Zeichen zugeordnet das Verhalten des Konstruktors ist systemabhängig und eine zugriffsverletzung auftreten. Darüber hinaus auf dem Intel Itanium-Prozessor aufgerufen, um die <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> Konstruktor löst möglicherweise eine <xref:System.DataMisalignedException> Ausnahme. In diesem Fall rufen die <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> stattdessen.  
  
-   Von einem Zeiger auf ein Array von Byte mit Vorzeichen. Entweder das gesamte Array oder einem angegebenen Bereich kann verwendet werden, um die Zeichenfolge zu initialisieren. Die Abfolge von Bytes mit der Standardcodepage-Codierung interpretiert werden kann, oder eine Codierung im Konstruktoraufruf angegeben werden. Wenn der Konstruktor versucht, eine Zeichenfolge aus einem gesamten Array zu instanziieren, der keine Null-terminiert ist, oder wenn der Bereich der Arrays von `value`  +  `startIndex` zu `value`  +  `startIndex`  +  `length` -1 ist, außerhalb des Arbeitsspeichers für das Array, das Verhalten dieses Konstruktors ist systemabhängig und eine zugriffsverletzung auftreten.  
  
     Die drei Konstruktoren, die als Parameter ein Bytearray mit Vorzeichen enthalten dienen in erster Linie zum Konvertieren einer C++ `char` array in eine Zeichenfolge, wie im folgenden Beispiel gezeigt:  
  
     [!code-cpp[System.String.Ctor#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/sbyte_ctor1.cpp#4)]  
  
     Wenn das Array enthält Null-Zeichen ('\0') oder die Bytes, deren Wert 0 gleich, und der <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> Überladung aufgerufen wird, wird die Zeichenfolgeninstanz enthält `length` Zeichen einschließlich aller eingebettete NULL-Werte. Das folgende Beispiel zeigt, was geschieht, wenn ein Zeiger auf ein Array aus 10 Elementen, die zwei Null-Zeichen enthält, übergeben, wird die <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> Methode. Da die Adresse der Anfang des Arrays ist und alle Elemente im Array der Zeichenfolge hinzugefügt werden, instanziiert der Konstruktor eine Zeichenfolge mit zehn Zeichen, einschließlich der zwei eingebettete NULL-Werte. Andererseits, wenn dasselbe Array übergeben wird, um die <xref:System.String.%23ctor%28System.SByte%2A%29> -Konstruktor, der das Ergebnis ist eine vier-Zeichenfolge, die keine erste Null-Zeichen enthält.  
  
     [!code-cpp[System.String.ctor#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/ptrctor_null.cpp#6)]
     [!code-csharp[System.String.ctor#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ptrctor_null.cs#6)]  
  
     Da die <xref:System.String.%23ctor%28System.SByte%2A%29> und <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> Konstruktoren interpretieren `value` verwenden die Standard-ANSI-Codepage, diese Konstruktoren mit identischer Byte-Arrays aufrufen kann erstellen Zeichenfolgen, die auf anderen Systemen unterschiedliche Werte aufweisen.  
  
<a name="Repetitive"></a>   
## <a name="handling-repetitive-strings"></a>Behandlung von Zeichenfolgen  
 Verwenden Sie Apps, die analysiert werden, oder Streams von Text häufig Decodieren der <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Konstruktor oder die <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> Methode, um Sequenzen von Zeichen in eine Zeichenfolge zu konvertieren. Erstellen neue Zeichenfolgen wiederholt mit den gleichen Wert anstatt zu erstellen und Wiederverwenden von einer Zeichenfolge wird Arbeitsspeicher vergeudet. Wenn Sie wahrscheinlich den gleichen Zeichenfolgenwert wiederholt zu erstellen, indem die <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Konstruktor, selbst wenn Sie nicht in kennen fahren Sie fort, was diese Werte identisch sein können, können Sie stattdessen eine Nachschlagetabelle verwenden.  
  
 Nehmen wir beispielsweise an, Sie lesen und Analysieren einen Stream von Zeichen aus einer Datei, die XML-Tags und Attribute enthält. Wenn Sie den Stream zu analysieren, treten wiederholt bestimmte Token (d. h. Sequenzen von Zeichen, die eine symbolische Bedeutung haben). Token, die die Zeichenfolgen "0", "1", "true" und "false" werden wahrscheinlich in einem XML-Stream häufig auftreten.  
  
 Nicht jedes Token in einer neuen Zeichenfolge zu konvertieren, können Sie erstellen eine <xref:System.Xml.NameTable?displayProperty=nameWithType> Objekt, das häufig auftretende Zeichenfolgen. Die <xref:System.Xml.NameTable> -Objekt verbessert die Leistung, da es sich um gespeicherten Zeichenfolgen abruft, ohne den temporären Speicher zuzuordnen. Wenn Sie ein Token auftritt, verwenden Sie die <xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> Methode, um das Token aus der Tabelle abzurufen. Wenn das Token vorhanden ist, gibt die Methode die entsprechende Zeichenfolge zurück. Wenn das Token nicht vorhanden ist, verwenden Sie die <xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> Methode, um das Token in die Tabelle einzufügen und die entsprechende Zeichenfolge abgerufen.  
  
<a name="Ctor1_Example"></a>   
## <a name="example-1-using-string-assignment"></a>Beispiel 1: Mit der Zeichenfolge-Zuweisung  
 Das folgende Beispiel erstellt eine neue Zeichenfolge, indem Sie ihm ein Zeichenfolgenliteral zuweisen. Es erstellt eine zweite Zeichenfolge an, indem Sie den Wert der ersten Zeichenfolge zuweisen. Hierbei handelt es sich um die beiden am häufigsten verwendeten Arten zum Instanziieren einer neuen <xref:System.String> Objekt.  
  
 [!code-cpp[System.String.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/assignment.cpp#1)]
 [!code-csharp[System.String.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.String.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.ctor/vb/ctor1.vb#1)]  
  
<a name="Ctor2_Example"></a>   
## <a name="example-2-using-a-character-array"></a>Beispiel 2: Verwenden ein Array von Zeichen  
 Im folgende Beispiel wird veranschaulicht, wie zum Erstellen eines neuen <xref:System.String> Objekt aus einem Zeichenarray.  
  
 [!code-cpp[stringexample1#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#1)]
 [!code-csharp[stringexample1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#1)]
 [!code-vb[stringexample1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#1)]  
  
<a name="Ctor3_Example"></a>   
## <a name="example-3-using-a-portion-of-a-character-array-and-repeating-a-single-character"></a>Beispiel 3: Verwenden einen Teil eines Arrays von Zeichen, und wiederholen ein einzelnes Zeichen  
 Im folgende Beispiel wird veranschaulicht, wie zum Erstellen eines neuen <xref:System.String> Objekt aus einem Abschnitt der ein Array von Zeichen und das Erstellen eines neuen <xref:System.String> -Objekt, das mehrere Vorkommen eines einzelnen Zeichens enthält.  
  
 [!code-cpp[stringexample1#3](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#3)]
 [!code-csharp[stringexample1#3](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#3)]
 [!code-vb[stringexample1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#3)]  
  
<a name="Ctor4_Example"></a>   
## <a name="example-4-using-a-pointer-to-a-character-array"></a>Beispiel 4: Mithilfe eines Zeigers auf ein Array von Zeichen  
 Im folgende Beispiel wird veranschaulicht, wie zum Erstellen eines neuen <xref:System.String> Objekt von einem Zeiger auf ein Array von Zeichen. C#-Beispiel muss kompiliert werden, mithilfe der `/unsafe` Compilerschalter.  
  
 [!code-cpp[System.String.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char1_ctor.cpp#2)]
 [!code-csharp[System.String.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor2.cs#2)]  
  
<a name="Ctor5_Example"></a>   
## <a name="example-5-instantiating-a-string-from-a-pointer-and-a-range-of-an-array"></a>Beispiel 5: Instanziieren eine Zeichenfolge von einem Zeiger und einen Bereich eines Arrays  
 Im folgende Beispiel werden die Elemente eines Arrays von Zeichen für einen Zeitraum oder ein Ausrufezeichen untersucht. Wenn eines gefunden wird, instanziiert er eine Zeichenfolge aus den Zeichen im Array, die das interpunktionssymbol vorangestellt sein. Wenn dies nicht der Fall ist, wird er instanziiert eine Zeichenfolge mit den gesamten Inhalt des Arrays. C#-Beispiel muss kompiliert werden, mithilfe der `/unsafe` Compilerschalter.  
  
 [!code-cpp[System.String.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char2_ctor.cpp#3)]
 [!code-csharp[System.String.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/char2_ctor.cs#3)]  
  
<a name="Ctor6_Example"></a>   
## <a name="example-6-instantiating-a-string-from-a-pointer-to-a-signed-byte-array"></a>Beispiel 6: Instanziieren eine Zeichenfolge von einem Zeiger auf ein Array von Byte mit Vorzeichen  
 Im folgende Beispiel wird veranschaulicht, wie Sie eine Instanz von erstellen können die <xref:System.String> -Klasse mit der <xref:System.String.%23ctor%28System.SByte%2A%29> Konstruktor.  
  
 [!code-cpp[stringexample1#2](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#2)]
 [!code-csharp[stringexample1#2](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#2)]  
  
<a name="Versions"></a>   
## <a name="version-information"></a>Versionsinformationen  
 .NET Framework  
 Alle Überladungen werden unterstützt: 4.5 "," 4 "," 3.5 "," 3.0 "," 2.0 "," 1.1 "," 1.0  
  
 .NET Framework Client Profile  
 Alle Überladungen werden unterstützt: 4 3.5 SP1  
  
 Portable Klassenbibliothek  
 Alle Überladungen ohne eine <xref:System.SByte> `*` Parameter werden unterstützt.  
  
 .NET für Windows Store-Apps  
 Alle Überladungen ohne eine <xref:System.SByte> `*` Parameter werden unterstützt: Windows 8  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
      </Parameters>
      <Docs>
        <param name="value">Ein Zeiger auf ein mit Null endendes Array von Unicode-Zeichen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.String" />-Klasse mit dem Wert, der durch einen angegebenen Zeiger auf ein Array von Unicode-Zeichen bestimmt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und eine umfassende von Nutzungsinformationen zu diesem und anderen `String` Konstruktorüberladungen, finden Sie unter den <xref:System.String.%23ctor%2A> Konstruktor Zusammenfassung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der aktuelle Prozess hat keinen Lesezugriff auf alle adressierten Zeichen.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> gibt ein Array an, das ein ungültiges Unicode-Zeichen enthält, oder <paramref name="value" /> gibt eine Adresse kleiner als 64000 an.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new string : char[] -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">Ein Array von Unicode-Zeichen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.String" />-Klasse mit dem durch ein Array von Unicode-Zeichen angegebenen Wert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und eine umfassende von Nutzungsinformationen zu diesem und anderen `String` Konstruktorüberladungen, finden Sie unter den <xref:System.String.%23ctor%2A> Konstruktor Zusammenfassung.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="new string : ReadOnlySpan&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
      </Parameters>
      <Docs>
        <param name="value">Ein Zeiger auf ein mit NULL endendes Array von 8-Bit-Ganzzahlen mit Vorzeichen. Die Ganzzahlen werden mit der aktuellen Systemcodeseiten-Codierung interpretiert (d.h. der durch <see cref="P:System.Text.Encoding.Default" /> angegebenen Codierung).</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.String" />-Klasse mit dem durch einen Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen angegebenen Wert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und eine umfassende von Nutzungsinformationen zu diesem und anderen `String` Konstruktorüberladungen, finden Sie unter den <xref:System.String.%23ctor%2A> Konstruktor Zusammenfassung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Eine neue Instanz von <see cref="T:System.String" /> konnte nicht mit <paramref name="value" /> initialisiert werden, wobei angenommen wurde, dass <paramref name="value" /> in ANSI codiert ist.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Länge der neuen zu initialisierenden Zeichenfolge, die durch das NULL-Abschlusszeichen von <paramref name="value" /> bestimmt wird, ist zu groß für die Zuordnung.</exception>
        <exception cref="T:System.AccessViolationException"><paramref name="value" /> gibt eine ungültige Adresse an.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char c, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char c, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (c As Char, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char c, int count);" />
      <MemberSignature Language="F#" Value="new string : char * int -&gt; string" Usage="new System.string (c, count)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="c">Ein Unicode-Zeichen.</param>
        <param name="count">Die Anzahl des Vorkommens von <paramref name="c" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.String" />-Klasse mit dem Wert, der durch ein angegebenes so oft wie angegeben wiederholtes Unicode-Zeichen bestimmt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und eine umfassende von Nutzungsinformationen zu diesem und anderen `String` Konstruktorüberladungen, finden Sie unter den <xref:System.String.%23ctor%2A> Konstruktor Zusammenfassung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ein Zeiger auf ein Array von Unicode-Zeichen.</param>
        <param name="startIndex">Die Anfangsposition in <paramref name="value" />.</param>
        <param name="length">Die Anzahl der aus <paramref name="value" /> zu verwendenden Zeichen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.String" />-Klasse mit dem Wert, der durch einen angegebenen Zeiger auf ein Array von Unicode-Zeichen, durch die Position des ersten Zeichens innerhalb dieses Arrays und durch eine Länge bestimmt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und eine umfassende von Nutzungsinformationen zu diesem und anderen `String` Konstruktorüberladungen, finden Sie unter den <xref:System.String.%23ctor%2A> Konstruktor Zusammenfassung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> oder <paramref name="length" /> ist kleiner als 0 (null), <paramref name="value" /> + <paramref name="startIndex" /> verursacht einen Zeigerüberlauf oder der aktuelle Prozess hat keinen Lesezugriff auf alle adressierten Zeichen.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> gibt ein Array an, das ein ungültiges Unicode-Zeichen enthält, oder <paramref name="value" /> + <paramref name="startIndex" /> gibt eine Adresse kleiner als 64000 an.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : char[] * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ein Array von Unicode-Zeichen.</param>
        <param name="startIndex">Die Anfangsposition in <paramref name="value" />.</param>
        <param name="length">Die Anzahl der aus <paramref name="value" /> zu verwendenden Zeichen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.String" />-Klasse mit dem Wert, der durch ein Array von Unicode-Zeichen, die Position des ersten Zeichens innerhalb dieses Arrays und eine Länge bestimmt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und eine umfassende von Nutzungsinformationen zu diesem und anderen `String` Konstruktorüberladungen, finden Sie unter den <xref:System.String.%23ctor%2A> Konstruktor Zusammenfassung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> oder <paramref name="length" /> ist kleiner als 0.  
  
- oder -  
Die Summe von <paramref name="startIndex" /> und <paramref name="length" /> ist größer als die Anzahl von Elementen in <paramref name="value" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ein Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen. Die Ganzzahlen werden mit der aktuellen Systemcodeseiten-Codierung interpretiert (d.h. der durch <see cref="P:System.Text.Encoding.Default" /> angegebenen Codierung).</param>
        <param name="startIndex">Die Anfangsposition in <paramref name="value" />.</param>
        <param name="length">Die Anzahl der aus <paramref name="value" /> zu verwendenden Zeichen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.String" />-Klasse mit dem Wert, der durch einen angegebenen Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen, die Startposition innerhalb dieses Arrays und die Länge angegeben wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und eine umfassende von Nutzungsinformationen zu diesem und anderen `String` Konstruktorüberladungen, finden Sie unter den <xref:System.String.%23ctor%2A> Konstruktor Zusammenfassung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> oder <paramref name="length" /> ist kleiner als 0.  
  
- oder -  
Die durch <paramref name="value" /> + <paramref name="startIndex" /> angegebene Adresse ist für die aktuelle Plattform zu groß, d.h., bei der Berechnung der Adresse ist ein Überlauf aufgetreten.  
  
- oder -  
Die Länge der zu initialisierenden neuen Zeichenfolge ist zu groß und kann daher nicht zugeordnet werden.</exception>
        <exception cref="T:System.ArgumentException">Die durch <paramref name="value" /> + <paramref name="startIndex" /> angegebene Adresse ist kleiner als 64K.  
  
- oder -  
Eine neue Instanz von <see cref="T:System.String" /> konnte nicht mit <paramref name="value" /> initialisiert werden, wobei angenommen wurde, dass <paramref name="value" /> in ANSI codiert ist.</exception>
        <exception cref="T:System.AccessViolationException"><paramref name="value" />, <paramref name="startIndex" /> und <paramref name="length" /> geben zusammen eine ungültige Adresse an.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length, System.Text.Encoding enc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length, class System.Text.Encoding enc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length, System::Text::Encoding ^ enc);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int * System.Text.Encoding -&gt; string" Usage="new System.string (value, startIndex, length, enc)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="enc" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="value">Ein Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen.</param>
        <param name="startIndex">Die Anfangsposition in <paramref name="value" />.</param>
        <param name="length">Die Anzahl der aus <paramref name="value" /> zu verwendenden Zeichen.</param>
        <param name="enc">Ein Objekt, das angibt, wie das Array codiert ist, auf das <paramref name="value" /> verweist. Wenn <paramref name="enc" /><see langword="null" /> ist, wird von ANSI-Codierung ausgegangen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.String" />-Klasse mit dem Wert, der durch einen angegebenen Zeiger auf ein Array von 8-Bit-Ganzzahlen mit Vorzeichen, die Startposition innerhalb dieses Arrays, eine Länge und ein <see cref="T:System.Text.Encoding" />-Objekt angegeben wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beispiele und eine umfassende von Nutzungsinformationen zu diesem und anderen `String` Konstruktorüberladungen, finden Sie unter den <xref:System.String.%23ctor%2A> Konstruktor Zusammenfassung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> oder <paramref name="length" /> ist kleiner als 0.  
  
- oder -  
Die durch <paramref name="value" /> + <paramref name="startIndex" /> angegebene Adresse ist für die aktuelle Plattform zu groß, d.h., bei der Berechnung der Adresse ist ein Überlauf aufgetreten.  
  
- oder -  
Die Länge der zu initialisierenden neuen Zeichenfolge ist zu groß und kann daher nicht zugeordnet werden.</exception>
        <exception cref="T:System.ArgumentException">Die durch <paramref name="value" /> + <paramref name="startIndex" /> angegebene Adresse ist kleiner als 64K.  
  
- oder -  
Eine neue Instanz von <see cref="T:System.String" /> konnte nicht mit <paramref name="value" /> initialisiert werden, wobei angenommen wurde, dass <paramref name="value" /> entsprechend der Angabe durch <paramref name="enc" /> codiert ist.</exception>
        <exception cref="T:System.AccessViolationException"><paramref name="value" />, <paramref name="startIndex" /> und <paramref name="length" /> geben zusammen eine ungültige Adresse an.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Eine Position in der aktuellen Zeichenfolge.</param>
        <summary>Ruft das <see cref="T:System.Char" />-Objekt an einer angegebenen Zeichenposition innerhalb des aktuellen <see cref="T:System.String" />-Objekts ab.</summary>
        <value>Das Objekt an der <paramref name="index" />-Position.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `index` Parameter ist nullbasiert.  
  
 Diese Eigenschaft gibt die <xref:System.Char> -Objekt an der Position, die gemäß der `index` Parameter. Allerdings kann ein Unicode-Zeichen dargestellt werden, von mehreren <xref:System.Char>. Verwenden der <xref:System.Globalization.StringInfo?displayProperty=nameWithType> -Klasse zum Arbeiten mit Unicode-Zeichen anstelle von <xref:System.Char> Objekte. Weitere Informationen finden Sie im Abschnitt "Char-Objekten und Unicode-Zeichen" in der <xref:System.String> Übersicht über die Klasse.  
  
 In c# die <xref:System.String.Chars%2A> Eigenschaft ist ein Indexer. In Visual Basic ist es die Standardeigenschaft der <xref:System.String> Klasse. Jede <xref:System.Char> Objekt in der Zeichenfolge kann mit Code wie den folgenden zugegriffen werden.  
  
 [!code-csharp[System.String.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.chars/cs/chars1.cs#1)]
 [!code-vb[System.String.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.chars/vb/chars1.vb#1)]  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie Sie mit diesem Indexer in einer Routine verwenden können, um eine Zeichenfolge zu überprüfen.  
  
 [!code-cpp[Uri_IsHexDigit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Uri_IsHexDigit/CPP/uri_ishexdigit.cpp#1)]
 [!code-csharp[Uri_IsHexDigit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Uri_IsHexDigit/CS/uri_ishexdigit.cs#1)]
 [!code-vb[Uri_IsHexDigit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Uri_IsHexDigit/VB/uri_ishexdigit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> ist größer oder gleich der Länge dieses Objekts oder kleiner als 0 (null).</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.GetEnumerator" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="string.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Verweis auf diese Instanz von <see cref="T:System.String" /> zurück.</summary>
        <returns>Diese Instanz von <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rückgabewert ist nicht über eine unabhängige Kopie dieser Instanz; Es ist einfach eine andere Ansicht derselben Daten. Verwenden der <xref:System.String.Copy%2A> oder <xref:System.String.CopyTo%2A> Methode zum Erstellen eines separaten <xref:System.String> Objekt mit dem gleichen Wert wie diese Instanz.  
  
 Da die <xref:System.String.Clone%2A> Methode gibt einfach die vorhandenen Zeichenfolgeninstanz zurück, ist es eigentlich nicht direkt aufgerufen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Copy(System.String)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Compare">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Vergleicht zwei angegebene <see cref="T:System.String" />-Objekte und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Überladungen der Methode <xref:System.String.Compare%2A> geben eine 32-Bit-Ganzzahl mit Vorzeichen zurück, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.  
  
|Wert|Bedingung|  
|-----------|---------------|  
|Kleiner als 0 (null)|Die erste Teilzeichenfolge steht die zweite Teilzeichenfolge in der Sortierreihenfolge vor.|  
|Zero|Die Teilzeichenfolgen treten in der Sortierreihenfolge an der gleichen Position auf, oder `length` ist 0 (null).|  
|Größer als 0 (null)|Die erste Teilzeichenfolge folgt die zweite Teilzeichenfolge in der Sortierreihenfolge an.|  
  
> [!WARNING]
>  Wann immer möglich, sollten Sie eine Überladung von Aufrufen der <xref:System.String.Compare%2A> Methode, enthält eine <xref:System.StringComparison> Parameter. Weitere Informationen finden Sie unter [Empfohlene Vorgehensweisen für die Verwendung von Zeichenfolgen in .NET Framework](~/docs/standard/base-types/best-practices-strings.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7">Empfohlene Vorgehensweisen für die Verwendung von Zeichenfolgen in .NET Framework</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string -&gt; int" Usage="System.string.Compare (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">Die erste zu vergleichende Zeichenfolge.</param>
        <param name="strB">Die zweite zu vergleichende Zeichenfolge.</param>
        <summary>Vergleicht zwei angegebene <see cref="T:System.String" />-Objekte und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.  
  
 <list type="table"><listheader><term> Wert 
 </term><description> Bedingung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description><paramref name="strA" /> steht in der Sortierreihenfolge vor <paramref name="strB" />.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="strA" /> tritt in der Sortierreihenfolge an der gleichen Position wie <paramref name="strB" /> auf.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description><paramref name="strA" /> steht in der Sortierreihenfolge hinter <paramref name="strB" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Vergleich verwendet die aktuelle Kultur zum Abrufen von kulturspezifischen Informationen wie z. B. Groß-/ Kleinschreibregeln und die alphabetische Reihenfolge der einzelnen Zeichen. Z. B. eine Kultur angeben, dass bestimmte Kombinationen von Zeichen als ein einzelnes Zeichen behandelt werden, oder auf eine bestimmte Weise Groß-und Kleinschreibung verglichen werden, oder, der die Sortierreihenfolge der ein Zeichen ist abhängig von der Zeichen, die vor oder Führen Sie es aus.  
  
 Der Vergleich erfolgt mithilfe von Word-Sortierregeln. Weitere Informationen über Wort-, Zeichenfolgen- und ordinal sortiert, finden Sie unter <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Beim Vergleichen von Zeichenfolgen, Sie sollten aufrufen, die <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> -Methode, die erfordert, dass Sie den Typ des Zeichenfolgenvergleichs explizit angeben, die die Methode verwendet. Weitere Informationen finden Sie unter [Empfohlene Vorgehensweisen für die Verwendung von Zeichenfolgen in .NET Framework](~/docs/standard/base-types/best-practices-strings.md).  
  
 Einer oder beiden Vergleichswerte möglich `null`. Definitionsgemäß eine beliebige Zeichenfolge, einschließlich die leere Zeichenfolge (""), verglichen, die größer als ein null-Verweis; und zwei null-Verweis gleich miteinander vergleichen.  
  
 Der Vergleich wird beendet, wenn eine Ungleichheit ermittelt wird, oder beide Zeichenfolgen verglichen wurden. Allerdings wird, wenn die beiden Zeichenfolgen gleich dem Ende einer Zeichenfolge vergleichen und die andere Zeichenfolge enthält Zeichen, die verbleibenden, klicken Sie dann die Zeichenfolge mit den verbleibenden Zeichen größer angesehen. Der Rückgabewert ist das Ergebnis der letzten Vergleich ausgeführt.  
  
 Beim Vergleichen von Kultur-, Groß-/Kleinschreibung Regeln betroffen sind, können unerwartete Ergebnisse auftreten. Gibt z. B. im türkischen im folgenden Beispiel wird die falsche Ergebnisse da Dateisystem im türkischen nicht linguistische Schreibweise Regeln für den Buchstaben "i" in "File".  
  
 [!code-cpp[System.String.Compare#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#10)]
 [!code-csharp[System.String.Compare#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#10)]
 [!code-vb[System.String.Compare#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#10)]  
  
 Vergleichen Sie den Pfadnamen in "File" verwenden einen Ordinalvergleich durch. Zu diesem Zweck der richtige Code lautet wie folgt aus:  
  
 [!code-cpp[System.String.Compare#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#11)]
 [!code-csharp[System.String.Compare#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#11)]
 [!code-vb[System.String.Compare#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#11)]  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.String.Compare%28System.String%2CSystem.String%29> Methode, um die drei Sätze von Zeichenfolgen zu vergleichen.  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 Im folgenden Beispiel die `ReverseStringComparer` Klasse veranschaulicht, wie Sie zwei Zeichenfolgen mit auswerten können die <xref:System.String.Compare%2A> Methode.  
  
 [!code-cpp[ArrayList#7](~/samples/snippets/cpp/VS_Snippets_CLR/ArrayList/CPP/ArrayListSample.cpp#7)]
 [!code-csharp[ArrayList#7](~/samples/snippets/csharp/VS_Snippets_CLR/ArrayList/CS/ArrayListSample.cs#7)]
 [!code-vb[ArrayList#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/ArrayList/VB/ArrayListSample.vb#7)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Zeichensätze enthalten ignorierbare Zeichen. Die <see cref="M:System.String.Compare(System.String,System.String)" /> Methode berücksichtigt keine solche Zeichen, wenn er einen kulturabhängigen Vergleich ausführt. Angenommen, der folgende Code ausgeführt wird, auf die [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder später ein kulturabhängigen Vergleich "Tier" mit "Ani-falsch" (mit einem bedingten Bindestrichs oder U + 00AD) gibt an, dass die beiden Zeichenfolgen entspricht.  
  
[! Code-Csharp[System.String.Compare#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare21.cs#21)] [! Code – Vb[System.String.Compare#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare21.vb#21)] 
Rufen Sie so, dass Ignorierbare Zeichen in einen Zeichenfolgenvergleich erkennen zu können, die <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> -Methode, und geben Sie entweder den Wert <see cref="F:System.Globalization.CompareOptions.Ordinal" /> oder <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> für die `comparisonType` Parameter.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="strA">Die erste zu vergleichende Zeichenfolge.</param>
        <param name="strB">Die zweite zu vergleichende Zeichenfolge.</param>
        <param name="ignoreCase"><see langword="true" />, wenn die Groß-/Kleinschreibung beim Vergleich ignoriert werden soll, andernfalls <see langword="false" />.</param>
        <summary>Vergleicht zwei angegebene <see cref="T:System.String" />-Objekte, wobei ihre Groß- und Kleinschreibung entweder ignoriert oder berücksichtigt wird, und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.  
  
 <list type="table"><listheader><term> Wert 
 </term><description> Bedingung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description><paramref name="strA" /> steht in der Sortierreihenfolge vor <paramref name="strB" />.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="strA" /> tritt in der Sortierreihenfolge an der gleichen Position wie <paramref name="strB" /> auf.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description><paramref name="strA" /> steht in der Sortierreihenfolge hinter <paramref name="strB" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Vergleich verwendet die aktuelle Kultur zum Abrufen von kulturspezifischen Informationen wie z. B. Groß-/ Kleinschreibregeln und die alphabetische Reihenfolge der einzelnen Zeichen. Z. B. eine Kultur angeben, dass bestimmte Kombinationen von Zeichen als ein einzelnes Zeichen behandelt werden, oder auf eine bestimmte Weise Groß-und Kleinschreibung verglichen werden, oder, der die Sortierreihenfolge der ein Zeichen ist abhängig von der Zeichen, die vor oder Führen Sie es aus.  
  
 Der Vergleich erfolgt mithilfe von Word-Sortierregeln. Weitere Informationen über Wort-, Zeichenfolgen- und ordinal sortiert, finden Sie unter <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Beim Vergleichen von Zeichenfolgen, Sie sollten aufrufen, die <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> -Methode, die erfordert, dass Sie den Typ des Zeichenfolgenvergleichs explizit angeben, die die Methode verwendet. Weitere Informationen finden Sie unter [Empfohlene Vorgehensweisen für die Verwendung von Zeichenfolgen in .NET Framework](~/docs/standard/base-types/best-practices-strings.md).  
  
 Einer oder beiden Vergleichswerte möglich `null`. Definitionsgemäß eine beliebige Zeichenfolge, einschließlich die leere Zeichenfolge (""), verglichen, die größer als ein null-Verweis; und zwei null-Verweis gleich miteinander vergleichen.  
  
 Der Vergleich wird beendet, wenn eine Ungleichheit ermittelt wird, oder beide Zeichenfolgen verglichen wurden. Allerdings wird, wenn die beiden Zeichenfolgen gleich dem Ende einer Zeichenfolge vergleichen und die andere Zeichenfolge enthält Zeichen, die verbleibenden, klicken Sie dann die Zeichenfolge mit den verbleibenden Zeichen größer angesehen. Der Rückgabewert ist das Ergebnis der letzten Vergleich ausgeführt.  
  
 Beim Vergleichen von Kultur-, Groß-/Kleinschreibung Regeln betroffen sind, können unerwartete Ergebnisse auftreten. Gibt z. B. im türkischen im folgenden Beispiel wird die falsche Ergebnisse da Dateisystem im türkischen nicht linguistische Schreibweise Regeln für den Buchstaben "i" in "File".  
  
 [!code-cpp[System.String.Compare#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#12)]
 [!code-csharp[System.String.Compare#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#12)]
 [!code-vb[System.String.Compare#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#12)]  
  
 Vergleichen Sie den Pfadnamen in "File" verwenden einen Ordinalvergleich durch. Zu diesem Zweck der richtige Code lautet wie folgt aus:  
  
 [!code-cpp[System.String.Compare#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#13)]
 [!code-csharp[System.String.Compare#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#13)]
 [!code-vb[System.String.Compare#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#13)]  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, dass die <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29> Methode ist äquivalent zur Verwendung <xref:System.String.ToUpper%2A> oder <xref:System.String.ToLower%2A> beim Vergleichen von Zeichenfolgen.  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Zeichensätze enthalten ignorierbare Zeichen. Die <see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" /> Methode berücksichtigt keine solche Zeichen, wenn er einen kulturabhängigen Vergleich ausführt. Angenommen, der folgende Code ausgeführt wird, auf die [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder später ein Vergleich Kultur, Unterscheidung nach Groß-/Kleinschreibung der "Tier" mit "Ani-falsch" (mit einem bedingten Bindestrichs oder U + 00AD) gibt an, dass die beiden Zeichenfolgen entspricht.  
  
[! Code-Csharp[System.String.Compare#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare22.cs#22)] [! Code – Vb[System.String.Compare#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare22.vb#22)] 
Rufen Sie so, dass Ignorierbare Zeichen in einen Zeichenfolgenvergleich erkennen zu können, die <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> -Methode, und geben Sie entweder den Wert <see cref="F:System.Globalization.CompareOptions.Ordinal" /> oder <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> für die <paramref name="comparisonType" /> Parameter.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * StringComparison -&gt; int" Usage="System.string.Compare (strA, strB, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="strA">Die erste zu vergleichende Zeichenfolge.</param>
        <param name="strB">Die zweite zu vergleichende Zeichenfolge.</param>
        <param name="comparisonType">Einer der Enumerationswerte, der die für den Vergleich zu verwendenden Regeln angibt.</param>
        <summary>Vergleicht zwei angegebene <see cref="T:System.String" />-Objekte gemäß den angegebenen Vergleichsregeln und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.  
  
 <list type="table"><listheader><term> Wert 
 </term><description> Bedingung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description><paramref name="strA" /> steht in der Sortierreihenfolge vor <paramref name="strB" />.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="strA" /> befindet sich in der Sortierreihenfolge an der gleichen Position wie <paramref name="strB" />.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description><paramref name="strA" /> steht in der Sortierreihenfolge hinter <paramref name="strB" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `comparisonType` Parameter gibt an, ob der Vergleich die aktuelle oder der invariante Kultur verwenden soll, berücksichtigen oder ignorieren die Groß-/Kleinschreibung der verglichenen Elemente angibt, oder verwenden (kulturabhängige) oder ordinalen (kulturunabhängigen) Sortierregeln.  
  
 Einer oder beiden Vergleichswerte möglich `null`. Definitionsgemäß eine beliebige Zeichenfolge, einschließlich die leere Zeichenfolge (""), verglichen, die größer als ein null-Verweis; und zwei null-Verweis gleich miteinander vergleichen.  
  
 Der Vergleich wird beendet, wenn eine Ungleichheit ermittelt wird, oder beide Zeichenfolgen verglichen wurden. Allerdings wird, wenn die beiden Zeichenfolgen gleich dem Ende einer Zeichenfolge vergleichen und die andere Zeichenfolge über die verbleibenden Zeichen, die Zeichenfolge mit den verbleibenden Zeichen größer angesehen. Der Rückgabewert ist das Ergebnis der letzten Vergleich ausgeführt.  
  
 Beim Vergleichen von Kultur-, Groß-/Kleinschreibung Regeln betroffen sind, können unerwartete Ergebnisse auftreten. Gibt z. B. im türkischen im folgenden Beispiel wird die falsche Ergebnisse da Dateisystem im türkischen nicht linguistische Schreibweise Regeln für den Buchstaben "i" in "File".  
  
 [!code-cpp[System.String.Compare#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#16)]
 [!code-csharp[System.String.Compare#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#16)]
 [!code-vb[System.String.Compare#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#16)]  
  
 Vergleichen Sie den Pfadnamen in "File" verwenden einen Ordinalvergleich durch. Zu diesem Zweck der richtige Code lautet wie folgt aus:  
  
 [!code-cpp[System.String.Compare#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#17)]
 [!code-csharp[System.String.Compare#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#17)]
 [!code-vb[System.String.Compare#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#17)]  
  
   
  
## Examples  
 Im folgenden Beispiel werden drei Versionen von den Buchstaben "I". Die Ergebnisse sind betroffen, durch die Auswahl der Kultur, ob die Groß-/Kleinschreibung ignoriert wird und gibt an, ob ein ordinaler Vergleich ausgeführt wird.  
  
 [!code-cpp[System.String.CompareCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.CompareCmp/cpp/cmpcmp.cpp#1)]
 [!code-csharp[System.String.CompareCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.CompareCmp/cs/cmpcmp.cs#1)]
 [!code-vb[System.String.CompareCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.CompareCmp/vb/cmpcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> ist kein <see cref="T:System.StringComparison" />-Wert.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.StringComparison" /> wird nicht unterstützt.</exception>
        <block subset="none" type="usage"><para>Zeichensätze enthalten ignorierbare Zeichen. Die <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> Methode berücksichtigt keine solche Zeichen, wenn er einen kulturabhängigen Vergleich ausführt. Geben Sie den Wert so, dass um Ignorierbare Zeichen in den Vergleich zu erkennen, <see cref="F:System.StringComparison.Ordinal" /> oder <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> für die <paramref name="comparisonType" /> Parameter.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="strA">Die erste zu vergleichende Zeichenfolge.</param>
        <param name="strB">Die zweite zu vergleichende Zeichenfolge.</param>
        <param name="ignoreCase"><see langword="true" />, wenn die Groß-/Kleinschreibung beim Vergleich ignoriert werden soll, andernfalls <see langword="false" />.</param>
        <param name="culture">Ein Objekt, das kulturspezifische Vergleichsinformationen angibt.</param>
        <summary>Vergleicht zwei angegebene <see cref="T:System.String" />-Objekte, wobei ihre Groß- und Kleinschreibung entweder ignoriert oder berücksichtigt und der Vergleich durch kulturspezifische Informationen beeinflusst wird, und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.  
  
 <list type="table"><listheader><term> Wert 
 </term><description> Bedingung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description><paramref name="strA" /> steht in der Sortierreihenfolge vor <paramref name="strB" />.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="strA" /> tritt in der Sortierreihenfolge an der gleichen Position wie <paramref name="strB" /> auf.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description><paramref name="strA" /> steht in der Sortierreihenfolge hinter <paramref name="strB" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Vergleich wird die `culture` Parameter zum Abrufen von kulturspezifischen Informationen wie z. B. Groß-/ Kleinschreibregeln und die alphabetische Reihenfolge der einzelnen Zeichen. Z. B. eine Kultur angeben, dass bestimmte Kombinationen von Zeichen als ein einzelnes Zeichen behandelt werden, oder auf eine bestimmte Weise Groß-und Kleinschreibung verglichen werden, oder, der die Sortierreihenfolge der ein Zeichen ist abhängig von der Zeichen, die vor oder Führen Sie es aus.  
  
 Der Vergleich erfolgt mithilfe von Word-Sortierregeln. Weitere Informationen über Wort-, Zeichenfolgen- und ordinal sortiert, finden Sie unter <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Einer oder beiden Vergleichswerte möglich `null`. Definitionsgemäß eine beliebige Zeichenfolge, einschließlich die leere Zeichenfolge (""), verglichen, die größer als ein null-Verweis; und zwei null-Verweis gleich miteinander vergleichen.  
  
 Der Vergleich wird beendet, wenn eine Ungleichheit ermittelt wird, oder beide Zeichenfolgen verglichen wurden. Allerdings wird, wenn die beiden Zeichenfolgen gleich dem Ende einer Zeichenfolge vergleichen und die andere Zeichenfolge enthält Zeichen, die verbleibenden, klicken Sie dann die Zeichenfolge mit den verbleibenden Zeichen größer angesehen. Der Rückgabewert ist das Ergebnis der letzten Vergleich ausgeführt.  
  
 Beim Vergleichen von Kultur-, Groß-/Kleinschreibung Regeln betroffen sind, können unerwartete Ergebnisse auftreten. Gibt z. B. im türkischen im folgenden Beispiel wird die falsche Ergebnisse da Dateisystem im türkischen nicht linguistische Schreibweise Regeln für den Buchstaben "i" in "File".  
  
 [!code-cpp[System.String.Compare#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#14)]
 [!code-csharp[System.String.Compare#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#14)]
 [!code-vb[System.String.Compare#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#14)]  
  
 Vergleichen Sie den Pfadnamen in "File" verwenden einen Ordinalvergleich durch. Zu diesem Zweck der richtige Code lautet wie folgt aus:  
  
 [!code-cpp[System.String.Compare#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#15)]
 [!code-csharp[System.String.Compare#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#15)]
 [!code-vb[System.String.Compare#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#15)]  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie die Kultur ein Vergleichs auswirken kann. Tschechisch - Kultur der Tschechischen Republik, ist "ch" für ein einzelnes Zeichen, das größer als "d" ist. Jedoch in Englisch - USA Kultur "ch" besteht aus zwei Zeichen, und "c" ist kleiner als "d".  
  
 [!code-cpp[string.comp4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.comp4/CPP/string.comp4.cpp#1)]
 [!code-csharp[string.comp4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.comp4/CS/string.comp4.cs#1)]
 [!code-vb[string.comp4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.comp4/VB/string.comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> ist <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Zeichensätze enthalten ignorierbare Zeichen. Die <see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" /> Methode berücksichtigt keine solche Zeichen, wenn er einen kulturabhängigen Vergleich ausführt. Z. B., wenn der folgende Code ausgeführt wird, auf die [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher, ein Groß-/Kleinschreibung Vergleich "Tier" mit "Ani-falsch" (mit einem bedingten Bindestrichs oder U + 00AD) die invariante Kultur angibt, dass die zwei Zeichenfolgen identisch sind.  
  
[! Code-Csharp[System.String.Compare#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare23.cs#23)] [! Code – Vb[System.String.Compare#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare23.vb#23)] 
Rufen Sie so, dass Ignorierbare Zeichen in einen Zeichenfolgenvergleich erkennen zu können, die <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> -Methode, und geben Sie entweder den Wert <see cref="F:System.Globalization.CompareOptions.Ordinal" /> oder <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> für die <paramref name="options" /> Parameter.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, strB, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="strA">Die erste zu vergleichende Zeichenfolge.</param>
        <param name="strB">Die zweite zu vergleichende Zeichenfolge.</param>
        <param name="culture">Die Kultur, die kulturspezifische Vergleichsinformationen liefert.</param>
        <param name="options">Die beim Ausführen des Vergleichs zu verwendenden Optionen (z. B. Ignorieren von Groß- und Kleinschreibung oder Symbolen).</param>
        <summary>Vergleicht zwei angegebene <see cref="T:System.String" />-Objekte mit den festgelegten Vergleichsoptionen und kulturspezifischen Informationen, die den Vergleich beeinflussen, und gibt eine ganze Zahl zurück, die die Beziehung der beiden Zeichenfolgen zueinander in der Sortierreihenfolge angibt.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung zwischen <paramref name="strA" /> und <paramref name="strB" /> angibt, wie in der folgenden Tabelle veranschaulicht wird. 
 <list type="table"><listheader><term> Wert 
 </term><description> Bedingung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description><paramref name="strA" /> steht in der Sortierreihenfolge vor <paramref name="strB" />.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="strA" /> tritt in der Sortierreihenfolge an der gleichen Position wie <paramref name="strB" /> auf.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description><paramref name="strA" /> steht in der Sortierreihenfolge hinter <paramref name="strB" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Vergleich wird die `culture` Parameter zum Abrufen von kulturspezifischen Informationen, z. B. Groß-/ Kleinschreibregeln und die alphabetische Reihenfolge der einzelnen Zeichen. Z. B. eine bestimmte Kultur angeben, dass bestimmte Kombinationen von Zeichen als ein einzelnes Zeichen behandelt werden, auf eine bestimmte Weise Groß-und Kleinschreibung verglichen werden soll, oder, der die Sortierreihenfolge der ein Zeichen ist abhängig von der Zeichen, vorausgehen und folgen.  
  
> [!CAUTION]
>  Die <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> Methode dient in erster Linie zur Verwendung in sortiert oder alphabetisch sortiert Vorgänge. Es sollte nicht verwendet werden, wenn der primäre Zweck des Methodenaufrufs ist, um festzustellen, ob zwei Zeichenfolgen identisch sind (d. h. wenn der Zweck des Methodenaufrufs für einen Rückgabewert von 0 (null) testen). Um zu bestimmen, ob zwei Zeichenfolgen identisch sind, rufen Sie die <xref:System.String.Equals%2A> Methode.  
  
 Der Vergleich kann weiter angegeben werden, werden die `options` -Parameter, der eine oder mehrere Member besteht aus den <xref:System.Globalization.CompareOptions> Enumeration. Jedoch, da der Zweck dieser Methode wird einen kulturabhängige Zeichenfolgenvergleich, Durchführen der <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> und <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> Werte haben keine Auswirkungen.  
  
 Einer oder beiden Vergleichswerte möglich `null`. Definitionsgemäß eine beliebige Zeichenfolge, einschließlich <xref:System.String.Empty?displayProperty=nameWithType>, Vergleich größer als ein null-Verweis, und zwei null-Verweise sind gleich.  
  
 Der Vergleich wird beendet, wenn eine Ungleichheit ermittelt wird, oder beide Zeichenfolgen verglichen wurden. Allerdings wird, wenn die beiden Zeichenfolgen gleich dem Ende einer Zeichenfolge vergleichen und die andere Zeichenfolge über die verbleibenden Zeichen, die Zeichenfolge mit den verbleibenden Zeichen größer angesehen.  
  
   
  
## Examples  
 Das folgende Beispiel vergleicht zwei Zeichenfolgen auf drei verschiedene Arten: Verwenden von linguistischen Vergleich für die Kultur En-US Verwenden von linguistischen Vergleich von Groß-/Kleinschreibung für die Kultur En-US; und verwenden einen Ordinalvergleich durch. Es wird veranschaulicht, wie die drei Methoden der Vergleich für drei unterschiedliche Ergebnisse liefern.  
  
 [!code-cpp[System.String.Compare#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/example.cpp#1)]
 [!code-csharp[System.String.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/Example.cs#1)]
 [!code-vb[System.String.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> ist kein <see cref="T:System.Globalization.CompareOptions" />-Wert.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> ist <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Die <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> Methode berücksichtigt keine solche Zeichen, wenn er einen kulturabhängigen Vergleich ausführt. Geben Sie den Wert so, dass um Ignorierbare Zeichen in den Vergleich zu erkennen, <see cref="F:System.Globalization.CompareOptions.Ordinal" /> oder <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> für die <paramref name="options" /> Parameter.</para></block>
        <altmember cref="Overload:System.String.CompareOrdinal" />
        <altmember cref="Overload:System.String.CompareTo" />
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">Die erste im Vergleich zu verwendende Zeichenfolge.</param>
        <param name="indexA">Die Position der Teilzeichenfolge innerhalb von <paramref name="strA" />.</param>
        <param name="strB">Die zweite im Vergleich zu verwendende Zeichenfolge.</param>
        <param name="indexB">Die Position der Teilzeichenfolge innerhalb von <paramref name="strB" />.</param>
        <param name="length">Die maximale Anzahl der zu vergleichenden Zeichen der Teilzeichenfolgen.</param>
        <summary>Vergleicht zwei angegebene <see cref="T:System.String" />-Objekte und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.  
  
 <list type="table"><listheader><term> Wert 
 </term><description> Bedingung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description> Die Teilzeichenfolge in <paramref name="strA" /> ist der Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge vorangestellt.  
  
 </description></item><item><term> Zero 
 </term><description> Die Teilzeichenfolgen treten in der Sortierreihenfolge an der gleichen Position auf, oder <paramref name="length" /> ist 0 (null).  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description> Die Teilzeichenfolge in <paramref name="strA" /> folgt der Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Starten Sie die zu vergleichenden Teilzeichenfolgen im `strA` am `indexA` und `strB` am `indexB`. Beide `indexA` und `indexB` sind nullbasiert, d. h. das erste Zeichen in `strA` und `strB` an Position 0 (null) ist. Die Länge der ersten Teilzeichenfolge ist gleich der Länge der `strA` minus `indexA` plus eins. Die Länge der zweiten Teilzeichenfolge ist gleich der Länge der `strB` minus `indexB` plus eins.  
  
 Die Anzahl der zu vergleichenden Zeichen ist kleiner als die Länge der beiden Teilzeichenfolgen und `length`. Die `indexA`, `indexB`, und `length` Parameter dürfen nicht negativ sein.  
  
 Der Vergleich verwendet die aktuelle Kultur zum Abrufen von kulturspezifischen Informationen wie z. B. Groß-/ Kleinschreibregeln und die alphabetische Reihenfolge der einzelnen Zeichen. Z. B. eine Kultur angeben, dass bestimmte Kombinationen von Zeichen als ein einzelnes Zeichen behandelt werden, oder auf eine bestimmte Weise Groß-und Kleinschreibung verglichen werden, oder, der die Sortierreihenfolge der ein Zeichen ist abhängig von der Zeichen, die vor oder Führen Sie es aus.  
  
 Der Vergleich erfolgt mithilfe von Word-Sortierregeln. Weitere Informationen über Wort-, Zeichenfolgen- und ordinal sortiert, finden Sie unter <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Beim Vergleichen von Zeichenfolgen, Sie sollten aufrufen, die <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> -Methode, die erfordert, dass Sie den Typ des Zeichenfolgenvergleichs explizit angeben, die die Methode verwendet. Weitere Informationen finden Sie unter [Empfohlene Vorgehensweisen für die Verwendung von Zeichenfolgen in .NET Framework](~/docs/standard/base-types/best-practices-strings.md).  
  
 Einer oder beiden Vergleichswerte möglich `null`. Definitionsgemäß eine beliebige Zeichenfolge, einschließlich die leere Zeichenfolge (""), verglichen, die größer als ein null-Verweis; und zwei null-Verweis gleich miteinander vergleichen.  
  
 Der Vergleich wird beendet, wenn Ungleichheit ermittelt wird, oder beide Teilzeichenfolgen verglichen wurden. Allerdings wird, wenn die beiden Zeichenfolgen gleich dem Ende einer Zeichenfolge vergleichen und die andere Zeichenfolge enthält Zeichen, die verbleibenden, klicken Sie dann die Zeichenfolge mit den verbleibenden Zeichen größer angesehen. Der Rückgabewert ist das Ergebnis der letzten Vergleich ausgeführt.  
  
 Beim Vergleichen von Kultur-, Groß-/Kleinschreibung Regeln betroffen sind, können unerwartete Ergebnisse auftreten. Gibt z. B. im türkischen im folgenden Beispiel wird die falsche Ergebnisse da Dateisystem im türkischen nicht linguistische Schreibweise Regeln für den Buchstaben "i" in "File".  
  
 [!code-cpp[System.String.Compare#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#2)]
 [!code-csharp[System.String.Compare#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#2)]
 [!code-vb[System.String.Compare#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#2)]  
  
 Vergleichen Sie den Pfadnamen in "File" verwenden einen Ordinalvergleich durch. Zu diesem Zweck der richtige Code lautet wie folgt aus:  
  
 [!code-cpp[System.String.Compare#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#3)]
 [!code-csharp[System.String.Compare#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#3)]
 [!code-vb[System.String.Compare#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#3)]  
  
   
  
## Examples  
 Im folgende Beispiel werden zwei Teilzeichenfolgen verglichen.  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> ist größer als <paramref name="strA" /><see cref="P:System.String.Length" />.  
  
- oder -  
 <paramref name="indexB" /> ist größer als <paramref name="strB" /><see cref="P:System.String.Length" />.  
  
- oder -  
 <paramref name="indexA" />, <paramref name="indexB" /> oder <paramref name="length" /> ist ein negativer Wert.  
  
- oder -  
Entweder <paramref name="indexA" /> oder <paramref name="indexB" /> ist <see langword="null" />, und <paramref name="length" /> ist größer als 0 (null).</exception>
        <block subset="none" type="usage"><para>Zeichensätze enthalten ignorierbare Zeichen. Die <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /> Methode berücksichtigt nicht diese Zeichen aus, wenn er einen linguistischen oder kulturabhängigen Vergleich ausführt. Rufen Sie so, dass um Ignorierbare Zeichen in den Vergleich zu erkennen, die <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> Methode, und geben Sie den Wert <see cref="F:System.Globalization.CompareOptions.Ordinal" /> oder <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> für die <paramref name="comparisonType" /> Parameter.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="strA">Die erste im Vergleich zu verwendende Zeichenfolge.</param>
        <param name="indexA">Die Position der Teilzeichenfolge innerhalb von <paramref name="strA" />.</param>
        <param name="strB">Die zweite im Vergleich zu verwendende Zeichenfolge.</param>
        <param name="indexB">Die Position der Teilzeichenfolge innerhalb von <paramref name="strB" />.</param>
        <param name="length">Die maximale Anzahl der zu vergleichenden Zeichen der Teilzeichenfolgen.</param>
        <param name="ignoreCase"><see langword="true" />, wenn die Groß-/Kleinschreibung beim Vergleich ignoriert werden soll, andernfalls <see langword="false" />.</param>
        <summary>Vergleicht Teilzeichenfolgen von zwei angegebenen <see cref="T:System.String" />-Objekten, wobei ihre Groß- und Kleinschreibung entweder ignoriert oder berücksichtigt wird, und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.  
  
 <list type="table"><listheader><term> Wert 
 </term><description> Bedingung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description> Die Teilzeichenfolge in <paramref name="strA" /> ist der Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge vorangestellt.  
  
 </description></item><item><term> Zero 
 </term><description> Die Teilzeichenfolgen treten in der Sortierreihenfolge an der gleichen Position auf, oder <paramref name="length" /> ist 0 (null).  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description> Die Teilzeichenfolge in <paramref name="strA" /> folgt der Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Starten Sie die zu vergleichenden Teilzeichenfolgen im `strA` am `indexA`, und klicken Sie in `strB` am `indexB`. Beide `indexA` und `indexB` sind nullbasiert, d. h. das erste Zeichen in `strA` und `strB` an Position 0 (null) ist. Die Länge der ersten Teilzeichenfolge ist gleich der Länge der `strA` minus `indexA` plus eins. Die Länge der zweiten Teilzeichenfolge ist gleich der Länge der `strB` minus `indexB` plus eins.  
  
 Die Anzahl der zu vergleichenden Zeichen ist kleiner als die Länge der beiden Teilzeichenfolgen und `length`. Die `indexA`, `indexB`, und `length` Parameter dürfen nicht negativ sein.  
  
 Der Vergleich verwendet die aktuelle Kultur zum Abrufen von kulturspezifischen Informationen wie z. B. Groß-/ Kleinschreibregeln und die alphabetische Reihenfolge der einzelnen Zeichen. Z. B. eine Kultur angeben, dass bestimmte Kombinationen von Zeichen als ein einzelnes Zeichen behandelt werden, oder auf eine bestimmte Weise Groß-und Kleinschreibung verglichen werden, oder, der die Sortierreihenfolge der ein Zeichen ist abhängig von der Zeichen, die vor oder Führen Sie es aus.  
  
 Der Vergleich erfolgt mithilfe von Word-Sortierregeln. Weitere Informationen über Wort-, Zeichenfolgen- und ordinal sortiert, finden Sie unter <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Beim Vergleichen von Zeichenfolgen, Sie sollten aufrufen, die <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> -Methode, die erfordert, dass Sie den Typ des Zeichenfolgenvergleichs explizit angeben, die die Methode verwendet. Weitere Informationen finden Sie unter [Empfohlene Vorgehensweisen für die Verwendung von Zeichenfolgen in .NET Framework](~/docs/standard/base-types/best-practices-strings.md).  
  
 Einer oder beiden Vergleichswerte möglich `null`. Definitionsgemäß eine beliebige Zeichenfolge, einschließlich die leere Zeichenfolge (""), verglichen, die größer als ein null-Verweis; und zwei null-Verweis gleich miteinander vergleichen.  
  
 Der Vergleich wird beendet, wenn Ungleichheit ermittelt wird, oder beide Teilzeichenfolgen verglichen wurden. Allerdings wird, wenn die beiden Zeichenfolgen gleich dem Ende einer Zeichenfolge vergleichen und die andere Zeichenfolge enthält Zeichen, die verbleibenden, klicken Sie dann die Zeichenfolge mit den verbleibenden Zeichen größer angesehen. Der Rückgabewert ist das Ergebnis der letzten Vergleich ausgeführt.  
  
 Beim Vergleichen von Kultur-, Groß-/Kleinschreibung Regeln betroffen sind, können unerwartete Ergebnisse auftreten. Gibt z. B. im türkischen im folgenden Beispiel wird die falsche Ergebnisse da Dateisystem im türkischen nicht linguistische Schreibweise Regeln für den Buchstaben "i" in "File".  
  
 [!code-cpp[System.String.Compare#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#4)]
 [!code-csharp[System.String.Compare#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#4)]
 [!code-vb[System.String.Compare#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#4)]  
  
 Der Pfadname muss in einer invariante Weise verglichen werden soll. Zu diesem Zweck der richtige Code lautet wie folgt aus.  
  
 [!code-cpp[System.String.Compare#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#5)]
 [!code-csharp[System.String.Compare#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#5)]
 [!code-vb[System.String.Compare#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#5)]  
  
   
  
## Examples  
 Im folgende Beispiel führt zwei Vergleiche der beiden Teilzeichenfolgen, die unterscheiden sich nur bei. Der erste Vergleich ignoriert die Groß-/Kleinschreibung, und die zweite Vergleich berücksichtigt.  
  
 [!code-cpp[string.compare4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare4/CPP/comp4.cpp#1)]
 [!code-csharp[string.compare4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare4/CS/comp4.cs#1)]
 [!code-vb[string.compare4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare4/VB/comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> ist größer als <paramref name="strA" /><see cref="P:System.String.Length" />.  
  
- oder -  
 <paramref name="indexB" /> ist größer als <paramref name="strB" /><see cref="P:System.String.Length" />.  
  
- oder -  
 <paramref name="indexA" />, <paramref name="indexB" /> oder <paramref name="length" /> ist ein negativer Wert.  
  
- oder -  
Entweder <paramref name="indexA" /> oder <paramref name="indexB" /> ist <see langword="null" />, und <paramref name="length" /> ist größer als 0 (null).</exception>
        <block subset="none" type="usage"><para>Zeichensätze enthalten ignorierbare Zeichen. Die <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /> Methode berücksichtigt nicht diese Zeichen aus, wenn er einen linguistischen oder kulturabhängigen Vergleich ausführt. Rufen Sie so, dass um Ignorierbare Zeichen in den Vergleich zu erkennen, die <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> Methode, und geben Sie den Wert <see cref="F:System.Globalization.CompareOptions.Ordinal" /> oder <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> für die <paramref name="comparisonType" /> Parameter.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * StringComparison -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="strA">Die erste im Vergleich zu verwendende Zeichenfolge.</param>
        <param name="indexA">Die Position der Teilzeichenfolge innerhalb von <paramref name="strA" />.</param>
        <param name="strB">Die zweite im Vergleich zu verwendende Zeichenfolge.</param>
        <param name="indexB">Die Position der Teilzeichenfolge innerhalb von <paramref name="strB" />.</param>
        <param name="length">Die maximale Anzahl der zu vergleichenden Zeichen der Teilzeichenfolgen.</param>
        <param name="comparisonType">Einer der Enumerationswerte, der die für den Vergleich zu verwendenden Regeln angibt.</param>
        <summary>Vergleicht Teilzeichenfolgen von zwei angegebenen <see cref="T:System.String" />-Objekten gemäß den angegebenen Vergleichsregeln und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.  
  
 <list type="table"><listheader><term> Wert 
 </term><description> Bedingung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description> Die Teilzeichenfolge in <paramref name="strA" /> ist der Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge vorangestellt.  
  
 </description></item><item><term> Zero 
 </term><description> Die Teilzeichenfolgen treten in der Sortierreihenfolge an der gleichen Position auf, oder der <paramref name="length" />-Parameter ist 0 (null).  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description> Die Teilzeichenfolge in <paramref name="strA" /> folgt der Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Starten Sie die zu vergleichenden Teilzeichenfolgen im `strA` am `indexA` und `strB` am `indexB`. Beide `indexA` und `indexB` sind nullbasiert, d. h. das erste Zeichen in `strA` und `strB` an position 0 (null) ist, nicht an der position einer. Die Länge der ersten Teilzeichenfolge ist gleich der Länge der `strA` minus `indexA` plus eins. Die Länge der zweiten Teilzeichenfolge ist gleich der Länge der `strB` minus `indexB` plus eins.  
  
 Die Anzahl der zu vergleichenden Zeichen ist kleiner als die Länge der beiden Teilzeichenfolgen und `length`. Die `indexA`, `indexB`, und `length` Parameter dürfen nicht negativ sein.  
  
 Die `comparisonType` Parameter gibt an, ob der Vergleich die aktuelle oder der invariante Kultur verwenden soll, berücksichtigen oder ignorieren die Groß-/Kleinschreibung der verglichenen Elemente angibt, oder verwenden (kulturabhängige) oder ordinalen (kulturunabhängigen) Sortierregeln.  
  
 Einer oder beiden Vergleichswerte möglich `null`. Definitionsgemäß eine beliebige Zeichenfolge, einschließlich die leere Zeichenfolge (""), verglichen, die größer als ein null-Verweis; und zwei null-Verweis gleich miteinander vergleichen.  
  
 Der Vergleich wird beendet, wenn Ungleichheit ermittelt wird, oder beide Teilzeichenfolgen verglichen wurden. Allerdings wird, wenn die beiden Zeichenfolgen gleich dem Ende einer Zeichenfolge vergleichen und die andere Zeichenfolge über die verbleibenden Zeichen, die Zeichenfolge mit den verbleibenden Zeichen größer angesehen. Der Rückgabewert ist das Ergebnis der letzten Vergleich ausgeführt.  
  
 Beim Vergleichen von Kultur-, Groß-/Kleinschreibung Regeln betroffen sind, können unerwartete Ergebnisse auftreten. Gibt z. B. im türkischen im folgenden Beispiel wird die falsche Ergebnisse da Dateisystem im türkischen nicht linguistische Schreibweise Regeln für den Buchstaben "i" in "File".  
  
 [!code-cpp[System.String.Compare#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#8)]
 [!code-csharp[System.String.Compare#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#8)]
 [!code-vb[System.String.Compare#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#8)]  
  
 Vergleichen Sie den Pfadnamen in "File" verwenden einen Ordinalvergleich durch. Zu diesem Zweck der richtige Code lautet wie folgt aus:  
  
 [!code-cpp[System.String.Compare#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#9)]
 [!code-csharp[System.String.Compare#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#9)]
 [!code-vb[System.String.Compare#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#9)]  
  
   
  
## Examples  
 Im folgende Beispiel werden zwei Teilzeichenfolgen verglichen.  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> ist größer als <paramref name="strA" /><see cref="P:System.String.Length" />.  
  
- oder -  
 <paramref name="indexB" /> ist größer als <paramref name="strB" /><see cref="P:System.String.Length" />.  
  
- oder -  
 <paramref name="indexA" />, <paramref name="indexB" /> oder <paramref name="length" /> ist ein negativer Wert.  
  
- oder -  
Entweder <paramref name="indexA" /> oder <paramref name="indexB" /> ist <see langword="null" />, und <paramref name="length" /> ist größer als 0 (null).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> ist kein <see cref="T:System.StringComparison" />-Wert.</exception>
        <block subset="none" type="usage"><para>Zeichensätze enthalten ignorierbare Zeichen. Die <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> Methode berücksichtigt nicht diese Zeichen aus, wenn er einen linguistischen oder kulturabhängigen Vergleich ausführt. Geben Sie den Wert so, dass um Ignorierbare Zeichen in den Vergleich zu erkennen, <see cref="F:System.StringComparison.Ordinal" /> oder <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> für die <paramref name="comparisonType" /> Parameter.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="strA">Die erste im Vergleich zu verwendende Zeichenfolge.</param>
        <param name="indexA">Die Position der Teilzeichenfolge innerhalb von <paramref name="strA" />.</param>
        <param name="strB">Die zweite im Vergleich zu verwendende Zeichenfolge.</param>
        <param name="indexB">Die Position der Teilzeichenfolge innerhalb von <paramref name="strB" />.</param>
        <param name="length">Die maximale Anzahl der zu vergleichenden Zeichen der Teilzeichenfolgen.</param>
        <param name="ignoreCase"><see langword="true" />, wenn die Groß-/Kleinschreibung beim Vergleich ignoriert werden soll, andernfalls <see langword="false" />.</param>
        <param name="culture">Ein Objekt, das kulturspezifische Vergleichsinformationen angibt.</param>
        <summary>Vergleicht Teilzeichenfolgen von zwei angegebenen <see cref="T:System.String" />-Objekten, wobei ihre Groß- und Kleinschreibung entweder ignoriert oder berücksichtigt und der Vergleich durch kulturspezifische Informationen beeinflusst wird, und gibt eine ganze Zahl zurück, die ihre relative Position in der Sortierreihenfolge angibt.</summary>
        <returns>Eine ganze Zahl, die die lexikalische Beziehung zwischen den beiden Vergleichswerten angibt.  
  
 <list type="table"><listheader><term> Wert 
 </term><description> Bedingung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description> Die Teilzeichenfolge in <paramref name="strA" /> ist der Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge vorangestellt.  
  
 </description></item><item><term> Zero 
 </term><description> Die Teilzeichenfolgen treten in der Sortierreihenfolge an der gleichen Position auf, oder <paramref name="length" /> ist 0 (null).  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description> Die Teilzeichenfolge in <paramref name="strA" /> folgt der Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Starten Sie die zu vergleichenden Teilzeichenfolgen im `strA` am `indexA`, und klicken Sie in `strB` am `indexB`. Beide `indexA` und `indexB` sind nullbasiert, d. h. das erste Zeichen in `strA` und `strB` an position 0 (null) ist, nicht an der position einer. Die Länge der ersten Teilzeichenfolge ist gleich der Länge der `strA` minus `indexA` plus eins. Die Länge der zweiten Teilzeichenfolge ist gleich der Länge der `strB` minus `indexB` plus eins.  
  
 Die Anzahl der zu vergleichenden Zeichen ist kleiner als die Länge der beiden Teilzeichenfolgen und `length`. Die `indexA`, `indexB`, und `length` Parameter dürfen nicht negativ sein.  
  
 Der Vergleich wird die `culture` Parameter zum Abrufen von kulturspezifischen Informationen wie z. B. Groß-/ Kleinschreibregeln und die alphabetische Reihenfolge der einzelnen Zeichen. Z. B. eine Kultur angeben, dass bestimmte Kombinationen von Zeichen als ein einzelnes Zeichen behandelt werden, oder auf eine bestimmte Weise Groß-und Kleinschreibung verglichen werden, oder, der die Sortierreihenfolge der ein Zeichen ist abhängig von der Zeichen, die vor oder Führen Sie es aus.  
  
 Der Vergleich erfolgt mithilfe von Word-Sortierregeln. Weitere Informationen über Wort-, Zeichenfolgen- und ordinal sortiert, finden Sie unter <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Einer oder beiden Vergleichswerte möglich `null`. Definitionsgemäß eine beliebige Zeichenfolge, einschließlich die leere Zeichenfolge (""), verglichen, die größer als ein null-Verweis; und zwei null-Verweis gleich miteinander vergleichen.  
  
 Der Vergleich wird beendet, wenn Ungleichheit ermittelt wird, oder beide Teilzeichenfolgen verglichen wurden. Allerdings wird, wenn die beiden Zeichenfolgen gleich dem Ende einer Zeichenfolge vergleichen und die andere Zeichenfolge enthält Zeichen, die verbleibenden, klicken Sie dann die Zeichenfolge mit den verbleibenden Zeichen größer angesehen. Der Rückgabewert ist das Ergebnis der letzten Vergleich ausgeführt.  
  
 Beim Vergleichen von Kultur-, Groß-/Kleinschreibung Regeln betroffen sind, können unerwartete Ergebnisse auftreten. Gibt z. B. im türkischen im folgenden Beispiel wird die falsche Ergebnisse da Dateisystem im türkischen nicht linguistische Schreibweise Regeln für den Buchstaben "i" in "File".  
  
 [!code-cpp[System.String.Compare#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#6)]
 [!code-csharp[System.String.Compare#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#6)]
 [!code-vb[System.String.Compare#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#6)]  
  
 Vergleichen Sie den Pfadnamen in "File" verwenden einen Ordinalvergleich durch. Zu diesem Zweck der richtige Code lautet wie folgt aus:  
  
 [!code-cpp[System.String.Compare#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#7)]
 [!code-csharp[System.String.Compare#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#7)]
 [!code-vb[System.String.Compare#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#7)]  
  
   
  
## Examples  
 Das folgende Beispiel vergleicht zwei Verwendung unterschiedlicher Kulturen und ignorieren die Groß-/Kleinschreibung der Teilzeichenfolgen. Die bevorzugte Kultur wirkt sich auf, wie der Buchstabe "I" ist im Vergleich.  
  
 [!code-cpp[string.compare5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare5/CPP/comp5.cpp#1)]
 [!code-csharp[string.compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare5/CS/comp5.cs#1)]
 [!code-vb[string.compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare5/VB/comp5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> ist größer als <paramref name="strA" /><see cref="P:System.String.Length" />.  
  
- oder -  
 <paramref name="indexB" /> ist größer als <paramref name="strB" /><see cref="P:System.String.Length" />.  
  
- oder -  
 <paramref name="indexA" />, <paramref name="indexB" /> oder <paramref name="length" /> ist ein negativer Wert.  
  
- oder -  
Entweder <paramref name="strA" /> oder <paramref name="strB" /> ist <see langword="null" />, und <paramref name="length" /> ist größer als 0 (null).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> ist <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Zeichensätze enthalten ignorierbare Zeichen. Die <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /> Methode berücksichtigt nicht diese Zeichen aus, wenn er einen linguistischen oder kulturabhängigen Vergleich ausführt. Rufen Sie so, dass um Ignorierbare Zeichen in den Vergleich zu erkennen, die <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> Methode, und geben Sie den Wert <see cref="F:System.Globalization.CompareOptions.Ordinal" /> oder <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> für die <paramref name="options" /> Parameter.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="strA">Die erste im Vergleich zu verwendende Zeichenfolge.</param>
        <param name="indexA">Die Anfangsposition der Teilzeichenfolge innerhalb des <paramref name="strA" />-Parameters.</param>
        <param name="strB">Die zweite im Vergleich zu verwendende Zeichenfolge.</param>
        <param name="indexB">Die Anfangsposition der Teilzeichenfolge innerhalb des <paramref name="strB" />-Parameters.</param>
        <param name="length">Die maximale Anzahl der zu vergleichenden Zeichen der Teilzeichenfolgen.</param>
        <param name="culture">Ein Objekt, das kulturspezifische Vergleichsinformationen angibt.</param>
        <param name="options">Die beim Ausführen des Vergleichs zu verwendenden Optionen (z. B. Ignorieren von Groß- und Kleinschreibung oder Symbolen).</param>
        <summary>Vergleicht Teilzeichenfolgen von zwei angegebenen <see cref="T:System.String" />-Objekten mit den festgelegten Vergleichsoptionen und kulturspezifischen Informationen, die den Vergleich beeinflussen, und gibt eine ganze Zahl zurück, die die Beziehung der beiden Teilzeichenfolgen zueinander in der Sortierreihenfolge angibt.</summary>
        <returns>Eine ganze Zahl, die die lexikalische Beziehung zwischen den beiden Teilzeichenfolgen angibt, wie in der folgenden Tabelle veranschaulicht.  
  
 <list type="table"><listheader><term> Wert 
 </term><description> Bedingung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description> Die Teilzeichenfolge in <paramref name="strA" /> ist der Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge vorangestellt.  
  
 </description></item><item><term> Zero 
 </term><description> Die Teilzeichenfolgen treten in der Sortierreihenfolge an der gleichen Position auf, oder <paramref name="length" /> ist 0 (null).  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description> Die Teilzeichenfolge in <paramref name="strA" /> folgt der Teilzeichenfolge in <paramref name="strB" /> in der Sortierreihenfolge.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Starten Sie die zu vergleichenden Teilzeichenfolgen im `strA` an Position `indexA` und `strB` an Position `indexB`. Die Länge der ersten Teilzeichenfolge ist die Länge des `strA` minus `indexA`. Die Länge der zweiten Teilzeichenfolge ist die Länge des `strB` minus `indexB`.  
  
 Die Anzahl der zu vergleichenden Zeichen ist kleiner als die Länge der beiden Teilzeichenfolgen und `length`. Die `indexA`, `indexB`, und `length` Parameter dürfen nicht negativ sein.  
  
 Der Vergleich wird die `culture` Parameter zum Abrufen von kulturspezifischen Informationen, z. B. Groß-/ Kleinschreibregeln und die alphabetische Reihenfolge der einzelnen Zeichen. Z. B. eine bestimmte Kultur angeben, dass bestimmte Kombinationen von Zeichen als ein einzelnes Zeichen behandelt werden, auf eine bestimmte Weise Groß-und Kleinschreibung verglichen werden soll, oder, der die Sortierreihenfolge der ein Zeichen ist abhängig von der Zeichen, vorausgehen und folgen.  
  
> [!CAUTION]
>  Die <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> Methode dient in erster Linie zur Verwendung in sortiert oder alphabetisch sortiert Vorgänge. Es sollte nicht verwendet werden, wenn der primäre Zweck des Methodenaufrufs ist, um festzustellen, ob die beiden Teilzeichenfolgen äquivalent sind (d. h. wenn der Zweck des Methodenaufrufs für einen Rückgabewert von 0 (null) testen). Um zu bestimmen, ob zwei Zeichenfolgen identisch sind, rufen Sie die <xref:System.String.Equals%2A> Methode.  
  
 Eine oder beide der `strA` und `strB` kann `null`. Definitionsgemäß eine beliebige Zeichenfolge, einschließlich <xref:System.String.Empty?displayProperty=nameWithType>, Vergleich größer als ein null-Verweis, und zwei null-Verweise sind gleich.  
  
 Der Vergleich kann weiter angegeben werden, werden die `options` -Parameter, der eine oder mehrere Member besteht aus den <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> Enumeration. Jedoch, da der Zweck dieser Methode wird einen kulturabhängige Zeichenfolgenvergleich, Durchführen der <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> und <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> Werte haben keine Auswirkungen.  
  
 Der Vergleich wird beendet, wenn Ungleichheit ermittelt wird, oder beide Teilzeichenfolgen verglichen wurden. Allerdings wird, wenn die beiden Zeichenfolgen gleich dem Ende einer Zeichenfolge vergleichen und die andere Zeichenfolge über die verbleibenden Zeichen, die Zeichenfolge mit den verbleibenden Zeichen größer angesehen. Der Rückgabewert ist das Ergebnis der letzten Vergleich ausgeführt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> Methode, um die Nachnamen von zwei Personen vergleichen. Anschließend werden diese in alphabetischer Reihenfolge aufgeführt.  
  
 [!code-csharp[System.String.Compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare5/cs/Example.cs#1)]
 [!code-vb[System.String.Compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare5/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> ist kein <see cref="T:System.Globalization.CompareOptions" />-Wert.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> ist größer als <paramref name="strA" /><see langword=".Length" />.  
  
- oder -  
 <paramref name="indexB" /> ist größer als <paramref name="strB" /><see langword=".Length" />.  
  
- oder -  
 <paramref name="indexA" />, <paramref name="indexB" /> oder <paramref name="length" /> ist ein negativer Wert.  
  
- oder -  
Entweder <paramref name="strA" /> oder <paramref name="strB" /> ist <see langword="null" />, und <paramref name="length" /> ist größer als 0 (null).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> ist <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Zeichensätze enthalten ignorierbare Zeichen. Die <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> Methode berücksichtigt nicht diese Zeichen aus, wenn er einen linguistischen oder kulturabhängigen Vergleich ausführt. Geben Sie den Wert so, dass um Ignorierbare Zeichen in den Vergleich zu erkennen, <see cref="F:System.Globalization.CompareOptions.Ordinal" /> oder <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> für die <paramref name="options" /> Parameter.</para></block>
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareOrdinal">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Vergleicht zwei <see cref="T:System.String" />-Objekte, indem die numerischen Werte der entsprechenden <see cref="T:System.Char" />-Objekte in den Zeichenfolgen ausgewertet werden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * string -&gt; int" Usage="System.string.CompareOrdinal (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">Die erste zu vergleichende Zeichenfolge.</param>
        <param name="strB">Die zweite zu vergleichende Zeichenfolge.</param>
        <summary>Vergleicht zwei <see cref="T:System.String" />-Objekte, indem die numerischen Werte der entsprechenden <see cref="T:System.Char" />-Objekte in den Zeichenfolgen ausgewertet werden.</summary>
        <returns>Eine ganze Zahl, die die lexikalische Beziehung zwischen den beiden Vergleichswerten angibt.  
  
 <list type="table"><listheader><term> Wert 
 </term><description> Bedingung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description><paramref name="strA" /> ist kleiner als <paramref name="strB" />.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="strA" /> und <paramref name="strB" /> sind gleich.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description><paramref name="strA" /> ist größer als <paramref name="strB" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt einen Vergleich Groß-/Kleinschreibung anhand der ordinalen Sortierregeln. Weitere Informationen über Wort-, Zeichenfolgen- und ordinal sortiert, finden Sie unter <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>. Um einen Groß-/Kleinschreibung, anhand der ordinalen Sortierregeln Vergleich durchzuführen, rufen die <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> -Methode mit dem `comparisonType` Argument festgelegt wird, um <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.  
  
 Da <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> ist eine statische Methode, `strA` und `strB` kann `null`. Wenn beide Werte sind `null`, die Methode gibt 0 (null), der angibt, dass `strA` und `strB` gleich sind. Wenn nur einer der Werte ist `null`, die Methode berücksichtigt, die Null-Wert größer sein.  
  
   
  
## Examples  
 Im folgenden Beispiel wird und ordinalen Vergleich von zwei Zeichenfolgen unterscheiden sich nur hinsichtlich der Fall.  
  
 [!code-cpp[string.compareordinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compareordinal/CPP/comp0.cpp#1)]
 [!code-csharp[string.compareordinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compareordinal/CS/comp0.cs#1)]
 [!code-vb[string.compareordinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compareordinal/VB/comp0.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * int * string * int * int -&gt; int" Usage="System.string.CompareOrdinal (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">Die erste im Vergleich zu verwendende Zeichenfolge.</param>
        <param name="indexA">Der Anfangsindex der Teilzeichenfolge in <paramref name="strA" />.</param>
        <param name="strB">Die zweite im Vergleich zu verwendende Zeichenfolge.</param>
        <param name="indexB">Der Anfangsindex der Teilzeichenfolge in <paramref name="strB" />.</param>
        <param name="length">Die maximale Anzahl der zu vergleichenden Zeichen der Teilzeichenfolgen.</param>
        <summary>Vergleicht Teilzeichenfolgen zweier angegebener <see cref="T:System.String" />-Objekte, indem die numerischen Werte der entsprechenden <see cref="T:System.Char" />-Objekte in den Teilzeichenfolgen ausgewertet werden.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die die lexikalische Beziehung der beiden verglichenen Elemente angibt.  
  
 <list type="table"><listheader><term> Wert 
 </term><description> Bedingung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description> Die Teilzeichenfolge in <paramref name="strA" /> ist kleiner als die Teilzeichenfolge in <paramref name="strB" />.  
  
 </description></item><item><term> Zero 
 </term><description> Die Teilzeichenfolgen sind gleich, oder <paramref name="length" /> ist 0.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description> Die Teilzeichenfolge in <paramref name="strA" /> ist größer als die Teilzeichenfolge in <paramref name="strB" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `indexA`, `indexB`, und `length` Parameter dürfen nicht negativ sein.  
  
 Die Anzahl der Zeichen im Vergleich ist kleiner als die Länge des `strA` weniger `indexA`, die Länge des `strB` weniger `indexB`, und `length`.  
  
 Diese Methode führt einen Vergleich Groß-/Kleinschreibung anhand der ordinalen Sortierregeln. Weitere Informationen über Wort-, Zeichenfolgen- und ordinal sortiert, finden Sie unter <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>. Um einen Groß-/Kleinschreibung, anhand der ordinalen Sortierregeln Vergleich durchzuführen, rufen die <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> -Methode mit dem `comparisonType` Argument festgelegt wird, um <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.  
  
 Da <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> ist eine statische Methode, `strA` und `strB` kann `null`. Wenn beide Werte sind `null`, die Methode gibt 0 (null), der angibt, dass `strA` und `strB` gleich sind. Wenn nur einer der Werte ist `null`, die Methode berücksichtigt, die Null-Wert größer sein.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, dass <xref:System.String.CompareOrdinal%2A> und <xref:System.String.Compare%2A> unterschiedliche Sortierreihenfolgen verwenden.  
  
 [!code-cpp[StringCompareOrdinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareOrdinal/CPP/stringcompareordinal.cpp#1)]
 [!code-csharp[StringCompareOrdinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareOrdinal/CS/stringcompareordinal.cs#1)]
 [!code-vb[StringCompareOrdinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareOrdinal/VB/stringcompareordinal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="strA" /> ist nicht <see langword="null" /> und <paramref name="indexA" /> ist größer als <paramref name="strA" /><see cref="P:System.String.Length" />.  
  
- oder -  
 <paramref name="strB" /> ist nicht <see langword="null" /> und <paramref name="indexB" /> ist größer als <paramref name="strB" /><see cref="P:System.String.Length" />.  
  
- oder -  
 <paramref name="indexA" />, <paramref name="indexB" /> oder <paramref name="length" /> ist ein negativer Wert.</exception>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Vergleicht diese Instanz mit einem angegebenen Objekt oder <see cref="T:System.String" /> und gibt eine ganze Zahl zurück, die angibt, ob diese Instanz in der Sortierreihenfolge an einer früheren, späteren oder derselben Position wie das angegebene Objekt oder <see cref="T:System.String" /> aufgeführt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beide Überladungen der <xref:System.String.CompareTo%2A> -Methode führen kulturabhängige und Groß-/Kleinschreibung im Vergleich. Sie können nicht auf diese Methode verwenden, um kulturunabhängige oder Ordinalzahl Vergleiche durchzuführen. Aus Gründen der Übersichtlichkeit des Codes, wird empfohlen, dass Sie vermeiden die <xref:System.String.CompareTo%2A> Methode, und rufen die <xref:System.String.Compare%2A> Methode stattdessen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="string.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Ein Objekt, das als <see cref="T:System.String" /> ausgewertet wird.</param>
        <summary>Vergleicht diese Instanz mit einem angegebenen <see cref="T:System.Object" /> und gibt an, ob diese Instanz in der Sortierreihenfolge an einer früheren, späteren oder derselben Position wie das angegebene <see cref="T:System.Object" /> aufgeführt wird.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die angibt, ob diese Instanz in der Sortierreihenfolge an einer früheren, späteren oder derselben Position wie der <paramref name="value" />-Parameter aufgeführt wird.  
  
 <list type="table"><listheader><term> Wert 
 </term><description> Bedingung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description> Diese Instanz geht <paramref name="value" /> voran.  
  
 </description></item><item><term> Zero 
 </term><description> Diese Instanz hat in der Sortierreihenfolge dieselbe Position wie <paramref name="value" />.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description> Diese Instanz folgt <paramref name="value" />.  
  
- oder -  
 <paramref name="value" /> ist <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` muss eine <xref:System.String> Objekt.  
  
> [!CAUTION]
>  Die <xref:System.String.CompareTo%2A> Methode ist darauf ausgelegt, in erster Linie zur Verwendung in sortiert oder alphabetisch sortiert Vorgänge. Es sollte nicht verwendet werden, wenn der primäre Zweck des Methodenaufrufs ist, um festzustellen, ob zwei Zeichenfolgen identisch sind. Um zu bestimmen, ob zwei Zeichenfolgen identisch sind, rufen Sie die <xref:System.String.Equals%2A> Methode.  
  
 Diese Methode vergleicht Word (Groß-/Kleinschreibung beachtet und kulturabhängige) mit der aktuellen Kultur. Weitere Informationen über Wort-, Zeichenfolgen- und ordinal sortiert, finden Sie unter <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Weitere Informationen über das Verhalten dieser Methode finden Sie im Abschnitt "Hinweise" der <xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType> Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.String.CompareTo%2A> -Methode mit einem <xref:System.Object>. Da versucht wird, vergleichen Sie ein <xref:System.String> -Instanz, auf eine `TestClass` Objekt ist, löst die Methode eine <xref:System.ArgumentException>.  
  
 [!code-cpp[ExToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ExToString/CPP/extostring.cpp#1)]
 [!code-csharp[ExToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ExToString/CS/extostring.cs#1)]
 [!code-vb[ExToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ExToString/VB/extostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> ist keine <see cref="T:System.String" />.</exception>
        <block subset="none" type="usage"><para>Zeichensätze enthalten ignorierbare Zeichen. Die <see cref="M:System.String.CompareTo(System.Object)" /> Methode berücksichtigt keine solche Zeichen, wenn er einen kulturabhängigen Vergleich ausführt. Angenommen, der folgende Code ausgeführt wird, auf die [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder später ein Vergleich der "Tier" mit "Ani-falsch" (mit einem bedingten Bindestrichs oder U + 00AD) gibt an, dass die beiden Zeichenfolgen entspricht.  
  
[! Code-Csharp[System.String.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto1.cs#1)] [! Code – Vb[System.String.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto1.vb#1)] 
Rufen Sie so, dass Ignorierbare Zeichen in einen Zeichenfolgenvergleich erkennen zu können, die <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> Methode.</para></block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::String ^ strB);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : string -&gt; int&#xA;override this.CompareTo : string -&gt; int" Usage="string.CompareTo strB" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strB">Die Zeichenfolge, die mit dieser Instanz verglichen werden soll.</param>
        <summary>Vergleicht diese Instanz mit einem angegebenen <see cref="T:System.String" />-Objekt und gibt an, ob diese Instanz in der Sortierreihenfolge an einer früheren, späteren oder derselben Position wie die angegebene Zeichenfolge aufgeführt wird.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die angibt, ob diese Instanz in der Sortierreihenfolge an einer früheren, späteren oder derselben Position wie der <paramref name="strB" />-Parameter aufgeführt wird.  
  
 <list type="table"><listheader><term> Wert 
 </term><description> Bedingung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description> Diese Instanz geht <paramref name="strB" /> voran.  
  
 </description></item><item><term> Zero 
 </term><description> Diese Instanz hat in der Sortierreihenfolge dieselbe Position wie <paramref name="strB" />.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description> Diese Instanz folgt <paramref name="strB" />.  
  
- oder -  
 <paramref name="strB" /> ist <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode vergleicht Word (Groß-/Kleinschreibung beachtet und kulturabhängige) mit der aktuellen Kultur. Weitere Informationen über Wort-, Zeichenfolgen- und ordinal sortiert, finden Sie unter <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!CAUTION]
>  Die <xref:System.String.CompareTo%2A> Methode ist darauf ausgelegt, in erster Linie zur Verwendung in sortiert oder alphabetisch sortiert Vorgänge. Es sollte nicht verwendet werden, wenn der primäre Zweck des Methodenaufrufs ist, um festzustellen, ob zwei Zeichenfolgen identisch sind. Um zu bestimmen, ob zwei Zeichenfolgen identisch sind, rufen Sie die <xref:System.String.Equals%2A> Methode.  
  
 Weitere Informationen über das Verhalten dieser Methode finden Sie im Abschnitt "Hinweise" der <xref:System.String.Compare%28System.String%2CSystem.String%29> Methode.  
  
 Diese Methode implementiert die <xref:System.IComparable%601?displayProperty=nameWithType> -Schnittstelle und führt geringfügig besser als die <xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType> -Methode, da er nicht verfügt, um zu bestimmen, ob die `strB` Argument ist ein Typ von änderbaren Wert, der mittels Boxing konvertiert werden muss, und es muss keine Umwandlung der Parameter aus einem <xref:System.Object> zu einem <xref:System.String>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.String.CompareTo%2A> Methode, um die aktuelle Zeichenfolgeninstanz mit einer anderen Zeichenfolge verglichen werden soll.  
  
 [!code-cpp[stringcompareto#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareTo/CPP/stringcompareto.cpp#1)]
 [!code-csharp[stringcompareto#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareTo/CS/stringcompareto.cs#1)]
 [!code-vb[stringcompareto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareTo/VB/stringcompareto.vb#1)]  
  
 Im folgende Beispiel wird veranschaulicht, generische und nicht generischen Versionen der CompareTo-Methode für verschiedene Wert- und Referenztypen.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Zeichensätze enthalten ignorierbare Zeichen. Die <see cref="M:System.String.CompareTo(System.String)" /> Methode berücksichtigt keine solche Zeichen, wenn er einen kulturabhängigen Vergleich ausführt. Angenommen, der folgende Code ausgeführt wird, auf die [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder später ein Vergleich der "Tier" mit "Ani-falsch" (mit einem bedingten Bindestrichs oder U + 00AD) gibt an, dass die beiden Zeichenfolgen entspricht.  
  
[! Code-Csharp[System.String.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto2.cs#2)] [! Code – Vb[System.String.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto2.vb#2)] 
Rufen Sie so, dass Ignorierbare Zeichen in einen Zeichenfolgenvergleich erkennen zu können, die <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> Methode.</para></block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Concat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Verkettet eine oder mehrere Instanzen von <see cref="T:System.String" /> oder die <see cref="T:System.String" />-Darstellungen der Werte einer oder mehrerer Instanzen von <see cref="T:System.Object" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;string&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="values">Ein Auflistungsobjekt, das <see cref="T:System.Collections.Generic.IEnumerable`1" /> implementiert und dessen generisches Typargument <see cref="T:System.String" /> ist.</param>
        <summary>Verkettet die Member einer erstellten <see cref="T:System.Collections.Generic.IEnumerable`1" />-Auflistung vom Typ <see cref="T:System.String" />.</summary>
        <returns>Die verketteten Zeichenfolgen in <paramref name="values" /> oder <see cref="F:System.String.Empty" />, wenn <paramref name="values" /> ein leeres <see langword="IEnumerable(Of String)" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methode verkettet, jedes Objekt in `values`; es werden Trennzeichen nicht hinzugefügt. Ein Trennzeichen zwischen den einzelnen Elementen an `values`, rufen Sie die <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> Methode.  
  
 Ein <xref:System.String.Empty> diese Zeichenfolge wird verwendet, statt alle null-Element im `values`.  
  
 Wenn `values` ist eine leere `IEnumerable(Of String)`, gibt die Methode zurück <xref:System.String.Empty?displayProperty=nameWithType>. Wenn `values` ist `null`, löst die Methode eine <xref:System.ArgumentNullException> Ausnahme.  
  
 <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> ist eine bequeme Methode, mit dem Sie verketten, jedes Element in einer `IEnumerable(Of String)` Auflistung ohne Elemente zunächst in ein Zeichenfolgenarray konvertiert. Es ist besonders nützlich bei Abfrageausdrücken Language-Integrated Query (LINQ). Das folgende Beispiel übergibt eine `List(Of String)` Objekt, das die Groß- oder Kleinbuchstaben Buchstaben des Alphabets, einen Lambda-Ausdruck, die Buchstaben, die gleich oder größer als einen bestimmten Buchstaben enthält auswählt (die im Beispiel "M" ist). Die `IEnumerable(Of String)` -Auflistung, die von zurückgegeben wird die <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> Methode übergeben wird, um die <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> Methode, um das Ergebnis als eine einzelne Zeichenfolge anzuzeigen.  
  
 [!code-csharp[System.String.Concat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat2.cs#3)]
 [!code-vb[System.String.Concat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat2.vb#3)]  
  
   
  
## Examples  
 Im folgenden Beispiel wird den Algorithmus Sieb des Eratosthenes zum Berechnen von Primzahlen, die kleiner als oder gleich 100 sind. Weist das Ergebnis an eine <xref:System.Collections.Generic.List%601> Objekt vom Typ <xref:System.String>, die es dann an übergibt die <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> Methode.  
  
 [!code-csharp[System.String.Concat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat1.cs#2)]
 [!code-vb[System.String.Concat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Concat : obj -&gt; string" Usage="System.string.Concat arg0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Das darzustellende Objekt oder <see langword="null" />.</param>
        <summary>Erstellt die Zeichenfolgendarstellung eines angegebenen Objekts.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts von <paramref name="arg0" /> oder <see cref="F:System.String.Empty" />, wenn <paramref name="arg0" /> <see langword="null" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.Concat%28System.Object%29> Methode stellt `arg0` als Zeichenfolge durch Aufrufen der parameterlosen `ToString` Methode.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.Concat%2A> Methode.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Concat : obj[] -&gt; string" Usage="System.string.Concat args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">Ein Objektarray, das die zu verkettenden Elemente enthält.</param>
        <summary>Verkettet die Zeichenfolgendarstellungen der Elemente in einem angegebenen <see cref="T:System.Object" />-Array.</summary>
        <returns>Die verketteten Zeichenfolgendarstellungen der Werte der Elemente in <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methode verkettet, jedes Objekt in `args` durch Aufrufen der parameterlosen `ToString` Methode dieses Objekts; es werden Trennzeichen nicht hinzugefügt.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> wird anstelle eines null-Objekts im Array verwendet.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Verwendung der <xref:System.String.Concat%2A> -Methode mit einer <xref:System.Object> Array.  
  
 [!code-csharp[stringconcat1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat1/CS/stringconcat1.cs#1)]
 [!code-vb[stringconcat1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat1/VB/stringconcat1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="args" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Nicht genügend Arbeitsspeicher.</exception>
        <block subset="none" type="usage"><para>Diese Methode wird von C++-Code nicht aufgerufen. Der C++-Compiler löst Aufrufe von <see cref="Overload:System.String.Concat" /> deren vier oder mehr Objektparameter als Aufruf an <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />.</para></block>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray values As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : string[] -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="values">Ein Array von Zeichenfolgeninstanzen.</param>
        <summary>Verkettet die Elemente eines angegebenen <see cref="T:System.String" />-Arrays.</summary>
        <returns>Die verketteten Elemente von <paramref name="values" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methode verkettet, jedes Objekt in `values`; es werden Trennzeichen nicht hinzugefügt.  
  
 Ein <xref:System.String.Empty> Zeichenfolge anstelle eines null-Objekts im Array verwendet wird.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Verwendung der <xref:System.String.Concat%2A> -Methode mit einer <xref:System.String> Array.  
  
 [!code-cpp[stringconcat3#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat3/CPP/stringconcat3.cpp#1)]
 [!code-csharp[stringconcat3#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat3/CS/stringconcat3.cs#1)]
 [!code-vb[stringconcat3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat3/VB/stringconcat3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Nicht genügend Arbeitsspeicher.</exception>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Das erste zu verkettende Objekt.</param>
        <param name="arg1">Das zweite zu verkettende Objekt.</param>
        <summary>Verkettet die Zeichenfolgendarstellungen zweier angegebener Objekte.</summary>
        <returns>Die verketteten Zeichenfolgendarstellungen der Werte von <paramref name="arg0" /> und <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methode verkettet `arg0` und `arg1` durch Aufrufen der parameterlosen `ToString` -Methode der `arg0` und `arg1`; es werden Trennzeichen nicht hinzugefügt.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> wird anstelle von null-Argumenten verwendet.  
  
 Wenn entweder der Argumente der Verweis auf ein Array ist, verkettet die Methode eine Zeichenfolge, die dieses Arrays, anstatt ihre Mitglieder (z. B. "System.String[]").  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.Concat%2A> Methode.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Die erste zu verkettende Zeichenfolge.</param>
        <param name="str1">Die zweite zu verkettende Zeichenfolge.</param>
        <summary>Verkettet zwei angegebene Instanzen von <see cref="T:System.String" />.</summary>
        <returns>Die Verkettung von <paramref name="str0" /> und <paramref name="str1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methode verkettet `str0` und `str1`; es werden Trennzeichen nicht hinzugefügt.  
  
> [!NOTE]
>  Sie können auch die Sprache der Operator für zeichenfolgenverkettungen, verwenden, z. B. `+` in c# oder `&` und `+` in Visual Basic)  
>   
>  , um Zeichenfolgen zu verketten.  
  
 Ein <xref:System.String.Empty> diese Zeichenfolge wird anstelle von null-Argumenten verwendet.  
  
   
  
## Examples  
 Das folgende Beispiel, verkettet den Namen einer Person vor-, zweit- und letzte.  
  
 [!code-cpp[stringconcat4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat4/CPP/stringconcat4.cpp#1)]
 [!code-csharp[stringconcat4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat4/CS/stringconcat4.cs#1)]
 [!code-vb[stringconcat4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat4/VB/stringconcat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Das erste zu verkettende Objekt.</param>
        <param name="arg1">Das zweite zu verkettende Objekt.</param>
        <param name="arg2">Das dritte zu verkettende Objekt.</param>
        <summary>Verkettet die Zeichenfolgendarstellungen von drei angegebenen Objekten.</summary>
        <returns>Die verketteten Zeichenfolgendarstellungen der Werte von <paramref name="arg0" />, <paramref name="arg1" /> und <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methode verkettet `arg0`, `arg1`, und `arg2` durch Aufrufen der parameterlosen `ToString` -Methode aller Objekte; es werden Trennzeichen nicht hinzugefügt.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> wird anstelle von null-Argumenten verwendet.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.Concat%2A> Methode.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Die erste zu verkettende Zeichenfolge.</param>
        <param name="str1">Die zweite zu verkettende Zeichenfolge.</param>
        <param name="str2">Die dritte zu verkettende Zeichenfolge.</param>
        <summary>Verkettet zwei angegebene Instanzen von <see cref="T:System.String" />.</summary>
        <returns>Die Verkettung von <paramref name="str0" />, <paramref name="str1" /> und <paramref name="str2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methode verkettet `str0`, `str1`, und `str2`; es werden Trennzeichen nicht hinzugefügt.  
  
> [!NOTE]
>  Sie können auch die Sprache der Operator für zeichenfolgenverkettungen, verwenden, z. B. `+` in c# oder `&` und `+` in Visual Basic)  
>   
>  , um Zeichenfolgen zu verketten.  
  
 Ein <xref:System.String.Empty> diese Zeichenfolge wird anstelle von null-Argumenten verwendet.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.String.Concat%2A> Methode zum Verketten von drei Zeichenfolgen und das Ergebnis wird angezeigt.  
  
 [!code-cpp[System.String.Concat#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.concat/cpp/Concat6.cpp#6)]
 [!code-csharp[System.String.Concat#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/Concat6.cs#6)]
 [!code-vb[System.String.Concat#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/Concat6.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
        <Parameter Name="arg3" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Das erste zu verkettende Objekt.</param>
        <param name="arg1">Das zweite zu verkettende Objekt.</param>
        <param name="arg2">Das dritte zu verkettende Objekt.</param>
        <param name="arg3">Das vierte zu verkettende Objekt.</param>
        <summary>Verkettet die Zeichenfolgenentsprechungen von vier angegebenen Objekten sowie aller in einer optionalen Parameterliste variabler Länger angegebenen Objekte.</summary>
        <returns>Die verkettete Zeichenfolgendarstellung aller Werte in der Parameterliste.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese API ist nicht CLS-kompatibel. Die CLS-kompatible Alternative ist <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>. Die C#- und Visual Basic-Compiler lösen einen Aufruf dieser Methode automatisch als Aufruf an <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>.  
  
 Verkettet die Methode jedes Objekt in der Liste durch Aufrufen der parameterlosen `ToString` Methode; sie werden keine Trennzeichen hinzugefügt.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> wird anstelle von null-Argumenten verwendet.  
  
> [!NOTE]
>  Der letzte Parameter von der <xref:System.String.Concat%2A> Methode ist eine optionale durch Trennzeichen getrennte Liste von einem oder mehreren zusätzlichen Objekten zu verketten.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der <xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> Methode, um eine Liste der Variablenparameter verketten. In diesem Fall wird die Methode mit neun Parametern aufgerufen.  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Diese Methode ist mit markiert die <see langword="vararg" /> -Schlüsselwort, das bedeutet, dass es sich um eine Variable Anzahl an Parametern unterstützt. Die Methode kann aufgerufen werden, von Visual C++, aber es kann nicht in c# oder Visual Basic-Code aufgerufen werden. Die C#- und Visual Basic-Compiler lösen Aufrufe von <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /> als Aufrufe von <see cref="M:System.String.Concat(System.Object[])" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2, string str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2, string str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String, str3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2, System::String ^ str3);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
        <Parameter Name="str3" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Die erste zu verkettende Zeichenfolge.</param>
        <param name="str1">Die zweite zu verkettende Zeichenfolge.</param>
        <param name="str2">Die dritte zu verkettende Zeichenfolge.</param>
        <param name="str3">Die vierte zu verkettende Zeichenfolge.</param>
        <summary>Verkettet zwei angegebene Instanzen von <see cref="T:System.String" />.</summary>
        <returns>Die Verkettung von <paramref name="str0" />, <paramref name="str1" />, <paramref name="str2" /> und <paramref name="str3" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methode verkettet `str0`, `str1`, `str2`, und `str3`; es werden Trennzeichen nicht hinzugefügt.  
  
> [!NOTE]
>  Sie können auch die Sprache der Operator für zeichenfolgenverkettungen, verwenden, z. B. `+` in c# oder `&` und `+` in Visual Basic)  
>   
>  , um Zeichenfolgen zu verketten.  
  
 Ein <xref:System.String.Empty> Zeichenfolge anstelle eines null-Objekts im Array verwendet wird.  
  
   
  
## Examples  
 Im folgenden Beispiel definiert ein Array von vier Buchstaben Wörter und die einzelnen Buchstaben in ein Zeichenfolgenarray gespeichert, um sie der Zeichenfolge durcheinanderbringen. Es ruft dann die <xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29> Methode, um die unverständliche Wörter wieder zusammensetzen.  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Concat&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat(Of T) (values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;'T&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Member von <paramref name="values" />.</typeparam>
        <param name="values">Ein Auflistungsobjekt, das die <see cref="T:System.Collections.Generic.IEnumerable`1" />-Schnittstelle implementiert.</param>
        <summary>Verkettet die Member einer <see cref="T:System.Collections.Generic.IEnumerable`1" />-Implementierung.</summary>
        <returns>Die verketteten Zeichenfolgen in <paramref name="values" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methode verkettet, jedes Objekt in `values`; es werden Trennzeichen nicht hinzugefügt.  
  
 Ein <xref:System.String.Empty> diese Zeichenfolge wird anstelle von null-Argumenten verwendet.  
  
 <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> ist eine bequeme Methode, mit dem Sie verketten, jedes Element in einer <xref:System.Collections.Generic.IEnumerable%601> Auflistung ohne Elemente zunächst in Zeichenfolgen konvertiert. Es ist besonders nützlich bei Abfrageausdrücken Language-Integrated Query (LINQ), wie im Beispiel veranschaulicht. Die Zeichenfolgendarstellung der einzelnen Objekte in der <xref:System.Collections.Generic.IEnumerable%601> Auflistung wird durch Aufrufen des Objekts abgeleitet `ToString` Methode.  
  
   
  
## Examples  
 Das folgende Beispiel definiert eine sehr einfache `Animal` Klasse enthält den Namen des Tieres und die Reihenfolge an, zu dem er gehört. Es definiert dann eine <xref:System.Collections.Generic.List%601> Objekt, das eine Reihe von enthalten `Animal` Objekte. Die <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> Erweiterungsmethode aufgerufen, um das Extrahieren der `Animal` Objekte, deren `Order` -Eigenschaft gleich "Nagetier". Das Ergebnis wird zum Übergeben der <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> Methode und in der Konsole angezeigt.  
  
 [!code-csharp[System.String.Concat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat3.cs#4)]
 [!code-vb[System.String.Concat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value);" />
      <MemberSignature Language="F#" Value="member this.Contains : char -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Contains : string -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob eine angegebene untergeordnete Zeichenfolge in dieser Zeichenfolge vorkommt.</summary>
        <returns><see langword="true" />, wenn der <paramref name="value" />-Parameter in dieser Zeichenfolge vorkommt oder <paramref name="value" /> eine leere Zeichenfolge ("") ist; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt einen Ordinalvergleich der (Groß-/Kleinschreibung beachtet und kulturunabhängige). Die Suche beginnt an der Position des ersten Zeichens dieser Zeichenfolge und wird fortgesetzt, bis der letzten Zeichenposition.  
  
 Um zu bestimmen, ob eine Zeichenfolge eine angegebene Teilzeichenfolge mit etwas anderes als ordinaler Vergleich (z. B. ein kulturabhängiger Vergleich oder Groß-/Kleinschreibung Ordinalvergleich) enthält, können Sie eine benutzerdefinierte Methode erstellen. Das folgende Beispiel veranschaulicht einen solchen Ansatz. Definiert eine <xref:System.String> -Erweiterungsmethode, die enthält eine <xref:System.StringComparison> Parameter und gibt an, ob eine Zeichenfolge eine Teilzeichenfolge enthält, wenn das angegebene Formular des Zeichenfolgenvergleichs verwenden.  
  
 [!code-csharp[System.String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#1)]
 [!code-vb[System.String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#1)]  
  
 Das folgende Beispiel ruft dann die `Contains` Erweiterungsmethode, um zu bestimmen, ob eine Teilzeichenfolge in einer Zeichenfolge gefunden wird, wenn ordinaler Vergleich und die Groß-/Kleinschreibung Ordinalvergleich verwenden.  
  
 [!code-csharp[System.String.Contains#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#2)]
 [!code-vb[System.String.Contains#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#2)]  
  
 Wenn Sie die Position der Teilzeichenfolge interessiert sind `value` in der aktuellen Instanz ist, können Sie Aufrufen der <xref:System.String.IndexOf%2A> -Methode zum Abrufen der Position des ersten Vorkommens, oder Sie können Aufrufen der <xref:System.String.LastIndexOf%2A> -Methode zum Abrufen der ab der position der Letztes auftreten. Das Beispiel enthält einen Aufruf an die <xref:System.String.IndexOf%28System.String%29> Methode, wenn in einer Zeichenfolgeninstanz eine Teilzeichenfolge gefunden wurde.  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, ob die Zeichenfolge "Fuchs" eine Teilzeichenfolge eines Angebots vertraut. Wenn "Fuchs" in der Zeichenfolge gefunden werden, wird auch die Position des ersten angezeigt.  
  
 [!code-cpp[String.Contains#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.contains/CPP/cont.cpp#1)]
 [!code-csharp[String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.contains/CS/cont.cs#1)]
 [!code-vb[String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.contains/VB/cont.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : char * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : string * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static string Copy (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Copy(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Copy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Copy (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Copy(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Copy : string -&gt; string" Usage="System.string.Copy str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Die zu kopierende Zeichenfolge.</param>
        <summary>Erstellt eine neue Instanz von <see cref="T:System.String" /> mit demselben Wert wie eine angegebene Instanz von <see cref="T:System.String" />.</summary>
        <returns>Eine neue Zeichenfolge mit demselben Wert wie <paramref name="str" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.Copy%2A> Methode gibt eine <xref:System.String> Objekt, das den gleichen Wert wie die ursprüngliche Zeichenfolge aber einen anderes Objektverweis darstellt. Es unterscheidet sich vom eine Zuweisungsoperation, die einen vorhandenen Zeichenfolgenverweis auf eine zusätzliche Objektvariable weist. Das Beispiel veranschaulicht den Unterschied.  
  
   
  
## Examples  
 Im folgende Beispiel werden zwei Zeichenfolgenobjekte mit unterschiedlichen Werten erstellt. Bei Aufruf der <xref:System.String.Copy%2A> Methode zum Zuweisen des ersten Werts in der zweiten Zeichenfolge, die Ausgabe gibt an, dass die Zeichenfolgen verschiedene Objektverweise darstellen, obwohl Sie jetzt ihre Werte gleich sind. Andererseits, wenn die erste Zeichenfolge, die zweite Zeichenfolge zugewiesen wird, verfügen beide Zeichenfolgen über identische Werte, da sie auf den gleichen Objektverweis darstellen.  
  
 [!code-csharp[System.String.Copy#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.copy/cs/copy1.cs#1)]
 [!code-vb[System.String.Copy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.copy/vb/copy1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="string.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">Der Index des ersten Zeichens in dieser Instanz, das kopiert werden soll.</param>
        <param name="destination">Ein Array von Unicode-Zeichen, in das Zeichen in dieser Instanz kopiert werden.</param>
        <param name="destinationIndex">Der Index in <paramref name="destination" />, bei dem der Kopiervorgang beginnt.</param>
        <param name="count">Die Anzahl der Zeichen in dieser Instanz, die nach <paramref name="destination" /> kopiert werden sollen.</param>
        <summary>Kopiert eine angegebene Anzahl von Zeichen von einer angegebenen Position in dieser Instanz an eine angegebene Position in einem Array von Unicode-Zeichen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kopiert `count` Zeichen aus der `sourceIndex` Position dieser Instanz mit der `destinationIndex` position `destination` Zeichenarray. Diese Methode ändert nicht die Größe der `destination` Zeichenarray; muss eine ausreichende Anzahl von Elementen, die die kopierten Zeichen aufzunehmen, oder die Methode löst eine <xref:System.ArgumentOutOfRangeException>.  
  
 `sourceIndex` und `destinationIndex` sind nullbasiert.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.CopyTo%2A> Methode.  
  
 [!code-cpp[stringcopyto#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringcopyto/CPP/stringcopyto.cpp#1)]
 [!code-csharp[stringcopyto#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringcopyto/CS/stringcopyto.cs#1)]
 [!code-vb[stringcopyto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringcopyto/VB/stringcopyto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destination" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" />, <paramref name="destinationIndex" /> oder <paramref name="count" /> ist ein negativer Wert. 
- oder -  
 <paramref name="sourceIndex" /> identifiziert keine Position in der aktuellen Instanz.  
  
- oder -  
 <paramref name="destinationIndex" /> identifiziert keinen gültigen Index im <paramref name="destination" />-Array.  
  
- oder -  
 <paramref name="count" /> ist größer als die Länge der Teilzeichenfolge von <paramref name="sourceIndex" /> bis zum Ende dieser Instanz 
- oder -  
 <paramref name="count" /> ist größer als die Länge des Teilarrays von <paramref name="destinationIndex" /> bis zum Ende des <paramref name="destination" />-Arrays.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Create&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static string Create&lt;TState&gt; (int length, TState state, System.Buffers.SpanAction&lt;char,TState&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Create&lt;TState&gt;(int32 length, !!TState state, class System.Buffers.SpanAction`2&lt;char, !!TState&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Create``1(System.Int32,``0,System.Buffers.SpanAction{System.Char,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of TState) (length As Integer, state As TState, action As SpanAction(Of Char, TState)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static System::String ^ Create(int length, TState state, System::Buffers::SpanAction&lt;char, TState&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member Create : int * 'State * System.Buffers.SpanAction&lt;char, 'State&gt; -&gt; string" Usage="System.string.Create (length, state, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="action" Type="System.Buffers.SpanAction&lt;System.Char,TState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="length">To be added.</param>
        <param name="state">To be added.</param>
        <param name="action">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static readonly string Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string Empty" />
      <MemberSignature Language="DocId" Value="F:System.String.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Empty As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ Empty;" />
      <MemberSignature Language="F#" Value=" staticval mutable Empty : string" Usage="System.string.Empty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt die leere Zeichenfolge dar. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieses Felds ist die Zeichenfolge der Länge 0 (null), "".  
  
 Im Code wird dieses Feld am häufigsten in Zuweisungen verwendet, um eine String-Variable auf eine leere Zeichenfolge zu initialisieren. Um zu testen, ob der Wert einer Zeichenfolge entweder `null` oder <xref:System.String.Empty?displayProperty=nameWithType>, verwenden Sie die <xref:System.String.IsNullOrEmpty%2A> Methode.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="EndsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bestimmt, ob das Ende dieser Zeichenfolgeninstanz mit einer angegebenen Zeichenfolge übereinstimmt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : char -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolge, die mit der Teilzeichenfolge am Ende dieser Instanz verglichen werden soll.</param>
        <summary>Bestimmt, ob das Ende dieser Zeichenfolgeninstanz mit der angegebenen Zeichenfolge übereinstimmt.</summary>
        <returns><see langword="true" />, wenn <paramref name="value" /> mit dem Ende dieser Instanz übereinstimmt; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode vergleicht `value` mit der Teilzeichenfolge am Ende dieser Instanz, die gleiche Länge wie `value`, und gibt einen Wert zurück, ob diese gleich sind. Gleich, `value` muss ein Verweis auf die gleiche Instanz sein oder mit dem Ende dieser Instanz übereinstimmt.  
  
 Diese Methode vergleicht Word (Groß-/Kleinschreibung beachtet und kulturabhängige) mit der aktuellen Kultur.  
  
   
  
## Examples  
 Das folgende Beispiel gibt an, ob jede Zeichenfolge in ein Array mit einem Punkt endet (".").  
  
 [!code-csharp[System.String.EndsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.EndsWith/cs/EndsWith1.cs#1)]
 [!code-vb[System.String.EndsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.EndsWith/vb/EndsWith1.vb#1)]  
  
 Das folgende Beispiel definiert eine `StripEndTags` Methode, verwendet der <xref:System.String.EndsWith%28System.String%29> Methode, um HTML-Endtags vom Ende einer Zeile zu entfernen. Beachten Sie, dass die `StripEndTags` Methode rekursiv aufgerufen, um sicherzustellen, dass mehrere HTML-End-Tags am Ende der Zeile entfernt werden.  
  
 [!code-cpp[stringendswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringendswith/CPP/stringendswith.cpp#1)]
 [!code-csharp[stringendswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringendswith/CS/stringendswith.cs#1)]
 [!code-vb[stringendswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringendswith/VB/stringendswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Siehe [bewährte Methoden für die Verwendung von Zeichenfolgen](~/docs/standard/base-types/best-practices-strings.md), es wird empfohlen, dass Sie vermeiden, Aufrufen von Methoden zum Zeichenfolgenvergleich, die Standardwerte ersetzen, und rufen stattdessen die Methoden, die für Parameter explizit angegeben werden müssen. Aufrufen, um zu bestimmen, ob eine Zeichenfolge mit einer bestimmten Teilzeichenfolge endet, mithilfe der Regeln für Zeichenfolgenvergleiche der aktuellen Kultur, die <see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /> methodenüberladung mit einem Wert von <see cref="F:System.StringComparison.CurrentCulture" /> für seine <paramref name="comparisonType" /> Parameter.</para></block>
        <altmember cref="M:System.String.StartsWith(System.String)" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * StringComparison -&gt; bool" Usage="string.EndsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolge, die mit der Teilzeichenfolge am Ende dieser Instanz verglichen werden soll.</param>
        <param name="comparisonType">Einer der Enumerationswerte, die bestimmen, wie diese Zeichenfolge und <paramref name="value" /> verglichen werden.</param>
        <summary>Bestimmt, ob das Ende dieser Zeichenfolgeninstanz bei einem Vergleich unter Verwendung der angegebenen Vergleichsoption mit der angegebenen Zeichenfolge übereinstimmt.</summary>
        <returns><see langword="true" />, wenn der <paramref name="value" />-Parameter mit dem Ende dieser Zeichenfolge übereinstimmt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.EndsWith%2A> -Methode vergleicht die `value` Parameter mit der Teilzeichenfolge am Ende dieser Zeichenfolge und gibt einen Wert, der angibt, ob diese gleich sind. Gleich, `value` ein Verweis auf die gleiche Zeichenfolge sein muss, muss die leere Zeichenfolge (""), oder mit das Ende dieser Zeichenfolge übereinstimmt. Den Typ des Vergleichs wurden und die <xref:System.String.EndsWith%2A> Methode hängt vom Wert von der `comparisonType` Parameter.  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, ob eine Zeichenfolge mit einer bestimmten Teilzeichenfolge endet. Die Ergebnisse sind betroffen, durch die Auswahl der Kultur, ob die Groß-/Kleinschreibung ignoriert wird und gibt an, ob ein ordinaler Vergleich ausgeführt wird.  
  
 [!code-cpp[System.String.EndsWithCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cpp/ewcmp.cpp#1)]
 [!code-csharp[System.String.EndsWithCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cs/ewcmp.cs#1)]
 [!code-vb[System.String.EndsWithCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.EndsWithCmp/vb/ewcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> ist kein <see cref="T:System.StringComparison" />-Wert.</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.EndsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolge, die mit der Teilzeichenfolge am Ende dieser Instanz verglichen werden soll.</param>
        <param name="ignoreCase"><see langword="true" />, wenn die Groß-/Kleinschreibung beim Vergleich ignoriert werden soll, andernfalls <see langword="false" />.</param>
        <param name="culture">Kulturinformationen, die bestimmen, wie diese Instanz und <paramref name="value" /> verglichen werden. Wenn <paramref name="culture" /> <see langword="null" /> ist, wird die aktuelle Kultur verwendet.</param>
        <summary>Bestimmt, ob das Ende dieser Zeichenfolgeninstanz bei einem Vergleich unter Verwendung der angegebenen Kultur mit der angegebenen Zeichenfolge übereinstimmt.</summary>
        <returns><see langword="true" />, wenn der <paramref name="value" />-Parameter mit dem Ende dieser Zeichenfolge übereinstimmt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode vergleicht die `value` Parameter mit der Teilzeichenfolge am Ende dieser Zeichenfolge, die gleiche Länge wie `value`, und gibt einen Wert, der angibt, ob diese gleich sind. Gleich, `value` muss ein Verweis auf die gleiche Instanz sein oder mit dem Ende dieser Zeichenfolge übereinstimmt.  
  
 Diese Methode vergleicht Word (kulturabhängig) mithilfe der angegebenen Groß-/Kleinschreibung und Kultur.  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, ob eine Zeichenfolge am Ende einer anderen Zeichenfolge auftritt. Die <xref:System.String.EndsWith%2A> Methode wird aufgerufen, mehrmals mit Groß-/Kleinschreibung, Groß-/Kleinschreibung und andere Kulturen, die die Ergebnisse der Suche zu beeinflussen.  
  
 [!code-csharp[system.string.EndsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.EndsWithCI/cs/ewci.cs#1)]
 [!code-vb[system.string.EndsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.EndsWithCI/vb/ewci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bestimmt, ob zwei <see cref="T:System.String" />-Objekte denselben Wert haben.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="string.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Die Zeichenfolge, die mit dieser Instanz verglichen werden soll.</param>
        <summary>Bestimmt, ob diese Instanz und ein angegebenes Objekt, das ebenfalls ein <see cref="T:System.String" />-Objekt sein muss, denselben Wert haben.</summary>
        <returns><see langword="true" />, wenn <paramref name="obj" /> ein <see cref="T:System.String" /> ist und denselben Wert wie diese Instanz hat; andernfalls <see langword="false" />.  Wenn <paramref name="obj" /> gleich <see langword="null" /> ist, gibt die Methode <see langword="false" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt einen Ordinalvergleich der (Groß-/Kleinschreibung beachtet und kulturunabhängige).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.Equals%2A> Methode.  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::String ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : string -&gt; bool" Usage="string.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolge, die mit dieser Instanz verglichen werden soll.</param>
        <summary>Bestimmt, ob diese Instanz und ein anderes angegebenes <see cref="T:System.String" />-Objekt denselben Wert haben.</summary>
        <returns><see langword="true" />, wenn der <paramref name="value" />-Parameter und diese Instanz denselben Wert haben, andernfalls <see langword="false" />. Wenn <paramref name="value" /> gleich <see langword="null" /> ist, gibt die Methode <see langword="false" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt einen Ordinalvergleich der (Groß-/Kleinschreibung beachtet und kulturunabhängige).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.String.Equals%2A> Methode. Es vergleicht die Groß-/Kleinschreibung Titel Wort "File" mit ein Äquivalent Wort, dessen Entsprechung in Kleinbuchstaben, dessen Entsprechung in Großbuchstaben und ein Wort, das LATIN kleine Buchstaben ohne Punkte I enthält (U + 0131) anstelle von kleinen Buchstaben LATEINISCH I (U + 0069). Da die <xref:System.String.Equals%28System.String%29> Methode führt einen Ordinalvergleich, nur für der Vergleich mit einer identischen Wort gibt `true`.  
  
 [!code-csharp[System.String.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equalsex1.cs#2)]
 [!code-vb[System.String.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equalsex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string -&gt; bool" Usage="System.string.Equals (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Die erste Zeichenfolge für den Vergleich oder <see langword="null" />.</param>
        <param name="b">Die zweite Zeichenfolge für den Vergleich oder <see langword="null" />.</param>
        <summary>Bestimmt, ob zwei angegebene <see cref="T:System.String" />-Objekte denselben Wert haben.</summary>
        <returns><see langword="true" />, wenn <paramref name="a" /> und <paramref name="b" /> denselben Wert haben, andernfalls <see langword="false" />. Wenn <paramref name="a" /> und <paramref name="b" /> <see langword="null" /> sind, gibt diese Methode <see langword="true" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt einen Ordinalvergleich der (Groß-/Kleinschreibung beachtet und kulturunabhängige).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.Equals%2A> Methode.  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.Equals : string * StringComparison -&gt; bool" Usage="string.Equals (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolge, die mit dieser Instanz verglichen werden soll.</param>
        <param name="comparisonType">Einer der Enumerationswerte, die angeben, wie die Zeichenfolgen verglichen werden.</param>
        <summary>Bestimmt, ob diese Zeichenfolge und ein angegebenes <see cref="T:System.String" />-Objekt denselben Wert haben. Ein Parameter gibt die Kultur, Berücksichtigung von Groß- und Kleinschreibung und Sortierregeln, die für den Vergleich verwendet werden.</summary>
        <returns><see langword="true" />, wenn der <paramref name="value" />-Parameter und diese Zeichenfolge denselben Wert haben; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `comparisonType` Parameter gibt an, ob der Vergleich die aktuelle oder der invariante Kultur verwenden soll, berücksichtigen die zwei verglichenen Zeichenfolgen die Groß-/Kleinschreibung ignorieren oder Wort- oder ordinalen Sortierregeln verwendet.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein Array von Zeichenfolgen, die von einem großen "I" Kleinbuchstaben "i" und eine ohne Punkte "ı" besteht. Es ruft dann die <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> Methode, um sie zu vergleichen mit jedem möglichen <xref:System.StringComparison> Enumerationswert.  
  
 [!code-csharp[System.String.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/eqcmp.cs#1)]
 [!code-vb[System.String.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/eqcmp.vb#1)]  
  
 Im folgenden Beispiel werden vier Sätze von Wörtern mit jedem Mitglied der <xref:System.StringComparison> Enumeration.  Die Vergleiche, die Konventionen der Samisch (obere Schweden) Kulturen Englisch (USA) und verwenden. Beachten Sie, dass die Zeichenfolgen "Encyclopædia" und "Enzyklopädie" entspricht in der Kultur En-US, aber nicht in der Kultur Samisch (Nord, Schweden) berücksichtigt werden.  
  
 [!code-csharp[System.String.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex4.cs#4)]
 [!code-vb[System.String.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> ist kein <see cref="T:System.StringComparison" />-Wert.</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string * StringComparison -&gt; bool" Usage="System.string.Equals (a, b, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="a">Die erste Zeichenfolge für den Vergleich oder <see langword="null" />.</param>
        <param name="b">Die zweite Zeichenfolge für den Vergleich oder <see langword="null" />.</param>
        <param name="comparisonType">Einer der Enumerationswerte, der die Regeln für den Vergleich angibt.</param>
        <summary>Bestimmt, ob zwei angegebene <see cref="T:System.String" />-Objekte denselben Wert haben. Ein Parameter gibt die Kultur, Berücksichtigung von Groß- und Kleinschreibung und Sortierregeln, die für den Vergleich verwendet werden.</summary>
        <returns><see langword="true" />, wenn der Wert des <paramref name="a" />-Parameters dem Wert des <paramref name="b" />-Parameters entspricht, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `comparisonType` Parameter gibt an, ob der Vergleich die aktuelle oder der invariante Kultur verwenden soll, berücksichtigen die zwei verglichenen Zeichenfolgen die Groß-/Kleinschreibung ignorieren oder Wort- oder ordinalen Sortierregeln verwendet.  
  
   
  
## Examples  
 Im folgenden Beispiel werden vier Sätze von Wörtern mit jedem Mitglied der <xref:System.StringComparison> Enumeration.  Die Vergleiche, die Konventionen der Samisch (obere Schweden) Kulturen Englisch (USA) und verwenden. Beachten Sie, dass die Zeichenfolgen "Encyclopædia" und "Enzyklopädie" entspricht in der Kultur En-US, aber nicht in der Kultur Samisch (Nord, Schweden) berücksichtigt werden.  
  
 [!code-csharp[System.String.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex3.cs#3)]
 [!code-vb[System.String.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> ist kein <see cref="T:System.StringComparison" />-Wert.</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Format">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert auf der Grundlage der angegebenen Formate den Wert von Objekten in Zeichenfolgen und fügt sie in eine andere Zeichenfolge ein.  
  
Wenn Sie die `String.Format`-Methode noch nicht kennen, lesen Sie den Abschnitt zur [String.Format-Methode](#Starting), um sich einen Überblick zu verschaffen.  
  
Eine allgemeine Dokumentation zur `String.Format`-Methode finden Sie im Abschnitt [Hinweise](#remarks-top).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
<a name="remarks-top"></a>   
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
 
 In diesem Abschnitt  
  
 [Erste Schritte mit der String.Format-Methode](#Starting)   
 [Welche Methode rufe ich?](#FTaskList)   
 [Der Format-Methode in Kürze](#Format_Brief)   
 [Das Format-Element](#FormatItem)   
 [Wie werden Argumente formatiert.](#HowFormatted)   
 [Formatelemente, die den gleichen Index aufweisen.](#SameIndex)   
 [Formatierung und Kultur](#Format_Culture)   
 [Benutzerdefinierte Formatierung Vorgänge](#Format_Custom)   
 ["String.Format"-F & A](#QA)  
  
<a name="Starting"></a>   
## <a name="get-started-with-the-stringformat-method"></a>Erste Schritte mit der String.Format-Methode  
 Verwendung <xref:System.String.Format%2A?displayProperty=nameWithType> Wenn Sie den Wert eines Objekts, eine Variable oder ein Ausdruck in einer anderen Zeichenfolge einzufügen müssen. Sie können beispielsweise den Wert der Einfügen einer <xref:System.Decimal> Wert in eine Zeichenfolge für den Benutzer als einzelne Zeichenfolge angezeigt:  
  
 [!code-cpp[System.String.Format#35](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#35)]
 [!code-csharp-interactive[System.String.Format#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#35)]
 [!code-vb[System.String.Format#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#35)]  
  
 Und Sie können die Formatierung des Werts steuern:  
  
 [!code-cpp[System.String.Format#36](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#36)]
 [!code-csharp-interactive[System.String.Format#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#36)]
 [!code-vb[System.String.Format#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#36)]  
  
 Neben der Formatierung, können Sie auch die Ausrichtung und Abstände steuern.  
  
 ### <a name="inserting-a-string"></a>Eine Zeichenfolge eingefügt  

 <xref:System.String.Format%2A?displayProperty=nameWithType> beginnt mit einer Formatzeichenfolge, gefolgt von ein oder mehrere Objekte oder Ausdrücke, die in Zeichenfolgen konvertiert und an einer angegebenen Position in der Formatzeichenfolge eingefügt werden. Zum Beispiel:  
  
 [!code-cpp[System.String.Format#30](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#30)]
 [!code-csharp-interactive[System.String.Format#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#30)]
 [!code-vb[System.String.Format#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#30)]  
  
 Die `{0}` im Format Zeichenfolge eines Formatelements ist. `0` ist der Index des Objekts, dessen Wert an dieser Position eingefügt wird. (Indizes beginnen bei 0.) Wenn das Objekt eingefügt werden soll, keine Zeichenfolge, ist die `ToString` Methode wird aufgerufen, um sie zu einem vor dem Einfügen in der Ergebniszeichenfolge zu konvertieren.  
  
 Hier ist ein weiteres Beispiel, das zwei Formatelemente und zwei Objekte in der Objektliste verwendet:  
  
 [!code-cpp[System.String.Format#31](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#31)]
 [!code-csharp-interactive[System.String.Format#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#31)]
 [!code-vb[System.String.Format#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#31)]  
  
 Sie können beliebig viele Formatelemente und beliebig viele Objekte in der Objektliste, wie Sie möchten, solange der Index der jedes Formatelement, das kein übereinstimmendes Objekt in der Objektliste verfügt. Ferner müssen nicht Gedanken machen, über welche, die Überladung Sie aufrufen; der Compiler wird das entsprechende Feld für die Sie auswählen.  
  
 ### <a name="controlling-formatting"></a>Steuern der Formatierung  
 Führen Sie den Index in einem Formatelement, das mit einer Formatzeichenfolge zu steuern, wie ein Objekt formatiert ist. Z. B. `{0:d}` gilt die Zeichenfolge "d" zum ersten Objekt in der Objektliste. Es folgt ein Beispiel mit einem einzelnen Objekt und zwei Elemente formatieren:  
  
 [!code-cpp[System.String.Format#32](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#32)]
 [!code-csharp-interactive[System.String.Format#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#32)]
 [!code-vb[System.String.Format#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#32)]  
  
 Eine Anzahl von Typen unterstützen Formatzeichenfolgen, einschließlich aller numerischen Typen (sowohl [standard](~/docs/standard/base-types/standard-numeric-format-strings.md) und [benutzerdefinierte](~/docs/standard/base-types/custom-numeric-format-strings.md) Formatzeichenfolgen), alle Datums- und Uhrzeitangaben (beide [standard](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und [benutzerdefinierte](~/docs/standard/base-types/custom-date-and-time-format-strings.md) Formatzeichenfolgen) und Zeitintervalle (beide [standard](~/docs/standard/base-types/standard-timespan-format-strings.md) und [benutzerdefinierte](~/docs/standard/base-types/custom-timespan-format-strings.md) Formatzeichenfolgen), alle Enumerationstypen [Enumerationstypen ](~/docs/standard/base-types/enumeration-format-strings.md), und [GUIDs](https://msdn.microsoft.com/library/97af8hh4.aspx). Sie können auch Unterstützung für Formatzeichenfolgen für eigene Typen hinzufügen.  
  
 ### <a name="controlling-spacing"></a>Steuern der Abstand  
 Sie können die Breite der Zeichenfolge, die in die Ergebniszeichenfolge eingefügt wird, wie z. B. mit der Syntax definieren `{0,12}`, die eine 12 Zeichen bestehende Zeichenfolge eingefügt. In diesem Fall ist die Zeichenfolgendarstellung des ersten Objekts rechtsbündig in das Feld 12 Zeichen bestehende.  (Wenn die Zeichenfolgendarstellung des ersten Objekts mehr als 12 Zeichen lang ist, jedoch die gewünschte Feldbreite wird ignoriert, und die gesamte Zeichenfolge wird in die Ergebniszeichenfolge eingefügt.)  
  
 Das folgende Beispiel definiert ein Feld 6 Zeichen, um die Zeichenfolge "Year" und einige Zeichenfolgen von Jahr, als auch ein Feld 15 Zeichen für die Zeichenfolge "Auffüllung" und einige Daten auffüllen. Beachten Sie, dass die Zeichen rechtsbündig in das Feld.  
  
 [!code-cpp[System.String.Format#33](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#33)]
 [!code-csharp-interactive[System.String.Format#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting3.cs)]
 [!code-vb[System.String.Format#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#33)]  
  
 ### <a name="controlling-alignment"></a>Steuern der Ausrichtung  
 Standardmäßig werden Zeichenfolgen in ihre Feld rechtsbündig ausgerichtet, wenn Sie eine Feldbreite angeben. Um Zeichenfolgen in einem Feld linksbündig, Sie stellen die Feldbreite ein negatives Vorzeichen, z. B. `{0,-12}` so definieren Sie ein Feld mit 12 Zeichen bestehende linksbündig ausgerichtet.  
  
 Im folgende Beispiel ähnelt dem vorherigen Beispiel, außer dass sie sowohl die Bezeichnungen als auch die Daten linksbündig.  
  
 [!code-cpp[System.String.Format#34](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#34)]
 [!code-csharp-interactive[System.String.Format#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#34)]
 [!code-vb[System.String.Format#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#34)]  
  
 <xref:System.String.Format%2A?displayProperty=nameWithType> der Funktion für kombinierte Formatierung verwendet. Weitere Informationen finden Sie unter [Zusammengesetzte Formatierung](~/docs/standard/base-types/composite-formatting.md).  
  
<a name="FTaskList"></a>   
## <a name="which-method-do-i-call"></a>Welche Methode rufe ich?  
  
|Beschreibung|Call|  
|--------|----------|  
|Ein oder mehrere Objekte mit den Konventionen der aktuellen Kultur zu formatieren.|Mit Ausnahme der Überladungen, die eine `provider` Parameter, die verbleibenden <xref:System.String.Format%2A> -Überladungen enthalten eine <xref:System.String> Parameter folgen eine oder mehrere Objektparameter. Aus diesem Grund müssen Sie nicht ermitteln, welche <xref:System.String.Format%2A> Überladung, die Sie aufrufen möchten. Ihr Sprachcompiler wählt die entsprechende Überladung zwischen Überladungen, die keinem `provider` basierend auf Ihrer Typargumentliste-Parameter. Z. B. Wenn Sie Ihrer Typargumentliste fünf Argumente verfügt, die der Compiler Ruft die <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> Methode.|  
|Ein oder mehrere Objekte mit den Konventionen einer bestimmten Kultur zu formatieren.|Jede <xref:System.String.Format%2A> Überladung, die mit beginnt eine `provider` -Parameter folgt einem <xref:System.String> Parameter und mindestens eine Objekt-Parameter. Aus diesem Grund nicht haben festlegen, um zu bestimmen, welche spezifischen <xref:System.String.Format%2A> Überladung, die Sie aufrufen möchten. Ihr Sprachcompiler wählt die entsprechende Überladung aus die Überladungen mit einem `provider` basierend auf Ihrer Typargumentliste-Parameter. Z. B. Wenn Sie Ihrer Typargumentliste fünf Argumente verfügt, die der Compiler Ruft die <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> Methode.|  
|Führen Sie einem benutzerdefinierten Formatierungsvorgang entweder mit einem <xref:System.ICustomFormatter> Implementierung oder <xref:System.IFormattable> Implementierung.|Die vier Überladungen mit einem `provider` Parameter. Der Compiler wählt die entsprechende Überladung aus die Überladungen mit einem `provider` basierend auf Ihrer Typargumentliste-Parameter.|  
  
<a name="Format_Brief"></a>   
## <a name="the-format-method-in-brief"></a>Der Format-Methode in Kürze 

 Jede Überladung der der <xref:System.String.Format%2A> -Methode verwendet die [Funktion für kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) nullbasierte indizierte Platzhaltern, so genannten einschließen *Elemente formatieren*, in eine kombinierte Formatzeichenfolge. Zur Laufzeit wird jedes Formatelement durch die Zeichenfolgendarstellung des entsprechenden Arguments in einer Parameterliste ersetzt. Wenn der Wert des Arguments `null`, ersetzt das Formatelement mit <xref:System.String.Empty?displayProperty=nameWithType>. Beispielsweise der folgende Aufruf von der <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> Methode enthält eine Formatzeichenfolge mit drei Formatelemente {0}, {1}, und {2}, und einer Argumentliste mit drei Elementen.  
  
 [!code-cpp[System.String.Format#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload1.cpp#8)]
 [!code-csharp-interactive[System.String.Format#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload1.cs#8)]
 [!code-vb[System.String.Format#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload1.vb#8)]  
  
<a name="FormatItem"></a>   
## <a name="the-format-item"></a>Das Formatelement  
 Ein Formatelement, das hat folgende Syntax:  
  
```  
{index[,alignment][:formatString]}  
```  
 
 Klammern bezeichnen optionale Elemente. Die öffnende und schließende geschweifte Klammern sind erforderlich. (Umfassen eine literale öffnende oder schließende geschweifte Klammer in der Formatzeichenfolge der [versehen von geschweiften Klammern](~/docs/standard/base-types/composite-formatting.md#escaping-braces) im Abschnitt der [kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) Artikel.)  
  
 Beispielsweise kann ein Formatelement, das einen Währungswert formatiert Folgendes angezeigt:  
  
 [!code-cpp[System.String.Format#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatsyntax1.cpp#12)]
 [!code-csharp-interactive[System.String.Format#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatsyntax1.cs#12)]  
 [!code-vb[System.String.Format#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatsyntax1.vb#12)]  

 Einem Formatelement hat die folgenden Elemente:  
  
 *index*  
 Der nullbasierte Index des Arguments, dessen Zeichenfolgendarstellung werden an dieser Position in der Zeichenfolge enthalten. Wenn dieses Argument `null`, eine leere Zeichenfolge wird an dieser Position in der Zeichenfolge enthalten sein.  
  
 *Ausrichtung*  
 Dies ist optional. Eine Ganzzahl mit Vorzeichen gibt an, dass die Gesamtlänge des Felds in der eingefügt wird, dass Sie des Arguments und gibt an, ob rechts ausgerichtet wird (eine positive ganze Zahl) oder linksbündig ausgerichtet (eine negative ganze Zahl). Wenn Sie weglassen *Ausrichtung*, die Zeichenfolgendarstellung des entsprechenden Arguments in einem Feld darf keine führenden oder nachgestellten Leerzeichen eingefügt wird.  
  
 Wenn der Wert des *Ausrichtung* ist kleiner als die Länge des Arguments, eingefügt werden soll, *Ausrichtung* wird ignoriert, und die Länge der Zeichenfolgendarstellung des Arguments wird als Feldbreite verwendet.  
  
 *formatString*  
 Dies ist optional. Eine Zeichenfolge, die das Format der Ergebniszeichenfolge für das entsprechende Argument angibt. Wenn Sie weglassen *FormatString*, das entsprechende Argument der parameterlosen `ToString` Methode wird aufgerufen, um die Zeichenfolgendarstellung zu erzeugen. Bei Angabe von *FormatString*, muss das Argument verwiesen wird, von dem Formatelement, das Implementieren der <xref:System.IFormattable> Schnittstelle. Typen, die Formatzeichenfolgen unterstützen umfassen:  
  
-   Alle Ganzzahlen und Gleitkomma-Typen. (Finden Sie unter [standardmäßige numerische Formatzeichenfolgen](~/docs/standard/base-types/standard-numeric-format-strings.md) und [benutzerdefinierte numerische Formatzeichenfolgen](~/docs/standard/base-types/custom-numeric-format-strings.md).)  
  
-   <xref:System.DateTime> und <xref:System.DateTimeOffset>. (Finden Sie unter [Formatzeichenfolgen für Datum und Uhrzeit](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und [Formatzeichenfolgen für Datum und Uhrzeit](~/docs/standard/base-types/custom-date-and-time-format-strings.md).)  
  
-   Alle Enumerationstypen. (Finden Sie unter [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).)  
  
-   <xref:System.TimeSpan>-Werte sind. (Finden Sie unter [TimeSpan-Standardformatzeichenfolgen](~/docs/standard/base-types/standard-timespan-format-strings.md) und [benutzerdefinierte TimeSpan-Formatzeichenfolgen](~/docs/standard/base-types/custom-timespan-format-strings.md).)  
  
-   GUIDs. (Finden Sie unter den <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> Methode.)  
  
 Beachten Sie jedoch, dass für jeden benutzerdefinierter Typ implementieren, kann <xref:System.IFormattable> oder Erweitern eines vorhandenen Typs <xref:System.IFormattable> Implementierung.  
  
 Im folgenden Beispiel wird die `alignment` und `formatString` Argumente, die formatierte Ausgabe erzeugen.  
  
 [!code-cpp[System.String.Format#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload2.cpp#9)]
 [!code-csharp-interactive[System.String.Format#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload2.cs#9)]
 [!code-vb[System.String.Format#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload2.vb#9)]  
  
<a name="HowFormatted"></a>   
## <a name="how-arguments-are-formatted"></a>Wie werden Argumente formatiert.  
 Formatelemente werden nacheinander vom Anfang der Zeichenfolge verarbeitet. Jedes Formatelement verfügt über einen Index, der auf ein Objekt in der Methode Argumentliste entspricht. Die <xref:System.String.Format%2A> Methode ruft das Argument und seine Zeichenfolgendarstellung wie folgt abgeleitet:  
  
-   Wenn das Argument ist `null`, die Methode fügt <xref:System.String.Empty?displayProperty=nameWithType> in die Ergebniszeichenfolge. Sie müssen keine kümmern Behandlung einer <xref:System.NullReferenceException> für null-Argumente. 
  
-   Aufrufen der <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> überladen und `provider` des Objekts <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> Implementierung gibt eine Wert ungleich Null zurück <xref:System.ICustomFormatter> -Implementierung, mit das Argument übergeben wird seine <xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode. Wenn das Formatelement enthält eine *FormatString* -Argument, es wird als erstes Argument an die Methode übergeben. Wenn die <xref:System.ICustomFormatter> Implementierung zur Verfügung und erzeugt eine nicht-Null-Zeichenfolge, die Zeichenfolge als die Zeichenfolgendarstellung des Arguments zurückgegeben wird; andernfalls der nächste Schritt ausgeführt wird.  
  
-   Wenn das Argument implementiert die <xref:System.IFormattable> -Schnittstelle, die <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> -Implementierung aufgerufen wird.  
  
-   Das Argument der parameterlosen `ToString` -Methode, die entweder überschreibt oder die Implementierung einer Basisklasse erbt, heißt.  
  
 Ein Beispiel für die fängt Aufrufe an die <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> Methode und ermöglicht Ihnen, welche Informationen das <xref:System.String.Format%2A> -Methode übergibt, einer Formatierungsmethode für jedes Formatelement in einer zusammengesetzten Formatzeichenfolge, finden Sie unter [Beispiel: Eine Konstante Glied-Anbieter und die römische Zahl Formatierungsprogramm](#Format7_Example).  

 Weitere Informationen finden Sie unter den [Verarbeitungsreihenfolge](~/docs/standard/base-types/composite-formatting.md##processing-order) im Abschnitt der [kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) Artikel.  
  
<a name="SameIndex"></a>   
## <a name="format-items-that-have-the-same-index"></a>Formatelemente, die den gleichen Index aufweisen.  
 Die <xref:System.String.Format%2A> -Methode löst eine <xref:System.FormatException> -Ausnahme aus, wenn der Index eines Elements der Index größer als oder gleich der Anzahl von Argumenten in der Argumentliste ist. Allerdings `format` zählen mehrere Formatelemente, die als Argumente vorhanden sind, als mehrere Formatelemente auf den gleichen Index aufweisen. Im Aufruf der <xref:System.String.Format%28System.String%2CSystem.Object%29> -Methode in der folgenden Beispiel wird die Argumentliste verfügt über ein einzelnes Argument, aber die Formatzeichenfolge enthält zwei Formatelemente: eine zeigt den Dezimalwert einer Zahl und das andere seinem Hexadezimalwert.  
  
 [!code-csharp-interactive[System.String.Format2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example1.cs#1)]
 [!code-vb[System.String.Format2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example1.vb#1)]  
  
<a name="Format_Culture"></a>   
## <a name="formatting-and-culture"></a>Formatierung und Kultur  
 Im Allgemeinen Objekte in der Argumentliste werden in konvertiert die zeichenfolgendarstellungen, die mithilfe der Konventionen der aktuellen Kultur, die von zurückgegeben wird das <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> Eigenschaft. Sie können dieses Verhalten steuern, indem Sie eine der Überladungen der <xref:System.String.Format%2A> , umfasst eine `provider` Parameter. Die `provider` -Parameter ist ein <xref:System.IFormatProvider> -Implementierung, die benutzerdefinierte und kulturspezifische Formatierungsinformationen bereitstellt, der verwendet wird, um die Formatierung Mittel zu verarbeiten.  
  
 Die <xref:System.IFormatProvider> Schnittstelle verfügt über einen einzelnen Member, <xref:System.IFormatProvider.GetFormat%2A>, ist zuständig für die Rückgabe des Objekts, das Formatierungsinformationen bereitstellt. .NET verfügt über drei <xref:System.IFormatProvider> Implementierungen, die kulturspezifische Formatierung bereitzustellen:  
  
-   <xref:System.Globalization.CultureInfo>. Die <xref:System.Globalization.CultureInfo.GetFormat%2A> Methodenrückgabe eine kulturspezifische <xref:System.Globalization.NumberFormatInfo> Objekt zum Formatieren von numerischen Werten und eine kulturspezifische <xref:System.Globalization.DateTimeFormatInfo> Objekt zum Formatieren von Datums-und Uhrzeitwerte.  
  
-   <xref:System.Globalization.DateTimeFormatInfo>, die für die kulturabhängige Formatierung von Datums-und Uhrzeitwerte verwendet wird. Die <xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A> -Methode sich selbst zurückgibt.  
  
-   <xref:System.Globalization.NumberFormatInfo>, die für die kulturabhängige Formatierung von numerischen Werten verwendet wird. Die <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> Eigenschaft sich selbst zurückgibt. 

<a name="Format_Custom"></a>   
## <a name="custom-formatting-operations"></a>Benutzerdefinierte Formatierung Vorgänge  
 Sie können auch eine der Überladungen der Aufrufen der <xref:System.String.Format%2A> Methode, die eine `provider` Parameter vom Typ <xref:System.IFormatProvider> zum Ausführen von Vorgängen für benutzerdefinierte Formatierung. Sie können z. B. eine ganze Zahl als eine ID oder eine Telefonnummer formatieren. Benutzerdefinierte Formatierung Ausführen Ihrer `provider` Argument muss beide implementieren die <xref:System.IFormatProvider> und <xref:System.ICustomFormatter> Schnittstellen. Bei der <xref:System.String.Format%2A> -Methode übergeben ein <xref:System.ICustomFormatter> Implementierung als die `provider` -Argument, die <xref:System.String.Format%2A> Methodenaufrufe der <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> Implementierung und fordert ein Objekt vom Typ <xref:System.ICustomFormatter>. Es ruft dann die zurückgegebene <xref:System.ICustomFormatter> des Objekts <xref:System.ICustomFormatter.Format%2A> Methode zum Formatieren der einzelnen Elemente in der zusammengesetzten Zeichenfolge übergeben.  
  
 Weitere Informationen zum Bereitstellen von benutzerdefinierter Formatierung Lösungen finden Sie unter [Vorgehensweise: Definieren und Verwenden von benutzerdefinierten Zahlenformatanbietern](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md) und <xref:System.ICustomFormatter>. Ein Beispiel, das ganze Zahlen in formatierte benutzerdefinierte Zahlen konvertiert, finden Sie unter [Beispiel: Einen benutzerdefinierten Formatierungsvorgang](#Format6_Example). Ein Beispiel, das Bytes ohne Vorzeichen in römischen Ziffern konvertiert werden, finden Sie unter [Beispiel: Eine Konstante Glied-Anbieter und die römische Zahl Formatierungsprogramm](#Format7_Example).  
  
<a name="Format6_Example"></a>   
### <a name="example-a-custom-formatting-operation"></a>Beispiel: Einen benutzerdefinierten Formatierungsvorgang  
 Dieses Beispiel definiert einen Formatanbieter, der einen ganzzahligen Wert als die Kontonummer eines Kunden in der Form X-Xxxxx-Xx formatiert.  
  
 [!code-cpp[System.String.Format#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample2.cpp#2)]
 [!code-csharp-interactive[System.String.Format#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/FormatExample2.cs#2)]
 [!code-vb[System.String.Format#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/FormatExample2.vb#2)]  
  
<a name="Format7_Example"></a>   
### <a name="example-an-intercept-provider-and-roman-numeral-formatter"></a>Beispiel: Eine Konstante Glied-Anbieter und die römische Zahl Formatierungsprogramm  
 Dieses Beispiel definiert einen benutzerdefiniertes Format-Anbieter, implementiert die <xref:System.ICustomFormatter> und <xref:System.IFormatProvider> Schnittstellen für zwei Dinge tun:  
  
-   Es zeigt die Parameter, die an die <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> Implementierung. Dies ermöglicht uns, welche Parameter finden Sie unter den <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> übergeben Methode ist für die benutzerdefinierte Formatierung Implementierung für jedes Objekt, das er versucht, zu formatieren. Dies kann nützlich sein, wenn Sie Ihre Anwendung debuggen.  
  
-   Wenn das Objekt zu formatierenden einen Bytewert ohne Vorzeichen, die mit der standardmäßigen Formatzeichenfolge "R" formatiert sein, formatiert das benutzerdefinierte Formatierungsprogramm den numerischen Wert als einer römischen Zahl.  
  
 [!code-cpp[System.String.Format#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/interceptor2.cpp#11)]
 [!code-csharp-interactive[System.String.Format#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/interceptor2.cs#11)]
 [!code-vb[System.String.Format#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/interceptor2.vb#11)]  
  
<a name="QA"></a>   
## <a name="stringformat-q--a"></a>"String.Format"-F & A  
  
### <a name="why-do-you-recommend-string-interpolation-over-calls-to-the-stringformat-method"></a>Warum empfehlen Sie zeichenfolgeninterpolation über Aufrufe an die `String.Format` Methode?

Zeichenfolgeninterpolation ist:

- Mehr Flexibilität. Es kann eine beliebige Zeichenfolge ohne einen Aufruf einer Methode, die kombinierte Formatierung unterstützen verwendet werden. Andernfalls muss der <xref:System.String.Format%2A> -Methode oder eine andere Methode, die kombinierte Formatierung, z. B. unterstützt <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> oder <xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType>. 

- Besser lesbar. Da der Ausdruck zum Einfügen in eine Zeichenfolge in der interpolierte Ausdruck nicht in einer Argumentliste angezeigt wird, sind interpolierte Zeichenfolgen viel einfacher, Code zu lesen. Aufgrund ihrer bessere Lesbarkeit interpolierte Zeichenfolgen können nicht nur Aufrufe von Methoden für zusammengesetzte ersetzen, aber sie können auch in zeichenfolgenverkettung verwendet werden, um präziseren Code klarer zu erzeugen. 

Ein Vergleich der folgenden beiden Codebeispiele veranschaulicht der Überlegenheit von interpolierten Zeichenfolgen verketten von Zeichenfolgen und Aufrufe von Methoden zur kombinierten Formatierung. Die Verwendung von mehreren zeichenfolgenverkettung im folgenden Beispiel erzeugt ausführliche und schwer lesbaren Code.

[!code-csharp-interactive[non-interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated1.cs)]
[!code-vb[non-interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated1.vb)]  

Im Gegensatz dazu die Verwendung von interpolierte Zeichenfolgen im folgenden Beispiel erzeugen viel klarer Code präziser als die Zeichenfolge verketten-Anweisung und der Aufruf von der <xref:System.String.Format%2A> -Methode in der im vorherigen Beispiel.

[!code-csharp-interactive[interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated2.cs)]
[!code-vb[interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated2.vb)]  

### <a name="where-can-i-find-a-list-of-the-predefined-format-strings-that-can-be-used-with-format-items"></a>Wo finde ich eine Liste der vordefinierten Formatzeichenfolgen, die mit einem Formatelement verwendet werden können?  
  
-   Alle Typen für Ganzzahl- und Gleitkommatypen finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Datum und Uhrzeit-Werten, finden Sie unter [Standardformatzeichenfolgen für Datum und Uhrzeit-Formatzeichenfolgen](~/docs/standard/base-types/standard-date-and-time-format-strings.md) und [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Enumerationswerte, finden Sie unter [Enumerationsformatzeichenfolgen](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Für <xref:System.TimeSpan> Werte finden Sie unter [TimeSpan-Standardformatzeichenfolgen](~/docs/standard/base-types/standard-timespan-format-strings.md) und [benutzerdefinierte TimeSpan-Formatzeichenfolgen](~/docs/standard/base-types/custom-timespan-format-strings.md).  
  
-   Für <xref:System.Guid> Werte finden Sie im Abschnitt "Hinweise" der <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> Referenzseite.  
  
### <a name="how-do-i-control-the-alignment-of-the-result-strings-that-replace-format-items"></a>Wie steuere ich die Ausrichtung des Ergebniszeichenfolgen, die Formatelemente ersetzen?  
 Die allgemeine Syntax eines Formatelements ist:  
  
```  
{index[,alignment][: formatString]}  
```  
  
 wo *Ausrichtung* ist eine Ganzzahl mit Vorzeichen, die die Breite des Felds definiert. Wenn dieser Wert negativ ist, wird Text in das Feld linksbündig ausgerichtet. Wenn sie positiv ist, ist Text rechtsbündig ausgerichtet.  
  
### <a name="how-do-i-control-the-number-of-digits-after-the-decimal-separator"></a>Wie steuere ich die Anzahl der Ziffern nach dem Dezimaltrennzeichen?  
 Alle [standardmäßige numerische Formatzeichenfolgen](~/docs/standard/base-types/standard-numeric-format-strings.md) mit Ausnahme von "D" (die mit nur ganze Zahlen verwendet wird), "G", "R" und "X" ermöglichen ein Genauigkeitsbezeichner angegeben, die die Anzahl von Dezimalstellen in der Ergebniszeichenfolge definiert. Im folgenden Beispiel wird die standardmäßige numerische Formatzeichenfolgen, die Anzahl von Dezimalstellen in der Ergebniszeichenfolge steuern.  
  
 [!code-csharp-interactive[System.String.Format#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa26.cs#26)]
 [!code-vb[System.String.Format#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa26.vb#26)]  
  
 Bei Verwendung einer [benutzerdefinierte numerische Formatzeichenfolge](~/docs/standard/base-types/custom-numeric-format-strings.md), den Formatbezeichner "0" zum Steuern der Anzahl von Dezimalstellen in der Ergebniszeichenfolge enthält, wie im folgenden Beispiel gezeigt verwenden.  
  
 [!code-csharp-interactive[System.String.Format#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa27.cs#27)]
 [!code-vb[System.String.Format#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa27.vb#27)]  
  
### <a name="how-do-i-control-the-number-of-integral-digits"></a>Wie steuere ich die Anzahl von ganzzahligen Ziffern?  
 Standardmäßig werden Formatierungsvorgängen nur ungleich NULL ganzzahlige Ziffern angezeigt. Wenn Sie ganze Zahlen formatieren, können Sie ein Genauigkeitsbezeichner angegeben, mit der "D" und "X" standard verwendete Formatzeichenfolgen, zum Steuern der Anzahl von Ziffern.  
  
 [!code-csharp-interactive[System.String.Format#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa29.cs#29)]
 [!code-vb[System.String.Format#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa29.vb#29)]  
  
 Können Sie eine ganze Zahl oder Gleitkommazahl mit führenden Nullen, um eine Ergebniszeichenfolge, die mit einer angegebenen Anzahl von ganzzahligen Ziffern zu erzeugen, mithilfe von "0" Auffüllen [benutzerdefinierten numerischen Format Specifier](~/docs/standard/base-types/custom-numeric-format-strings.md), wie im folgende Beispiel gezeigt.  
  
 [!code-csharp-interactive[System.String.Format#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa28.cs#28)]
 [!code-vb[System.String.Format#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa28.vb#28)]  
  
### <a name="how-many-items-can-i-include-in-the-format-list"></a>Wie viele Elemente kann ich in der Formatliste aufnehmen?  
 Es ist praktisch unbeschränkt. Der zweite Parameter von der <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> Methode wird mit markiert die <xref:System.ParamArrayAttribute> -Attribut, das Ihnen ermöglicht, die entweder eine durch Trennzeichen getrennte Liste oder ein Objektarray als Formatliste enthalten.  
  
<a name="braces"></a>
### <a name="how-do-i-include-literal-braces--and--in-the-result-string"></a>Wie beziehe ich ein literal geschweifte Klammern ("{" und "}") in der Ergebniszeichenfolge?  
 Z. B. wie Sie verhindern, dass den folgende Methodenaufruf vom Auslösen einer <xref:System.FormatException> Ausnahme?  
  
 [!code-csharp[System.String.Format#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#23)]
 [!code-vb[System.String.Format#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#23)]  
  
 Eine einzelne öffnende oder schließende geschweifte Klammer wird immer als Anfang oder Ende eines Formatelements interpretiert. Um die interpretiert werden, muss er mit Escapezeichen versehen werden. Sie eine geschweifte Klammer durch Hinzufügen einer anderen geschweiften Klammern mit Escapezeichen versehen ("{{" und "}}" anstelle von "{" und "}"), wie in den folgenden Methodenaufruf:  
  
 [!code-csharp-interactive[System.String.Format#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#24)]
 [!code-vb[System.String.Format#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#24)]  
  
 Geschweifte Klammern selbst mit Escapezeichen gibt allerdings leicht falsch interpretiert. Es wird empfohlen, dass Sie die geschweiften Klammern, in der Formatliste einschließen und Formatelementen zum Einfügen in der Ergebniszeichenfolge enthält, wie im folgenden Beispiel gezeigt verwenden.  
  
 [!code-csharp-interactive[System.String.Format#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#25)]
 [!code-vb[System.String.Format#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#25)]  
  
### <a name="why-does-my-call-to-the-stringformat-method-throw-a-formatexception"></a>Warum wird meine Aufruf der Methode "String.Format" FormatException ausgelöst?  
 Die häufigste Ursache der Ausnahme ist, dass der Index eines Formatelements entspricht nicht auf ein Objekt in der Formatliste definiert. In der Regel bedeutet dies, Sie die Indizes der Formatelemente misnumbered haben oder Sie vergessen haben, ein Objekt in der Formatliste einfügen möchten. Es wird versucht, einen ohne Escapezeichen linke oder rechte Klammer Zeichen auch löst eine <xref:System.FormatException>. In einigen Fällen ist die Ausnahme das Ergebnis war ein Tippfehler; ein typischer Fehler ist beispielsweise falsch eingeben "[" (die öffnende Klammer) anstelle von "{" (die linke geschweifte Klammer).  
  
### <a name="if-the-formatsystemiformatprovidersystemstringsystemobject-method-supports-parameter-arrays-why-does-my-code-throw-an-exception-when-i-use-an-array"></a>Wenn die Methode Format(System.IFormatProvider,System.String,System.Object[]) Parameterarrays, warum mein Code eine Ausnahme auslöst unterstützt, wenn ich ein Array verwenden?  
 Der folgende code beispielsweise löst ein <xref:System.FormatException> Ausnahme:  
  
 [!code-csharp[System.String.Format#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa1.cs#21)]
 [!code-vb[System.String.Format#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa1.vb#21)]  
  
 Dies ist ein Problem der überladungsauflösung des Compiler. Da der Compiler ein Array von Ganzzahlen in ein Objektarray konvertieren kann, es wird das ganze Zahl Array als ein einzelnes Argument, aufruft und es dem <xref:System.String.Format%28System.String%2CSystem.Object%29> Methode. Die Ausnahme wird ausgelöst, da es vier Formatelemente aber nur ein einzelnes Element in der Formatliste gibt.  
  
 Da weder Visual Basic oder c# ein Array von Ganzzahlen in ein Objektarray konvertieren kann, haben Sie zum Durchführen der Konvertierung selbst vor dem Aufruf der <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> Methode. Im folgenden Beispiel wird eine Implementierung.  
  
 [!code-csharp-interactive[System.String.Format#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa2.cs#22)]
 [!code-vb[System.String.Format#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa2.vb#22)]  

## Examples

Zahlreiche Beispiele, die aufgerufen werden die <xref:System.String.Format%2A> Methode vermischt werden, über die ["Hinweise"](#remarks) Abschnitt dieses Artikels.  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

Sie können auch einen vollständigen Satz von `String.Format` Beispiele, die enthalten sind ein [.NET Core 2.0-Projekt für C#-Code](https://github.com/dotnet/samples/raw/master/snippets/csharp/downloads/api/System/String.Format.zip) und [.NET Core 2.0-Projekt für Visual Basic](https://github.com/dotnet/samples/raw/master/snippets/visualbasic/downloads/api/System/String.Format.zip), aus der [Dotnet / GitHub-beispielrepository](https://github.com/dotnet/samples).

Im folgenden werden einige der Beispiele in diesem Artikel enthalten:

### <a name="create-a-format-string"></a>Erstellen Sie eine Formatzeichenfolge

[Eine Zeichenfolge eingefügt](#inserting-a-string)  
[Das Formatelement](#the-format-item)  
[Formatelemente, die den gleichen Index aufweisen.](#format-items-that-have-the-same-index)

### <a name="control-formatted-output"></a>Steuern Sie formatierten Ausgabe

[Steuern der Formatierung](#controlling-formatting)  
[Steuern der Abstand](#controlling-spacing)  
[Steuern der Ausrichtung](#controlling-alignment)  
[Steuern der Anzahl von ganzzahligen Ziffern](#how-do-i-control-the-number-of-integral-digits)  
[Steuern die Anzahl der Ziffern nach dem Dezimaltrennzeichen](#how-do-i-control-the-number-of-digits-after-the-decimal-separator)  
[Literale geschweifte Klammern einschließlich in eine Ergebniszeichenfolge](#braces)  

### <a name="make-format-strings-culture-sensitive"></a>Stellen Sie Formatzeichenfolgen kulturabhängige

[Kulturabhängige Formatierung](#culture-sensitive-formatting)  

### <a name="customize-the-formatting-operation"></a>Anpassen des Formatierungsvorgangs

[Einen benutzerdefinierten Formatierungsvorgang](#example-a-custom-formatting-operation)  
[Eine Konstante Glied-Anbieter und die römische Zahl Formatierungsprogramm](#example-an-intercept-provider-and-roman-numeral-formatter)  

 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standard-Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Benutzerdefinierte Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">TimeSpan-Standardformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Benutzerdefinierte TimeSpan-Formatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Enumerationsformatzeichenfolgen</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj -&gt; string" Usage="System.string.Format (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Eine [kombinierte Formatzeichenfolge](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Das zu formatierende Objekt.</param>
        <summary>Ersetzt mindestens ein Formatelement in einer Zeichenfolge durch die Zeichenfolgendarstellung eines angegebenen Objekts.</summary>
        <returns>Eine Kopie von <paramref name="format" />, in der alle Formatelemente durch die Zeichenfolgendarstellung von <paramref name="arg0" /> ersetzt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Diese Methode verwendet die [Funktion für kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) , den Wert eines Ausdrucks in seine Zeichenfolgendarstellung zu konvertieren und diese Darstellung in einer Zeichenfolge einzubetten. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-a-single-argument"></a>Beispiel: Formatieren ein einzelnes argument  
 
 Im folgenden Beispiel wird die <xref:System.String.Format%28System.String%2CSystem.Object%29> Methode, um das Alter einer Einzelperson in der Mitte einer Zeichenfolge einzubetten.  
  
 [!code-cpp[System.String.Format#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format7.cpp#7)]
 [!code-csharp-interactive[System.String.Format#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format7.cs#7)]
 [!code-vb[System.String.Format#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format7.vb#7)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Das Formatelement in <paramref name="format" /> ist ungültig.  
  
- oder -  
Der Index eines Formatelements ist nicht 0 (null).</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standard-Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Benutzerdefinierte Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">TimeSpan-Standardformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Benutzerdefinierte TimeSpan-Formatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Enumerationsformatzeichenfolgen</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj[] -&gt; string" Usage="System.string.Format (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Eine [kombinierte Formatzeichenfolge](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="args">Ein Objektarray mit 0 (null) oder mehr zu formatierenden Objekten.</param>
        <summary>Ersetzt das Formatelement in einer angegebenen Zeichenfolge durch die Zeichenfolgendarstellung eines entsprechenden Objekts in einem angegebenen Array.</summary>
        <returns>Eine Kopie von <paramref name="format" />, in der die Formatelemente durch die Zeichenfolgendarstellung der entsprechenden Objekte in <paramref name="args" /> ersetzt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Diese Methode verwendet die [Funktion für kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) , den Wert der vier oder mehr Ausdrücke, deren Zeichenfolgenrepräsentationen konvertieren und diese Darstellungen in eine Zeichenfolge einzubetten. Da die `args` Parameter markiert wird, mit der <xref:System.ParamArrayAttribute?displayProperty=nameWithType> -Attribut, Sie können die Objekte an die Methode übergeben als einzelne Argumente oder als ein <xref:System.Object> Array. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-more-than-three-arguments"></a>Beispiel: Formatieren von mehr als drei Argumente  
 
 Dieses Beispiel erstellt eine Zeichenfolge, die Daten für die Höchst- und Tiefsttemperatur für ein bestimmtes Datum enthält. Die zusammengesetzte Formatierungszeichenfolge verfügt über fünf Formatelemente in c#-Beispiel und sechs in Visual Basic-Beispiel. Zwei der die Formatelemente definieren die Breite des Werts, auf die entsprechende Zeichenfolgendarstellung und das erste Formatelement enthält auch einen Standardformatbezeichner für Datum und Uhrzeit-Formatzeichenfolge.  
  
 [!code-cpp[System.String.Format#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format5.cpp#5)]
 [!code-csharp-interactive[System.String.Format#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format5.cs#5)]
 [!code-vb[System.String.Format#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format5.vb#5)]  
  
 Sie können auch übergeben der Objekte, die als Array formatiert werden anstelle eines Argumentliste enthalten.  
  
 [!code-cpp[System.String.Format#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format_paramarray1.cpp#10)]
 [!code-csharp-interactive[System.String.Format#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format_paramarray1.cs#10)]
 [!code-vb[System.String.Format#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format_paramarray1.vb#10)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> oder <paramref name="args" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> ist ungültig.  
  
- oder -  
Der Index eines Formatelements ist kleiner als 0 (null) oder größer oder gleich der Länge des <paramref name="args" />-Arrays.</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standard-Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Benutzerdefinierte Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">TimeSpan-Standardformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Benutzerdefinierte TimeSpan-Formatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Enumerationsformatzeichenfolgen</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj -&gt; string" Usage="System.string.Format (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <param name="format">Eine [kombinierte Formatzeichenfolge](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Das zu formatierende Objekt.</param>
        <summary>Ersetzt die Formatelemente in einer angegebenen Zeichenfolge durch die Zeichenfolgendarstellung des angegebenen Objekts. Ein Parameter liefert kulturspezifische Formatierungsinformationen.</summary>
        <returns>Eine Kopie von <paramref name="format" />, in der die Formatelemente durch die Zeichenfolgendarstellung von <paramref name="arg0" /> ersetzt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Diese Methode verwendet die [Funktion für kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) , den Wert eines Ausdrucks in seine Zeichenfolgendarstellung zu konvertieren und diese Darstellung in einer Zeichenfolge einzubetten. Beim Durchführen der Konvertierung, verwendet die Methode, kulturabhängige Formatierung oder einen benutzerdefinierten Formatierer. Konvertiert die Methode `arg0` in seine Zeichenfolgendarstellung durch Aufrufen der **ToString(IFormatProvider)** Methode oder das Objekt entsprechende schließt Formatelement, das eine Formatzeichenfolge, durch den Aufruf der **ToString () String, IFormatProvider)** Methode. Wenn diese Methoden nicht vorhanden sind, ruft das Objekt die parameterlosen **ToString** Methode.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> ist ungültig.  
  
- oder -  
Der Index eines Formatelements ist nicht 0 (null).</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj[] -&gt; string" Usage="System.string.Format (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <param name="format">Eine [kombinierte Formatzeichenfolge](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="args">Ein Objektarray mit 0 (null) oder mehr zu formatierenden Objekten.</param>
        <summary>Ersetzt die Formatelemente in einer Zeichenfolge durch die Zeichenfolgendarstellungen entsprechender Objekte in einem angegebenen Array. Ein Parameter liefert kulturspezifische Formatierungsinformationen.</summary>
        <returns>Eine Kopie von <paramref name="format" />, in der die Formatelemente durch die Zeichenfolgendarstellung der entsprechenden Objekte in <paramref name="args" /> ersetzt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Diese Methode verwendet die [Funktion für kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) , vier oder mehr Ausdrücke in ihre Zeichenfolgendarstellung konvertieren und diese Darstellungen in eine Zeichenfolge einzubetten. Beim Durchführen der Konvertierung, verwendet die Methode, kulturabhängige Formatierung oder einen benutzerdefinierten Formatierer. Die Methode konvertiert jede <xref:System.Object> Argument in seine Zeichenfolgendarstellung durch Aufrufen der **ToString(IFormatProvider)** Methode oder das Objekt entsprechende schließt Formatelement, das eine Formatzeichenfolge, durch Aufrufen der **ToString(String,IFormatProvider)** Methode. Wenn diese Methoden nicht vorhanden sind, ruft das Objekt die parameterlosen **ToString** Methode.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
## <a name="example-culture-sensitive-formatting"></a>Beispiel: Kulturabhängige Formatierung  
 Dieses Beispiel verwendet die <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> Methode, um die Zeichenfolgendarstellung für einige Datums-und Uhrzeitwerte und numerische Werte anzeigen, indem Sie verschiedene Kulturen verwenden.  
  
 [!code-csharp-interactive[System.String.Format2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example2.cs#2)]
 [!code-vb[System.String.Format2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example2.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> oder <paramref name="args" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> ist ungültig.  
  
- oder -  
Der Index eines Formatelements ist kleiner als 0 (null) oder größer oder gleich der Länge des <paramref name="args" />-Arrays.</exception>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.ICustomFormatter" />
        <altmember cref="T:System.IFormatProvider" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standard-Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Benutzerdefinierte Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">TimeSpan-Standardformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Benutzerdefinierte TimeSpan-Formatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Enumerationsformatzeichenfolgen</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Eine [kombinierte Formatzeichenfolge](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Das erste zu formatierende Objekt.</param>
        <param name="arg1">Das zweite zu formatierende Objekt.</param>
        <summary>Ersetzt die Formatelemente in einer Zeichenfolge durch die Zeichenfolgendarstellung von zwei angegebenen Objekten.</summary>
        <returns>Eine Kopie von <paramref name="format" />, in der Formatelemente durch die Zeichenfolgendarstellung von <paramref name="arg0" /> und <paramref name="arg1" /> ersetzt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Diese Methode verwendet die [Funktion für kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) , den Wert von zwei Ausdrücken, deren Zeichenfolgenrepräsentationen konvertieren und diese Darstellungen in eine Zeichenfolge einzubetten. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-two-arguments"></a>Beispiel: Formatieren von zwei Argumenten  
 
 Dieses Beispiel verwendet die <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29> anzuzeigenden Zeit und Temperatur-Daten in einer generischen Methode <xref:System.Collections.Generic.Dictionary%602> Objekt. Beachten Sie, dass die Zeichenfolge drei Formatelemente, allerdings nur zwei stehen zu formatierenden Objekten. Dies ist das erste Objekt in der Liste (ein Wert für Datum und Uhrzeit) von zwei Formatelemente verwendet: Das erste Format Element zeigt die Zeit, und die zweite zeigt das Datum an.  
  
 [!code-cpp[System.String.Format#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample4.cpp#6)]
 [!code-csharp-interactive[System.String.Format#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatexample4.cs#6)]
 [!code-vb[System.String.Format#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatexample4.vb#6)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> ist ungültig.  
  
- oder -  
Der Index eines Formatelements ist nicht 0 (null) oder 1.</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standard-Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Benutzerdefinierte Formatzeichenfolgen für Datum und Uhrzeit</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">TimeSpan-Standardformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Benutzerdefinierte TimeSpan-Formatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Enumerationsformatzeichenfolgen</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <param name="format">Eine [kombinierte Formatzeichenfolge](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Das erste zu formatierende Objekt.</param>
        <param name="arg1">Das zweite zu formatierende Objekt.</param>
        <summary>Ersetzt die Formatelemente in einer Zeichenfolge durch die Zeichenfolgendarstellung von zwei angegebenen Objekten. Ein Parameter liefert kulturspezifische Formatierungsinformationen.</summary>
        <returns>Eine Kopie von <paramref name="format" />, in der Formatelemente durch die Zeichenfolgendarstellung von <paramref name="arg0" /> und <paramref name="arg1" /> ersetzt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Diese Methode verwendet die [Funktion für kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) , zwei Ausdrücke in ihre Zeichenfolgendarstellung konvertieren und diese Darstellungen in eine Zeichenfolge einzubetten. Beim Durchführen der Konvertierung, verwendet die Methode, kulturabhängige Formatierung oder einen benutzerdefinierten Formatierer. Die Methode konvertiert jede <xref:System.Object> Argument in seine Zeichenfolgendarstellung durch Aufrufen der **ToString(IFormatProvider)** Methode oder das Objekt entsprechende schließt Formatelement, das eine Formatzeichenfolge, durch Aufrufen der **ToString(String,IFormatProvider)** Methode. Wenn diese Methoden nicht vorhanden sind, ruft das Objekt die parameterlosen **ToString** Methode.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> ist ungültig.  
  
- oder -  
Der Index eines Formatelements ist nicht 0 (null) oder 1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Eine [kombinierte Formatzeichenfolge](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Das erste zu formatierende Objekt.</param>
        <param name="arg1">Das zweite zu formatierende Objekt.</param>
        <param name="arg2">Das dritte zu formatierende Objekt.</param>
        <summary>Ersetzt die Formatelemente in einer Zeichenfolge durch die Zeichenfolgendarstellung von drei angegebenen Objekten.</summary>
        <returns>Eine Kopie von <paramref name="format" />, in der die Formatelemente durch die Zeichenfolgendarstellung von <paramref name="arg0" />, <paramref name="arg1" /> und <paramref name="arg2" /> ersetzt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Diese Methode verwendet die [Funktion für kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) um den Wert der drei Ausdrücke, deren Zeichenfolgenrepräsentationen konvertieren und diese Darstellungen in eine Zeichenfolge einzubetten. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-three-arguments"></a>Beispiel: Formatieren von drei Argumenten  
 
 Dieses Beispiel verwendet die <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> Methode, um eine Zeichenfolge zu erstellen, die das Ergebnis von booleschen Werten veranschaulicht `And` Vorgang mit zwei ganzzahligen Werten. Beachten Sie, dass die Formatzeichenfolge sechs Formatelemente enthält, aber die Methode nur drei Elemente in der Parameterliste hat, da jedes Element auf zwei verschiedene Arten formatiert ist.  
  
 [!code-cpp[System.String.Format#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format4.cpp#4)]
 [!code-csharp-interactive[System.String.Format#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format4.cs#4)]
 [!code-vb[System.String.Format#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format4.vb#4)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> ist ungültig.  
  
- oder -  
Der Index eines Formatelements ist kleiner als 0 (null) oder größer als 2.</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Kombinierte Formatierung</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <param name="format">Eine [kombinierte Formatzeichenfolge](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Das erste zu formatierende Objekt.</param>
        <param name="arg1">Das zweite zu formatierende Objekt.</param>
        <param name="arg2">Das dritte zu formatierende Objekt.</param>
        <summary>Ersetzt die Formatelemente in einer Zeichenfolge durch die Zeichenfolgendarstellung von drei angegebenen Objekten. Ein Parameter liefert kulturspezifische Formatierungsinformationen.</summary>
        <returns>Eine Kopie von <paramref name="format" />, in der die Formatelemente durch die Zeichenfolgendarstellung von <paramref name="arg0" />, <paramref name="arg1" /> und <paramref name="arg2" /> ersetzt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Diese Methode verwendet die [Funktion für kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) , drei Ausdrücke in ihre Zeichenfolgendarstellung konvertieren und diese Darstellungen in eine Zeichenfolge einzubetten. Beim Durchführen der Konvertierung, verwendet die Methode, kulturabhängige Formatierung oder einen benutzerdefinierten Formatierer. Die Methode konvertiert jede <xref:System.Object> Argument in seine Zeichenfolgendarstellung durch Aufrufen der **ToString(IFormatProvider)** Methode oder das Objekt entsprechende schließt Formatelement, das eine Formatzeichenfolge, durch Aufrufen der **ToString(String,IFormatProvider)** Methode. Wenn diese Methoden nicht vorhanden sind, ruft das Objekt die parameterlosen **ToString** Methode.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> ist ungültig.  
  
- oder -  
Der Index eines Formatelements ist kleiner als 0 (null) oder größer als 2.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public CharEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.CharEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As CharEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CharEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; CharEnumerator" Usage="string.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CharEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft ein Objekt ab, das die einzelnen Zeichen dieser Zeichenfolge durchlaufen kann.</summary>
        <returns>Ein Enumeratorobjekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
> Anstatt Aufrufen der <xref:System.String.GetEnumerator%2A> Methode zum Abrufen einer <xref:System.CharEnumerator> Objekt, das Sie verwenden, um eine Zeichenfolge aufgelistet werden, verwenden Sie stattdessen die Sprache des Iteration-Konstrukt (in c# in C++ / CLR, und in Visual Basic). [Foreach](~/docs/csharp/language-reference/keywords/foreach-in.md) in c# [für jede](/cpp/dotnet/for-each-in) in C++ / CLR und [für jede](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md) in Visual Basic).
  
 Diese Methode können Sie die einzelnen Zeichen in einer Zeichenfolge zu durchlaufen. Z. B. Visual Basic `For Each` und C#- `foreach` -Anweisungen Aufrufen dieser Methode zurückgeben einer <xref:System.CharEnumerator> Objekt, das nur-Lese Zugriff auf die Zeichen in dieser Zeichenfolgeninstanz bereitstellen kann.  
  
   
  
## Examples  
 Das folgende Beispiel durchläuft die Zeichen in der mehrere Zeichenfolgen und zeigt Informationen zu den einzelnen Zeichen. Er verwendet das Language-Iteration-Konstrukt, anstatt einen Aufruf der <xref:System.String.GetEnumerator%2A> Methode.  
  
 [!code-cpp[system.string.getenumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetEnumerator/CPP/getenumerator.cpp#1)]
 [!code-csharp[system.string.getenumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetEnumerator/CS/getenumerator.cs#1)]
 [!code-vb[system.string.getenumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetEnumerator/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
        <altmember cref="T:System.Collections.IEnumerable" />
        <altmember cref="P:System.String.Chars(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="string.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hashcode für diese Zeichenfolge zurück.</summary>
        <returns>Ein 32-Bit-Hashcode als ganze Zahl mit Vorzeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Verhalten der <xref:System.String.GetHashCode%2A> richtet sich nach der Implementierung, die von einer Version der common Language Runtime auf einen anderen ändern kann. Ein Grund, warum dies vorkommen kann, wird zur Verbesserung der Leistung von <xref:System.String.GetHashCode%2A>.  
  
> [!IMPORTANT]
>  Wenn zwei Zeichenfolgenobjekte gleich sind, die <xref:System.String.GetHashCode%2A> -Methode identische Werte zurück. Es ist jedoch kein eindeutigen Hashcodewert für jeden eindeutigen Zeichenfolgenwert. Verschiedene Zeichenfolgen können den gleichen Hashcode zurückgeben.  
>   
>  Der Hashcode selbst ist nicht garantiert, stabil sein. Hashcodes für identische Zeichenfolgen können in .NET-Implementierungen für .NET-Versionen und auf verschiedenen .NET-Plattformen (z. B. ein 32-Bit- und 64-Bit) für eine einzelne Version von .NET unterscheiden. In einigen Fällen können sie auch durch die Anwendungsdomäne unterscheiden. Dies bedeutet, dass zwei nachfolgende Ausführungen desselben Programms möglicherweise unterschiedliche Hashcodes zurückgeben.  
>   
>  Als Ergebnis Hash Codes niemals außerhalb der Anwendungsdomäne verwendet werden, sollte in der sie erstellt wurden, sollten nicht als wichtige Felder in einer Auflistung verwendet werden, und diese nie beibehalten werden sollen.  
>   
>  Abschließend verwenden Sie nicht den Hashcode anstelle eines Werts von einer kryptografischen Hashfunktion zurückgegeben wird, wenn Sie einen kryptographisch starken Hashwert benötigen. Für kryptografische Hashes, verwenden Sie eine von abgeleitete Klasse die <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> oder <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> Klasse.  
>   
>  Weitere Informationen zu Hashcodes finden Sie unter <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 In desktop-apps können Sie mithilfe der [ \<UseRandomizedStringHashAlgorithm >-Element](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md) zum Generieren von eindeutigen Hashcodes für eine pro Anwendungsdomäne. Die Anzahl der Konflikte reduzieren können und verbessern die allgemeine Leistung von einfügungen und Suchvorgängen, die Hashtabellen verwenden. Das folgende Beispiel zeigt, wie Sie mit der [ \<UseRandomizedStringHashAlgorithm >-Element](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md). Definiert eine zur Generierung der eindeutigen Hash-Codes auf einer pro Anwendungsdomäne. Die Anzahl der Konflikte reduzieren können und verbessern die allgemeine Leistung von einfügungen und Suchvorgängen, die Hashtabellen verwenden. Das folgende Beispiel zeigt, wie Sie mit der. Definiert eine `DisplayString` -Klasse, eine private Zeichenfolgenkonstante enthält `s`, deren Wert ist "Dies ist eine Zeichenfolge". Außerdem enthält sie eine `ShowStringHashCode`-Methode, die den Zeichenfolgenwert und dessen Hashcode zusammen mit dem Namen der Anwendungsdomäne anzeigt, in der die Methode ausgeführt wird.  
  
 [!code-csharp[System.String.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/perdomain.cs#2)]
 [!code-vb[System.String.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/perdomain.vb#2)]  
  
 Wenn Sie das Beispiel ausführen, ohne eine Konfigurationsdatei anzugeben, wird die folgende Ausgabe angezeigt. Beachten Sie, dass die Hashcodes für die Zeichenfolge in den zwei Anwendungsdomänen identisch sind.  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 941BCEAC  
String 'This is a string.' in domain 'NewDomain': 941BCEAC  
  
```  
  
 Wenn Sie jedoch die folgende Konfigurationsdatei im Verzeichnis des Beispiels hinzufügen und dann das Beispiel ausführen, unterscheiden sich die Hashcodes je nach Anwendungsdomäne.  
  
```xml  
  
<?xml version ="1.0"?>  
<configuration>  
   <runtime>  
      <UseRandomizedStringHashAlgorithm enabled="1" />  
   </runtime>  
</configuration>  
  
```  
  
 Wenn die Konfigurationsdatei vorhanden ist, zeigt das Beispiel die folgende Ausgabe an:  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 5435776D  
String 'This is a string.' in domain 'NewDomain': 75CC8236  
  
```  
  
> [!IMPORTANT]
>  Hashcodes dienen zum Einfügen und verschlüsselte Objekte von Hashtabellen effizient abrufen. Hashcodes Identifizierung Zeichenfolgen jedoch nicht. Identische Zeichenfolgen haben gleich Hashcodes, aber den gleichen Hashcode kann auch in andere Zeichenfolgen von die common Language Runtime zuweisen. Darüber hinaus können Hashcodes mit Version von .NET, nach Plattform in eine einzelne Version und von Anwendungsdomäne variieren. Aus diesem Grund sollten Sie nicht zu serialisieren oder Code-Hashwerte beibehalten, noch sollten Sie verwenden diese als Schlüssel in eine Hashtabelle oder Wörterbuch.  
  
 Weitere Informationen zur Verwendung von Hashcodes und `GetHashCode` -Methode finden Sie unter <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.String.GetHashCode%2A> Methode, die mit verschiedenen Eingabezeichenfolgen.  
  
 [!code-cpp[system.string.gethashcode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetHashCode/CPP/gethashcode.cpp#1)]
 [!code-csharp[system.string.gethashcode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/gethashcode.cs#1)]
 [!code-vb[system.string.gethashcode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/gethashcode.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Der Rückgabewert von <see cref="M:System.String.GetHashCode" /> ist plattformabhängig. Es unterscheidet sich auf die 32-Bit und 64-Bit-Versionen von .NET Framework. Sie können auch zwischen den Versionen von .NET Framework und .NET Core abweichen.</para></block>
        <altmember cref="M:System.Object.GetHashCode" />
        <related type="Article" href="https://msdn.microsoft.com/library/c08125d6-56cc-4b23-b482-813ff85dc630">&lt;UseRandomizedStringHashAlgorithm&gt; Element</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public int GetHashCode (StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetHashCode(valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHashCode (comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetHashCode(StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : StringComparison -&gt; int" Usage="string.GetHashCode comparisonType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="string.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen <see cref="T:System.TypeCode" /> für das <see cref="T:System.String" /> zurück.</summary>
        <returns>Die Enumerationskonstante <see cref="F:System.TypeCode.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.TypeCode> Enumerationskonstante, die für die <xref:System.String> Typ.  
  
 [!code-cpp[string.gettypecode#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.gettypecode/CPP/gtc.cpp#1)]
 [!code-csharp[string.gettypecode#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.gettypecode/CS/gtc.cs#1)]
 [!code-vb[string.gettypecode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.gettypecode/VB/gtc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens eines angegebenen Unicode-Zeichens oder einer angegebenen Unicode-Zeichenfolge in dieser Instanz an. Die Methode gibt -1 zurück, wenn das Zeichen oder die Zeichenfolge in dieser Instanz nicht gefunden wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Ein zu suchendes Unicode-Zeichen.</param>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens des angegebenen Unicode-Zeichens in dieser Zeichenfolge an.</summary>
        <returns>Die nullbasierte Indexposition von <paramref name="value" />, wenn dieses Zeichen gefunden wurde, andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Index die Nummerierung beginnt bei 0 (null).  
  
 Diese Methode führt eine ordinale (kulturunabhängige) Suche, in dem ein Zeichen als gleich betrachtet, ein anderes Zeichen nur dann, wenn die Unicode-Skalarwerten identisch sind. Um eine kulturabhängige Suche durchzuführen, verwenden die <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> -Methode, in dem ein Unicode-Skalarwert, ein zusammengesetztes Zeichen, z. B. die Ligatur "Æ" (U + 00 C 6) betrachtet werden kann entspricht jedem Vorkommen des Zeichens-Komponenten in der Korrigieren Sie die Sequenz, wie z. B. "AE" (U + 0041, U + 0045), je nach Kultur.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie Sie durchsucht eine <xref:System.String> für ein Zeichen mithilfe der <xref:System.String.IndexOf%2A> Methode.  
  
 [!code-cpp[System.String.IndexOf#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexof_c.cpp#5)]
 [!code-csharp[System.String.IndexOf#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexof_c.cs#5)]
 [!code-vb[System.String.IndexOf#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexof_c.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens der angegebenen Zeichenfolge in dieser Instanz an.</summary>
        <returns>Die nullbasierte Indexposition von <paramref name="value" />, wenn diese Zeichenfolge gefunden wurde, andernfalls -1. Wenn <paramref name="value" /> <see cref="F:System.String.Empty" /> ist, wird 0 zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Index die Nummerierung beginnt bei 0 (null).  
  
 Diese Methode führt eine Wortsuche (Groß-/Kleinschreibung beachtet und kulturabhängige) mit der aktuellen Kultur. Die Suche beginnt an der Position des ersten Zeichens dieser Instanz und wird fortgesetzt, bis der letzten Zeichenposition.  
  
 Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Bei einer kulturabhängige Suche, bei der `value` ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen. Wenn `value` besteht nur aus ein oder mehrere Ignorierbare Zeichen, die <xref:System.String.IndexOf%28System.String%29> Methode gibt immer 0 (null), um anzugeben, dass die Übereinstimmung am Anfang der aktuellen Instanz gefunden wird. Im folgenden Beispiel die <xref:System.String.IndexOf%28System.String%29> Methode wird verwendet, um drei Teilzeichenfolgen (einen bedingten Bindestrich (U + 00AD), einen bedingten Bindestrich gefolgt von "n" und einen bedingten Bindestrich gefolgt von "m") in zwei Zeichenfolgen zu suchen. Nur eine der Zeichenfolgen enthält einen bedingten Bindestrich. Wenn Sie das Beispiel ausgeführt wird, auf die [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher in jedem Fall, da die bedingten Bindestrich ein ignorierbares Zeichen ist das Ergebnis ist identisch, als ob bedingten Bindestrichs nicht in einbezogen wurden, mussten `value`. Bei der Suche nach nur einen bedingten Bindestrich gibt die Methode 0 (null), um anzugeben, dass es eine Übereinstimmung am Anfang der Zeichenfolge gefunden wurde.  
  
 [!code-csharp[System.String.IndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable21.cs#21)]
 [!code-vb[System.String.IndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable21.vb#21)]  
  
   
  
## Examples  
 Das folgende Beispiel sucht nach "n" in "Tier". Da 0 (null) anstelle einer Zeichenfolge Indizes beginnen die <xref:System.String.IndexOf%28System.String%29> Methode gibt an, dass die "n" an Position 1.  
  
 [!code-cpp[System.String.IndexOf#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/simple1.cpp#12)]
 [!code-csharp[System.String.IndexOf#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/simple1.cs#12)]
 [!code-vb[System.String.IndexOf#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/simple1.vb#12)]  
  
 Im folgenden Beispiel wird die <xref:System.String.IndexOf%2A> Methode, um die Position des Tiernamens in einem Satz zu bestimmen. Diese Position dann verwendet, um ein Adjektiv einzufügen, die das Tier wird, in dem Satz beschrieben.  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Siehe [bewährte Methoden für die Verwendung von Zeichenfolgen](~/docs/standard/base-types/best-practices-strings.md), es wird empfohlen, dass Sie vermeiden, Aufrufen von Methoden zum Zeichenfolgenvergleich, die Standardwerte ersetzen, und rufen stattdessen die Methoden, die für Parameter explizit angegeben werden müssen. Um den ersten Index aus einer Unterzeichenfolge einer Zeichenfolgeninstanz mit die Vergleichsregeln der aktuellen Kultur zu suchen, rufen die <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> methodenüberladung mit einem Wert von <see cref="F:System.StringComparison.CurrentCulture" /> für seine `comparisonType` Parameter.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ein zu suchendes Unicode-Zeichen.</param>
        <param name="startIndex">Die Anfangsposition der Suche.</param>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens des angegebenen Unicode-Zeichens in dieser Zeichenfolge an. Die Suche beginnt an einer angegebenen Zeichenposition.</summary>
        <returns>Die nullbasierte Indexposition von <paramref name="value" /> ab dem Anfang der Zeichenfolge, wenn dieses Zeichen gefunden wurde, andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Index die Nummerierung beginnt bei 0. Der `startIndex`-Parameter kann von 0 bis zu der Länge der Zeichenfolgeninstanz reichen. Wenn `startIndex` entspricht der Länge der Zeichenfolgeninstanz, die Methode gibt-1 zurück.  
  
 Die Suche erfolgt von `startIndex` bis zum Ende der Zeichenfolge.  
  
 Diese Methode führt eine ordinale (kulturunabhängige) Suche, in dem ein Zeichen als gleich betrachtet, ein anderes Zeichen nur dann, wenn die Unicode-Skalarwerten identisch sind. Um eine kulturabhängige Suche durchzuführen, verwenden die <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> -Methode, in dem ein Unicode-Skalarwert, ein zusammengesetztes Zeichen, z. B. die Ligatur "Æ" (U + 00 C 6) betrachtet werden kann entspricht jedem Vorkommen des Zeichens-Komponenten in der Korrigieren Sie die Sequenz, wie z. B. "AE" (U + 0041, U + 0045), je nach Kultur.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.IndexOf%2A> Methode.  
  
 [!code-cpp[string.indexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof1/CPP/ixof1.cpp#1)]
 [!code-csharp[string.indexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof1/CS/ixof1.cs#1)]
 [!code-vb[string.indexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof1/VB/ixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> ist kleiner als 0 (null) oder größer als die Länge der Zeichenfolge.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Das zu suchende Zeichen.</param>
        <param name="comparisonType">Ein Enumerationswert, der die Regeln für die Suche festlegt.</param>
        <summary>Gibt den nullbasierte Index des ersten Vorkommens des angegebenen Unicode-Zeichens in dieser Zeichenfolge an. Ein Parameter gibt den Typ der Suche für das angegebene Zeichen an.</summary>
        <returns>Der nullbasierte Index von <paramref name="value" />, wenn dieses Zeichen gefunden wurde, andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Der Index die Nummerierung beginnt bei 0 (null).  
  
Die `comparisonType` -Parameter ist ein <xref:System.StringComparison> -Enumerationsmember, der angibt, ob die Suche nach der `value` Argument wird die aktuelle oder die invariante Kultur verwendet, wird die Groß- und Kleinschreibung beachten oder Word oder Ordinalvergleichsregeln verwendet.
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> ist kein gültiger <see cref="T:System.StringComparison" />-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <param name="startIndex">Die Anfangsposition der Suche.</param>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens der angegebenen Zeichenfolge in dieser Instanz an. Die Suche beginnt an einer angegebenen Zeichenposition.</summary>
        <returns>Die nullbasierte Indexposition von <paramref name="value" /> vom Anfang der aktuellen Instanz, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde. Wenn <paramref name="value" /> <see cref="F:System.String.Empty" /> ist, wird <paramref name="startIndex" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Index die Nummerierung beginnt bei 0. Der `startIndex`-Parameter kann von 0 bis zu der Länge der Zeichenfolgeninstanz reichen. Wenn `startIndex` entspricht der Länge der Zeichenfolgeninstanz, die Methode gibt-1 zurück.  
  
 Diese Methode führt eine Wortsuche (Groß-/Kleinschreibung beachtet und kulturabhängige) mit der aktuellen Kultur. Die Suche beginnt an der `startIndex` Zeichen Position dieser Instanz und wird fortgesetzt, bis der letzten Zeichenposition.  
  
 Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Bei einer kulturabhängige Suche, bei der `value` ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen. Wenn `value` besteht nur aus ein oder mehrere Ignorierbare Zeichen, die <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> Methode gibt immer `startIndex`, d.h. die Zeichenposition, an dem die Suche beginnt. Im folgenden Beispiel die <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> Methode wird verwendet, um die Position (U + 00AD) über einen bedingten Bindestrich gefolgt von einem "m" in zwei Zeichenfolgen zu suchen. Nur eine der Zeichenfolgen enthält die erforderliche Teilzeichenfolge. Wenn Sie das Beispiel ausgeführt wird, auf die [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher in beiden Fällen, da die bedingten Bindestrich ein ignorierbares Zeichen ist, wird die Methode gibt den Index des "m" in der Zeichenfolge. Beachten Sie, dass bei der ersten Zeichenfolge, die den bedingten Bindestrich gefolgt von einem "m" umfasst, die Methode den Index des bedingten Bindestrichs nicht zurückgeben kann, sondern stattdessen den Index des "m" zurückgibt.  
  
 [!code-csharp[System.String.IndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable22.cs#22)]
 [!code-vb[System.String.IndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable22.vb#22)]  
  
   
  
## Examples  
 Das folgende Beispiel sucht nach allen Vorkommen der angegebenen Zeichenfolge in eine Zielzeichenfolge.  
  
 [!code-cpp[stringindexof4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringindexof4/CPP/stringindexof4.cpp#1)]
 [!code-csharp[stringindexof4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringindexof4/CS/stringindexof4.cs#1)]
 [!code-vb[stringindexof4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringindexof4/VB/stringindexof4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> ist kleiner als 0 (null) oder größer als die Länge dieser Zeichenfolge.</exception>
        <block subset="none" type="usage"><para>Siehe [bewährte Methoden für die Verwendung von Zeichenfolgen](~/docs/standard/base-types/best-practices-strings.md), es wird empfohlen, dass Sie vermeiden, Aufrufen von Methoden zum Zeichenfolgenvergleich, die Standardwerte ersetzen, und rufen stattdessen die Methoden, die für Parameter explizit angegeben werden müssen. Um den ersten Index einer Teilzeichenfolge, die auftritt, nach einer bestimmten Zeichenposition mithilfe der Vergleichsregeln der aktuellen Kultur zu suchen, rufen die <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> methodenüberladung mit einem Wert von <see cref="F:System.StringComparison.CurrentCulture" /> für seine `comparisonType` Parameter.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <param name="comparisonType">Einer der Enumerationswerte, der die Regeln für die Suche angibt.</param>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens der angegebenen Zeichenfolge im aktuellen <see cref="T:System.String" />-Objekt an. Ein Parameter gibt den Typ der Suche für die angegebene Zeichenfolge an.</summary>
        <returns>Die Indexposition des <paramref name="value" />-Parameters, wenn diese Zeichenfolge gefunden wurde, andernfalls -1. Wenn <paramref name="value" /> <see cref="F:System.String.Empty" /> ist, wird 0 zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Index die Nummerierung beginnt bei 0 (null).  
  
 Die `comparisonType` Parameter gibt an, dass für die Suche die `value` Parameter unter Verwendung der aktuellen oder der invarianten Kultur, mithilfe einer Suche Groß- und Kleinschreibung beachtet und mithilfe von Word oder Ordinalvergleichsregeln.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt drei Überladungen des der <xref:System.String.IndexOf%2A> -Methode, die das erste Vorkommen einer Zeichenfolge innerhalb einer anderen Zeichenfolge, die mit unterschiedlichen Werten der suchen die <xref:System.StringComparison> Enumeration.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> ist kein gültiger <see cref="T:System.StringComparison" />-Wert.</exception>
        <block subset="none" type="usage"><para>Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Bei einer kulturabhängige Suche (das heißt, wenn <paramref name="comparisonType" /> nicht <see cref="F:System.StringComparison.Ordinal" /> oder <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> ist), bei der <paramref name="value" /> ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen. Wenn <paramref name="value" /> besteht nur aus ein oder mehrere Ignorierbare Zeichen, die <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> Methode gibt immer 0 (null), um anzugeben, dass die Übereinstimmung am Anfang der aktuellen Instanz gefunden wird.  
  
Im folgenden Beispiel die <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> Methode wird verwendet, um drei Teilzeichenfolgen (einen bedingten Bindestrich (U + 00AD), einen bedingten Bindestrich gefolgt von "n" und einen bedingten Bindestrich gefolgt von "m") in zwei Zeichenfolgen zu suchen. Nur eine der Zeichenfolgen enthält einen bedingten Bindestrich. Wenn Sie das Beispiel ausgeführt wird, auf die [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher, da der bedingten Bindestrich ein ignorierbares Zeichen ist, eine kulturabhängige Suche derselbe Wert zurückgegeben, die es zurückgegeben würde, wenn es sich bei bedingten Bindestrichs nicht in der Suchzeichenfolge enthalten waren. Allerdings eine Ordinalsuche erfolgreich bedingten Bindestrichs in einer Zeichenfolge sucht und gibt an, dass sie nicht vorhanden ist aus der zweiten Zeichenfolge.  
  
[! Code-Csharp[System.String.IndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable26.cs#26)] [! Code – Vb[System.String.IndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable26.vb#26)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ein zu suchendes Unicode-Zeichen.</param>
        <param name="startIndex">Die Anfangsposition der Suche.</param>
        <param name="count">Die Anzahl der zu überprüfenden Zeichenpositionen.</param>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens des angegebenen Zeichens in dieser Instanz an. Die Suche beginnt an einer angegebenen Zeichenposition, und es wird eine angegebene Anzahl von Zeichenpositionen überprüft.</summary>
        <returns>Die nullbasierte Indexposition von <paramref name="value" /> ab dem Anfang der Zeichenfolge, wenn dieses Zeichen gefunden wurde, andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Suche beginnt an `startIndex` und weiterhin `startIndex`  +  `count` -1. Das Zeichen an der `startIndex`  +  `count` ist in der Suche nicht enthalten.  
  
 Der Index die Nummerierung beginnt bei 0 (null). Der `startIndex`-Parameter kann von 0 bis zu der Länge der Zeichenfolgeninstanz reichen.  
  
 Diese Methode führt eine ordinale (kulturunabhängige) Suche, in dem ein Zeichen als gleich betrachtet, ein anderes Zeichen nur dann, wenn die Unicode-Skalarwerten identisch sind. Um eine kulturabhängige Suche durchzuführen, verwenden die <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> -Methode, in dem ein Unicode-Skalarwert, ein zusammengesetztes Zeichen, z. B. die Ligatur "Æ" (U + 00 C 6) betrachtet werden kann entspricht jedem Vorkommen des Zeichens-Komponenten in der Korrigieren Sie die Sequenz, wie z. B. "AE" (U + 0041, U + 0045), je nach Kultur.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.IndexOf%2A> Methode.  
  
 [!code-cpp[system.string.indexof#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexofcii.cpp#1)]
 [!code-csharp[system.string.indexof#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexofcii.cs#1)]
 [!code-vb[system.string.indexof#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexofcii.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> oder <paramref name="startIndex" /> ist ein negativer Wert.  
  
- oder -  
 <paramref name="startIndex" /> ist größer als die Länge dieser Zeichenfolge.  
  
- oder -  
 <paramref name="count" /> ist größer als die Länge dieser Zeichenfolge minus <paramref name="startIndex" />.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <param name="startIndex">Die Anfangsposition der Suche.</param>
        <param name="count">Die Anzahl der zu überprüfenden Zeichenpositionen.</param>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens der angegebenen Zeichenfolge in dieser Instanz an. Die Suche beginnt an einer angegebenen Zeichenposition, und es wird eine angegebene Anzahl von Zeichenpositionen überprüft.</summary>
        <returns>Die nullbasierte Indexposition von <paramref name="value" /> vom Anfang der aktuellen Instanz, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde. Wenn <paramref name="value" /> <see cref="F:System.String.Empty" /> ist, wird <paramref name="startIndex" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Index die Nummerierung beginnt bei 0 (null). Der `startIndex`-Parameter kann von 0 bis zu der Länge der Zeichenfolgeninstanz reichen.  
  
 Diese Methode führt eine Wortsuche (Groß-/Kleinschreibung beachtet und kulturabhängige) mit der aktuellen Kultur. Die Suche beginnt an `startIndex` und weiterhin `startIndex`  +  `count` -1. Das Zeichen an der `startIndex`  +  `count` ist in der Suche nicht enthalten.  
  
 Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Bei einer kulturabhängige Suche, bei der `value` ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen. Wenn `value` besteht nur aus ein oder mehrere Ignorierbare Zeichen, die <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> Methode gibt immer `startIndex`, d.h. die Zeichenposition, an dem die Suche beginnt. Im folgenden Beispiel die <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> Methode wird verwendet, um die Position (U + 00AD) über einen bedingten Bindestrich gefolgt von einem "m" ab dem dritten bis sechsten Zeichenpositionen werden in zwei Zeichenfolgen zu suchen. Nur eine der Zeichenfolgen enthält die erforderliche Teilzeichenfolge. Wenn Sie das Beispiel ausgeführt wird, auf die [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher in beiden Fällen, da die bedingten Bindestrich ein ignorierbares Zeichen ist die Methode gibt den Index des "m" in der Zeichenfolge, wenn sie einen kulturabhängigen Vergleich ausführt. Beachten Sie, dass bei der ersten Zeichenfolge, die den bedingten Bindestrich gefolgt von einem "m" umfasst, die Methode den Index des bedingten Bindestrichs nicht zurückgeben kann, sondern stattdessen den Index des "m" zurückgibt.  
  
 [!code-csharp[System.String.IndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable23.cs#23)]
 [!code-vb[System.String.IndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable23.vb#23)]  
  
   
  
## Examples  
 Das folgende Beispiel sucht den Index aller Vorkommen der Zeichenfolge "he" in einer Teilzeichenfolge einer anderen Zeichenfolge. Beachten Sie, dass die Anzahl von Zeichen an, die durchsucht werden für jede Iteration Suche neu berechnet werden muss.  
  
 [!code-cpp[string.indexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof8/CPP/ixof8.cpp#1)]
 [!code-csharp[string.indexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof8/CS/ixof8.cs#1)]
 [!code-vb[string.indexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof8/VB/ixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> oder <paramref name="startIndex" /> ist ein negativer Wert.  
  
- oder -  
 <paramref name="startIndex" /> ist größer als die Länge dieser Zeichenfolge.  
  
- oder -  
 <paramref name="count" /> ist größer als die Länge dieser Zeichenfolge minus <paramref name="startIndex" />.</exception>
        <block subset="none" type="usage"><para>Siehe [bewährte Methoden für die Verwendung von Zeichenfolgen](~/docs/standard/base-types/best-practices-strings.md), es wird empfohlen, dass Sie vermeiden, Aufrufen von Methoden zum Zeichenfolgenvergleich, die Standardwerte ersetzen, und rufen stattdessen die Methoden, die für Parameter explizit angegeben werden müssen. Um die Vergleichsregeln der aktuellen Kultur verwenden, um diesen Vorgang auszuführen, rufen Sie die <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> methodenüberladung mit einem Wert von <see cref="F:System.StringComparison.CurrentCulture" /> für seine `comparisonType` Parameter.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <param name="startIndex">Die Anfangsposition der Suche.</param>
        <param name="comparisonType">Einer der Enumerationswerte, der die Regeln für die Suche angibt.</param>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens der angegebenen Zeichenfolge im aktuellen <see cref="T:System.String" />-Objekt an. Parameter geben die Anfangssuchposition in der aktuellen Zeichenfolge und den Typ der Suche an, die für die angegebene Zeichenfolge verwendet werden soll.</summary>
        <returns>Die nullbasierte Indexposition des <paramref name="value" />-Parameters vom Anfang der aktuellen Instanz, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde. Wenn <paramref name="value" /> <see cref="F:System.String.Empty" /> ist, wird <paramref name="startIndex" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Index die Nummerierung beginnt bei 0. Der `startIndex`-Parameter kann von 0 bis zu der Länge der Zeichenfolgeninstanz reichen. Wenn `startIndex` entspricht der Länge der Zeichenfolgeninstanz, die Methode gibt-1 zurück.  
  
 Die `comparisonType` Parameter gibt an, dass für die Suche die `value` Parameter unter Verwendung der aktuellen oder der invarianten Kultur, mithilfe einer Suche Groß- und Kleinschreibung beachtet und mithilfe von Word oder Ordinalvergleichsregeln.  
  
   
  
## Examples  
 Die folgenden Exampledemonstrates drei Überladungen, der die <xref:System.String.IndexOf%2A> -Methode, die das erste Vorkommen einer Zeichenfolge innerhalb einer anderen Zeichenfolge, die mit unterschiedlichen Werten der suchen die <xref:System.StringComparison> Enumeration.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> ist kleiner als 0 (null) oder größer als die Länge dieser Zeichenfolge.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> ist kein gültiger <see cref="T:System.StringComparison" />-Wert.</exception>
        <block subset="none" type="usage"><para>Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Bei einer kulturabhängige Suche (das heißt, wenn <paramref name="comparisonType" /> nicht <see cref="F:System.StringComparison.Ordinal" /> oder <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> ist), bei der <paramref name="value" /> ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen. Wenn <paramref name="value" /> besteht nur aus ein oder mehrere Ignorierbare Zeichen, die <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> Methode gibt immer <paramref name="startIndex" />, d.h. die Zeichenposition, an dem die Suche beginnt.  
  
Im folgenden Beispiel die <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> Methode wird verwendet, um die Position (U + 00AD) über einen bedingten Bindestrich gefolgt von einem "m" beginnend mit der dritten Zeichenposition in zwei Zeichenfolgen zu suchen. Nur eine der Zeichenfolgen enthält die erforderliche Teilzeichenfolge. Wenn Sie das Beispiel ausgeführt wird, auf die [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher in beiden Fällen, da die bedingten Bindestrich ein ignorierbares Zeichen ist die Methode gibt den Index des "m" in der Zeichenfolge, wenn sie einen kulturabhängigen Vergleich ausführt. Beachten Sie, dass bei der ersten Zeichenfolge, die den bedingten Bindestrich gefolgt von einem "m" umfasst, die Methode den Index des bedingten Bindestrichs nicht zurückgeben kann, sondern stattdessen den Index des "m" zurückgibt. Die Methode gibt den Index des bedingten Bindestrichs in der ersten Zeichenfolge nur dann zurück, wenn sie einen Ordinalvergleich ausführt.  
  
[! Code-Csharp[System.String.IndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable25.cs#25)] [! Code – Vb[System.String.IndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable25.vb#25)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <param name="startIndex">Die Anfangsposition der Suche.</param>
        <param name="count">Die Anzahl der zu überprüfenden Zeichenpositionen.</param>
        <param name="comparisonType">Einer der Enumerationswerte, der die Regeln für die Suche angibt.</param>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens der angegebenen Zeichenfolge im aktuellen <see cref="T:System.String" />-Objekt an. Parameter geben die Anfangssuchposition in der aktuellen Zeichenfolge, die Anzahl der Zeichen in der aktuellen Zeichenfolge und den Typ der Suche für die angegebene Zeichenfolge an.</summary>
        <returns>Die nullbasierte Indexposition des <paramref name="value" />-Parameters vom Anfang der aktuellen Instanz, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde. Wenn <paramref name="value" /> <see cref="F:System.String.Empty" /> ist, wird <paramref name="startIndex" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Index die Nummerierung beginnt bei 0 (null). Der `startIndex`-Parameter kann von 0 bis zu der Länge der Zeichenfolgeninstanz reichen.  
  
 Die Suche beginnt an `startIndex` und weiterhin `startIndex`  +  `count` -1. Das Zeichen an der `startIndex`  +  `count` ist in der Suche nicht enthalten.  
  
 Die `comparisonType` Parameter gibt an, dass für die Suche die `value` Parameter unter Verwendung der aktuellen oder der invarianten Kultur, mithilfe einer Suche Groß- und Kleinschreibung beachtet und mithilfe von Word oder Ordinalvergleichsregeln.  
  
   
  
## Examples  
 Die folgenden Exampledemonstrates drei Überladungen, der die <xref:System.String.IndexOf%2A> -Methode, die das erste Vorkommen einer Zeichenfolge innerhalb einer anderen Zeichenfolge, die mit unterschiedlichen Werten der suchen die <xref:System.StringComparison> Enumeration.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> oder <paramref name="startIndex" /> ist ein negativer Wert.  
  
- oder -  
 <paramref name="startIndex" /> ist größer als die Länge dieser Instanz.  
  
- oder -  
 <paramref name="count" /> ist größer als die Länge dieser Zeichenfolge minus <paramref name="startIndex" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> ist kein gültiger <see cref="T:System.StringComparison" />-Wert.</exception>
        <block subset="none" type="usage"><para>Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Bei einer kulturabhängige Suche (das heißt, wenn <paramref name="comparisonType" /> nicht <see cref="F:System.StringComparison.Ordinal" /> oder <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> ist), bei der <paramref name="value" /> ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen. Wenn <paramref name="value" /> besteht nur aus ein oder mehrere Ignorierbare Zeichen, die <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> Methode gibt immer <paramref name="startIndex" />, d.h. die Zeichenposition, an dem die Suche beginnt.  
  
Im folgenden Beispiel die <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> Methode wird verwendet, um die Position (U + 00AD) über einen bedingten Bindestrich gefolgt von einem "m" ab dem dritten bis sechsten Zeichenpositionen werden in zwei Zeichenfolgen zu suchen. Nur eine der Zeichenfolgen enthält die erforderliche Teilzeichenfolge. Wenn Sie das Beispiel ausgeführt wird, auf die [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher in beiden Fällen, da die bedingten Bindestrich ein ignorierbares Zeichen ist die Methode gibt den Index des "m" in der Zeichenfolge, wenn sie einen kulturabhängigen Vergleich ausführt. Wenn sie einen Ordinalvergleich ausführt, sucht er die Teilzeichenfolge jedoch nur in der ersten Zeichenfolge fest. Beachten Sie, dass bei der ersten Zeichenfolge, die den bedingten Bindestrich gefolgt von einem "m" enthält, die Methode ein Fehler auftritt, um den Index des bedingten Bindestrichs zurückzugeben, aber gibt stattdessen den Index des "m" aus, wenn er einen kulturabhängigen Vergleich ausführt. Die Methode gibt den Index des bedingten Bindestrichs in der ersten Zeichenfolge nur dann zurück, wenn sie einen Ordinalvergleich ausführt.  
  
[! Code-Csharp[System.String.IndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable24.cs#24)] [! Code – Vb[System.String.IndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable24.vb#24)]</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt den Index des ersten Vorkommens eines beliebigen Zeichens aus einem angegebenen Array von Unicode-Zeichen in dieser Instanz an. Die Methode gibt -1 zurück, wenn die Zeichen im Array nicht in dieser Instanz gefunden werden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] -&gt; int" Usage="string.IndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">Ein Array von Unicode-Zeichen mit mindestens einem zu suchenden Zeichen.</param>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens eines beliebigen Zeichens aus einem angegebenen Array von Unicode-Zeichen in dieser Instanz an.</summary>
        <returns>Die nullbasierte Indexposition des ersten Vorkommens eines beliebigen Zeichens aus <paramref name="anyOf" /> in dieser Instanz. -1, wenn kein Zeichen in <paramref name="anyOf" /> gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Index die Nummerierung beginnt bei 0 (null).  
  
 Die Suche nach `anyOf` Groß-/Kleinschreibung beachtet wird. Wenn `anyOf` ist ein leeres Array, der die Methode findet eine Übereinstimmung am Anfang der Zeichenfolge (d. h. am index 0 (null)).  
  
 Diese Methode führt eine ordinale (kulturunabhängige) Suche, in dem ein Zeichen als gleich betrachtet, ein anderes Zeichen nur dann, wenn die Unicode-Skalarwerten identisch sind. Um eine kulturabhängige Suche durchzuführen, verwenden die <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> -Methode, in dem ein Unicode-Skalarwert, ein zusammengesetztes Zeichen, z. B. die Ligatur "Æ" (U + 00 C 6) betrachtet werden kann entspricht jedem Vorkommen des Zeichens-Komponenten in der Korrigieren Sie die Sequenz, wie z. B. "AE" (U + 0041, U + 0045), je nach Kultur.  
  
   
  
## Examples  
 Im folgende Beispiel wird der erste Vokal in einer Zeichenfolge gesucht.  
  
 [!code-csharp[System.String.IndexOfAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.IndexOfAny/cs/IndexOfAny1.cs#1)]
 [!code-vb[System.String.IndexOfAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.IndexOfAny/vb/IndexOfAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Ein Array von Unicode-Zeichen mit mindestens einem zu suchenden Zeichen.</param>
        <param name="startIndex">Die Anfangsposition der Suche.</param>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens eines beliebigen Zeichens aus einem angegebenen Array von Unicode-Zeichen in dieser Instanz an. Die Suche beginnt an einer angegebenen Zeichenposition.</summary>
        <returns>Die nullbasierte Indexposition des ersten Vorkommens eines beliebigen Zeichens aus <paramref name="anyOf" /> in dieser Instanz. -1, wenn kein Zeichen in <paramref name="anyOf" /> gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Index die Nummerierung beginnt bei 0 (null). Die `startIndex` Parameter kann im Bereich von 0 bis eins weniger als die Länge der Zeichenfolgeninstanz.  
  
 Die Suche erfolgt von `startIndex` bis zum Ende der Zeichenfolge.  
  
 Die Suche nach `anyOf` Groß-/Kleinschreibung beachtet wird.  
  
 Diese Methode führt eine ordinale (kulturunabhängige) Suche, in dem ein Zeichen als gleich betrachtet, ein anderes Zeichen nur dann, wenn die Unicode-Skalarwert identisch sind. Um eine kulturabhängige Suche durchzuführen, verwenden die <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> -Methode, in dem ein Unicode-Skalarwert, ein zusammengesetztes Zeichen, z. B. die Ligatur "Æ" (U + 00 C 6) betrachtet werden kann entspricht jedem Vorkommen des Zeichens-Komponenten in der Korrigieren Sie die Sequenz, wie z. B. "AE" (U + 0041, U + 0045), je nach Kultur.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Index des Vorkommens eines beliebigen Zeichens der Zeichenfolge "is" in einer Teilzeichenfolge einer anderen Zeichenfolge gesucht.  
  
 [!code-cpp[string.indexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany2/CPP/ixany2.cpp#1)]
 [!code-csharp[string.indexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany2/CS/ixany2.cs#1)]
 [!code-vb[string.indexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany2/VB/ixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> ist ein negativer Wert.  
  
- oder -  
 <paramref name="startIndex" /> ist größer als die Anzahl der Zeichen in dieser Instanz.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Ein Array von Unicode-Zeichen mit mindestens einem zu suchenden Zeichen.</param>
        <param name="startIndex">Die Anfangsposition der Suche.</param>
        <param name="count">Die Anzahl der zu überprüfenden Zeichenpositionen.</param>
        <summary>Gibt den NULL-basierten Index des ersten Vorkommens eines beliebigen Zeichens aus einem angegebenen Array von Unicode-Zeichen in dieser Instanz an. Die Suche beginnt an einer angegebenen Zeichenposition, und es wird eine angegebene Anzahl von Zeichenpositionen überprüft.</summary>
        <returns>Die nullbasierte Indexposition des ersten Vorkommens eines beliebigen Zeichens aus <paramref name="anyOf" /> in dieser Instanz. -1, wenn kein Zeichen in <paramref name="anyOf" /> gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Suche beginnt an `startIndex` und weiterhin `startIndex`  +  `count` -1. Das Zeichen an der `startIndex`  +  `count` ist in der Suche nicht enthalten.  
  
 Der Index die Nummerierung beginnt bei 0 (null). Die `startIndex` Parameter kann im Bereich von 0 bis eins weniger als die Länge der Zeichenfolgeninstanz.  
  
 Die Suche nach `anyOf` Groß-/Kleinschreibung beachtet wird.  
  
 Diese Methode führt eine ordinale (kulturunabhängige) Suche, in dem ein Zeichen als gleich betrachtet, ein anderes Zeichen nur dann, wenn die Unicode-Skalarwert identisch sind. Um eine kulturabhängige Suche durchzuführen, verwenden die <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> -Methode, in dem ein Unicode-Skalarwert, ein zusammengesetztes Zeichen, z. B. die Ligatur "Æ" (U + 00 C 6) betrachtet werden kann entspricht jedem Vorkommen des Zeichens-Komponenten in der Korrigieren Sie die Sequenz, wie z. B. "AE" (U + 0041, U + 0045), je nach Kultur.  
  
   
  
## Examples  
 Das folgende Beispiel sucht den Index des Vorkommens eines beliebigen Zeichens der Zeichenfolge "Aid" in einer Teilzeichenfolge einer anderen Zeichenfolge.  
  
 [!code-cpp[string.indexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany3/CPP/ixany3.cpp#1)]
 [!code-csharp[string.indexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany3/CS/ixany3.cs#1)]
 [!code-vb[string.indexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany3/VB/ixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> oder <paramref name="startIndex" /> ist ein negativer Wert.  
  
- oder -  
 <paramref name="count" /> + <paramref name="startIndex" /> ist größer als die Anzahl der Zeichen in dieser Instanz.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public string Insert (int startIndex, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Insert(int32 startIndex, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (startIndex As Integer, value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Insert(int startIndex, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; string" Usage="string.Insert (startIndex, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="startIndex">Die nullbasierte Indexposition für das Einfügen.</param>
        <param name="value">Die einzufügende Zeichenfolge.</param>
        <summary>Gibt eine neue Zeichenfolge zurück, in der eine angegebene Zeichenfolge an einer angegebenen Indexposition in dieser Instanz eingefügt wird.</summary>
        <returns>Eine neue Zeichenfolge, die dieser Instanz mit einem an der Position <paramref name="value" /> eingefügten <paramref name="startIndex" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `startIndex` ist gleich der Länge dieser Instanz `value` am Ende dieser Instanz angefügt ist.  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge zurückgegeben, in dem `value` in der aktuellen Instanz eingefügt wird.  
  
 Beispielsweise ist der Rückgabewert von `"abc".Insert(2, "XYZ")` "AbXYZc" ist.  
  
   
  
## Examples  
 Das folgende Beispiel fügt ein Leerzeichen in der vierten Zeichenposition (das Zeichen am Index 3) einer Zeichenfolge.  
  
 [!code-csharp[System.String.Insert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Insert/cs/Insert1.cs#1)]
 [!code-vb[System.String.Insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Insert/vb/Insert1.vb#1)]  
  
 Die folgende Konsolenanwendung fordert den Benutzer zur Eingabe von ein oder mehrere Adjektive um zwei Tiere zu beschreiben. Es ruft dann die <xref:System.String.Insert%2A> Methode, die in eine Zeichenfolge vom Benutzer eingegebenen Text eingefügt werden.  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> ist negativ oder größer als die Länge dieser Instanz.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Intern">
      <MemberSignature Language="C#" Value="public static string Intern (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Intern(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Intern(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Intern (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Intern(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Intern : string -&gt; string" Usage="System.string.Intern str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Eine im Internpool zu suchende Zeichenfolge.</param>
        <summary>Ruft den Verweis des Systems auf den angegebenen <see cref="T:System.String" /> ab.</summary>
        <returns>Der Verweis des Systems auf <paramref name="str" />, wenn dieser im Internpool vorhanden ist, andernfalls ein neuer Verweis auf eine Zeichenfolge mit dem Wert von <paramref name="str" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die common Language Runtime behält Zeichenfolgenspeicher durch verwalten eine Tabelle, mit dem Namen Internpool, die einen einzelnen Verweis auf jedes eindeutigen Zeichenfolgenliterals deklariert oder programmgesteuert erstellt, in Ihrem Programm enthält. Daher vorhanden eine Instanz einer Literalzeichenfolge mit einem bestimmten Wert nur einmal im System.  
  
 Beispielsweise, wenn Sie mehrere Variablen, die die gleiche Zeichenfolge zuweisen, die Runtime Ruft den gleichen Verweis auf das Zeichenfolgenliteral aus Internpool und jeder Variablen zugewiesen.  
  
 Die <xref:System.String.Intern%2A> Methode verwendet Internpool um zu suchende eine Zeichenfolge, die gleich dem Wert des `str`. Wenn eine solche Zeichenfolge vorhanden ist, wird der Verweis im Internpool zurückgegeben. Wenn die Zeichenfolge nicht vorhanden ist, einen Verweis auf `str` dem Internpool hinzugefügt wird, und klicken Sie dann diesen Verweis zurückgegeben wird.  
  
 Im folgenden Beispiel wird der Zeichenfolge s1 mit die Wert "MyTest", bereits intern gespeichert, da es sich um ein Literal in der Anwendung handelt. Die <xref:System.Text.StringBuilder?displayProperty=nameWithType> Klasse generiert ein neues Zeichenfolgenobjekt, das den gleichen Wert wie bei s1 verfügt. Ein Verweis auf diese Zeichenfolge wird auf s2 Herunterskalieren zugewiesen. Die <xref:System.String.Intern%2A> Methode sucht eine Zeichenfolge, die den gleichen Wert wie s2 hat. Da eine solche Zeichenfolge vorhanden ist, gibt die Methode den gleichen Verweis, der auf s1 zugewiesen ist. Dieser Verweis wird dann auf s3 zugewiesen. Verweise s1 und s2 sind ungleich, da sie auf verschiedene Objekte verweisen. Verweise s1 und s3 sind gleich, da sie auf die gleiche Zeichenfolge verweisen.  
  
 [!code-csharp[System.String.Intern#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern1.cs#1)]
 [!code-vb[System.String.Intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern1.vb#1)]  
  
 Vergleichen Sie diese Methode, um die <xref:System.String.IsInterned%2A> Methode.  
  
## <a name="version-considerations"></a>Version-Überlegungen  
 In der [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)], <xref:System.String.Intern%2A> Methode auf das Verhalten in .NET Framework 1.0 und 1.1 im Hinblick auf eine Internalisierung die leere Zeichenfolge zurückgesetzt. In der folgenden Beispiel wird die Variable `str1` erhält einen Verweis auf <xref:System.String.Empty>, und die Variable `str2` erhält den Verweis auf <xref:System.String.Empty> zurückgegeben, die durch Aufrufen der <xref:System.String.Intern%2A> Methode nach der Konvertierung einer <xref:System.Text.StringBuilder>Objekt, dessen Wert <xref:System.String.Empty> in eine Zeichenfolge. Klicken Sie dann die Verweise, die in enthaltenen `str1` und `str2` Gleichheit verglichen werden.  
  
 [!code-csharp[System.String.Intern#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern2.cs#2)]
 [!code-vb[System.String.Intern#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern2.vb#2)]  
  
 In der [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)], [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], und [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)], `str1` und `str2` gleich sind. In der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] und [!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)], `str1` und `str2` ungleich sind.  
  
## <a name="performance-considerations"></a>Überlegungen zur Leistung  
 Wenn Sie versuchen, die die Gesamtmenge des Arbeitsspeichers zu reduzieren. Ihre Anwendung weist, denken Sie daran, die Internalisieren von Zeichenfolgen zwei unerwünschte Nebeneffekte hat. Zunächst der zugeordnete Arbeitsspeicher für internalisiert <xref:System.String> Objekte wahrscheinlich nicht freigegeben werden, bis die common Language Runtime (CLR) beendet wird. Der Grund dafür ist, die der CLR-Verweis auf das internalisierte <xref:System.String> Objekt können beibehalten, nachdem die Anwendung oder sogar der Anwendungsdomäne, beendet wird. Um eine Zeichenfolge intern, müssen Sie zweitens zunächst die Zeichenfolge erstellen. Der Speicher ein, die die <xref:System.String> Objekt muss immer noch zugeordnet werden können, auch wenn der Arbeitsspeicher schließlich Garbage Collection durchgeführt wird.  
  
 .NET Framework, Version 2.0 stellt die <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType> -Enumerationsmember. Die <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> Element markiert eine Assembly nicht eine erforderliche Zeichenfolge interning von. Sie anwenden können <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> auf eine Assembly mit der <xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute> Attribut. Wenn Sie darüber hinaus verwenden die [Ngen.exe (Native Image Generator)](~/docs/framework/tools/ngen-exe-native-image-generator.md) zum Kompilieren einer Assembly im Vorfeld zur Laufzeit Zeichenfolgen nicht modulübergreifend Module.  
  
   
  
## Examples  
 Das folgende Beispiel verwendet drei Zeichenfolgen, die Wert zu bestimmen, ob eine neu erstellte Zeichenfolge identisch ist, und eine im Internpool vorhanden Zeichenfolge sind gleich.  
  
 [!code-cpp[string.intern#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.intern/CPP/string_intern.cpp#1)]
 [!code-csharp[string.intern#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.intern/CS/string_intern.cs#1)]
 [!code-vb[string.intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.intern/VB/string_intern.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.String.IsInterned(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsInterned">
      <MemberSignature Language="C#" Value="public static string IsInterned (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string IsInterned(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsInterned(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInterned (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ IsInterned(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsInterned : string -&gt; string" Usage="System.string.IsInterned str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Die im Internpool zu suchende Zeichenfolge.</param>
        <summary>Ruft einen Verweis auf einen angegebenen <see cref="T:System.String" /> ab.</summary>
        <returns>Ein Verweis auf <paramref name="str" />, wenn sich dieser im Internpool der Common Language Runtime befindet; andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die common Language Runtime verwaltet automatisch eine Tabelle, mit dem Namen Internpool, die eine einzelne Instanz jedes eindeutigen Zeichenfolgenliterals-Konstante, die in einem Programm als auch eine beliebige eindeutige Instanz des deklarierten enthält <xref:System.String> Sie programmgesteuert durch Aufrufen von hinzufügen die <xref:System.String.Intern%2A> Methode.  
  
 Der Internpool erhält Zeichenfolgenspeicher. Wenn Sie eine literale Zeichenfolgenkonstante mit verschiedenen Variablen zuweisen, wird jede Variable auf die gleiche Konstante im Internpool anstelle von Verweisen auf unterschiedliche Instanzen von festgelegt <xref:System.String> , die gleiche Werte aufweisen.  
  
 Diese Methode sucht `str` im Internpool. Wenn `str` wurde bereits intern gespeichert, die ein Verweis auf diese Instanz wird zurückgegeben, andernfalls `null` zurückgegeben wird.  
  
 Vergleichen Sie diese Methode, um die <xref:System.String.Intern%2A> Methode.  
  
 Diese Methode gibt keinen booleschen Wert zurück. Wenn Sie möchten einen booleschen Wert, der angibt, ob eine bestimmte Zeichenfolge internalisiert ist, dass die Methode aufrufen, können Sie Code wie den folgenden.  
  
 [!code-csharp[System.String.IsInterned#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isinterned/cs/isinternedex1.cs#1)]
 [!code-vb[System.String.IsInterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isinterned/vb/isinternedex1.vb#1)]  
  
> [!NOTE]
>  Ab .NET Framework, Version 2.0, können Sie die Verwendung von Internpool bei Verwendung von überschreiben die [Ngen.exe (Native Image Generator)](~/docs/framework/tools/ngen-exe-native-image-generator.md) , eine Assembly auf den Cache für systemeigene Images auf einem lokalen Computer zu installieren. Weitere Informationen finden Sie unter Überlegungen zur Leistung im Abschnitt "Hinweise", um die <xref:System.String.Intern%2A> Eigenschaft.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, dass die Literalzeichenfolgen automatisch vom Compiler intern gespeichert werden.  
  
 [!code-cpp[string.isinterned#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isinterned/CPP/isin.cpp#1)]
 [!code-csharp[string.isinterned#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isinterned/CS/isin.cs#1)]
 [!code-vb[string.isinterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isinterned/VB/isin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.String.Intern(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt an, ob diese Zeichenfolge in einer bestimmten Unicode-Normalisierungsform vorliegt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : unit -&gt; bool" Usage="string.IsNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt an, ob diese Zeichenfolge in der Unicode-Normalisierungsform C vorliegt.</summary>
        <returns><see langword="true" />, wenn diese Zeichenfolge in der Normalisierungsform C vorliegt; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige Unicode-Zeichen umfassen mehrere entsprechende binärdarstellungen bestehend aus Gruppen von der Kombination von und/oder zusammengesetzte Unicode-Zeichen. Das Vorhandensein mehrerer Darstellungen für ein einzelnes Zeichen erschwert suchen, sortieren, Abgleich und andere Vorgänge.  
  
 Die Unicode-standard definiert einen Prozess namens Normalisierung, die eine binäre Darstellung, wenn jede der entsprechende binäre Darstellung eines Zeichens zurückgibt. Normalisierung kann ausgeführt werden, mit mehreren Algorithmen, die genannte Normalisierungsformen, die unterschiedliche Regeln einhalten. .NET unterstützt derzeit Normalisierungsformen C, D, KC und KD.  
  
 Eine Beschreibung der unterstützten Unicode-Normalisierungsformen, finden Sie unter <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, ob eine Zeichenfolge erfolgreich in verschiedenen Normalisierungsformen normalisiert wird.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die aktuelle Instanz enthält ungültige Unicode-Zeichen.</exception>
        <block subset="none" type="usage"><para>Die <see cref="Overload:System.String.IsNormalized" /> Methodenrückgabe <see langword="false" /> , sobald es feststellt, dass das erste Zeichen der nicht normalisierte in einer Zeichenfolge. Aus diesem Grund, wenn eine Zeichenfolge nicht normalisierte Zeichen gefolgt von ungültigen Unicode-Zeichen, enthält die <see cref="Overload:System.String.Normalize" /> Methode löst eine <see cref="T:System.ArgumentException" /> zwar <see cref="Overload:System.String.IsNormalized" /> gibt <see langword="false" />.</para></block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : System.Text.NormalizationForm -&gt; bool" Usage="string.IsNormalized normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Eine Unicode-Normalisierungsform.</param>
        <summary>Gibt an, ob diese Zeichenfolge in der angegebenen Unicode-Normalisierungsform vorliegt.</summary>
        <returns><see langword="true" />, wenn diese Zeichenfolge in der vom <paramref name="normalizationForm" />-Parameter angegebenen Normalisierungsform vorliegt; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige Unicode-Zeichen umfassen mehrere entsprechende binärdarstellungen bestehend aus Gruppen von der Kombination von und/oder zusammengesetzte Unicode-Zeichen. Das Vorhandensein mehrerer Darstellungen für ein einzelnes Zeichen erschwert suchen, sortieren, Abgleich und andere Vorgänge.  
  
 Die Unicode-standard definiert einen Prozess namens Normalisierung, die eine binäre Darstellung, wenn jede der entsprechende binäre Darstellung eines Zeichens zurückgibt. Normalisierung kann ausgeführt werden, mit mehreren Algorithmen, die genannte Normalisierungsformen, die unterschiedliche Regeln einhalten. .NET unterstützt derzeit Normalisierungsformen C, D, KC und KD.  
  
 Eine Beschreibung der unterstützten Unicode-Normalisierungsformen, finden Sie unter <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.IsNormalized%2A> und <xref:System.String.Normalize%2A> Methoden.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die aktuelle Instanz enthält ungültige Unicode-Zeichen.</exception>
        <block subset="none" type="usage"><para>Die <see cref="Overload:System.String.IsNormalized" /> Methodenrückgabe <see langword="false" /> , sobald es feststellt, dass das erste Zeichen der nicht normalisierte in einer Zeichenfolge. Aus diesem Grund, wenn eine Zeichenfolge nicht normalisierte Zeichen gefolgt von ungültigen Unicode-Zeichen, enthält die <see cref="Overload:System.String.Normalize" /> Methode löst eine <see cref="T:System.ArgumentException" /> zwar <see cref="Overload:System.String.IsNormalized" /> gibt <see langword="false" />.</para></block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrEmpty">
      <MemberSignature Language="C#" Value="public static bool IsNullOrEmpty (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrEmpty(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrEmpty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrEmpty (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrEmpty(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrEmpty : string -&gt; bool" Usage="System.string.IsNullOrEmpty value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Die zu testende Zeichenfolge.</param>
        <summary>Gibt an, ob die angegebene Zeichenfolge <see langword="null" /> oder eine leere Zeichenfolge ("") ist.</summary>
        <returns><see langword="true" />, wenn der <paramref name="value" />-Parameter <see langword="null" /> oder eine leere Zeichenfolge ("") ist; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrEmpty%2A> ist eine bequeme Methode, die Ihnen ermöglicht, gleichzeitig zu testen, ob eine <xref:System.String> ist `null` oder der Wert ist <xref:System.String.Empty?displayProperty=nameWithType>. Dies entspricht dem folgenden Code:  
  
 [!code-cpp[System.String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/isnullorempty1.cpp#1)]
 [!code-csharp[System.String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/isnullorempty1.cs#1)]
 [!code-vb[System.String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/isnullorempty1.vb#1)]  
  
 Können Sie die <xref:System.String.IsNullOrWhiteSpace%2A> Methode zum Testen, ob eine Zeichenfolge `null`, sein Wert ist <xref:System.String.Empty?displayProperty=nameWithType>, oder es besteht nur aus Leerzeichen.  
  
## <a name="what-is-a-null-string"></a>Was ist eine null-Zeichenfolge?

Eine Zeichenfolge ist `null` , wenn sie keinen Wert (in C++ und Visual Basic) zugewiesen wurde, oder wenn es explizit einen Wert zugewiesen wurde `null`. Obwohl die [kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) Feature kann eine null-Zeichenfolge, ordnungsgemäß behandelt werden wie im folgenden Beispiel gezeigt, der versucht, rufen Sie eine Falls ihre Member löst eine <xref:System.NullReferenceException>.  
  
[!code-cpp[System.String.IsNullOrEmpty#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#2)]
[!code-csharp[System.String.IsNullOrEmpty#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#2)]
[!code-vb[System.String.IsNullOrEmpty#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#2)]  
  
## <a name="what-is-an-empty-string"></a>Was ist eine leere Zeichenfolge?  

Eine Zeichenfolge ist leer, wenn sie eine leere Zeichenfolge explizit zugewiesen ist ("") oder <xref:System.String.Empty?displayProperty=nameWithType>. Eine leere Zeichenfolge ist eine <xref:System.String.Length%2A> 0.  Das folgende Beispiel erstellt eine leere Zeichenfolge und zeigt den Wert und die Länge.  
  
[!code-cpp[System.String.IsNullOrEmpty#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#3)]
[!code-csharp[System.String.IsNullOrEmpty#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#3)]
[!code-vb[System.String.IsNullOrEmpty#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#3)]  
  
## Examples  
 Im folgenden Beispiel werden drei Zeichenfolgen und bestimmt, ob jede Zeichenfolge ist, eine leere Zeichenfolge ist oder ist `null`.  
  
 [!code-cpp[String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isNullOrEmpty/CPP/inoe.cpp#1)]
 [!code-csharp[String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isNullOrEmpty/CS/inoe.cs#1)]
 [!code-vb[String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isNullOrEmpty/VB/inoe.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsNullOrWhiteSpace (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrWhiteSpace(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrWhiteSpace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrWhiteSpace (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrWhiteSpace(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrWhiteSpace : string -&gt; bool" Usage="System.string.IsNullOrWhiteSpace value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Die zu testende Zeichenfolge.</param>
        <summary>Gibt an, ob eine angegebene Zeichenfolge <see langword="null" /> ist, leer ist oder nur aus Leerzeichen besteht.</summary>
        <returns><see langword="true" />, wenn der <paramref name="value" />-Parameter <see langword="null" /> oder <see cref="F:System.String.Empty" /> ist oder wenn <paramref name="value" /> ausschließlich aus Leerzeichen besteht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrWhiteSpace%2A> ist eine bequeme Möglichkeit, der ähnlich wie in den folgenden Code, mit dem Unterschied, dass es sich um eine bessere Leistung bietet:  
  
 [!code-csharp[System.String.IsNullOrWhitespace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace.cs#2)]
 [!code-vb[System.String.IsNullOrWhitespace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace.vb#2)]  
  
 Leerzeichen werden durch den Unicode-Standard definiert. Die <xref:System.String.IsNullOrWhiteSpace%2A> -Methode interpretiert alle Zeichen, die den Wert zurückgibt `true` wann erfolgt eine Übergabe an die <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> -Methode, wie ein Leerzeichen.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein Zeichenfolgenarray, und übergibt dann jedes Element des Arrays, das die <xref:System.String.IsNullOrWhiteSpace%2A> Methode.  
  
 [!code-csharp[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace1.cs#1)]
 [!code-vb[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Verkettet die Elemente eines angegebenen Arrays oder die Member einer Auflistung und verwendet das angegebene Trennzeichen zwischen jedem Element bzw. Member.</summary>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;string&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="separator">Die Zeichenfolge, die als Trennzeichen verwendet werden soll.<paramref name="separator" /> ist in der zurückgegebenen Zeichenfolge nur enthalten, wenn <paramref name="values" /> mehr als ein Element enthält.</param>
        <param name="values">Eine Auflistung, die die zu verkettenden Zeichenfolgen enthält.</param>
        <summary>Verkettet die Member einer erstellten <see cref="T:System.Collections.Generic.IEnumerable`1" />-Auflistung vom Typ <see cref="T:System.String" /> und verwendet das angegebene Trennzeichen zwischen den einzelnen Membern.</summary>
        <returns>Eine Zeichenfolge, die aus den Membern von <paramref name="values" /> besteht, getrennt durch die <paramref name="separator" />-Zeichenfolge. Wenn <paramref name="values" /> keine Mitglieder hat, gibt die Methode <see cref="F:System.String.Empty" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `separator` ist `null`, eine leere Zeichenfolge (<xref:System.String.Empty?displayProperty=nameWithType>) wird stattdessen verwendet. Wenn alle Member des `values` ist `null`, eine leere Zeichenfolge wird stattdessen verwendet.  
  
 <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> ist eine bequeme Methode, mit dem Sie verketten, jedes Element in einer `IEnumerable(Of String)` Auflistung ohne Elemente zunächst in ein Zeichenfolgenarray konvertiert. Es ist besonders nützlich bei Abfrageausdrücken Language-Integrated Query (LINQ). Das folgende Beispiel übergibt eine `List(Of String)` Objekt, das die Groß- oder Kleinbuchstaben Buchstaben des Alphabets, einen Lambda-Ausdruck, die Buchstaben, die gleich oder größer als einen bestimmten Buchstaben enthält auswählt (die im Beispiel "M" ist). Die `IEnumerable(Of String)` von zurückgegebene Auflistung der <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> Methode übergeben wird, um die <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> Methode, um das Ergebnis als eine einzelne Zeichenfolge anzuzeigen.  
  
 [!code-csharp[System.String.Join#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join4.cs#4)]
 [!code-vb[System.String.Join#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join4.vb#4)]  
  
   
  
## Examples  
 Im folgenden Beispiel wird den Algorithmus Sieb des Eratosthenes zum Berechnen von Primzahlen, die kleiner als oder gleich 100 sind. Weist das Ergebnis an eine <xref:System.Collections.Generic.List%601> Objekt vom Typ <xref:System.String>, die es dann an übergibt die <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> Methode.  
  
 [!code-csharp[System.String.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join3.cs#3)]
 [!code-vb[System.String.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Die Zeichenfolge, die als Trennzeichen verwendet werden soll. <paramref name="separator" /> ist in der zurückgegebenen Zeichenfolge nur enthalten, wenn <paramref name="values" /> mehr als ein Element enthält.</param>
        <param name="values">Ein Array, das die zu verkettenden Elemente enthält.</param>
        <summary>Verkettet die Elemente eines Objektarrays und verwendet das angegebene Trennzeichen zwischen den einzelnen Elementen.</summary>
        <returns>Eine Zeichenfolge, die aus den Membern von <paramref name="values" /> besteht, getrennt durch die <paramref name="separator" />-Zeichenfolge. Wenn <paramref name="values" /> eine leeres Array ist, gibt die Methode <see cref="F:System.String.Empty" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `separator` ist `null` oder, wenn ein beliebiges Element von `values` anders als das erste Element ist `null`, eine leere Zeichenfolge (<xref:System.String.Empty?displayProperty=nameWithType>) wird stattdessen verwendet. Siehe Hinweise für Aufrufer-Abschnitt, wenn das erste Element der `values` ist `null`.  
  
 <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> ist eine Hilfsmethode, mit dem Sie jedes Element in einem Objektarray zu verketten, ohne die Elemente explizit in Zeichenfolgen konvertiert werden kann. Die Zeichenfolgendarstellung der einzelnen Objekte im Array wird durch Aufrufen des Objekts abgeleitet `ToString` Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird den Algorithmus Sieb des Eratosthenes zum Berechnen von Primzahlen, die kleiner als oder gleich 100 sind. Es weist ein Ganzzahlarray, auf die diese dann an übergibt das Ergebnis der <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> Methode.  
  
 [!code-csharp[System.String.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join1.cs#1)]
 [!code-vb[System.String.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> ist <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Wenn das erste Element der <paramref name="values" /> ist <see langword="null" />, <see cref="M:System.String.Join(System.String,System.Object[])" /> Methode ist nicht die Elemente im verketten <paramref name="values" /> , sondern stattdessen <see cref="F:System.String.Empty" />. Eine Reihe von problemumgehungen zur Behebung dieses Problems stehen zur Verfügung. Weisen Sie den Wert der einfachste Weg ist <see cref="F:System.String.Empty" /> auf das erste Element des Arrays, wie im folgenden Beispiel gezeigt.  
  
[! Code-Csharp[System.String.Join#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/joinfix1.cs#6)] [! Code – Vb[System.String.Join#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/joinfix1.vb#6)]</para></block>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Die Zeichenfolge, die als Trennzeichen verwendet werden soll. <paramref name="separator" /> ist in der zurückgegebenen Zeichenfolge nur enthalten, wenn <paramref name="value" /> mehr als ein Element enthält.</param>
        <param name="value">Ein Array, das die zu verkettenden Elemente enthält.</param>
        <summary>Verkettet alle Elemente eines Zeichenfolgenarrays und verwendet das angegebene Trennzeichen zwischen den einzelnen Elementen.</summary>
        <returns>Eine Zeichenfolge, die aus den Membern von <paramref name="value" /> besteht, getrennt durch die <paramref name="separator" />-Zeichenfolge. Wenn <paramref name="value" /> eine leeres Array ist, gibt die Methode <see cref="F:System.String.Empty" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Z. B. wenn `separator` ist "," und die Elemente der `value` sind "Apple", "Orange", "Grape" und "Pear", `Join(separator, value)` gibt "" Apple "," Orange "," Grape "," Pear ".  
  
 Wenn `separator` ist `null`, eine leere Zeichenfolge (<xref:System.String.Empty?displayProperty=nameWithType>) wird stattdessen verwendet. Wenn ein Element in `value` ist `null`, eine leere Zeichenfolge wird stattdessen verwendet.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.Join%2A> Methode.  
  
 [!code-cpp[stringjoin#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringjoin/CPP/stringjoin.cpp#1)]
 [!code-csharp[stringjoin#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringjoin/CS/stringjoin.cs#1)]
 [!code-vb[stringjoin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringjoin/VB/stringjoin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">Die Zeichenfolge, die als Trennzeichen verwendet werden soll. <paramref name="separator" /> ist in der zurückgegebenen Zeichenfolge nur enthalten, wenn <paramref name="value" /> mehr als ein Element enthält.</param>
        <param name="value">Ein Array, das die zu verkettenden Elemente enthält.</param>
        <param name="startIndex">Das erste zu verwendende Element aus <paramref name="value" />.</param>
        <param name="count">Die Anzahl der zu verwendenden Elemente aus <paramref name="value" />.</param>
        <summary>Verkettet die angegebenen Elemente eines Zeichenfolgenarrays und verwendet das angegebene Trennzeichen zwischen den einzelnen Elementen.</summary>
        <returns>Eine Zeichenfolge, die aus den Zeichenfolgen in <paramref name="value" /> besteht, getrennt durch die <paramref name="separator" />-Zeichenfolge.  
  
- oder -  
 <see cref="F:System.String.Empty" />, wenn <paramref name="count" /> 0 (null) ist, <paramref name="value" /> keine Elemente enthält oder <paramref name="separator" /> und alle Elemente von <paramref name="value" /> <see cref="F:System.String.Empty" /> sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Z. B. wenn `separator` ist "," und die Elemente der `value` sind "Apple", "Orange", "Grape" und "Pear", `Join(separator, value, 1, 2)` gibt "Orange, Grape".  
  
 Wenn `separator` ist `null`, eine leere Zeichenfolge (<xref:System.String.Empty?displayProperty=nameWithType>) wird stattdessen verwendet. Wenn ein Element in `value` ist `null`, eine leere Zeichenfolge wird stattdessen verwendet.  
  
   
  
## Examples  
 Im folgende Beispiel werden zwei Elemente aus einem Array von Namen von Früchten verkettet.  
  
 [!code-cpp[string.join2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.join2/CPP/join2.cpp#1)]
 [!code-csharp[string.join2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.join2/CS/join2.cs#1)]
 [!code-vb[string.join2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.join2/VB/join2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> oder <paramref name="count" /> ist kleiner als 0 (null).  
  
- oder -  
 <paramref name="startIndex" /> plus <paramref name="count" /> ist größer als die Anzahl von Elementen in <paramref name="value" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Nicht genügend Arbeitsspeicher.</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As Char, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As String, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ der Member von <paramref name="values" />.</typeparam>
        <param name="separator">Die Zeichenfolge, die als Trennzeichen verwendet werden soll.<paramref name="separator" /> ist in der zurückgegebenen Zeichenfolge nur enthalten, wenn <paramref name="values" /> mehr als ein Element enthält.</param>
        <param name="values">Eine Auflistung, die die zu verkettenden Objekte enthält.</param>
        <summary>Verkettet die Member einer Auflistung und verwendet das angegebene Trennzeichen zwischen den einzelnen Membern.</summary>
        <returns>Eine Zeichenfolge, die aus den Membern von <paramref name="values" /> besteht, getrennt durch die <paramref name="separator" />-Zeichenfolge. Wenn <paramref name="values" /> keine Mitglieder hat, gibt die Methode <see cref="F:System.String.Empty" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `separator` ist `null`, eine leere Zeichenfolge (<xref:System.String.Empty?displayProperty=nameWithType>) wird stattdessen verwendet. Wenn alle Member des `values` ist `null`, eine leere Zeichenfolge wird stattdessen verwendet.  
  
 <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> ist eine bequeme Methode, mit dem Sie verketten, jedes Mitglied einer <xref:System.Collections.Generic.IEnumerable%601> Auflistung ohne sie in Zeichenfolgen konvertiert. Die Zeichenfolgendarstellung der einzelnen Objekte in der <xref:System.Collections.Generic.IEnumerable%601> Auflistung wird durch Aufrufen des Objekts abgeleitet `ToString` Methode.  
  
 Diese Methode ist besonders nützlich bei Abfrageausdrücken Language-Integrated Query (LINQ). Der folgende Code definiert z. B. eine sehr einfache `Animal` Klasse enthält den Namen des Tieres und die Reihenfolge an, zu dem er gehört. Es definiert dann eine <xref:System.Collections.Generic.List%601> -Objekt, das eine Reihe von enthält `Animal` Objekte. Die <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> Erweiterungsmethode aufgerufen, um das Extrahieren der `Animal` Objekte, deren `Order` -Eigenschaft gleich "Nagetier". Das Ergebnis wird zum Übergeben der <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> Methode.  
  
 [!code-csharp[System.String.Join#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join5.cs#5)]
 [!code-vb[System.String.Join#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join5.vb#5)]  
  
   
  
## Examples  
 Im folgenden Beispiel wird den Algorithmus Sieb des Eratosthenes zum Berechnen von Primzahlen, die kleiner als oder gleich 100 sind. Weist das Ergebnis einer <xref:System.Collections.Generic.List%601> Objekt vom typinteger, die es dann an übergibt die <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> Methode.  
  
 [!code-csharp[System.String.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join2.cs#2)]
 [!code-vb[System.String.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die NULL-basierte Indexposition des letzten Vorkommens eines angegebenen Unicode-Zeichens oder einer angegebenen Unicode-Zeichenfolge in dieser Instanz an. Die Methode gibt -1 zurück, wenn das Zeichen oder die Zeichenfolge in dieser Instanz nicht gefunden wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Das zu suchende Unicode-Zeichen.</param>
        <summary>Gibt die NULL-basierte Indexposition des letzten Vorkommens eines angegebenen Unicode-Zeichens in dieser Instanz an.</summary>
        <returns>Die nullbasierte Indexposition von <paramref name="value" />, wenn dieses Zeichen gefunden wurde, andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Index die Nummerierung beginnt bei 0 (null). D. h. das erste Zeichen in der Zeichenfolge ist, am Index 0 (null) und das letzte liegt bei <xref:System.String.Length%2A> - 1.  
  
 Diese Methode beginnt die Suche an der Position des letzten Zeichens dieser Instanz und wird rückwärts bis entweder fortgesetzt, `value` gefunden wird oder die Position des erste Zeichens überprüft wurde. Bei der Suche wird die Groß- und Kleinschreibung berücksichtigt.  
  
 Diese Methode führt eine ordinale (kulturunabhängige) Suche, in dem ein Zeichen als gleich betrachtet, ein anderes Zeichen nur dann, wenn die Unicode-Skalarwerten identisch sind. Um eine kulturabhängige Suche durchzuführen, verwenden die <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> -Methode, in dem ein Unicode-Skalarwert, ein zusammengesetztes Zeichen, z. B. die Ligatur "Æ" (U + 00 C 6) betrachtet werden kann entspricht jedem Vorkommen des Zeichens-Komponenten in der Korrigieren Sie die Sequenz, wie z. B. "AE" (U + 0041, U + 0045), je nach Kultur.  
  
   
  
## Examples  
 Das folgende Beispiel definiert eine `ExtractFilename` Methode, verwendet der <xref:System.String.LastIndexOf%28System.Char%29> Methode, um das letzte Verzeichnistrennzeichen in einer Zeichenfolge gesucht und Dateinamen der Zeichenfolge zu extrahieren. Wenn die Datei vorhanden ist, gibt die Methode den Dateinamen ohne Pfad zurück.  
  
 [!code-csharp[System.String.LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/LastIndexOf_Example.cs#1)]
 [!code-vb[System.String.LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/LastIndexOf_Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <summary>Gibt die NULL-basierte Indexposition des letzten Vorkommens einer angegebenen Zeichenfolge in dieser Instanz an.</summary>
        <returns>Die nullbasierte Indexposition von <paramref name="value" />, wenn diese Zeichenfolge gefunden wurde, andernfalls -1. Wenn <paramref name="value" /><see cref="F:System.String.Empty" /> ist, ist der Rückgabewert die letzte Indexposition in dieser Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Index die Nummerierung beginnt bei 0 (null). D. h. das erste Zeichen in der Zeichenfolge ist, am Index 0 (null) und das letzte liegt bei <xref:System.String.Length%2A> - 1.  
  
 Die Suche beginnt an der Position des letzten Zeichens dieser Instanz und wird rückwärts bis entweder fortgesetzt, `value` gefunden wird oder die Position des erste Zeichens überprüft wurde.  
  
 Diese Methode führt eine Wortsuche (Groß-/Kleinschreibung beachtet und kulturabhängige) mit der aktuellen Kultur.  
  
 Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Bei einer kulturabhängige Suche, bei der `value` ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen. Wenn `value` besteht nur aus ein oder mehrere Ignorierbare Zeichen, die <xref:System.String.LastIndexOf%28System.String%29> Methode gibt immer <xref:System.String.Length%2A?displayProperty=nameWithType> -1, der die letzte Indexposition in der aktuellen Instanz darstellt. Im folgenden Beispiel die <xref:System.String.LastIndexOf%28System.String%29> Methode wird verwendet, um drei Teilzeichenfolgen (einen bedingten Bindestrich (U + 00AD), einen bedingten Bindestrich gefolgt von "n" und einen bedingten Bindestrich gefolgt von "m") in zwei Zeichenfolgen zu suchen. Nur eine der Zeichenfolgen enthält einen bedingten Bindestrich. Wenn Sie das Beispiel ausgeführt wird, auf die [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher in jedem Fall, da die bedingten Bindestrich ein ignorierbares Zeichen ist das Ergebnis ist identisch, als ob bedingten Bindestrichs nicht in einbezogen wurden, mussten `value`. Bei der Suche nach nur einen bedingten Bindestrich erfolgt die Methodenrückgabe, 6 und 5. Diese Werte entsprechen dem Index des letzten Zeichens in den beiden Zeichenfolgen.  
  
 [!code-csharp[System.String.LastIndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof21.cs#21)]
 [!code-vb[System.String.LastIndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof21.vb#21)]  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Start- und Endtags HTML-Zeichenfolge, wenn die Tags beginnen und am Ende der Zeichenfolge. Wenn eine Zeichenfolge mit einer schließenden beendet Klammer Zeichen (">"), im Beispiel wird die <xref:System.String.LastIndexOf%2A> Methode, um den Start des Endtags zu suchen.  
  
 [!code-csharp[System.String.LastIndexOf#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof_example2.cs#2)]
 [!code-vb[System.String.LastIndexOf#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof_example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Siehe [bewährte Methoden für die Verwendung von Zeichenfolgen](~/docs/standard/base-types/best-practices-strings.md), es wird empfohlen, dass Sie vermeiden, Aufrufen von Methoden zum Zeichenfolgenvergleich, die Standardwerte ersetzen, und rufen stattdessen die Methoden, die für Parameter explizit angegeben werden müssen. Um den letzten Index einer Unterzeichenfolge einer Zeichenfolgeninstanz mit die Vergleichsregeln der aktuellen Kultur zu suchen, rufen die <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> methodenüberladung mit einem Wert von <see cref="F:System.StringComparison.CurrentCulture" /> für seine <paramref name="comparisonType" /> Parameter.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Das zu suchende Unicode-Zeichen.</param>
        <param name="startIndex">Die Anfangsposition der Suche. Die Suche wird von <paramref name="startIndex" /> bis zum Anfang dieser Instanz fortgesetzt.</param>
        <summary>Gibt die NULL-basierte Indexposition des letzten Vorkommens eines angegebenen Unicode-Zeichens in dieser Instanz an. Die Suche beginnt an einer angegebenen Zeichenposition und wird rückwärts bis zum Anfang der Zeichenfolge fortgesetzt.</summary>
        <returns>Die nullbasierte Indexposition von <paramref name="value" />, wenn dieses Zeichen gefunden wurde, oder -1, wenn es nicht gefunden wurde oder die aktuelle Instanz gleich <see cref="F:System.String.Empty" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Index die Nummerierung beginnt bei 0 (null). D. h. das erste Zeichen in der Zeichenfolge ist, am Index 0 (null) und das letzte liegt bei <xref:System.String.Length%2A> -1. diese Methode beginnt die Suche an der `startIndex` Zeichen Position dieser Instanz und wird rückwärts bis zum Anfang der aktuellen Instanz erst fortgesetzt `value` gefunden wird oder die Position des erste Zeichens überprüft wurde. Z. B. wenn `startIndex` ist <xref:System.String.Length%2A> - 1, sucht die Methode alle Zeichen aus dem letzten Zeichen in der Zeichenfolge an den Anfang. Bei der Suche wird die Groß- und Kleinschreibung berücksichtigt.  
  
 Diese Methode führt eine ordinale (kulturunabhängige) Suche, in dem ein Zeichen als gleich betrachtet, ein anderes Zeichen nur dann, wenn die Unicode-Skalarwerten identisch sind. Um eine kulturabhängige Suche durchzuführen, verwenden die <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> -Methode, in dem ein Unicode-Skalarwert, ein zusammengesetztes Zeichen, z. B. die Ligatur "Æ" (U + 00 C 6) betrachtet werden kann entspricht jedem Vorkommen des Zeichens-Komponenten in der Korrigieren Sie die Sequenz, wie z. B. "AE" (U + 0041, U + 0045), je nach Kultur.  
  
   
  
## Examples  
 Das folgende Beispiel sucht den Index der alle Vorkommen eines Zeichens in einer Zeichenfolge am Ende der Zeichenfolge an den Anfang der Zeichenfolge verwenden.  
  
 [!code-cpp[string.lastindexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof1/CPP/lastixof1.cpp#1)]
 [!code-csharp[string.lastindexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof1/CS/lastixof1.cs#1)]
 [!code-vb[string.lastindexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof1/VB/lastixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist kleiner als 0 (null) oder größer oder gleich der Länge dieser Instanz.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <param name="startIndex">Die Anfangsposition der Suche. Die Suche wird von <paramref name="startIndex" /> bis zum Anfang dieser Instanz fortgesetzt.</param>
        <summary>Gibt die NULL-basierte Indexposition des letzten Vorkommens einer angegebenen Zeichenfolge in dieser Instanz an. Die Suche beginnt an einer angegebenen Zeichenposition und wird rückwärts bis zum Anfang der Zeichenfolge fortgesetzt.</summary>
        <returns>Die nullbasierte Anfangsindexposition von <paramref name="value" />, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde oder die aktuelle Instanz gleich <see cref="F:System.String.Empty" /> ist. Wenn <paramref name="value" /> <see cref="F:System.String.Empty" /> ist, ist der Rückgabewert der kleinere <paramref name="startIndex" /> und die letzte Indexposition in dieser Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Index die Nummerierung beginnt bei 0 (null). D. h. das erste Zeichen in der Zeichenfolge ist, am Index 0 (null) und das letzte liegt bei <xref:System.String.Length%2A> - 1.  
  
 Die Suche beginnt an der `startIndex` Zeichen Position dieser Instanz und wird fortgesetzt, bis entweder rückwärts `value` gefunden wird oder die Position des erste Zeichens überprüft wurde. Z. B. wenn `startIndex` ist <xref:System.String.Length%2A> - 1, sucht die Methode alle Zeichen aus dem letzten Zeichen in der Zeichenfolge an den Anfang.  
  
 Diese Methode führt eine Wortsuche (Groß-/Kleinschreibung beachtet und kulturabhängige) mit der aktuellen Kultur.  
  
 Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Bei einer kulturabhängige Suche, bei der `value` ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen. Wenn `value` besteht nur aus ein oder mehrere Ignorierbare Zeichen, die <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> Methode gibt immer `startIndex`, d.h. die Zeichenposition, an dem die Suche beginnt. Im folgenden Beispiel die <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> Methode wird verwendet, finden Sie eine untergeordnete Zeichenfolge, die einen bedingten Bindestrich (U + 00AD) enthält und die vorangestellt ist, oder das letzte "m" in einer Zeichenfolge enthält. Wenn Sie das Beispiel ausgeführt wird, auf die [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher, da bedingten Bindestrichs in der Suchzeichenfolge ignoriert wird, einen Aufruf der Methode zu eine Teilzeichenfolge, die besteht aus den bedingten Bindestrich und "m" gibt die Position des "m" in der Zeichenfolge, suchen, während aufrufen, um eine Substrin suchen g, der den bedingten Bindestrich und "n" besteht, gibt die Position der "n" zurück. Wenn die zu suchende Zeichenfolge nur für den bedingten Bindestrich enthält, die Methode gibt den Index des "m", steht für den Wert der `startIndex`.  
  
 [!code-csharp[System.String.LastIndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof22.cs#22)]
 [!code-vb[System.String.LastIndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof22.vb#22)]  
  
   
  
## Examples  
 Das folgende Beispiel sucht den Index der alle Vorkommen einer Zeichenfolge in der Zielzeichenfolge, wird am Ende der Zielzeichenfolge an den Anfang der Zielzeichenfolge arbeiten.  
  
 [!code-cpp[string.lastindexof7#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf7/CPP/lastixof7.cpp#1)]
 [!code-csharp[string.lastindexof7#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf7/CS/lastixof7.cs#1)]
 [!code-vb[string.lastindexof7#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf7/VB/lastixof7.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist kleiner als 0 (null) oder größer als die Länge der aktuellen Instanz.  
  
- oder -  
Die aktuelle Instanz entspricht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist kleiner als -1 oder größer als 0 (null).</exception>
        <block subset="none" type="usage"><para>Siehe [bewährte Methoden für die Verwendung von Zeichenfolgen](~/docs/standard/base-types/best-practices-strings.md), es wird empfohlen, dass Sie vermeiden, Aufrufen von Methoden zum Zeichenfolgenvergleich, die Standardwerte ersetzen, und rufen stattdessen die Methoden, die für Parameter explizit angegeben werden müssen. Um den Index einer Teilzeichenfolge suchen, die eine bestimmten Zeichenposition, die mit die Vergleichsregeln der aktuellen Kultur vorangestellt ist, rufen die <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> methodenüberladung mit einem Wert von <see cref="F:System.StringComparison.CurrentCulture" /> für seine <paramref name="comparisonType" /> Parameter.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * StringComparison -&gt; int" Usage="string.LastIndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <param name="comparisonType">Einer der Enumerationswerte, der die Regeln für die Suche angibt.</param>
        <summary>Gibt den NULL-basierten Index des letzten Vorkommens einer angegebenen Zeichenfolge im aktuellen <see cref="T:System.String" />-Objekt an. Ein Parameter gibt den Typ der Suche für die angegebene Zeichenfolge an.</summary>
        <returns>Die nullbasierte Indexposition des <paramref name="value" />-Parameters, wenn diese Zeichenfolge gefunden wurde, andernfalls -1. Wenn <paramref name="value" /><see cref="F:System.String.Empty" /> ist, ist der Rückgabewert die letzte Indexposition in dieser Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Index die Nummerierung beginnt bei 0 (null). D. h. das erste Zeichen in der Zeichenfolge ist, am Index 0 (null) und das letzte liegt bei <xref:System.String.Length%2A> - 1.  
  
 Die `comparisonType` Parameter gibt an, dass für die Suche die `value` Parameter unter Verwendung der aktuellen oder der invarianten Kultur, mithilfe einer Suche Groß- und Kleinschreibung beachtet und mithilfe von Word oder Ordinalvergleichsregeln.  
  
 Die Suche beginnt an der Position des letzten Zeichens dieser Instanz und wird rückwärts bis entweder fortgesetzt, `value` gefunden wird oder die Position des erste Zeichens überprüft wurde.  
  
   
  
## Examples  
 Die folgenden Exampledemonstrates drei Überladungen, der die <xref:System.String.LastIndexOf%2A> -Methode, die das letzte Vorkommen einer Zeichenfolge innerhalb einer anderen Zeichenfolge, die mit unterschiedlichen Werten der suchen die <xref:System.StringComparison> Enumeration.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> ist kein gültiger <see cref="T:System.StringComparison" />-Wert.</exception>
        <block subset="none" type="usage"><para>Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Bei einer kulturabhängige Suche (das heißt, wenn <paramref name="options" /> nicht <see cref="F:System.StringComparison.Ordinal" /> oder <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> ist), bei der <paramref name="value" /> ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen. Wenn <paramref name="value" /> besteht nur aus ein oder mehrere Ignorierbare Zeichen, die <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> Methode gibt immer <see cref="P:System.String.Length" /> -1, der die letzte Indexposition in der aktuellen Instanz darstellt.  
  
Im folgenden Beispiel die <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> Methode wird verwendet, um drei Teilzeichenfolgen (einen bedingten Bindestrich (U + 00AD), einen bedingten Bindestrich gefolgt von "n" und einen bedingten Bindestrich gefolgt von "m") in zwei Zeichenfolgen zu suchen. Nur eine der Zeichenfolgen enthält einen bedingten Bindestrich. Wenn Sie das Beispiel ausgeführt wird, auf die [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher, da der bedingten Bindestrich ein ignorierbares Zeichen ist, eine kulturabhängige Suche derselbe Wert zurückgegeben, die es zurückgegeben würde, wenn es sich bei bedingten Bindestrichs nicht in der Suchzeichenfolge enthalten waren. Allerdings eine Ordinalsuche erfolgreich bedingten Bindestrichs in einer Zeichenfolge sucht und gibt an, dass sie nicht vorhanden ist aus der zweiten Zeichenfolge.  
  
[! Code-Csharp[System.String.LastIndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof26.cs#26)] [! Code – Vb[System.String.LastIndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof26.vb#26)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Das zu suchende Unicode-Zeichen.</param>
        <param name="startIndex">Die Anfangsposition der Suche. Die Suche wird von <paramref name="startIndex" /> bis zum Anfang dieser Instanz fortgesetzt.</param>
        <param name="count">Die Anzahl der zu überprüfenden Zeichenpositionen.</param>
        <summary>Gibt die NULL-basierte Indexposition des letzten Vorkommens des angegebenen Unicode-Zeichens in einer Teilzeichenfolge dieser Instanz an. Die Suche beginnt an einer angegebenen Zeichenposition und verläuft für eine angegebene Anzahl von Zeichenpositionen rückwärts zum Anfang der Zeichenfolge.</summary>
        <returns>Die nullbasierte Indexposition von <paramref name="value" />, wenn dieses Zeichen gefunden wurde, oder -1, wenn es nicht gefunden wurde oder die aktuelle Instanz gleich <see cref="F:System.String.Empty" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Index die Nummerierung beginnt bei 0 (null). D. h. das erste Zeichen in der Zeichenfolge ist, am Index 0 (null) und das letzte liegt bei <xref:System.String.Length%2A> - 1.  
  
 Diese Methode beginnt die Suche an der `startIndex` Zeichen, Position und wird fortgesetzt, bis zum Anfang dieser Instanz erst nach hinten `value` gefunden wird oder `count` Zeichenpositionen überprüft wurden. Z. B. wenn `startIndex` ist <xref:System.String.Length%2A> - 1, sucht die Methode nach hinten `count` Zeichen aus dem letzten Zeichen in der Zeichenfolge. Bei der Suche wird die Groß- und Kleinschreibung berücksichtigt.  
  
 Diese Methode führt eine ordinale (kulturunabhängige) Suche, in dem ein Zeichen als gleich betrachtet, ein anderes Zeichen nur dann, wenn die Unicode-Skalarwert identisch sind. Um eine kulturabhängige Suche durchzuführen, verwenden die <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> -Methode, in dem ein Unicode-Skalarwert, ein zusammengesetztes Zeichen, z. B. die Ligatur "Æ" (U + 00 C 6) betrachtet werden kann entspricht jedem Vorkommen des Zeichens-Komponenten in der Korrigieren Sie die Sequenz, wie z. B. "AE" (U + 0041, U + 0045), je nach Kultur.  
  
   
  
## Examples  
 Das folgende Beispiel sucht den Index der alle Vorkommen eines Zeichens in einer Teilzeichenfolge, arbeiten an den Anfang der Teilzeichenfolge am Ende der Teilzeichenfolge.  
  
 [!code-cpp[string.lastindexof2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof2/CPP/lastixof2.cpp#1)]
 [!code-csharp[string.lastindexof2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof2/CS/lastixof2.cs#1)]
 [!code-vb[string.lastindexof2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof2/VB/lastixof2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist kleiner als 0 (null) oder größer oder gleich der Länge dieser Instanz.  
  
- oder -  
Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> - <paramref name="count" /> + 1 ist kleiner als 0 (null).</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <param name="startIndex">Die Anfangsposition der Suche. Die Suche wird von <paramref name="startIndex" /> bis zum Anfang dieser Instanz fortgesetzt.</param>
        <param name="count">Die Anzahl der zu überprüfenden Zeichenpositionen.</param>
        <summary>Gibt die NULL-basierte Indexposition des letzten Vorkommens einer angegebenen Zeichenfolge in dieser Instanz an. Die Suche beginnt an einer angegebenen Zeichenposition und verläuft für eine angegebene Anzahl von Zeichenpositionen rückwärts zum Anfang der Zeichenfolge.</summary>
        <returns>Die nullbasierte Anfangsindexposition von <paramref name="value" />, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde oder die aktuelle Instanz gleich <see cref="F:System.String.Empty" /> ist. Wenn <paramref name="value" /> <see cref="F:System.String.Empty" /> ist, ist der Rückgabewert der kleinere <paramref name="startIndex" /> und die letzte Indexposition in dieser Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Index die Nummerierung beginnt bei 0 (null). D. h. das erste Zeichen in der Zeichenfolge ist, am Index 0 (null) und das letzte liegt bei <xref:System.String.Length%2A> - 1.  
  
 Die Suche beginnt an der `startIndex` Zeichen Position dieser Instanz und wird fortgesetzt, bis entweder rückwärts `value` gefunden wird oder `count` Zeichenpositionen überprüft wurden. Z. B. wenn `startIndex` ist <xref:System.String.Length%2A> - 1, sucht die Methode nach hinten `count` Zeichen aus dem letzten Zeichen in der Zeichenfolge.  
  
 Diese Methode führt eine Wortsuche (Groß-/Kleinschreibung beachtet und kulturabhängige) mit der aktuellen Kultur.  
  
 Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Bei einer kulturabhängige Suche, bei der `value` ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen. Wenn `value` besteht nur aus ein oder mehrere Ignorierbare Zeichen, die <xref:System.String.LastIndexOf%2A> Methode gibt immer `startIndex`, d.h. die Zeichenposition, an dem die Suche beginnt. Im folgenden Beispiel die <xref:System.String.LastIndexOf%2A> Methode wird verwendet, um die Position der einen bedingten Bindestrich (U + 00AD) in den beiden Zeichen zu finden, die vor der letzten "m" von zwei Zeichenfolgen. Nur eine der Zeichenfolgen enthält die erforderliche Teilzeichenfolge. Wenn Sie das Beispiel ausgeführt wird, auf die [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher in beiden Fällen, da die bedingten Bindestrich ein ignorierbares Zeichen ist die Methode gibt den Index des "m" in der Zeichenfolge, wenn sie einen kulturabhängigen Vergleich ausführt. Beachten Sie, dass bei der ersten Zeichenfolge, die den bedingten Bindestrich gefolgt von einem "m" umfasst, die Methode den Index des bedingten Bindestrichs nicht zurückgeben kann, sondern stattdessen den Index des "m" zurückgibt.  
  
 [!code-csharp[System.String.LastIndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof23.cs#23)]
 [!code-vb[System.String.LastIndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof23.vb#23)]  
  
   
  
## Examples  
 Das folgende Beispiel sucht den Index der alle Vorkommen einer Zeichenfolge in Teilzeichenfolgen, arbeiten an den Anfang der Teilzeichenfolge am Ende der Teilzeichenfolge.  
  
 [!code-cpp[string.lastindexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf8/CPP/lastixof8.cpp#1)]
 [!code-csharp[string.lastindexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf8/CS/lastixof8.cs#1)]
 [!code-vb[string.lastindexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf8/VB/lastixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> ist ein negativer Wert.  
  
- oder -  
Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist ein negativer Wert.  
  
- oder -  
Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist größer als die Länge dieser Instanz.  
  
- oder -  
Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> - <paramref name="count" />+ 1 gibt eine Position an, die nicht innerhalb dieser Instanz liegt.  
  
- oder -  
Die aktuelle Instanz entspricht <see cref="F:System.String.Empty" />, und <paramref name="start" /> ist kleiner als -1 oder größer als 0 (null).  
  
- oder -  
Die aktuelle Instanz entspricht <see cref="F:System.String.Empty" />, und <paramref name="count" /> ist größer als 1.</exception>
        <block subset="none" type="usage"><para>Siehe [bewährte Methoden für die Verwendung von Zeichenfolgen](~/docs/standard/base-types/best-practices-strings.md), es wird empfohlen, dass Sie vermeiden, Aufrufen von Methoden zum Zeichenfolgenvergleich, die Standardwerte ersetzen, und rufen stattdessen die Methoden, die für Parameter explizit angegeben werden müssen. Aufrufen, um diesen Vorgang auszuführen, mit die Vergleichsregeln der aktuellen Kultur, die <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> methodenüberladung mit einem Wert von <see cref="F:System.StringComparison.CurrentCulture" /> für seine <paramref name="comparisonType" /> Parameter.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <param name="startIndex">Die Anfangsposition der Suche. Die Suche wird von <paramref name="startIndex" /> bis zum Anfang dieser Instanz fortgesetzt.</param>
        <param name="comparisonType">Einer der Enumerationswerte, der die Regeln für die Suche angibt.</param>
        <summary>Gibt den NULL-basierten Index des letzten Vorkommens einer angegebenen Zeichenfolge im aktuellen <see cref="T:System.String" />-Objekt an. Die Suche beginnt an einer angegebenen Zeichenposition und wird rückwärts bis zum Anfang der Zeichenfolge fortgesetzt. Ein Parameter gibt den Typ des bei der Suche nach der angegebenen Zeichenfolge auszuführenden Vergleichs an.</summary>
        <returns>Die nullbasierte Anfangsindexposition des <paramref name="value" />-Parameters, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde oder die aktuelle Instanz gleich <see cref="F:System.String.Empty" /> ist. Wenn <paramref name="value" /> <see cref="F:System.String.Empty" /> ist, ist der Rückgabewert der kleinere <paramref name="startIndex" /> und die letzte Indexposition in dieser Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Index die Nummerierung beginnt bei 0 (null). D. h. das erste Zeichen in der Zeichenfolge ist, am Index 0 (null) und das letzte liegt bei <xref:System.String.Length%2A> - 1.  
  
 Die Suche beginnt an der `startIndex` Zeichen, Position und wird fortgesetzt, bis entweder rückwärts `value` gefunden wird oder die Position des erste Zeichens überprüft wurde. Z. B. wenn `startIndex` ist <xref:System.String.Length%2A> - 1, sucht die Methode alle Zeichen aus dem letzten Zeichen in der Zeichenfolge an den Anfang.  
  
 Die `comparisonType` Parameter gibt an, dass für die Suche die `value` Parameter unter Verwendung der aktuellen oder der invarianten Kultur, mithilfe einer Suche Groß- und Kleinschreibung beachtet und mithilfe von Word oder Ordinalvergleichsregeln.  
  
   
  
## Examples  
 Die folgenden Exampledemonstrates drei Überladungen, der die <xref:System.String.LastIndexOf%2A> -Methode, die das letzte Vorkommen einer Zeichenfolge innerhalb einer anderen Zeichenfolge, die mit unterschiedlichen Werten der suchen die <xref:System.StringComparison> Enumeration.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist kleiner als 0 (null) oder größer als die Länge der aktuellen Instanz.  
  
- oder -  
Die aktuelle Instanz entspricht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist kleiner als -1 oder größer als 0 (null).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> ist kein gültiger <see cref="T:System.StringComparison" />-Wert.</exception>
        <block subset="none" type="usage"><para>Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Bei einer kulturabhängige Suche (das heißt, wenn <paramref name="comparisonType" /> nicht <see cref="F:System.StringComparison.Ordinal" /> oder <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> ist), bei der <paramref name="value" /> ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen. Wenn <paramref name="value" /> besteht nur aus ein oder mehrere Ignorierbare Zeichen, die <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> Methode gibt immer <paramref name="startIndex" />, d.h. die Zeichenposition, an dem die Suche beginnt.  
  
Im folgenden Beispiel die <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> Methode wird verwendet, um die Position (U + 00AD) über einen bedingten Bindestrich gefolgt von einem "m", beginnend mit dem letzten "m" in zwei Zeichenfolgen zu suchen. Nur eine der Zeichenfolgen enthält die erforderliche Teilzeichenfolge. Wenn Sie das Beispiel ausgeführt wird, auf die [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher in beiden Fällen, da die bedingten Bindestrich ein ignorierbares Zeichen ist die Methode gibt den Index des "m" in der Zeichenfolge, wenn sie einen kulturabhängigen Vergleich ausführt. Beachten Sie, dass bei der ersten Zeichenfolge, die den bedingten Bindestrich gefolgt von einem "m" umfasst, die Methode den Index des bedingten Bindestrichs nicht zurückgeben kann, sondern stattdessen den Index des "m" zurückgibt. Die Methode gibt den Index des bedingten Bindestrichs in der ersten Zeichenfolge nur dann zurück, wenn sie einen Ordinalvergleich ausführt.  
  
[! Code-Csharp[System.String.LastIndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof25.cs#25)] [! Code – Vb[System.String.LastIndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof25.vb#25)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Die zu suchende Zeichenfolge.</param>
        <param name="startIndex">Die Anfangsposition der Suche. Die Suche wird von <paramref name="startIndex" /> bis zum Anfang dieser Instanz fortgesetzt.</param>
        <param name="count">Die Anzahl der zu überprüfenden Zeichenpositionen.</param>
        <param name="comparisonType">Einer der Enumerationswerte, der die Regeln für die Suche angibt.</param>
        <summary>Gibt die NULL-basierte Indexposition des letzten Vorkommens einer angegebenen Zeichenfolge in dieser Instanz an. Die Suche beginnt an einer angegebenen Zeichenposition und verläuft für eine angegebene Anzahl von Zeichenpositionen rückwärts zum Anfang der Zeichenfolge. Ein Parameter gibt den Typ des bei der Suche nach der angegebenen Zeichenfolge auszuführenden Vergleichs an.</summary>
        <returns>Die nullbasierte Anfangsindexposition des <paramref name="value" />-Parameters, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht gefunden wurde oder die aktuelle Instanz gleich <see cref="F:System.String.Empty" /> ist. Wenn <paramref name="value" /> <see cref="F:System.String.Empty" /> ist, ist der Rückgabewert der kleinere <paramref name="startIndex" /> und die letzte Indexposition in dieser Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Index die Nummerierung beginnt bei 0 (null). D. h. das erste Zeichen in der Zeichenfolge ist, am Index 0 (null) und das letzte liegt bei <xref:System.String.Length%2A> - 1.  
  
 Die Suche beginnt an der `startIndex` Zeichen, Position und wird fortgesetzt, bis entweder rückwärts `value` gefunden wird oder `count` Zeichenpositionen überprüft wurden. Z. B. wenn `startIndex` ist <xref:System.String.Length%2A> - 1, sucht die Methode nach hinten `count` Zeichen aus dem letzten Zeichen in der Zeichenfolge.  
  
 Die `comparisonType` Parameter gibt an, dass für die Suche die `value` Parameter unter Verwendung der aktuellen oder der invarianten Kultur, mithilfe einer Suche Groß- und Kleinschreibung beachtet und mithilfe von Word oder Ordinalvergleichsregeln.  
  
   
  
## Examples  
 Die folgenden Exampledemonstrates drei Überladungen, der die <xref:System.String.LastIndexOf%2A> -Methode, die das letzte Vorkommen einer Zeichenfolge innerhalb einer anderen Zeichenfolge, die mit unterschiedlichen Werten der suchen die <xref:System.StringComparison> Enumeration.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> ist ein negativer Wert.  
  
- oder -  
Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist ein negativer Wert.  
  
- oder -  
Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> ist größer als die Länge dieser Instanz.  
  
- oder -  
Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> + 1 - <paramref name="count" /> gibt eine Position an, die nicht innerhalb dieser Instanz liegt.  
  
- oder -  
Die aktuelle Instanz entspricht <see cref="F:System.String.Empty" />, und <paramref name="start" /> ist kleiner als -1 oder größer als 0 (null).  
  
- oder -  
Die aktuelle Instanz entspricht <see cref="F:System.String.Empty" />, und <paramref name="count" /> ist größer als 1.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> ist kein gültiger <see cref="T:System.StringComparison" />-Wert.</exception>
        <block subset="none" type="usage"><para>Zeichensätze enthalten ignorierbare Zeichen, d. h. Zeichen, die bei der Durchführung eines linguistischen oder kulturabhängigen Vergleichs nicht berücksichtigt werden. Bei einer kulturabhängige Suche (das heißt, wenn <paramref name="comparisonType" /> nicht <see cref="F:System.StringComparison.Ordinal" /> oder <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> ist), bei der <paramref name="value" /> ein ignorierbares Zeichen enthält, ist das Ergebnis das gleiche wie bei einer Suche ohne dieses Zeichen. Wenn <paramref name="value" /> besteht nur aus ein oder mehrere Ignorierbare Zeichen, die <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> Methode gibt immer <paramref name="startIndex" />, d.h. die Zeichenposition, an dem die Suche beginnt.  
  
Im folgenden Beispiel die <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> Methode wird verwendet, um die Position (U + 00AD) über einen bedingten Bindestrich gefolgt von einem "m" in allen jedoch der ersten Zeichenposition vor dem letzten "m" in zwei Zeichenfolgen zu suchen. Nur eine der Zeichenfolgen enthält die erforderliche Teilzeichenfolge. Wenn Sie das Beispiel ausgeführt wird, auf die [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] oder höher in beiden Fällen, da die bedingten Bindestrich ein ignorierbares Zeichen ist die Methode gibt den Index des "m" in der Zeichenfolge, wenn sie einen kulturabhängigen Vergleich ausführt. Wenn sie einen Ordinalvergleich ausführt, sucht er die Teilzeichenfolge jedoch nur in der ersten Zeichenfolge fest. Beachten Sie, dass bei der ersten Zeichenfolge, die den bedingten Bindestrich gefolgt von einem "m" enthält, die Methode ein Fehler auftritt, um den Index des bedingten Bindestrichs zurückzugeben, aber gibt stattdessen den Index des "m" aus, wenn er einen kulturabhängigen Vergleich ausführt. Die Methode gibt den Index des bedingten Bindestrichs in der ersten Zeichenfolge nur dann zurück, wenn sie einen Ordinalvergleich ausführt.  
  
[! Code-Csharp[System.String.LastIndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof24.cs#24)] [! Code – Vb[System.String.LastIndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof24.vb#24)]</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die NULL-basierte Indexposition des letzten Vorkommens eines oder mehrerer angegebener Zeichen eines Unicode-Arrays in dieser Instanz an. Die Methode gibt -1 zurück, wenn die Zeichen im Array nicht in dieser Instanz gefunden werden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] -&gt; int" Usage="string.LastIndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">Ein Array von Unicode-Zeichen mit mindestens einem zu suchenden Zeichen.</param>
        <summary>Gibt die NULL-basierte Indexposition des letzten Vorkommens eines oder mehrerer angegebener Zeichen eines Unicode-Arrays in dieser Instanz an.</summary>
        <returns>Die Indexposition des letzten Vorkommens eines beliebigen Zeichens aus <paramref name="anyOf" /> in dieser Instanz. -1, wenn kein Zeichen in <paramref name="anyOf" /> gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Index die Nummerierung beginnt bei 0 (null).  
  
 Diese Methode beginnt die Suche an dieser Instanz der letzten Zeichenposition und verläuft rückwärts zum Anfang bis entweder ein Zeichen in `anyOf` gefunden wird oder die Position des erste Zeichens überprüft wurde. Bei der Suche wird die Groß- und Kleinschreibung berücksichtigt.  
  
 Diese Methode führt eine ordinale (kulturunabhängige) Suche, in dem ein Zeichen als gleich betrachtet, ein anderes Zeichen nur dann, wenn die Unicode-Skalarwerten identisch sind. Um eine kulturabhängige Suche durchzuführen, verwenden die <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> -Methode, in dem ein Unicode-Skalarwert, ein zusammengesetztes Zeichen, z. B. die Ligatur "Æ" (U + 00 C 6) betrachtet werden kann entspricht jedem Vorkommen des Zeichens-Komponenten in der Korrigieren Sie die Sequenz, wie z. B. "AE" (U + 0041, U + 0045), je nach Kultur.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Index des letzten Vorkommens eines beliebigen Zeichens in der Zeichenfolge "is" in einer anderen Zeichenfolge gesucht.  
  
 [!code-cpp[string.lastindexofany1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny1/CPP/lastixany1.cpp#1)]
 [!code-csharp[string.lastindexofany1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny1/CS/lastixany1.cs#1)]
 [!code-vb[string.lastindexofany1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny1/VB/lastixany1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Ein Array von Unicode-Zeichen mit mindestens einem zu suchenden Zeichen.</param>
        <param name="startIndex">Die Anfangsposition der Suche. Die Suche wird von <paramref name="startIndex" /> bis zum Anfang dieser Instanz fortgesetzt.</param>
        <summary>Gibt die NULL-basierte Indexposition des letzten Vorkommens eines oder mehrerer angegebener Zeichen eines Unicode-Arrays in dieser Instanz an. Die Suche beginnt an einer angegebenen Zeichenposition und wird rückwärts bis zum Anfang der Zeichenfolge fortgesetzt.</summary>
        <returns>Die Indexposition des letzten Vorkommens eines beliebigen Zeichens aus <paramref name="anyOf" /> in dieser Instanz. -1, wenn kein Zeichen in <paramref name="anyOf" /> gefunden wurde, oder wenn die aktuelle Instanz gleich <see cref="F:System.String.Empty" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Index die Nummerierung beginnt bei 0 (null).  
  
 Diese Methode beginnt die Suche an der `startIndex` Zeichen Position dieser Instanz und wird fortgesetzt, bis entweder ein Zeichen in rückwärts `anyOf` gefunden wird oder die Position des erste Zeichens überprüft wurde. Bei der Suche wird die Groß- und Kleinschreibung berücksichtigt.  
  
 Diese Methode führt eine ordinale (kulturunabhängige) Suche, in dem ein Zeichen als gleich betrachtet, ein anderes Zeichen nur dann, wenn die Unicode-Skalarwerten identisch sind. Um eine kulturabhängige Suche durchzuführen, verwenden die <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> -Methode, in dem ein Unicode-Skalarwert, ein zusammengesetztes Zeichen, z. B. die Ligatur "Æ" (U + 00 C 6) betrachtet werden kann entspricht jedem Vorkommen des Zeichens-Komponenten in der Korrigieren Sie die Sequenz, wie z. B. "AE" (U + 0041, U + 0045), je nach Kultur.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Index des letzten Vorkommens eines beliebigen Zeichens in der Zeichenfolge "is" in einer Teilzeichenfolge einer anderen Zeichenfolge gesucht.  
  
 [!code-cpp[string.lastindexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny2/CPP/lastixany2.cpp#1)]
 [!code-csharp[string.lastindexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny2/CS/lastixany2.cs#1)]
 [!code-vb[string.lastindexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny2/VB/lastixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> gibt eine Position an, die nicht innerhalb dieser Instanz liegt.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Ein Array von Unicode-Zeichen mit mindestens einem zu suchenden Zeichen.</param>
        <param name="startIndex">Die Anfangsposition der Suche. Die Suche wird von <paramref name="startIndex" /> bis zum Anfang dieser Instanz fortgesetzt.</param>
        <param name="count">Die Anzahl der zu überprüfenden Zeichenpositionen.</param>
        <summary>Gibt die NULL-basierte Indexposition des letzten Vorkommens eines oder mehrerer angegebener Zeichen eines Unicode-Arrays in dieser Instanz an. Die Suche beginnt an einer angegebenen Zeichenposition und verläuft für eine angegebene Anzahl von Zeichenpositionen rückwärts zum Anfang der Zeichenfolge.</summary>
        <returns>Die Indexposition des letzten Vorkommens eines beliebigen Zeichens aus <paramref name="anyOf" /> in dieser Instanz. -1, wenn kein Zeichen in <paramref name="anyOf" /> gefunden wurde, oder wenn die aktuelle Instanz gleich <see cref="F:System.String.Empty" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Index die Nummerierung beginnt bei 0 (null).  
  
 Diese Methode beginnt die Suche an der `startIndex` Zeichen Position dieser Instanz und wird fortgesetzt, bis entweder ein Zeichen in rückwärts `anyOf` gefunden wird oder `count` Zeichenpositionen überprüft wurden. Bei der Suche wird die Groß- und Kleinschreibung berücksichtigt.  
  
 Diese Methode führt eine ordinale (kulturunabhängige) Suche, in dem ein Zeichen als gleich betrachtet, ein anderes Zeichen nur dann, wenn die Unicode-Skalarwerten identisch sind. Um eine kulturabhängige Suche durchzuführen, verwenden die <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> -Methode, in dem ein Unicode-Skalarwert, ein zusammengesetztes Zeichen, z. B. die Ligatur "Æ" (U + 00 C 6) betrachtet werden kann entspricht jedem Vorkommen des Zeichens-Komponenten in der Korrigieren Sie die Sequenz, wie z. B. "AE" (U + 0041, U + 0045), je nach Kultur.  
  
   
  
## Examples  
 Das folgende Beispiel sucht den Index des letzten Vorkommens eines beliebigen Zeichens aus der Zeichenfolge "Hilfe" in einer Teilzeichenfolge einer anderen Zeichenfolge.  
  
 [!code-cpp[string.lastindexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny3/CPP/lastixany3.cpp#1)]
 [!code-csharp[string.lastindexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny3/CS/lastixany3.cs#1)]
 [!code-vb[string.lastindexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny3/VB/lastixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die aktuelle Instanz entspricht nicht <see cref="F:System.String.Empty" />, und <paramref name="count" /> oder <paramref name="startIndex" /> ist ein negativer Wert.  
  
- oder -  
Die aktuelle Instanz ist nicht gleich <see cref="F:System.String.Empty" />, und <paramref name="startIndex" /> minus <paramref name="count" /> + 1 ist weniger als 0 (null).</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.String.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.string.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Zeichen im aktuellen <see cref="T:System.String" />-Objekt ab.</summary>
        <value>Die Anzahl der Zeichen in der aktuellen Zeichenfolge.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.Length%2A> Eigenschaft gibt die Anzahl der <xref:System.Char> Objekte in dieser Instanz, nicht die Anzahl der Unicode-Zeichen. Der Grund ist, dass ein Unicode-Zeichen kann, von mehr als einem dargestellt werden <xref:System.Char>. Verwenden der <xref:System.Globalization.StringInfo?displayProperty=nameWithType> -Klasse statt auf jedes Unicode-Zeichen verwendet <xref:System.Char>.  
  
 In einigen Sprachen wie C und C++ gibt ein Null-Zeichen am Ende einer Zeichenfolge an. In .NET kann ein Null-Zeichen in einer Zeichenfolge eingebettet werden. Wenn eine Zeichenfolge, ein oder mehrere Null-Zeichen enthält, werden sie in die Länge der Zeichenfolge enthalten. Z. B. in der folgenden Zeichenfolge, das die Teilzeichenfolgen, die "Abc" und "Def" durch ein Null-Zeichen getrennt sind. Die <xref:System.String.Length%2A> Eigenschaft zurückgibt, 7, was bedeutet, dass sie die sechs Buchstaben als auch für das Null-Zeichen enthält.  
  
 [!code-cpp[System.String.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/system.string.class.cpp#1)]
 [!code-csharp[System.String.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/System.String.Class.cs#1)]
 [!code-vb[System.String.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/System.String.Class.vb#1)]  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.String.Length%2A> Eigenschaft.  
  
 [!code-cpp[string.length#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.length/CPP/length.cpp#1)]
 [!code-csharp[string.length#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.length/CS/length.cs#1)]
 [!code-vb[string.length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.length/VB/length.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Normalize">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine neue Zeichenfolge zurück, deren binäre Darstellung in einer bestimmten Unicode-Normalisierungsform vorliegt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize" />
      <MemberSignature Language="VB.NET" Value="Public Function Normalize () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize();" />
      <MemberSignature Language="F#" Value="member this.Normalize : unit -&gt; string" Usage="string.Normalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine neue Zeichenfolge zurück, deren Textwert mit dieser Zeichenfolge übereinstimmt, deren binäre Darstellung jedoch in der Unicode-Normalisierungsform C vorliegt.</summary>
        <returns>Eine neue normalisierte Zeichenfolge, deren Textwert mit dieser Zeichenfolge übereinstimmt, deren binäre Darstellung jedoch in der Normalisierungsform C vorliegt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige Unicode-Zeichen umfassen mehrere entsprechende binärdarstellungen bestehend aus Gruppen von der Kombination von und/oder zusammengesetzte Unicode-Zeichen. Beispielsweise kann eine der folgenden Code verweist den Buchstaben "ắ" darstellen:  
  
-   U + 1EAF  
  
-   U + 0103 U + 0301  
  
-   U + 0061 U + 0306 U + 0301  
  
 Das Vorhandensein mehrerer Darstellungen für ein einzelnes Zeichen erschwert suchen, sortieren, Abgleich und andere Vorgänge.  
  
 Die Unicode-standard definiert einen Prozess namens Normalisierung, die eine binäre Darstellung, wenn jede der entsprechende binäre Darstellung eines Zeichens zurückgibt. Normalisierung kann ausgeführt werden, mit mehreren Algorithmen, die genannte Normalisierungsformen, die unterschiedliche Regeln einhalten. .NET unterstützt vier Normalisierungsformen (C, D, KC und KD), die durch die Unicode-Standard definiert sind. Wenn zwei Zeichenfolgen in der gleichen Normalisierungsform dargestellt werden, können sie mithilfe von ordinalen Vergleich verglichen werden.  
  
 Um zu normalisieren, und Vergleichen von zwei Zeichenfolgen, führen Sie folgende Schritte aus:  
  
1.  Rufen Sie die Zeichenfolgen, aus der Eingabequelle, z. B. eine Datei oder ein Eingabegerät Benutzer verglichen werden soll.  
  
2.  Rufen Sie die <xref:System.String.Normalize> Methode, um die Zeichenfolgen in der Normalisierungsform c normalisieren  
  
3.  Um zwei Zeichenfolgen zu vergleichen, rufen Sie eine Methode, Ordinalzeichenfolgenvergleich mit, wie z. B. unterstützt, die <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> -Methode, und geben Sie den Wert <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> oder <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> als die <xref:System.StringComparison> Argument. Um ein Array mit normalisierten Zeichenfolgen zu sortieren, übergeben Sie einen `comparer` Wert <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> oder <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> an eine geeignete Überladung der <xref:System.Array.Sort%2A?displayProperty=nameWithType>.  
  
4.  Geben Sie die Zeichenfolgen in der sortierten Ausgabe basierend auf der im vorherigen Schritt angegebenen Reihenfolge.  
  
 Eine Beschreibung der unterstützten Unicode-Normalisierungsformen, finden Sie unter <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Zeichenfolge, die jede der vier Normalisierungsformen normalisiert, normalisiert und bestätigt die Zeichenfolge wurde in die angegebene Normalisierungsform, die den Codepunkten in die normalisierte Zeichenfolge.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die aktuelle Instanz enthält ungültige Unicode-Zeichen.</exception>
        <block subset="none" type="usage"><para>Die <see cref="Overload:System.String.IsNormalized" /> Methodenrückgabe <see langword="false" /> , sobald es feststellt, dass das erste Zeichen der nicht normalisierte in einer Zeichenfolge. Aus diesem Grund, wenn eine Zeichenfolge nicht normalisierte Zeichen gefolgt von ungültigen Unicode-Zeichen, enthält die <see cref="Overload:System.String.Normalize" /> Methode löst eine <see cref="T:System.ArgumentException" /> zwar <see cref="Overload:System.String.IsNormalized" /> gibt <see langword="false" />.</para></block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.Normalize : System.Text.NormalizationForm -&gt; string" Usage="string.Normalize normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Eine Unicode-Normalisierungsform.</param>
        <summary>Gibt eine neue Zeichenfolge zurück, deren Textwert mit dieser Zeichenfolge übereinstimmt, deren binäre Darstellung jedoch in der angegebenen Unicode-Normalisierungsform vorliegt.</summary>
        <returns>Eine neue Zeichenfolge, deren Textwert mit dieser Zeichenfolge übereinstimmt, deren binäre Darstellung jedoch in der im <paramref name="normalizationForm" />-Parameter angegebenen Normalisierungsform vorliegt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige Unicode-Zeichen umfassen mehrere entsprechende binärdarstellungen bestehend aus Gruppen von der Kombination von und/oder zusammengesetzte Unicode-Zeichen. Das Vorhandensein mehrerer Darstellungen für ein einzelnes Zeichen erschwert suchen, sortieren, Abgleich und andere Vorgänge.  
  
 Die Unicode-standard definiert einen Prozess namens Normalisierung, die eine binäre Darstellung, wenn jede der entsprechende binäre Darstellung eines Zeichens zurückgibt. Normalisierung kann ausgeführt werden, mit mehreren Algorithmen, die genannte Normalisierungsformen, die unterschiedliche Regeln einhalten. .NET unterstützt vier Normalisierungsformen (C, D, KC und KD), die durch die Unicode-Standard definiert sind. Wenn zwei Zeichenfolgen in der gleichen Normalisierungsform dargestellt werden, können sie mithilfe von ordinalen Vergleich verglichen werden.  
  
 Um zu normalisieren, und Vergleichen von zwei Zeichenfolgen, führen Sie folgende Schritte aus:  
  
1.  Rufen Sie die Zeichenfolgen, aus der Eingabequelle, z. B. eine Datei oder ein Eingabegerät Benutzer verglichen werden soll.  
  
2.  Rufen Sie die <xref:System.String.Normalize%28System.Text.NormalizationForm%29> Methode, um die Zeichenfolgen in einer angegebenen Normalisierungsform zu normalisieren.  
  
3.  Um zwei Zeichenfolgen zu vergleichen, rufen Sie eine Methode, Ordinalzeichenfolgenvergleich mit, wie z. B. unterstützt, die <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> -Methode, und geben Sie den Wert <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> oder <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> als die <xref:System.StringComparison> Argument. Um ein Array mit normalisierten Zeichenfolgen zu sortieren, übergeben Sie einen `comparer` Wert <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> oder <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> an eine geeignete Überladung der <xref:System.Array.Sort%2A?displayProperty=nameWithType>.  
  
4.  Geben Sie die Zeichenfolgen in der sortierten Ausgabe basierend auf der im vorherigen Schritt angegebenen Reihenfolge.  
  
 Eine Beschreibung der unterstützten Unicode-Normalisierungsformen, finden Sie unter <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Zeichenfolge, die jede der vier Normalisierungsformen normalisiert, normalisiert und bestätigt die Zeichenfolge wurde in die angegebene Normalisierungsform, die den Codepunkten in die normalisierte Zeichenfolge.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die aktuelle Instanz enthält ungültige Unicode-Zeichen.</exception>
        <block subset="none" type="usage"><para>Die <see cref="Overload:System.String.IsNormalized" /> Methodenrückgabe <see langword="false" /> , sobald es feststellt, dass das erste Zeichen der nicht normalisierte in einer Zeichenfolge. Aus diesem Grund, wenn eine Zeichenfolge nicht normalisierte Zeichen gefolgt von ungültigen Unicode-Zeichen enthält die <see cref="Overload:System.String.Normalize" /> Methode Auslösen einer <see cref="T:System.ArgumentException" /> zwar <see cref="Overload:System.String.IsNormalized" /> gibt <see langword="false" />.</para></block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Equality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member ( = ) : string * string -&gt; bool" Usage="a = b" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Die erste Zeichenfolge für den Vergleich oder <see langword="null" />.</param>
        <param name="b">Die zweite Zeichenfolge für den Vergleich oder <see langword="null" />.</param>
        <summary>Bestimmt, ob zwei angegebene Zeichenfolgen denselben Wert haben.</summary>
        <returns><see langword="true" />, wenn <paramref name="a" /> und <paramref name="b" /> denselben Wert haben, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.op_Equality%2A> Methode definiert, den Vorgang des Gleichheitsoperators für die <xref:System.String> Klasse. Sie können Code wie z. B. "Beispiel" angezeigt. Der Operator ruft wiederum die statische <xref:System.String.Equals%28System.String%2CSystem.String%29> Methode, die einen Ordinalvergleich der (Groß-/Kleinschreibung beachtet und kulturunabhängige) ausführt.  
  
> [!NOTE]
>  Visual Basic-Compiler löst nicht den Gleichheitsoperator als Aufruf an die <xref:System.String.op_Equality%2A> Methode. Stattdessen der Gleichheitsoperator umschließt einen Aufruf der <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Equality-Operator.  
  
 [!code-cpp[system.string.equality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Equality/CPP/equalityop.cpp#1)]
 [!code-csharp[system.string.equality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Equality/CS/equalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;char&gt; (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;char&gt; op_Implicit(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Implicit(System.String)~System.ReadOnlySpan{System.Char}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As String) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;char&gt;(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.string.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Inequality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : string * string -&gt; bool" Usage="System.string.op_Inequality (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Die erste Zeichenfolge für den Vergleich oder <see langword="null" />.</param>
        <param name="b">Die zweite Zeichenfolge für den Vergleich oder <see langword="null" />.</param>
        <summary>Bestimmt, ob zwei angegebene Zeichenfolgen verschiedene Werte haben.</summary>
        <returns><see langword="true" />, wenn der Wert von <paramref name="a" /> vom Wert von <paramref name="b" /> verschieden ist; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.op_Inequality%2A> Methode definiert, den Vorgang des Ungleichheitsoperators für die <xref:System.String> Klasse.   Sie können Code wie im Abschnitt "Beispiele".  
  
 Die <xref:System.String.op_Inequality%2A> Operator ruft wiederum die statische <xref:System.String.Equals%28System.String%2CSystem.String%29> Methode, die einen Ordinalvergleich der (Groß-/Kleinschreibung beachtet und kulturunabhängige) ausführt.  
  
> [!NOTE]
>  Visual Basic-Compiler löst den Inequality-Operator nicht als Aufruf an die <xref:System.String.op_Inequality%2A> Methode. Stattdessen der Inequality-Operator umschließt einen Aufruf der <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Inequality-Operator.  
  
 [!code-cpp[system.string.inequality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Inequality/CPP/inequalityop.cpp#1)]
 [!code-csharp[system.string.inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Inequality/CS/inequalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PadLeft">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine neue Zeichenfolge mit einer angegebenen Länge zurück, in der der Anfang der aktuellen Zeichenfolge mit Leerzeichen oder einem angegebenen Unicode-Zeichen aufgefüllt wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int -&gt; string" Usage="string.PadLeft totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Die Anzahl der Zeichen in der resultierenden Zeichenfolge, entsprechend der Anzahl der ursprünglichen Zeichen zuzüglich aller zusätzlichen Füllzeichen.</param>
        <summary>Gibt eine neue Zeichenfolge zurück, bei der die Zeichen in dieser Instanz rechtsbündig ausgerichtet werden, indem die linke Seite mit Leerzeichen aufgefüllt wird, um eine angegebene Gesamtlänge zu erreichen.</summary>
        <returns>Eine neue Zeichenfolge, die dieser Instanz entspricht, jedoch rechtsbündig ausgerichtet und links mit Leerzeichen aufgefüllt ist, sodass die Länge <paramref name="totalWidth" /> erreicht wird. Wenn <paramref name="totalWidth" /> jedoch kleiner als die Länge dieser Instanz ist, gibt die Methode einen Verweis auf die vorhandene Instanz zurück. Wenn <paramref name="totalWidth" /> gleich der Länge dieser Instanz ist, gibt die Methode eine neue Zeichenfolge zurück, die mit dieser Instanz identisch ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Unicodeleerzeichen wird als hexadezimale 0 x 0020 definiert.  
  
 Die <xref:System.String.PadLeft%28System.Int32%29> Methode füllt den Anfang der zurückgegebenen Zeichenfolge. Dies bedeutet, dass bei Verwendung mit rechts-nach-links-Sprachen den rechten Teil der Zeichenfolge aufgefüllt wird.  
  
> [!NOTE]
>  Wenn die <xref:System.String.PadLeft%2A> Methode füllt die aktuelle Instanz mit Leerzeichen, diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge, die mit einem führenden Leerzeichen aufgefüllt wird, damit die Gesamtlänge `totalWidth` Zeichen.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.PadLeft%2A> Methode.  
  
 [!code-cpp[Classic String.PadLeft Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalWidth" /> ist kleiner als Null.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int * char -&gt; string" Usage="string.PadLeft (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Die Anzahl der Zeichen in der resultierenden Zeichenfolge, entsprechend der Anzahl der ursprünglichen Zeichen zuzüglich aller zusätzlichen Füllzeichen.</param>
        <param name="paddingChar">Ein Unicode-Füllzeichen.</param>
        <summary>Gibt eine neue Zeichenfolge zurück, bei der die Zeichen in dieser Instanz rechtsbündig ausgerichtet werden, indem die linke Seite mit einem angegebenen Unicode-Zeichen aufgefüllt wird, um eine angegebene Gesamtlänge zu erreichen.</summary>
        <returns>Eine neue Zeichenfolge, die dieser Instanz entspricht, jedoch rechtsbündig ausgerichtet und links mit <paramref name="paddingChar" />-Zeichen aufgefüllt ist, sodass die Länge <paramref name="totalWidth" /> erreicht wird. Wenn <paramref name="totalWidth" /> jedoch kleiner als die Länge dieser Instanz ist, gibt die Methode einen Verweis auf die vorhandene Instanz zurück. Wenn <paramref name="totalWidth" /> gleich der Länge dieser Instanz ist, gibt die Methode eine neue Zeichenfolge zurück, die mit dieser Instanz identisch ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29> Methode füllt den Anfang der zurückgegebenen Zeichenfolge. Dies bedeutet, dass bei Verwendung mit rechts-nach-links-Sprachen den rechten Teil der Zeichenfolge aufgefüllt wird.  
  
> [!NOTE]
>  Wenn die <xref:System.String.PadLeft%2A> Methode füllt die aktuelle Instanz mit Leerzeichen, diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge, die mit führenden aufgefüllt wird `paddingChar` Zeichen, damit die Gesamtlänge `totalWidth` Zeichen.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.PadLeft%2A> Methode.  
  
 [!code-cpp[Classic String.PadLeft1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalWidth" /> ist kleiner als Null.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PadRight">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine neue Zeichenfolge mit einer angegebenen Länge zurück, in der das Ende der aktuellen Zeichenfolge mit Leerzeichen oder einem angegebenen Unicode-Zeichen aufgefüllt wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int -&gt; string" Usage="string.PadRight totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Die Anzahl der Zeichen in der resultierenden Zeichenfolge, entsprechend der Anzahl der ursprünglichen Zeichen zuzüglich aller zusätzlichen Füllzeichen.</param>
        <summary>Gibt eine neue Zeichenfolge zurück, deren Zeichen linksbündig ausgerichtet werden, indem die rechte Seite mit Leerzeichen aufgefüllt wird, um eine angegebene Gesamtlänge zu erreichen.</summary>
        <returns>Eine neue Zeichenfolge, die dieser Instanz entspricht, jedoch rechtsbündig ausgerichtet und links mit Leerzeichen aufgefüllt ist, sodass die Länge <paramref name="totalWidth" /> erreicht wird. Wenn <paramref name="totalWidth" /> jedoch kleiner als die Länge dieser Instanz ist, gibt die Methode einen Verweis auf die vorhandene Instanz zurück. Wenn <paramref name="totalWidth" /> gleich der Länge dieser Instanz ist, gibt die Methode eine neue Zeichenfolge zurück, die mit dieser Instanz identisch ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Unicodeleerzeichen wird als hexadezimale 0 x 0020 definiert.  
  
 Die <xref:System.String.PadRight%28System.Int32%29> Methode füllt das Ende der zurückgegebenen Zeichenfolge. Dies bedeutet, dass bei Verwendung mit rechts-nach-links-Sprachen den linken Teil der Zeichenfolge aufgefüllt wird.  
  
> [!NOTE]
>  Wenn die <xref:System.String.PadRight%2A> Methode füllt die aktuelle Instanz mit Leerzeichen, diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge, die mit einem nachgestellten Leerzeichen aufgefüllt wird, damit die Gesamtlänge `totalWidth` Zeichen.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.PadRight%2A> Methode.  
  
 [!code-cpp[Classic String.PadRight Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalWidth" /> ist kleiner als Null.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int * char -&gt; string" Usage="string.PadRight (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Die Anzahl der Zeichen in der resultierenden Zeichenfolge, entsprechend der Anzahl der ursprünglichen Zeichen zuzüglich aller zusätzlichen Füllzeichen.</param>
        <param name="paddingChar">Ein Unicode-Füllzeichen.</param>
        <summary>Gibt eine neue Zeichenfolge zurück, deren Zeichen linksbündig ausgerichtet werden, indem die rechte Seite mit einem angegebenen Unicode-Zeichen aufgefüllt wird, um eine angegebene Gesamtlänge zu erreichen.</summary>
        <returns>Eine neue Zeichenfolge, die dieser Instanz entspricht, jedoch rechtsbündig ausgerichtet und links mit <paramref name="paddingChar" />-Zeichen aufgefüllt ist, sodass die Länge <paramref name="totalWidth" /> erreicht wird. Wenn <paramref name="totalWidth" /> jedoch kleiner als die Länge dieser Instanz ist, gibt die Methode einen Verweis auf die vorhandene Instanz zurück. Wenn <paramref name="totalWidth" /> gleich der Länge dieser Instanz ist, gibt die Methode eine neue Zeichenfolge zurück, die mit dieser Instanz identisch ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.PadRight%28System.Int32%2CSystem.Char%29> Methode füllt das Ende der zurückgegebenen Zeichenfolge. Dies bedeutet, dass bei Verwendung mit rechts-nach-links-Sprachen den linken Teil der Zeichenfolge aufgefüllt wird.  
  
> [!NOTE]
>  Wenn die <xref:System.String.PadRight%2A> Methode füllt die aktuelle Instanz mit Leerzeichen, diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge, die mit nachfolgenden aufgefüllt wird `paddingChar` Zeichen, damit die Gesamtlänge `totalWidth` Zeichen.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.PadRight%2A> Methode.  
  
 [!code-cpp[Classic String.PadRight1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalWidth" /> ist kleiner als Null.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine neue Zeichenfolge zurück, in der eine angegebene Anzahl von Zeichen aus der aktuellen Zeichenfolge gelöscht wurde.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Remove : int -&gt; string" Usage="string.Remove startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Die nullbasierte Position, ab der Zeichen gelöscht werden sollen.</param>
        <summary>Gibt eine neue Zeichenfolge zurück, in der alle Zeichen in der aktuellen Instanz, beginnend an einer angegebenen Position und sich über die letzte Position fortsetzend, gelöscht wurden.</summary>
        <returns>Eine neue Zeichenfolge, die dieser Zeichenfolge ohne die entfernten Zeichen entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], Zeichenfolgen sind nullbasiert. Der Wert des der `startIndex` Parameter kann von 0 (null) bis eins weniger als die Länge der Zeichenfolgeninstanz reichen.  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge in der alle Zeichen ab Position `startIndex` an das Ende der ursprünglichen Zeichenfolge entfernt wurden.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.String.Remove%2A> Methode. Der Case vorletztes entfernt den gesamten Text aus dem angegebenen Index bis zum Ende der Zeichenfolge ab. Im letzte Fall werden drei Zeichen, die beginnend beim angegebenen Indexes entfernt.  
  
 [!code-cpp[string.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.remove/CPP/r.cpp#1)]
 [!code-csharp[string.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.remove/CS/r.cs#1)]
 [!code-vb[string.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.remove/VB/r.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> ist kleiner als Null.  
  
- oder -  
 <paramref name="startIndex" /> gibt eine Position an, die sich nicht innerhalb der Zeichenfolge befindet.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; string" Usage="string.Remove (startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Die nullbasierte Position, ab der Zeichen gelöscht werden sollen.</param>
        <param name="count">Die Anzahl der zu löschenden Zeichen.</param>
        <summary>Gibt eine neue Zeichenfolge zurück, in der eine bestimmte Anzahl von Zeichen in er aktuellen Instanz, beginnend an einer angegebenen Position, gelöscht wurden.</summary>
        <returns>Eine neue Zeichenfolge, die dieser Instanz ohne die entfernten Zeichen entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], Zeichenfolgen sind nullbasiert. Der Wert des der `startIndex` Parameter kann von 0 (null) bis eins weniger als die Länge der Zeichenfolgeninstanz reichen.  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge, die in der die Anzahl der Zeichen, durch angegeben die `count` Parameter entfernt wurden. Die Zeichen an der Position gemäß entfernt `startIndex`.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie Sie aus dem vollständigen Namen des zweiten Vornamens entfernen können.  
  
 [!code-cpp[stringremove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringremove/CPP/stringremove.cpp#1)]
 [!code-csharp[stringremove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringremove/CS/stringremove.cs#1)]
 [!code-vb[stringremove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringremove/VB/stringremove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Entweder <paramref name="startIndex" /> oder <paramref name="count" /> ist kleiner als 0 (null).  
  
- oder -  
 <paramref name="startIndex" /> plus <paramref name="count" /> bezeichnen eine Position außerhalb dieser Instanz.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine neue Zeichenfolge zurück, in der alle Vorkommen von einem angegebenen Unicode-Zeichen oder <see cref="T:System.String" /> in der aktuellen Zeichenfolge durch ein anderes angegebenes Unicode-Zeichen oder einen anderen <see cref="T:System.String" /> ersetzt werden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; string" Usage="string.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">Das zu ersetzende Unicode-Zeichen.</param>
        <param name="newChar">Das Unicode-Zeichen, das jedes Vorkommen von <paramref name="oldChar" /> ersetzen soll.</param>
        <summary>Gibt eine neue Zeichenfolge zurück, in der alle Vorkommen eines angegebenen Unicode-Zeichens in dieser Instanz durch ein anderes angegebenes Unicode-Zeichen ersetzt wurden.</summary>
        <returns>Eine Zeichenfolge, die dieser Instanz entspricht, außer dass alle Instanzen von <paramref name="oldChar" /> durch <paramref name="newChar" /> ersetzt werden. Wenn <paramref name="oldChar" /> nicht in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt eine ordinale (Groß-/Kleinschreibung beachtet und kulturunabhängige) Suche gefunden `oldChar`.  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der alle Vorkommen von `oldChar` durch ersetzt `newChar`.  
  
 Da diese Methode die geänderte Zeichenfolge zurückgibt, Sie können miteinander verketten aufeinander folgende Aufrufe von der <xref:System.String.Replace%2A> Methode, um mehrere Ersetzungen für die ursprüngliche Zeichenfolge ausführen. Methodenaufrufe werden von links nach rechts ausgeführt. Dies wird im folgenden Beispiel veranschaulicht.  
  
 [!code-csharp[System.String.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace2.cs#2)]
 [!code-vb[System.String.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace2.vb#2)]  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine durch Komma getrennte Werteliste durch Kommas, die Leerzeichen zwischen einer Reihe von Zahlen zu ersetzen.  
  
 [!code-cpp[string.replace1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.replace1/CPP/string.replace1.cpp#1)]
 [!code-csharp[string.replace1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.replace1/CS/string.replace1.cs#1)]
 [!code-vb[string.replace1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.replace1/VB/string.replace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="string.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">Die zu ersetzende Zeichenfolge.</param>
        <param name="newValue">Die Zeichenfolge, die jedes Vorkommen von <paramref name="oldValue" /> ersetzen soll.</param>
        <summary>Gibt eine neue Zeichenfolge zurück, in der alle Vorkommen einer angegebenen Zeichenfolge in der aktuellen Instanz durch eine andere angegebene Zeichenfolge ersetzt wurden.</summary>
        <returns>Eine Zeichenfolge, die der aktuellen Zeichenfolge entspricht, außer dass alle Instanzen von <paramref name="oldValue" /> durch <paramref name="newValue" /> ersetzt werden. Wenn <paramref name="oldValue" /> nicht in der aktuellen Instanz gefunden wird, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `newValue` ist `null`, alle Vorkommen von `oldValue` werden entfernt.  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der alle Vorkommen von `oldValue` durch ersetzt `newValue`.  
  
 Diese Methode führt eine ordinale (Groß-/Kleinschreibung beachtet und kulturunabhängige) Suche gefunden `oldValue`.  
  
 Da diese Methode die geänderte Zeichenfolge zurückgibt, Sie können miteinander verketten aufeinander folgende Aufrufe von der <xref:System.String.Replace%2A> Methode, um mehrere Ersetzungen für die ursprüngliche Zeichenfolge ausführen. Methodenaufrufe werden von links nach rechts ausgeführt. Dies wird im folgenden Beispiel veranschaulicht.  
  
 [!code-csharp[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
 [!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]  
  
   
  
## Examples  
 Das folgende Beispiel zeigt Informationen zur Verwendung der <xref:System.String.Replace%2A> Methode, um einen Rechtschreibfehler zu korrigieren.  
  
 [!code-cpp[stringreplace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringreplace/CPP/stringreplace.cpp#1)]
 [!code-csharp[stringreplace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringreplace/CS/stringreplace.cs#1)]
 [!code-vb[stringreplace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringreplace/VB/stringreplace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="oldValue" /> ist die leere Zeichenfolge ("").</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, comparisonType As StringComparison) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * StringComparison -&gt; string" Usage="string.Replace (oldValue, newValue, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, ignoreCase As Boolean, culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * bool * System.Globalization.CultureInfo -&gt; string" Usage="string.Replace (oldValue, newValue, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <param name="culture">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt ein Zeichenfolgenarray zurück, das die Teilzeichenfolgen dieser Instanz enthält, die durch Elemente eines angegebenen Zeichenfolgen- oder Unicode-Zeichenarrays getrennt sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Split%2A> wird verwendet, um eine durch Trennzeichen getrennte Zeichenfolge in Teilzeichenfolgen zu unterteilen. Sie können entweder ein Array von Zeichen an der 0 (null), einer oder mehrerer Trennzeichen verwenden (die <xref:System.String.Split%28System.Char%5B%5D%29> Methode), oder Sie können ein Array von Zeichen an der 0 (null), einer oder mehrerer Trennzeichen-Zeichenfolgen. Überladungen der der <xref:System.String.Split%2A> Methode können Sie die Anzahl der Teilzeichenfolgen, die von der Methode zurückgegebenen zu beschränken (die <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29> Methode), um zu bestimmen, ob leere Zeichenfolgen in der zurückgegebenen untergeordneten Zeichenfolgen enthalten sind (die <xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29> und <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> Methoden oder beides (die <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> und <xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> Methoden).  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

### <a name="alternatives-to-stringsplit"></a>Alternativen zur String.Split

 Die <xref:System.String.Split%2A> Methode ist nicht immer die beste Methode zum Unterbrechen einer durch Trennzeichen getrennte Zeichenfolge in Teilzeichenfolgen. Wenn nicht alle der Teilzeichenfolgen einer durch Trennzeichen getrennten Zeichenfolge extrahiert werden soll, oder wenn Sie eine Zeichenfolge, die basierend auf einem Muster, anstatt einen Satz von Trennzeichen analysieren möchten, sollten Sie die folgenden Alternativen.  
  
### <a name="regular-expressions"></a>Reguläre Ausdrücke  
 Wenn die Zeichenfolgen mit einem festen Muster entsprechen, können Sie einen regulären Ausdruck zum Extrahieren und verarbeiten die Elemente. Wenn Zeichenfolgen in Form werden z. B. "*Anzahl* *Operanden* *Anzahl*" können Sie eine [reguläre](~/docs/standard/base-types/regular-expressions.md) extrahieren und Verarbeiten der Zeichenfolge-Elemente. Im Folgenden ein Beispiel:  
  
 [!code-csharp-interactive[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 Muster für reguläre Ausdrücke `(\d+)\s+([-+*/])\s+(\d+)` wird wie folgt definiert:  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`(\d+)`|Entsprechung für mindestens eine Dezimalstelle finden. Dies ist die erste Erfassungsgruppe.|  
|`\s+`|Übereinstimmung mit ein oder mehrere Leerzeichen Zeichen.|  
|`([-+*/])`|Entspricht einem arithmetischen Operator Vorzeichen (+, -, *, oder /). Dies ist die zweite Erfassungsgruppe.|  
|`\s+`|Übereinstimmung mit ein oder mehrere Leerzeichen Zeichen.|  
|`(\d+)`|Entsprechung für mindestens eine Dezimalstelle finden. Dies ist die dritte Erfassungsgruppe.|  
  
 Sie können auch einen regulären Ausdruck verwenden, um Teilzeichenfolgen aus einer Zeichenfolge basierend auf einen festen Satz von Zeichen, anstatt ein Muster zu extrahieren. Dies ist ein häufiges Szenario, wenn eine dieser Bedingungen auftritt:  
  
-   Mindestens ein Trennzeichen ist nicht immer als ein Trennzeichen in den <xref:System.String> Instanz.  
  
-   Die Reihenfolge und Anzahl von Trennzeichen ist variabel oder unbekannt.  
  
 Z. B. die <xref:System.String.Split%2A> Methode kann nicht zum Aufteilen der folgenden Zeichenfolge, nicht verwendet werden, da die Anzahl der `\n` (in c#) oder `vbCrLf` Zeichen ist die Variable (in Visual Basic), und sie nicht immer als Trennzeichen dienen.  
  
```text
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
```  
  
 Diese Zeichenfolge kann einfach, wie das folgende Beispiel zeigt ein regulärer Ausdruck aufgeteilt werden.  
  
 [!code-csharp-interactive[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 Muster für reguläre Ausdrücke `\[([^\[\]]+)\]` wird wie folgt definiert:  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`\[`|Übereinstimmung mit eine öffnende eckige Klammer ein.|  
|`([^\[\]]+)`|Übereinstimmung mit beliebigem Zeichen, das kein öffnendes oder eine schließende Klammer ist mindestens einmal aus. Dies ist die erste Erfassungsgruppe.|  
|`\]`|Übereinstimmung mit einer schließenden Klammer ein.|  
  
 Die <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Methode ist fast identisch mit <xref:System.String.Split%2A?displayProperty=nameWithType>, außer dass es sich um eine Zeichenfolge, die basierend auf das Muster eines regulären Ausdrucks anstelle eines festen Zeichen unterteilt. Z. B. im folgenden Beispiel wird die <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> Methode zum Aufteilen einer Zeichenfolge, die durch verschiedene Kombinationen von Bindestrichen und andere Zeichen getrennten Teilzeichenfolgen enthält.  
  
 [!code-csharp-interactive[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 Muster für reguläre Ausdrücke `\s-\s?[+*]?\s?-\s` wird wie folgt definiert:  
  
|Muster|Beschreibung |  
|-------------|-----------------|  
|`\s-`|Entspricht einem Leerstellenzeichen gefolgt von einem Bindestrich.|  
|`\s?`|Übereinstimmung mit keinem oder einem Leerzeichen.|  
|`[+*]?`|Übereinstimmung mit keinem oder einem Vorkommen entweder das + oder * Zeichen.|  
|`\s?`|Übereinstimmung mit keinem oder einem Leerzeichen.|  
|`-\s`|Übereinstimmung mit einem Bindestrich gefolgt von einem Leerzeichen.|  
  
### <a name="search-methods-and-the-substring-method"></a>Suchen von Methoden und der Substring-Methode  
 Wenn Sie nicht alle die Teilzeichenfolgen in einer Zeichenfolge interessiert sind, möchten Sie möglicherweise arbeiten mit einer der Methoden zum Zeichenfolgenvergleich, der den Index zurückgibt, an dem der Vergleich beginnt. Rufen Sie anschließend die <xref:System.String.Substring%2A> Methode, um die Teilzeichenfolge extrahiert, die Sie möchten. Die Methoden zum Zeichenfolgenvergleich umfassen:  
  
-   <xref:System.String.IndexOf%2A>, den nullbasierten Index des ersten Vorkommens eines Zeichens oder einer Zeichenfolge in eine Zeichenfolgeninstanz zurückgegeben.  
  
-   <xref:System.String.IndexOfAny%2A>, die den nullbasierten Index in der aktuellen Zeichenfolgeninstanz des ersten Vorkommens eines beliebigen Zeichens aus einem Array von Zeichen zurückgibt.  
  
-   <xref:System.String.LastIndexOf%2A>, den nullbasierten Index des letzten Vorkommens eines Zeichens oder einer Zeichenfolge in eine Zeichenfolgeninstanz zurückgegeben.  
  
-   <xref:System.String.LastIndexOfAny%2A>, die einen nullbasierten Index in der aktuellen Zeichenfolgeninstanz des letzten Vorkommens eines beliebigen Zeichens aus einem Array von Zeichen zurückgibt.  
  
 Im folgenden Beispiel wird die <xref:System.String.IndexOf%2A> Methode, um die Punkte in einer Zeichenfolge gesucht. Anschließend wird mithilfe der <xref:System.String.Substring%2A> Methode, um vollständige Sätze zurückzugeben.  
  
 [!code-csharp-interactive[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (params char[] separator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (ParamArray separator As Char()) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(... cli::array &lt;char&gt; ^ separator);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] -&gt; string[]" Usage="string.Split separator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Ein Zeichenarray, das die Teilzeichenfolgen in dieser Zeichenfolge trennt, ein leeres Array ohne Trennzeichen oder <see langword="null" />.</param>
        <summary>Unterteilt eine Zeichenfolge anhand der Zeichen in einem Array in Teilzeichenfolgen.</summary>
        <returns>Ein Array, dessen Elemente die Teilzeichenfolgen von dieser Instanz enthält, die durch ein oder mehr Zeichen aus <paramref name="separator" /> getrennt sind. Weitere Informationen finden Sie im Abschnitt "Hinweise".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine Zeichenfolge von einem bekannten Satz von Zeichen getrennt sind, können Sie die <xref:System.String.Split%28System.Char%5B%5D%29> Methode für die Trennung in Teilzeichenfolgen.   
  
### <a name="return-value-details"></a>Rückgabewert-details  
 Trennzeichen sind nicht in den Elementen des zurückgegebenen Arrays enthalten. Wenn das Array als Trennzeichen das Zeichen enthält z. B. "-" und der Wert der aktuellen Zeichenfolgeninstanz "aa-bb-cc", die Methode gibt ein Array, das drei Elemente enthält: "aa", "bb" und "cc".  
  
 Wenn diese Instanz keine Zeichen enthält `separator`, das zurückgegebene Array besteht aus einem einzelnen Element, das diese Instanz enthält.  
  
 Jedes Element der `separator` ein separates Trennzeichen definiert. Wenn zwei Trennzeichen benachbart sind oder ein Trennzeichen am Anfang oder Ende dieser Instanz gefunden wird, enthält das entsprechende Element im zurückgegebenen Array <xref:System.String.Empty>. Hier einige Beispiele:  
  
|Zeichenfolgenwert|Trennzeichen|Zurückgegebene array|  
|------------------|---------------|--------------------|  
|"42, 12, 19"|neue Char [] {',', ' '} (C#)<br /><br /> Char() = {"," c "" C}) (Visual Basic)|{"42", "", "12", "", "19"}|  
|"42..12..19"|new Char[] {'.'} (C#)<br /><br /> Char() = {"." c} (Visual Basic)|{"42", "", "12", "", "19"}|  
|"Banane"|new Char[] {'.'} (C#)<br /><br /> Char() = {"." c} (Visual Basic)|{"Banana"}|  
|"Darb\nSmarba" (c#)<br /><br /> "Darb", VbLf & "Smarba" (Visual Basic)|neue Char [] {} (C#)<br /><br /> Char() = {} (Visual Basic)|{"Darb", "Smarba"}|  
|"Darb\nSmarba" (c#)<br /><br /> "Darb", VbLf & "Smarba" (Visual Basic)|null (C#)<br /><br /> Nothing (Visual Basic)|{"Darb", "Smarba"}|  
  
### <a name="the-separator-array"></a>Das Separator-array  
 Jedes Element des Trennzeichens definiert ein separates Trennzeichen, das ein einzelnes Zeichen besteht. Wenn die `separator` Argument `null` oder keine Zeichen enthält, die Methode behandelt Leerzeichen als Trennzeichen. Leerzeichen werden durch die Unicode-standard definiert. Geben sie zurück `true` Wenn es sich bei der Übergabe an die <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> Methode.  
  
### <a name="stringsplitchar-and-compiler-overload-resolution"></a>Auflösen der Überladung String.Split(Char[]) und compiler  
 Obwohl die einzelnen Parameter für diese Überladung der <xref:System.String.Split%2A?displayProperty=nameWithType> ist ein Array von Zeichen, können Sie ihn mit einem einzelnen Zeichen, wie im folgenden Beispiel gezeigt aufrufen.  
  
 [!code-csharp-interactive[System.String.Split#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split_CompilerResolution1.cs#12)]
 [!code-vb[System.String.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split_CompilerResolution1.vb#12)]  
  
 Da die `separator` Parameter versehen ist, mit der <xref:System.ParamArrayAttribute> Attribut Compiler ein einzelnes Zeichen als ein Array von einem Element Zeichen interpretiert werden. Dies gilt nicht für andere <xref:System.String.Split%2A?displayProperty=nameWithType> Überladungen, die eine `separator` -Parameter müssen Sie explizit übergeben diese Überladungen ein Array von Zeichen als die `separator` Argument.  
  
### <a name="comparison-details"></a>Von Vergleichsdetails  
 Die <xref:System.String.Split%28System.Char%5B%5D%29> Methode extrahiert die Teilzeichenfolgen in dieser Zeichenfolge, die von einer oder mehreren Zeichen getrennt sind die `separator` array und gibt diese Teilzeichenfolgen als Elemente eines Arrays zurück.  
  
 Die <xref:System.String.Split%28System.Char%5B%5D%29> -Methode sucht nach Trennzeichen durch Durchführen von Vergleichen mit der Groß-/Kleinschreibung der ordinalen Sortierregeln. Weitere Informationen über Wort-, Zeichenfolgen- und ordinal sortiert, finden Sie unter den <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> Enumeration.  
  
### <a name="performance-considerations"></a>Überlegungen zur Leistung  
 Die <xref:System.String.Split%2A> Methoden von Arbeitsspeicher für das zurückgegebene Arrayobjekt und <xref:System.String> -Objekt für jedes Arrayelement. Wenn Ihre Anwendung eine optimale Leistung erfordert oder wenn die Verwaltung von speicherbelegung in Ihre Anwendung von entscheidender Bedeutung ist, sollten Sie die <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOfAny%2A> Methode. Sie haben auch die Möglichkeit der Verwendung der <xref:System.String.Compare%2A> Methode, um eine Teilzeichenfolge innerhalb einer Zeichenfolge suchen.  
  
 Verwenden Sie zum Aufteilen einer Zeichenfolge am Trennzeichen der <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOfAny%2A> Methode zum Suchen eines Trennzeichens in der Zeichenfolge. Verwenden Sie zum Aufteilen einer Zeichenfolge an einem Trennzeichen der <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOfAny%2A> Methode zum Suchen des ersten Zeichens der Zeichenfolge als Trennzeichen. Verwenden Sie dann die <xref:System.String.Compare%2A> Methode, um zu bestimmen, ob die Zeichen nach dem ersten Zeichen der verbleibenden Zeichen in der Trennzeichenfolge gleich sind.  
  
 Darüber hinaus, wenn der gleiche Satz von Zeichen wird verwendet, um Zeichenfolgen in mehreren Teilen <xref:System.String.Split%2A> Methodenaufrufe, sollten Sie ein einzelnes Array erstellen, und klicken Sie in jedem Methodenaufruf darauf verweisen. Dadurch wird erheblich reduziert, der zusätzliche Verarbeitungsaufwand von jedem Methodenaufruf.  
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie um einzelne Wörter aus einen Textblock zu extrahieren, indem Sie zum Behandeln von Leerzeichen und Satzzeichen als Trennzeichen verwendet wird. Das Zeichenarray übergeben, um die `separator` Parameter, der die <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> Methode besteht aus einem Leerzeichen und einem Tabstoppzeichen, zusammen mit einigen häufig verwendeten Interpunktionszeichen.  
  
 [!code-csharp-interactive[System.String.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split2.cs#2)]
 [!code-vb[System.String.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>In der [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] und frühere Versionen, wenn die <see cref="M:System.String.Split(System.Char[])" /> -Methode übergeben eine <paramref name="separator" /> , <see langword="null" /> oder keine Zeichen enthält, die Methode verwendet einen etwas anderen Satz von Zeichen zum Aufteilen der Zeichenfolge als die <see cref="M:System.String.Trim(System.Char[])" /> Methode führt zu Verringern Sie die Zeichenfolge ein. Ab .NET Framework 4, verwenden beide Methoden einen identischen Satz von Unicode-Zeichen.</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int -&gt; string[]" Usage="string.Split (separator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">Ein Zeichenarray, das die Teilzeichenfolgen in dieser Zeichenfolge trennt, ein leeres Array ohne Trennzeichen oder <see langword="null" />.</param>
        <param name="count">Die maximale Anzahl der zurückzugebenden Teilzeichenfolgen.</param>
        <summary>Unterteilt eine Zeichenfolge anhand der Zeichen in einem Array in eine maximale Anzahl von Teilzeichenfolgen. Sie geben außerdem die maximale Anzahl der zurückzugebenden Teilzeichenfolgen an.</summary>
        <returns>Ein Array, dessen Elemente die Teilzeichenfolgen in dieser Instanz enthält, die durch ein oder mehr Zeichen aus <paramref name="separator" /> getrennt sind. Weitere Informationen finden Sie im Abschnitt "Hinweise".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Trennzeichen sind nicht in den Elementen des zurückgegebenen Arrays enthalten.  
  
 Wenn diese Instanz keine Zeichen enthält `separator`, das zurückgegebene Array besteht aus einem einzelnen Element, das diese Instanz enthält. Wenn `count` NULL ist, wird ein leeres Array zurückgegeben.  
  
 Wenn die `separator` Parameter `null` oder keine Zeichen enthält, Leerzeichen werden als Trennzeichen angesehen. Leerzeichen werden durch die Unicode-standard und return definiert `true` Wenn es sich bei der Übergabe an die <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> Methode.  
  
 Jedes Element der `separator` ein separates Trennzeichen definiert. Wenn zwei Trennzeichen benachbart sind oder ein Trennzeichen am Anfang oder Ende dieser Instanz gefunden wird, enthält das entsprechende Arrayelement <xref:System.String.Empty>.  
  
 Treten mehr als `count` Teilzeichenfolgen in dieser Instanz, die die erste `count` -1 Teilzeichenfolgen werden in der ersten zurückgegeben `count` minus 1 Elemente zurückgegeben, und die restlichen Zeichen in dieser Instanz werden in den letzten zurückgegeben Element des Rückgabewerts.  
  
 Wenn `count` ist größer als die Anzahl von Teilzeichenfolgen auf, werden die verfügbaren Teilzeichenfolgen zurückgegeben und keine Ausnahme ausgelöst wird.  
  
 Die folgende Tabelle enthält Beispiele.  
  
|Zeichenfolgenwert|Trennzeichen|Anzahl|Zurückgegebene array|  
|------------------|---------------|-----------|--------------------|  
|"42, 12, 19"|neue Char [] {',', ' '} (C#)<br /><br /> Char() = {"," c "" C} (Visual Basic)|2|{"42", " 12, 19"}|  
|"42..12..19"|new Char[] {'.'} (C#)<br /><br /> Char() = {"." c} (Visual Basic)|4|{"42", "", "12", ".19"}|  
|"Banane"|new Char[] {'.'} (C#)<br /><br /> Char() = {"." c} (Visual Basic)|2|{"Banana"}|  
|"Darb\nSmarba" (c#)<br /><br /> "Darb", VbLf & "Smarba" (Visual Basic)|neue Char [] {} (C#)<br /><br /> Char() = {} (Visual Basic)|1|{"Darb\nSmarba"} (C#)<br /><br /> "Darb", VbLf & "Smarba" (Visual Basic)|  
|"Darb\nSmarba" (c#)<br /><br /> "Darb", VbLf & "Smarba" (Visual Basic)|neue Char [] null (C#)<br /><br /> Char() = Nothing|2|{"Darb", "Smarba"}|  
|"Darb\nSmarba" (c#)<br /><br /> "Darb", VbLf & "Smarba" (Visual Basic)|neue Char [] null (C#)<br /><br /> Char() = Nothing|100|{"Darb", "Smarba"}|  
  
### <a name="performance-considerations"></a>Überlegungen zur Leistung  
 Die <xref:System.String.Split%2A> Methoden von Arbeitsspeicher für das zurückgegebene Arrayobjekt und <xref:System.String> -Objekt für jedes Arrayelement. Wenn Ihre Anwendung eine optimale Leistung erfordert oder wenn die Verwaltung von speicherbelegung in Ihre Anwendung von entscheidender Bedeutung ist, sollten Sie die <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOfAny%2A> -Methode, und optional die <xref:System.String.Compare%2A> Methode, eine Teilzeichenfolge innerhalb einer Zeichenfolge suchen.  
  
 Wenn Sie eine Zeichenfolge an einem Trennzeichen teilen, verwenden Sie die <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOfAny%2A> Methode zum Suchen eines Trennzeichens in der Zeichenfolge. Wenn Sie eine Zeichenfolge an einem Trennzeichen teilen, verwenden Sie die <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOfAny%2A> Methode zum Suchen des ersten Zeichens der Zeichenfolge als Trennzeichen. Verwenden Sie dann die <xref:System.String.Compare%2A> Methode, um zu bestimmen, ob die Zeichen nach dem ersten Zeichen der verbleibenden Zeichen in der Trennzeichenfolge gleich sind.  
  
 Darüber hinaus, wenn der gleiche Satz von Zeichen wird verwendet, um Zeichenfolgen in mehreren Teilen <xref:System.String.Split%2A> Methodenaufrufe, sollten Sie ein einzelnes Array erstellen, und klicken Sie in jedem Methodenaufruf darauf verweisen. Dadurch wird erheblich reduziert, der zusätzliche Verarbeitungsaufwand von jedem Methodenaufruf.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie `count` wirkt sich auf die Anzahl der Zeichenfolgen, die vom <xref:System.String.Split%2A>.  
  
 [!code-csharp-interactive[StringSplit2#10](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/StringSplit10.cs#10)]
 [!code-vb[StringSplit2#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit10.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> ist ein negativer Wert.</exception>
        <block subset="none" type="usage"><para>In der [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] und frühere Versionen, wenn die <see cref="M:System.String.Split(System.Char[])" /> -Methode übergeben eine <paramref name="separator" /> , <see langword="null" /> oder keine Zeichen enthält, die Methode verwendet einen etwas anderen Satz von Zeichen zum Aufteilen der Zeichenfolge als die <see cref="M:System.String.Trim(System.Char[])" /> Methode führt zu Verringern Sie die Zeichenfolge ein. Ab .NET Framework 4, verwenden beide Methoden einen identischen Satz von Unicode-Zeichen.</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">Ein Zeichenarray, das die Teilzeichenfolgen in dieser Zeichenfolge trennt, ein leeres Array ohne Trennzeichen oder <see langword="null" />.</param>
        <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />, wenn leere Arrayelemente aus dem zurückgegebenen Array ausgelassen werden sollen, oder <see cref="F:System.StringSplitOptions.None" />, wenn leere Arrayelemente in das zurückgegebene Array eingeschlossen werden sollen.</param>
        <summary>Unterteilt eine Zeichenfolge anhand der Zeichen in einem Array in Teilzeichenfolgen. Sie können angeben, ob die Teilzeichenfolgen auch leere Arrayelemente umfassen.</summary>
        <returns>Ein Array, dessen Elemente die Teilzeichenfolgen in dieser Zeichenfolge enthält, die durch ein oder mehr Zeichen aus <paramref name="separator" /> getrennt sind. Weitere Informationen finden Sie im Abschnitt "Hinweise".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
### <a name="return-value-details"></a>Rückgabewert-details  
 Trennzeichen (die Zeichen in der `separator` Array) sind nicht in den Elementen des zurückgegebenen Arrays enthalten. Z. B. wenn die `separator` Array enthält das Zeichen "-" und der Wert der aktuellen Zeichenfolgeninstanz "aa-bb-cc", die Methode gibt ein Array, das drei Elemente enthält: "aa", "bb" und "cc".  
  
 Wenn diese Instanz keine Zeichen enthält `separator`, das zurückgegebene Array besteht aus einem einzelnen Element, das diese Instanz enthält.  
  
 Wenn die `options` Parameter <xref:System.StringSplitOptions.RemoveEmptyEntries> und die Länge dieser Instanz ist 0 (null), die Methode ein leeres Array zurück.  
  
 Jedes Element der `separator` definiert ein separates Trennzeichen, das ein einzelnes Zeichen besteht. Wenn die `options` Argument <xref:System.StringSplitOptions.None>, und zwei Trennzeichen benachbarten oder am Anfang oder Ende dieser Instanz ein einzeln verwendetes Trennzeichen gefunden wird, enthält das entsprechende Arrayelement <xref:System.String.Empty?displayProperty=nameWithType>. Z. B. wenn `separator` enthält zwei Elemente, die "-" und "\_", ist der Wert der Zeichenfolgeninstanz "-\_aa -\_", und der Wert des der `options` Argument ist <xref:System.StringSplitOptions.None>, die Methode gibt ein Zeichenfolgenarray mit zurück. die folgenden fünf Elemente:  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>, steht für die leere Zeichenfolge, die vor der "-"-Zeichen am Index 0.  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>, steht für die leere Zeichenfolge zwischen den "-"-Zeichen am Index 0 und das Zeichen "_" am Index 1.  
  
3.  "aa",  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>, die die leere Zeichenfolge, die das Zeichen "_" am Index 4 folgt darstellt.  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>, steht für die leere Zeichenfolge, die folgt der "-"-Zeichen am Index 5.  
  
### <a name="the-separator-array"></a>Das Separator-array  
 Wenn die `separator` Parameter `null` oder keine Zeichen enthält, Leerzeichen werden als Trennzeichen angesehen. Leerzeichen werden durch die Unicode-standard und return definiert `true` Wenn es sich bei der Übergabe an die <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> Methode.  
  
 Wenn die `separator` Parameter im Aufruf an die Überladung dieser Methode ist `null`, überladungsauflösung des Compiler ein Fehler auftritt. Um die aufgerufene Methode eindeutig identifizieren zu können, muss Ihr Code Geben Sie den Typ des der `null`. Das folgende Beispiel zeigt mehrere Möglichkeiten, diese Überladung eindeutig zu identifizieren.  
  
 [!code-csharp[System.String.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#5)]
 [!code-vb[System.String.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#5)]  
  
### <a name="comparison-details"></a>Von Vergleichsdetails  
 Die <xref:System.String.Split%2A> Methode extrahiert die Teilzeichenfolgen in dieser Zeichenfolge, die von einer oder mehreren Zeichen getrennt sind die `separator` -Parameter und gibt diese Teilzeichenfolgen als Elemente eines Arrays zurück.  
  
 Die <xref:System.String.Split%2A> -Methode sucht nach Trennzeichen durch Durchführen von Vergleichen mit der Groß-/Kleinschreibung der ordinalen Sortierregeln. Weitere Informationen über Wort-, Zeichenfolgen- und ordinal sortiert, finden Sie unter den <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> Enumeration.  
  
### <a name="performance-considerations"></a>Überlegungen zur Leistung  
 Die <xref:System.String.Split%2A> Methoden von Arbeitsspeicher für das zurückgegebene Arrayobjekt und <xref:System.String> -Objekt für jedes Arrayelement. Wenn Ihre Anwendung eine optimale Leistung erfordert oder wenn die Verwaltung von speicherbelegung in Ihre Anwendung von entscheidender Bedeutung ist, sollten Sie die <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOfAny%2A> -Methode, und optional die <xref:System.String.Compare%2A> Methode, eine Teilzeichenfolge innerhalb einer Zeichenfolge suchen.  
  
 Wenn Sie eine Zeichenfolge an einem Trennzeichen teilen, verwenden Sie die <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOfAny%2A> Methode zum Suchen eines Trennzeichens in der Zeichenfolge. Wenn Sie eine Zeichenfolge an einem Trennzeichen teilen, verwenden Sie die <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOfAny%2A> Methode zum Suchen des ersten Zeichens der Zeichenfolge als Trennzeichen. Verwenden Sie dann die <xref:System.String.Compare%2A> Methode, um zu bestimmen, ob die Zeichen nach dem ersten Zeichen der verbleibenden Zeichen in der Trennzeichenfolge gleich sind.  
  
 Darüber hinaus, wenn der gleiche Satz von Zeichen wird verwendet, um Zeichenfolgen in mehreren Teilen <xref:System.String.Split%2A> Methodenaufrufe, sollten Sie ein einzelnes Array erstellen, und klicken Sie in jedem Methodenaufruf darauf verweisen. Dadurch wird erheblich reduziert, der zusätzliche Verarbeitungsaufwand von jedem Methodenaufruf.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.StringSplitOptions> Enumeration zum ein- bzw. Ausschließen von generierte Teilzeichenfolgen der <xref:System.String.Split%2A> Methode.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> entspricht keinem der <see cref="T:System.StringSplitOptions" />-Werte.</exception>
        <block subset="none" type="usage"><para>In der [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] und frühere Versionen, wenn die <see cref="M:System.String.Split(System.Char[])" /> -Methode übergeben eine <paramref name="separator" /> , <see langword="null" /> oder keine Zeichen enthält, die Methode verwendet einen etwas anderen Satz von Zeichen zum Aufteilen der Zeichenfolge als die <see cref="M:System.String.Trim(System.Char[])" /> Methode führt zu Verringern Sie die Zeichenfolge ein. Ab .NET Framework 4, verwenden beide Methoden einen identischen Satz von Unicode-Zeichen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">Ein Array mit Zeichenfolgen, die die Teilzeichenfolgen in dieser Zeichenfolge trennen, ein leeres Array ohne Trennzeichen oder <see langword="null" />.</param>
        <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />, wenn leere Arrayelemente aus dem zurückgegebenen Array ausgelassen werden sollen, oder <see cref="F:System.StringSplitOptions.None" />, wenn leere Arrayelemente in das zurückgegebene Array eingeschlossen werden sollen.</param>
        <summary>Unterteilt eine Zeichenfolge anhand der Zeichenfolgen in einem Array in Teilzeichenfolgen. Sie können angeben, ob die Teilzeichenfolgen auch leere Arrayelemente umfassen.</summary>
        <returns>Ein Array, dessen Elemente die Teilzeichenfolgen in dieser Zeichenfolge enthält, die durch ein oder mehr Zeichenfolgen aus <paramref name="separator" /> getrennt sind. Weitere Informationen finden Sie im Abschnitt "Hinweise".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine Zeichenfolge, die von einem bekannten Satz von Zeichenfolgen getrennt sind, können Sie die <xref:System.String.Split%2A> Methode für die Trennung in Teilzeichenfolgen.  
  
### <a name="return-value-details"></a>Rückgabewert-details  
 Trennzeichen-Zeichenfolgen sind nicht in den Elementen des zurückgegebenen Arrays enthalten. Z. B. wenn die `separator` Array enthält die Zeichenfolge "--" und der Wert der aktuellen Zeichenfolgeninstanz "aa - bb-cc", die Methode gibt ein Array, das drei Elemente enthält: "aa", "bb" und "cc".  
  
 Wenn keine der Zeichenfolgen in dieser Instanz enthält `separator`, das zurückgegebene Array besteht aus einem einzelnen Element, das diese Instanz enthält.  
  
 Wenn die `options` Parameter <xref:System.StringSplitOptions.RemoveEmptyEntries> und die Länge dieser Instanz ist 0 (null), die Methode ein leeres Array zurück.  
  
 Jedes Element der `separator` definiert ein separates Trennzeichen, das ein oder mehrere Zeichen besteht. Wenn die `options` Argument <xref:System.StringSplitOptions.None>, und zwei Trennzeichen benachbarten oder am Anfang oder Ende dieser Instanz ein einzeln verwendetes Trennzeichen gefunden wird, enthält das entsprechende Arrayelement <xref:System.String.Empty?displayProperty=nameWithType>. Z. B. wenn `separator` enthält zwei Elemente, die "-" und "_", der Wert der Zeichenfolgeninstanz "- _aa -\_", und der Wert von der `options` Argument ist <xref:System.StringSplitOptions.None>, die Methode gibt ein Zeichenfolgenarray mit den folgenden fünf Elementen:  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>, steht für die leere Zeichenfolge, die vor der "-" Teilzeichenfolge am Index 0.  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>, steht für die leere Zeichenfolge zwischen den "-" Teilzeichenfolge am Index 0 und die Teilzeichenfolge "_" am Index 1.  
  
3.  "aa",  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>, steht für die leere Zeichenfolge, die die Teilzeichenfolge "_" am Index 4 folgt.  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>, steht für die leere Zeichenfolge, die folgt der "-" Teilzeichenfolge am Index 5.  
  
### <a name="the-separator-array"></a>Das Separator-array  
 Wenn eines der Elemente im `separator` besteht aus mehreren Zeichen, wird die gesamte Teilzeichenfolge als ein Trennzeichen betrachtet. Angenommen, eine der Elemente im `separator` ist "10", es wird versucht, teilen die Zeichenfolge "This10is10a10string." Gibt das folgende Array mit vier Elementen: {"This", "ist", "a", "String". }.  
  
 Wenn die `separator` Parameter `null` oder keine Zeichen enthält, Leerzeichen werden als Trennzeichen angesehen. Leerzeichen werden durch die Unicode-standard und return definiert `true` Wenn es sich bei der Übergabe an die <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> Methode.  
  
 Wenn die `separator` Parameter im Aufruf an die Überladung dieser Methode ist `null`, überladungsauflösung des Compiler ein Fehler auftritt. Um die aufgerufene Methode eindeutig identifizieren zu können, muss Ihr Code Geben Sie den Typ des der `null`. Das folgende Beispiel zeigt mehrere Möglichkeiten, diese Überladung eindeutig zu identifizieren.  
  
 [!code-csharp[System.String.Split#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#6)]
 [!code-vb[System.String.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#6)]  
  
### <a name="comparison-details"></a>Von Vergleichsdetails  
 Die <xref:System.String.Split%2A> -Methode extrahiert die Teilzeichenfolgen in dieser Zeichenfolge, die durch mindestens eine der Zeichenfolgen in getrennten der `separator` -Parameter und gibt diese Teilzeichenfolgen als Elemente eines Arrays zurück.  
  
 Die <xref:System.String.Split%2A> -Methode sucht nach Trennzeichen durch Durchführen von Vergleichen mit der Groß-/Kleinschreibung der ordinalen Sortierregeln. Weitere Informationen über Wort-, Zeichenfolgen- und ordinal sortiert, finden Sie unter den <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> Enumeration.  
  
 Die <xref:System.String.Split%2A> Methode ignoriert alle Elemente von `separator` , dessen Wert `null` oder eine leere Zeichenfolge ("").  
  
 Um mehrdeutige Ergebnisse zu vermeiden bei Zeichenfolgen im `separator` haben Zeichen gemeinsam, die <xref:System.String.Split%2A> Vorgang fortgesetzt wird vom Anfang bis zum Ende des Werts der Instanz, und entspricht dem ersten Element in `separator` gleich ein Trennzeichen in der -Instanz. Die Reihenfolge, in dem Teilzeichenfolgen in der Instanz, hat Vorrang vor der Reihenfolge der Elemente im `separator`.  
  
 Betrachten Sie beispielsweise eine Instanz, deren Wert "Abcdef". Wenn das erste Element im `separator` wurde von "Ef" und das zweite Element "bcde", das Ergebnis des Split-Vorgangs wäre ein Zeichenfolgenarray, das zwei Elemente enthält, "a" und "f". Grund hierfür ist die Teilzeichenfolge in der Instanz "bcde" überein, festgestellt wird, und entspricht einem Element im `separator` vor die Teilzeichenfolge "f" gefunden wird.  
  
 Aber wenn das erste Element der `separator` wurde, wurde "bc", "bcd" und das zweite Element, das Ergebnis des Split-Vorgangs wäre ein Zeichenfolgenarray, das zwei Elemente enthält, "a" und "Ef". Dies liegt daran "bcd" das erste Trennzeichen in `separator` , die ein Trennzeichen in der Instanz entspricht. Wenn die Reihenfolge der Trennzeichen umgekehrt wird, sodass das erste Element "bc" wurde und das zweite Element wurde "bcd", das Ergebnis wäre ein Zeichenfolgenarray, das zwei Elemente enthält, "a" und "Def".  
  
### <a name="performance-considerations"></a>Überlegungen zur Leistung  
 Die <xref:System.String.Split%2A> Methoden von Arbeitsspeicher für das zurückgegebene Arrayobjekt und <xref:System.String> -Objekt für jedes Arrayelement. Wenn Ihre Anwendung eine optimale Leistung erfordert oder wenn die Verwaltung von speicherbelegung in Ihre Anwendung von entscheidender Bedeutung ist, sollten Sie die <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOfAny%2A> -Methode, und optional die <xref:System.String.Compare%2A> Methode, eine Teilzeichenfolge innerhalb einer Zeichenfolge suchen.  
  
 Wenn Sie eine Zeichenfolge an einem Trennzeichen teilen, verwenden Sie die <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOfAny%2A> Methode zum Suchen eines Trennzeichens in der Zeichenfolge. Wenn Sie eine Zeichenfolge an einem Trennzeichen teilen, verwenden Sie die <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOfAny%2A> Methode zum Suchen des ersten Zeichens der Zeichenfolge als Trennzeichen. Verwenden Sie dann die <xref:System.String.Compare%2A> Methode, um zu bestimmen, ob die Zeichen nach dem ersten Zeichen der verbleibenden Zeichen in der Trennzeichenfolge gleich sind.  
  
 Darüber hinaus, wenn der gleiche Satz von Zeichen wird verwendet, um Zeichenfolgen in mehreren Teilen <xref:System.String.Split%2A> Methodenaufrufe, sollten Sie ein einzelnes Array erstellen, und klicken Sie in jedem Methodenaufruf darauf verweisen. Dadurch wird erheblich reduziert, der zusätzliche Verarbeitungsaufwand von jedem Methodenaufruf.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht den Unterschied in den Arrays zurückgegeben, indem einer Zeichenfolge <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType> -Methode mit der `options` Parameter gleich <xref:System.StringSplitOptions.None?displayProperty=nameWithType> und <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>.  
  
 [!code-csharp-interactive[System.String.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split.cs#1)]
 [!code-vb[System.String.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split.vb#1)]  
  
 Das folgende Beispiel definiert ein Array von Trennzeichen, die Interpunktion und Leerzeichen enthalten. Übergeben dieses Array zusammen mit einem Wert von <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType> auf die <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> -Methode gibt ein Array, das die einzelnen Wörter, aus der Zeichenfolge besteht.  
  
 [!code-csharp-interactive[System.String.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split7.cs#7)]
 [!code-vb[System.String.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split7.vb#7)]  
  
 Beachten Sie, die die Methode aufgerufen wird, mit der `options` Argument festgelegt wird, um <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>. Dadurch wird verhindert, dass das zurückgegebene Array einschließlich <xref:System.String.Empty?displayProperty=nameWithType> Werten, leeren Teilzeichenfolge Übereinstimmungen zwischen Satzzeichen und Leerzeichen darstellen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> entspricht keinem der <see cref="T:System.StringSplitOptions" />-Werte.</exception>
        <block subset="none" type="usage"><para>In der [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] und frühere Versionen, wenn die <see cref="M:System.String.Split(System.Char[])" /> -Methode übergeben eine <paramref name="separator" /> , <see langword="null" /> oder keine Zeichen enthält, die Methode verwendet einen etwas anderen Satz von Zeichen zum Aufteilen der Zeichenfolge als die <see cref="M:System.String.Trim(System.Char[])" /> Methode führt zu Verringern Sie die Zeichenfolge ein. Ab .NET Framework 4, verwenden beide Methoden einen identischen Satz von Unicode-Zeichen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">Ein Zeichenarray, das die Teilzeichenfolgen in dieser Zeichenfolge trennt, ein leeres Array ohne Trennzeichen oder <see langword="null" />.</param>
        <param name="count">Die maximale Anzahl der zurückzugebenden Teilzeichenfolgen.</param>
        <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />, wenn leere Arrayelemente aus dem zurückgegebenen Array ausgelassen werden sollen, oder <see cref="F:System.StringSplitOptions.None" />, wenn leere Arrayelemente in das zurückgegebene Array eingeschlossen werden sollen.</param>
        <summary>Unterteilt eine Zeichenfolge anhand der Zeichen in einem Array in eine maximale Anzahl von Teilzeichenfolgen.</summary>
        <returns>Ein Array, dessen Elemente die Teilzeichenfolgen in dieser Zeichenfolge enthält, die durch ein oder mehr Zeichen aus <paramref name="separator" /> getrennt sind. Weitere Informationen finden Sie im Abschnitt "Hinweise".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Trennzeichen sind nicht in den Elementen des zurückgegebenen Arrays enthalten.  
  
 Wenn diese Instanz keine Zeichen enthält `separator`, oder die `count` Parameter ist 1, das zurückgegebene Array besteht aus einem einzelnen Element, das diese Instanz enthält. Wenn die `separator` Parameter `null` oder keine Zeichen enthält, Leerzeichen werden als Trennzeichen angesehen. Leerzeichen werden durch die Unicode-standard und return definiert `true` Wenn es sich bei der Übergabe an die <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> Methode. Aber wenn die `separator` Parameter im Aufruf an die Überladung dieser Methode ist `null`, überladungsauflösung des Compiler ein Fehler auftritt. Um die aufgerufene Methode eindeutig identifizieren zu können, muss Ihr Code den Typ der Null angeben. Das folgende Beispiel zeigt mehrere Möglichkeiten, diese Überladung eindeutig zu identifizieren.  
  
 [!code-csharp[System.String.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#3)]
 [!code-vb[System.String.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#3)]  
  
 Wenn die `count` Parameter NULL ist, oder die `options` Parameter <xref:System.StringSplitOptions.RemoveEmptyEntries> und die Länge dieser Instanz ist 0 (null), wird ein leeres Array zurückgegeben.  
  
 Jedes Element der `separator` ein separates Trennzeichen definiert. Wenn die `options` Parameter <xref:System.StringSplitOptions.None>, und zwei Trennzeichen benachbarten oder am Anfang oder Ende dieser Instanz ein einzeln verwendetes Trennzeichen gefunden wird, enthält das entsprechende Arrayelement <xref:System.String.Empty>.  
  
 Treten mehr als `count` Teilzeichenfolgen in dieser Instanz, die die erste `count` -1 Teilzeichenfolgen werden in der ersten zurückgegeben `count` minus 1 Elemente zurückgegeben, und die restlichen Zeichen in dieser Instanz werden in den letzten zurückgegeben Element des Rückgabewerts.  
  
 Wenn `count` ist größer als die Anzahl von Teilzeichenfolgen auf, werden die verfügbaren Teilzeichenfolgen zurückgegeben und keine Ausnahme ausgelöst wird.  
  
### <a name="performance-considerations"></a>Überlegungen zur Leistung  
 Die <xref:System.String.Split%2A> Methoden von Arbeitsspeicher für das zurückgegebene Arrayobjekt und <xref:System.String> -Objekt für jedes Arrayelement. Wenn Ihre Anwendung eine optimale Leistung erfordert oder wenn die Verwaltung von speicherbelegung in Ihre Anwendung von entscheidender Bedeutung ist, sollten Sie die <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOfAny%2A> -Methode, und optional die <xref:System.String.Compare%2A> Methode, eine Teilzeichenfolge innerhalb einer Zeichenfolge suchen.  
  
 Wenn Sie eine Zeichenfolge an einem Trennzeichen teilen, verwenden Sie die <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOfAny%2A> Methode zum Suchen eines Trennzeichens in der Zeichenfolge. Wenn Sie eine Zeichenfolge an einem Trennzeichen teilen, verwenden Sie die <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOfAny%2A> Methode zum Suchen des ersten Zeichens der Zeichenfolge als Trennzeichen. Verwenden Sie dann die <xref:System.String.Compare%2A> Methode, um zu bestimmen, ob die Zeichen nach dem ersten Zeichen der verbleibenden Zeichen in der Trennzeichenfolge gleich sind.  
  
 Darüber hinaus, wenn der gleiche Satz von Zeichen wird verwendet, um Zeichenfolgen in mehreren Teilen <xref:System.String.Split%2A> Methodenaufrufe, sollten Sie ein einzelnes Array erstellen, und klicken Sie in jedem Methodenaufruf darauf verweisen. Dadurch wird erheblich reduziert, der zusätzliche Verarbeitungsaufwand von jedem Methodenaufruf.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.StringSplitOptions> Enumeration zum ein- bzw. Ausschließen von generierte Teilzeichenfolgen der <xref:System.String.Split%2A> Methode.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> entspricht keinem der <see cref="T:System.StringSplitOptions" />-Werte.</exception>
        <block subset="none" type="usage"><para>In der [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] und frühere Versionen, wenn die <see cref="M:System.String.Split(System.Char[])" /> -Methode übergeben eine <paramref name="separator" /> , <see langword="null" /> oder keine Zeichen enthält, die Methode verwendet einen etwas anderen Satz von Zeichen zum Aufteilen der Zeichenfolge als die <see cref="M:System.String.Trim(System.Char[])" /> Methode führt zu Verringern Sie die Zeichenfolge ein. Ab .NET Framework 4, verwenden beide Methoden einen identischen Satz von Unicode-Zeichen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">Ein Array mit Zeichenfolgen, die die Teilzeichenfolgen in dieser Zeichenfolge trennen, ein leeres Array ohne Trennzeichen oder <see langword="null" />.</param>
        <param name="count">Die maximale Anzahl der zurückzugebenden Teilzeichenfolgen.</param>
        <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" />, wenn leere Arrayelemente aus dem zurückgegebenen Array ausgelassen werden sollen, oder <see cref="F:System.StringSplitOptions.None" />, wenn leere Arrayelemente in das zurückgegebene Array eingeschlossen werden sollen.</param>
        <summary>Unterteilt eine Zeichenfolge anhand der Zeichenfolgen in einem Array in eine maximale Anzahl von Teilzeichenfolgen. Sie können angeben, ob die Teilzeichenfolgen auch leere Arrayelemente umfassen.</summary>
        <returns>Ein Array, dessen Elemente die Teilzeichenfolgen in dieser Zeichenfolge enthält, die durch ein oder mehr Zeichenfolgen aus <paramref name="separator" /> getrennt sind. Weitere Informationen finden Sie im Abschnitt "Hinweise".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
### <a name="return-value-details"></a>Rückgabewert-details  
 Trennzeichen-Zeichenfolgen sind nicht in den Elementen des zurückgegebenen Arrays enthalten.  
  
 Wenn keine der Zeichenfolgen in dieser Instanz enthält `separator`, oder die `count` Parameter ist 1, das zurückgegebene Array besteht aus einem einzelnen Element, das diese Instanz enthält. Wenn die `separator` Parameter `null` oder keine Zeichen enthält, Leerzeichen werden als Trennzeichen angesehen. Leerzeichen werden durch die Unicode-standard und return definiert `true` Wenn es sich bei der Übergabe an die <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> Methode. Aber wenn die `separator` Parameter im Aufruf an die Überladung dieser Methode ist `null`, überladungsauflösung des Compiler ein Fehler auftritt. Um die aufgerufene Methode eindeutig identifizieren zu können, muss Ihr Code Geben Sie den Typ des der `null`. Das folgende Beispiel zeigt mehrere Möglichkeiten, diese Überladung eindeutig zu identifizieren.  
  
 [!code-csharp[System.String.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#4)]
 [!code-vb[System.String.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#4)]  
  
 Wenn die `count` Parameter NULL ist, oder die `options` Parameter <xref:System.StringSplitOptions.RemoveEmptyEntries> und die Länge dieser Instanz ist 0 (null), wird ein leeres Array zurückgegeben.  
  
 Jedes Element der `separator` definiert ein separates Trennzeichen, das ein oder mehrere Zeichen besteht. Wenn die `options` Parameter <xref:System.StringSplitOptions.None>, und zwei Trennzeichen benachbarten oder am Anfang oder Ende dieser Instanz ein einzeln verwendetes Trennzeichen gefunden wird, enthält das entsprechende Arrayelement <xref:System.String.Empty>.  
  
 Treten mehr als `count` Teilzeichenfolgen in dieser Instanz, die die erste `count` -1 Teilzeichenfolgen werden in der ersten zurückgegeben `count` minus 1 Elemente zurückgegeben, und die restlichen Zeichen in dieser Instanz werden in den letzten zurückgegeben Element des Rückgabewerts.  
  
 Wenn `count` ist größer als die Anzahl von Teilzeichenfolgen auf, werden die verfügbaren Teilzeichenfolgen zurückgegeben und keine Ausnahme ausgelöst wird.  
  
### <a name="the-separator-array"></a>Das Separator-array  
 Wenn eines der Elemente im `separator` besteht aus mehreren Zeichen, wird die gesamte Teilzeichenfolge als ein Trennzeichen betrachtet. Angenommen, eine der Elemente im `separator` ist "10", es wird versucht, teilen die Zeichenfolge "This10is10a10string." Dieses Array mit vier Elementen zurückgegeben: {"This", "ist", "a", "String". }.  
  
### <a name="comparison-details"></a>Von Vergleichsdetails  
 Die <xref:System.String.Split%2A> -Methode extrahiert die Teilzeichenfolgen in dieser Zeichenfolge, die durch mindestens eine der Zeichenfolgen in getrennten der `separator` -Parameter und gibt diese Teilzeichenfolgen als Elemente eines Arrays zurück.  
  
 Die <xref:System.String.Split%2A> -Methode sucht nach Trennzeichen durch Durchführen von Vergleichen mit der Groß-/Kleinschreibung der ordinalen Sortierregeln. Weitere Informationen über Wort-, Zeichenfolgen- und ordinal sortiert, finden Sie unter den <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> Enumeration.  
  
 Die <xref:System.String.Split%2A> Methode ignoriert alle Elemente von `separator` , dessen Wert `null` oder eine leere Zeichenfolge ("").  
  
 Um mehrdeutige Ergebnisse zu vermeiden bei Zeichenfolgen im `separator` haben Zeichen gemeinsam, die <xref:System.String.Split%2A> Methode wird vom Anfang bis zum Ende des Werts der Instanz, und entspricht dem ersten Element in `separator` gleich ein Trennzeichen in der -Instanz. Die Reihenfolge, in dem Teilzeichenfolgen in der Instanz, hat Vorrang vor der Reihenfolge der Elemente im `separator`.  
  
 Betrachten Sie beispielsweise eine Instanz, deren Wert "Abcdef". Wenn das erste Element im `separator` wurde von "Ef" und das zweite Element "bcde", das Ergebnis des Split-Vorgangs wäre "a" und "f". Grund hierfür ist die Teilzeichenfolge in der Instanz "bcde" überein, festgestellt wird, und entspricht einem Element im `separator` vor die Teilzeichenfolge "f" gefunden wird.  
  
 Aber wenn das erste Element der `separator` wurde, wurde "bc", "bcd" und das zweite Element, das Ergebnis des Split-Vorgangs wäre "a" und "Ef". Dies liegt daran "bcd" das erste Trennzeichen in `separator` , die ein Trennzeichen in der Instanz entspricht. Wenn die Reihenfolge der Trennzeichen umgekehrt wird, sodass das erste Element "bc" wurde und das zweite Element wurde "bcd", das Ergebnis wäre "a" und "Def".  
  
### <a name="performance-considerations"></a>Überlegungen zur Leistung  
 Die <xref:System.String.Split%2A> Methoden von Arbeitsspeicher für das zurückgegebene Arrayobjekt und <xref:System.String> -Objekt für jedes Arrayelement. Wenn Ihre Anwendung eine optimale Leistung erfordert oder wenn die Verwaltung von speicherbelegung in Ihre Anwendung von entscheidender Bedeutung ist, sollten Sie die <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOfAny%2A> -Methode, und optional die <xref:System.String.Compare%2A> Methode, eine Teilzeichenfolge innerhalb einer Zeichenfolge suchen.  
  
 Wenn Sie eine Zeichenfolge an einem Trennzeichen teilen, verwenden Sie die <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOfAny%2A> Methode zum Suchen eines Trennzeichens in der Zeichenfolge. Wenn Sie eine Zeichenfolge an einem Trennzeichen teilen, verwenden Sie die <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOfAny%2A> Methode zum Suchen des ersten Zeichens der Zeichenfolge als Trennzeichen. Verwenden Sie dann die <xref:System.String.Compare%2A> Methode, um zu bestimmen, ob die Zeichen nach dem ersten Zeichen der verbleibenden Zeichen in der Trennzeichenfolge gleich sind.  
  
 Darüber hinaus, wenn der gleiche Satz von Zeichen wird verwendet, um Zeichenfolgen in mehreren Teilen <xref:System.String.Split%2A> Methodenaufrufe, sollten Sie ein einzelnes Array erstellen, und klicken Sie in jedem Methodenaufruf darauf verweisen. Dadurch wird erheblich reduziert, der zusätzliche Verarbeitungsaufwand von jedem Methodenaufruf.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.StringSplitOptions> Enumeration zum ein- bzw. Ausschließen von generierte Teilzeichenfolgen der <xref:System.String.Split%2A> Methode.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> entspricht keinem der <see cref="T:System.StringSplitOptions" />-Werte.</exception>
        <block subset="none" type="usage"><para>In der [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] und frühere Versionen, wenn die <see cref="M:System.String.Split(System.Char[])" /> -Methode übergeben eine <paramref name="separator" /> , <see langword="null" /> oder keine Zeichen enthält, die Methode verwendet einen etwas anderen Satz von Zeichen zum Aufteilen der Zeichenfolge als die <see cref="M:System.String.Trim(System.Char[])" /> Methode führt zu Verringern Sie die Zeichenfolge ein. Ab .NET Framework 4, verwenden beide Methoden einen identischen Satz von Unicode-Zeichen.</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bestimmt, ob der Anfang dieser Zeichenfolgeninstanz mit einer angegebenen Zeichenfolge übereinstimmt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : char -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Die zu vergleichende Zeichenfolge.</param>
        <summary>Bestimmt, ob der Anfang dieser Zeichenfolgeninstanz mit der angegebenen Zeichenfolge übereinstimmt.</summary>
        <returns><see langword="true" />, wenn <paramref name="value" /> mit dem Anfang dieser Zeichenfolge übereinstimmt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode vergleicht `value` mit der Teilzeichenfolge am Anfang dieser Instanz, die die gleiche Länge wie `value`, und gibt einen Wert zurück, ob diese gleich sind. Gleich, `value` muss eine leere Zeichenfolge (<xref:System.String.Empty?displayProperty=nameWithType>), muss ein Verweis auf die gleiche Instanz sein oder muss mit dem Anfang dieser Instanz übereinstimmt.  
  
 Diese Methode vergleicht Word (Groß-/Kleinschreibung beachtet und kulturabhängige) mit der aktuellen Kultur.  
  
   
  
## Examples  
 Das folgende Beispiel definiert eine `StripStartTags` Methode, verwendet der <xref:System.String.StartsWith%28System.String%29> -Methode zum Entfernen von HTML Tags am Anfang einer Zeichenfolge beginnen. Beachten Sie, dass die `StripStartTags` Methode rekursiv aufgerufen, um sicherzustellen, dass mehrere HTML-Tags mit Beginn am Anfang der Zeile entfernt werden. Im Beispiel werden keine HTML-Tags, eingebettet in einer Zeichenfolge entfernt.  
  
 [!code-cpp[stringstartswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringstartswith/CPP/stringstartswith.cpp#1)]
 [!code-csharp[stringstartswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringstartswith/CS/stringstartswith.cs#1)]
 [!code-vb[stringstartswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringstartswith/VB/stringstartswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Siehe [bewährte Methoden für die Verwendung von Zeichenfolgen](~/docs/standard/base-types/best-practices-strings.md), es wird empfohlen, dass Sie vermeiden, Aufrufen von Methoden zum Zeichenfolgenvergleich, die Standardwerte ersetzen, und rufen stattdessen die Methoden, die für Parameter explizit angegeben werden müssen. Aufrufen, um zu bestimmen, ob eine Zeichenfolge mit einer bestimmten Teilzeichenfolge beginnt, mithilfe der Regeln für Zeichenfolgenvergleiche der aktuellen Kultur, die <see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /> methodenüberladung mit einem Wert von <see cref="F:System.StringComparison.CurrentCulture" /> für seine <paramref name="comparisonType" /> Parameter.</para></block>
        <altmember cref="M:System.String.EndsWith(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * StringComparison -&gt; bool" Usage="string.StartsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Die zu vergleichende Zeichenfolge.</param>
        <param name="comparisonType">Einer der Enumerationswerte, die bestimmen, wie diese Zeichenfolge und <paramref name="value" /> verglichen werden.</param>
        <summary>Bestimmt, ob der Anfang dieser Zeichenfolgeninstanz bei einem Vergleich unter Verwendung der angegebenen Vergleichsoption mit der angegebenen Zeichenfolge übereinstimmt.</summary>
        <returns><see langword="true" />, wenn diese Instanz mit <paramref name="value" /> beginnt; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.StartsWith%2A> -Methode vergleicht die `value` Parameter mit der Teilzeichenfolge am Anfang dieser Zeichenfolge und gibt einen Wert, der angibt, ob diese gleich sind. Gleich, `value` ein Verweis auf die gleiche Zeichenfolge sein muss, muss die leere Zeichenfolge (""), oder mit den Anfang dieser Zeichenfolge übereinstimmt. Den Typ des Vergleichs wurden und die <xref:System.String.StartsWith%2A> Methode hängt vom Wert von der `comparisonType` Parameter. Der Vergleich können die Konventionen der aktuellen Kultur (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> und <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>) oder der invarianten Kultur (<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> und <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>), oder sie können besteht aus einem Zeichen für Zeichen Vergleich der Codepunkte (<xref:System.StringComparison.Ordinal?displayProperty=nameWithType> oder <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>). Der Vergleich kann auch sein, Groß-/Kleinschreibung (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>, oder <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>), oder sie können die Groß-/Kleinschreibung ignorieren (<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>).  
  
   
  
## Examples  
 Das folgende Beispiel sucht nach der Zeichenfolge "the" am Anfang einer längeren Zeichenfolge, die mit dem Wort "The". Wie die Ausgabe des Beispiels zeigt, wird durch einen Aufruf der <xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29> -Methode, die eine kulturunabhängige jedoch die Groß-/Kleinschreibung Vergleich ein Fehler auftritt, mit die Zeichenfolge übereinstimmen, während ein Aufruf, der eine Kultur und Groß-insensitive Vergleich mit der Zeichenfolge übereinstimmt.  
  
 [!code-cpp[System.String.StartsWith#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/StartsWith2.cpp#2)]
 [!code-csharp[System.String.StartsWith#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/StartsWith2.cs#2)]
 [!code-vb[System.String.StartsWith#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/StartsWith2.vb#2)]  
  
 Im folgenden Beispiel wird bestimmt, ob eine Zeichenfolge mit einer bestimmten Teilzeichenfolge beginnt. Ein zweidimensionales Zeichenfolgenarray initialisiert. Das erste Element in der zweiten Dimension enthält eine Zeichenfolge, und das zweite Element enthält die Zeichenfolge, die am Anfang der ersten Zeichenfolge gesucht. Die Ergebnisse sind betroffen, durch die Auswahl der Kultur, ob die Groß-/Kleinschreibung ignoriert wird und gibt an, ob ein ordinaler Vergleich ausgeführt wird. Beachten Sie, wenn die Zeichenfolgeninstanz eine Ligatur enthält, kulturabhängigen vergleichen mit aufeinander folgenden Zeichen erfolgreich entsprechen.  
  
 [!code-cpp[System.String.StartsWith#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/startswith1.cpp#1)]
 [!code-csharp[System.String.StartsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/startswith1.cs#1)]
 [!code-vb[System.String.StartsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/startswith1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> ist kein <see cref="T:System.StringComparison" />-Wert.</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.StartsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">Die zu vergleichende Zeichenfolge.</param>
        <param name="ignoreCase"><see langword="true" />, wenn die Groß-/Kleinschreibung beim Vergleich ignoriert werden soll, andernfalls <see langword="false" />.</param>
        <param name="culture">Kulturinformationen, die bestimmen, wie diese Instanz und <paramref name="value" /> verglichen werden. Wenn <paramref name="culture" /> <see langword="null" /> ist, wird die aktuelle Kultur verwendet.</param>
        <summary>Bestimmt, ob der Anfang dieser Zeichenfolgeninstanz bei einem Vergleich unter Verwendung der angegebenen Kultur mit der angegebenen Zeichenfolge übereinstimmt.</summary>
        <returns><see langword="true" />, wenn der <paramref name="value" />-Parameter mit dem Anfang dieser Zeichenfolge übereinstimmt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode vergleicht die `value` Parameter mit der Teilzeichenfolge am Anfang dieser Zeichenfolge, die gleiche Länge wie `value`, und gibt einen Wert, der angibt, ob diese gleich sind. Gleich, `value` muss eine leere Zeichenfolge (<xref:System.String.Empty?displayProperty=nameWithType>), muss ein Verweis auf die gleiche Instanz sein oder muss mit dem Anfang dieser Instanz übereinstimmt.  
  
 Diese Methode führt einen Vergleich mit der angegebenen Groß-/Kleinschreibung und der Kultur.  
  
   
  
## Examples  
 Im folgenden Beispiel wird bestimmt, ob eine Zeichenfolge am Anfang einer anderen Zeichenfolge auftritt. Die <xref:System.String.StartsWith%2A> Methode wird aufgerufen, mehrmals mit Groß-/Kleinschreibung, Groß-/Kleinschreibung und andere Kulturen, die die Ergebnisse der Suche zu beeinflussen.  
  
 [!code-csharp[system.string.StartsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.StartsWithCI/cs/swci.cs#1)]
 [!code-vb[system.string.StartsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.StartsWithCI/vb/swci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Substring">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft eine Teilzeichenfolge dieser Instanz ab.  
  
Dieser Member wird überladen. Klicken Sie auf einen Namen in der Überladungsliste, um vollständige Informationen zu diesem Member sowie zu Syntax, Nutzung und Beispielen zu erhalten.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Substring : int -&gt; string" Usage="string.Substring startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Die nullbasierte Anfangsposition einer Teilzeichenfolge innerhalb dieser Instanz.</param>
        <summary>Ruft eine Teilzeichenfolge dieser Instanz ab. Die untergeordnete Zeichenfolge beginnt in einer angegebenen Zeichenposition und wird an das Ende der Zeichenfolge fortgesetzt.</summary>
        <returns>Eine Zeichenfolge, die der Teilzeichenfolge ab <paramref name="startIndex" /> in dieser Instanz entspricht, oder <see cref="F:System.String.Empty" />, wenn <paramref name="startIndex" /> gleich der Länge dieser Instanz ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie die <xref:System.String.Substring%28System.Int32%29> Methode, um eine Unterzeichenfolge aus einer Zeichenfolge zu extrahieren, die an einer angegebenen Zeichenposition beginnt und am Ende der Zeichenfolge endet. Die Position des ersten Zeichens ist ein nullbasierter; Das heißt, ist das erste Zeichen in der Zeichenfolge am Index 0 (null) nicht Index 1 ein. Um eine Teilzeichenfolge, die an einer angegebenen Zeichenposition beginnt und endet, die vor dem Ende der Zeichenfolge zu extrahieren, rufen Sie die <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> Methode.  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge, die bei beginnt die `startIndex` Position in der aktuellen Zeichenfolge.  
  
 Um eine untergeordnete Zeichenfolge zu extrahieren, die mit einem bestimmten Zeichen oder die Zeichenfolge beginnt, eine Methode aufrufen, wie z. B. <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOf%2A> den Wert der abzurufenden `startIndex`. Das zweite Beispiel veranschaulicht dies; extrahiert einen Schlüssel-Wert, der eine Zeichenposition nach dem Zeichen "=" beginnt.  
  
 Wenn `startIndex` ist gleich 0 (null), die Methode gibt zurück, die die ursprüngliche Zeichenfolge unverändert.  
   
  
## Examples  
 Das folgende Beispiel zeigt eine Teilzeichenfolge aus einer Zeichenfolge abrufen.  
  
 [!code-cpp[System.String.Substring#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.String.Substring/cpp/Substring10.cpp#10)]
 [!code-csharp[System.String.Substring#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring10.cs#10)]
 [!code-vb[System.String.Substring#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring10.vb#10)]  
  
 Im folgenden Beispiel wird die <xref:System.String.Substring%2A> Methode, um Schlüssel/Wert-Paare trennen, die durch ein Gleichheitszeichen getrennt sind ("=") Zeichen.  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 Die <xref:System.String.IndexOf%2A> Methode wird verwendet, um die Position des Zeichens gleich in der Zeichenfolge abzurufen. Der Aufruf der <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> -Methode extrahiert den Schlüsselnamen, der vom ersten Zeichen in der Zeichenfolge beginnt, und erweitern für die Anzahl der Zeichen zurückgegeben werden, durch den Aufruf der <xref:System.String.IndexOf%2A> Methode. Der Aufruf der <xref:System.String.Substring%28System.Int32%29> Methode extrahiert dann den Wert auf den Schlüssel zugewiesen. Es beginnt an einer Position des Zeichens hinter dem Gleichheitszeichen und reicht bis zum Ende der Zeichenfolge.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> ist kleiner als 0 (null) oder größer als die Länge dieser Instanz.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Substring : int * int -&gt; string" Usage="string.Substring (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Die nullbasierte Anfangsposition einer Teilzeichenfolge innerhalb dieser Instanz.</param>
        <param name="length">Die Anzahl der Zeichen in der Teilzeichenfolge.</param>
        <summary>Ruft eine Teilzeichenfolge dieser Instanz ab. Die Teilzeichenfolge beginnt an einer angegebenen Zeichenposition und hat eine angegebene Länge.</summary>
        <returns>Eine Zeichenfolge, die der Teilzeichenfolge mit der Länge <paramref name="length" /> ab <paramref name="startIndex" /> in dieser Instanz entspricht, oder <see cref="F:System.String.Empty" />, wenn <paramref name="startIndex" /> gleich der Länge dieser Instanz und <paramref name="length" /> 0 (null) ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie die <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> Methode, um eine Unterzeichenfolge aus einer Zeichenfolge zu extrahieren, die an einer angegebenen Zeichenposition beginnt und vor dem Ende der Zeichenfolge endet. Die Position des ersten Zeichens ist ein nullbasierter; Das heißt, ist das erste Zeichen in der Zeichenfolge am Index 0 (null) nicht Index 1 ein. Um eine Teilzeichenfolge, die an einer angegebenen Zeichenposition beginnt und bis zum Ende der Zeichenfolge zu extrahieren, rufen Sie die <xref:System.String.Substring%28System.Int32%29> Methode.  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge mit `length` von Zeichen ab der der `startIndex` Position in der aktuellen Zeichenfolge.  
  
 Die `length` Parameter stellt die Gesamtzahl der Zeichen, die aus der aktuellen Zeichenfolgeninstanz zu extrahieren. Dies schließt das erste Zeichen am Index gefunden `startIndex`.  Das heißt, die <xref:System.String.Substring%2A> -Methode versucht, das Extrahieren von Zeichen aus dem Index `startIndex` Index `startIndex`  +  `length` - 1.  
  
 Um eine untergeordnete Zeichenfolge zu extrahieren, die mit einem bestimmten Zeichen oder die Zeichenfolge beginnt, eine Methode aufrufen, wie z. B. <xref:System.String.IndexOf%2A> oder <xref:System.String.LastIndexOf%2A> den Wert der abzurufenden `startIndex`.  
  
 Wenn die Teilzeichenfolge vom erstreckt `startIndex` auf eine angegebene Zeichenfolge angegeben wird, können Sie z. B. eine Methode aufrufen <xref:System.String.IndexOf%2A> oder <xref:System.String.LastIndexOf%2A> um den Index, der das abschließende Zeichen oder die Zeichenfolge abzurufen.  Sie können dann wie folgt diesen Wert an eine Indexposition in der Zeichenfolge konvertieren:  
  
-   Wenn Sie ein einzelnes Zeichen gesucht haben, die zum Kennzeichnen der Teilzeichenfolge, die `length` entspricht `endIndex`  -  `startIndex` + 1, in denen `endIndex` ist der Rückgabewert von der <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOf%2A> -Methode. Das folgende Beispiel extrahiert einen kontinuierlichen Speicherplatzblock "b"-Zeichen aus einer Zeichenfolge.  
  
     [!code-csharp[System.String.Substring#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring2.cs#2)]
     [!code-vb[System.String.Substring#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring2.vb#2)]  
  
-   Wenn Sie mehrere Zeichen gesucht haben, die zum Kennzeichnen der Teilzeichenfolge, die `length` entspricht `endIndex`  +  `endMatchLength`  -  `startIndex`, wobei `endIndex` ist der Rückgabewert von der <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOf%2A> -Methode und `endMatchLength` ist die Länge der Zeichenfolge, die das Ende der Teilzeichenfolge markiert. Das folgende Beispiel extrahiert einen Textblock, der eine XML-Code enthält `<definition>` Element.  
  
     [!code-csharp[System.String.Substring#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring3.cs#3)]
     [!code-vb[System.String.Substring#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring3.vb#3)]  
  
-   Wenn das Zeichen oder die Zeichenfolge am Ende der Teilzeichenfolge, nicht enthalten ist das `length` entspricht `endIndex`  -  `startIndex`, wobei `endIndex` ist der Rückgabewert von der <xref:System.String.IndexOf%2A> oder <xref:System.String.IndexOf%2A> -Methode.  
  
 Wenn `startIndex` gleich 0 (null) und ist gleich der Länge der aktuellen Zeichenfolge, die Methode gibt die ursprüngliche Zeichenfolge unverändert zurück.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht einen einfachen Aufruf der <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> -Methode, die zwei Zeichen aus einer Zeichenfolge, die beginnend ab der sechsten Zeichenposition extrahiert (d. h. am index 5).  
  
 [!code-csharp[System.String.Substring#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring4.cs#4)]
 [!code-vb[System.String.Substring#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring4.vb#4)]  
  
 Im folgenden Beispiel wird die <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> -Methode in der folgenden drei Fälle aus, um Teilzeichenfolgen in einer Zeichenfolge zu isolieren. In beiden Fällen werden die Teilzeichenfolgen in Vergleichen verwendet, und klicken Sie in den dritten Fall wird eine Ausnahme ausgelöst, weil ungültige Parameter angegeben werden.  
  
-   Er extrahiert das einzelne Zeichen und der dritten Position in der Zeichenfolge (am Index 2) und vergleicht sie mit der ein "c". Dieser Vergleich gibt `true`.  
  
-   Es werden keine Zeichen beginnend an der vierten Position in der Zeichenfolge (am Index 3) extrahiert und übergibt es an der <xref:System.String.IsNullOrEmpty%2A> Methode. Dies gibt true zurück, da der Aufruf der <xref:System.String.Substring%2A> Methodenrückgabe <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Es wird versucht, ein Zeichen, beginnend an der vierten Position in der Zeichenfolge zu extrahieren. Da Sie an dieser Position kein Zeichen vorhanden ist, löst der Methodenaufruf eine <xref:System.ArgumentOutOfRangeException> Ausnahme.  
  
 [!code-csharp[Classic String.Substring1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.Substring1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.Substring1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.Substring1 Example/VB/source.vb#1)]  
  
 Im folgenden Beispiel wird die <xref:System.String.Substring%2A> Methode, um Schlüssel/Wert-Paare trennen, die durch ein Gleichheitszeichen getrennt sind ("=") Zeichen.  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 Die <xref:System.String.IndexOf%2A> Methode wird verwendet, um die Position des Zeichens gleich in der Zeichenfolge abzurufen. Der Aufruf der <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> -Methode extrahiert den Schlüsselnamen, der vom ersten Zeichen in der Zeichenfolge beginnt, und erweitern für die Anzahl der Zeichen zurückgegeben werden, durch den Aufruf der <xref:System.String.IndexOf%2A> Methode. Der Aufruf der <xref:System.String.Substring%28System.Int32%29> Methode extrahiert dann den Wert auf den Schlüssel zugewiesen. Es beginnt an einer Position des Zeichens hinter dem Gleichheitszeichen und reicht bis zum Ende der Zeichenfolge.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> plus <paramref name="length" /> gibt eine Position außerhalb dieser Instanz an.  
  
- oder -  
 <paramref name="startIndex" /> oder <paramref name="length" /> ist kleiner als 0.</exception>
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Char&gt;.GetEnumerator" ExplicitInterfaceMemberName="System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;char&gt; IEnumerable&lt;char&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;char&gt; System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#Generic#IEnumerable&lt;char&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of Char) Implements IEnumerable(Of Char).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;char&gt; ^ System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;char&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der das aktuelle <see cref="T:System.String" />-Objekt durchläuft.</summary>
        <returns>Ein stark typisierter Enumerator, der zum Durchlaufen des aktuellen <see cref="T:System.String" />-Objekts verwendet werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Kann verwendet werden nur dann, wenn die <xref:System.String> Instanz der Umwandlung in eine <xref:System.Collections.Generic.IEnumerable%601> Schnittstellenobjekt. Weitere Informationen finden Sie unter der Methode <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der das aktuelle <see cref="T:System.String" />-Objekt durchläuft.</summary>
        <returns>Ein Enumerator, mit dem die Elemente in der aktuellen Zeichenfolge durchlaufen werden können.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.Collections.IEnumerable>-Schnittstelle umgewandelt wird. Weitere Informationen finden Sie unter der Methode <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns><see langword="true" />, wenn der Wert der aktuellen Zeichenfolge <see cref="F:System.Boolean.TrueString" /> ist. <see langword="false" />, wenn der Wert der aktuellen Zeichenfolge <see cref="F:System.Boolean.FalseString" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Der Wert der aktuellen Zeichenfolge ist weder <see cref="F:System.Boolean.TrueString" /> noch <see cref="F:System.Boolean.FalseString" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Der Wert des aktuellen <see cref="T:System.String" />-Objekts kann nicht analysiert werden.</exception>
        <exception cref="T:System.OverflowException">Der Wert des aktuellen <see cref="T:System.String" />-Objekts ist eine Zahl größer als <see cref="F:System.Byte.MaxValue" /> oder kleiner als <see cref="F:System.Byte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />.</summary>
        <returns>Das Zeichen am Index 0 im aktuellen <see cref="T:System.String" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Der Wert des aktuellen <see cref="T:System.String" />-Objekts kann nicht analysiert werden.</exception>
        <exception cref="T:System.OverflowException">Der Wert des aktuellen <see cref="T:System.String" />-Objekts ist eine Zahl kleiner als <see cref="F:System.Decimal.MinValue" /> oder größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Der Wert des aktuellen <see cref="T:System.String" />-Objekts kann nicht analysiert werden.</exception>
        <exception cref="T:System.OverflowException">Der Wert des aktuellen <see cref="T:System.String" />-Objekts ist eine Zahl kleiner als <see cref="F:System.Double.MinValue" /> oder größer als <see cref="F:System.Double.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Der Wert des aktuellen <see cref="T:System.String" />-Objekts kann nicht analysiert werden.</exception>
        <exception cref="T:System.OverflowException">Der Wert des aktuellen <see cref="T:System.String" />-Objekts ist eine Zahl größer als <see cref="F:System.Int16.MaxValue" /> oder kleiner als <see cref="F:System.Int16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Der Wert des aktuellen <see cref="T:System.String" />-Objekts kann nicht analysiert werden.</exception>
        <exception cref="T:System.OverflowException">Der Wert des aktuellen <see cref="T:System.String" />-Objekts ist eine Zahl größer als <see cref="F:System.SByte.MaxValue" /> oder kleiner als <see cref="F:System.SByte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (provider As IFormatProvider) As String Implements IConvertible.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IConvertible.ToString(IFormatProvider ^ provider) = IConvertible::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ des zurückgegebenen Objekts.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ChangeType%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">Der Wert des aktuellen <see cref="T:System.String" />-Objekts kann nicht in den vom <paramref name="type" />-Parameter angegebenen Typ konvertiert werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Der Wert des aktuellen <see cref="T:System.String" />-Objekts kann nicht analysiert werden.</exception>
        <exception cref="T:System.OverflowException">Der Wert des aktuellen <see cref="T:System.String" />-Objekts ist eine Zahl größer als <see cref="F:System.UInt16.MaxValue" /> oder kleiner als <see cref="F:System.UInt16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Der Wert des aktuellen <see cref="T:System.String" />-Objekts kann nicht analysiert werden.</exception>
        <exception cref="T:System.OverflowException">Der Wert des aktuellen <see cref="T:System.String" />-Objekts ist eine Zahl größer als <see cref="F:System.UInt32.MaxValue" /> oder kleiner als <see cref="F:System.UInt32.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>Der konvertierte Wert des aktuellen <see cref="T:System.String" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.String>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToCharArray">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiert die Zeichen dieser Instanz in ein Array von Unicode-Zeichen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray();" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : unit -&gt; char[]" Usage="string.ToCharArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kopiert die Zeichen dieser Instanz in ein Array von Unicode-Zeichen.</summary>
        <returns>Ein Array von Unicode-Zeichen, dessen Elemente die einzelnen Zeichen dieser Instanz darstellen. Wenn diese Instanz eine leere Zeichenfolge ist, ist das zurückgegebene Array leer und hat die Länge 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kopiert jedes Zeichen (d. h. jede <xref:System.Char> Objekt) in einer Zeichenfolge in ein Array von Zeichen. Das erste Zeichen kopiert befindet sich am Index 0 (null) im Zeichenarray zurückgegebenen. das letzte Zeichen am Index ist <xref:System.Array.Length%2A?displayProperty=nameWithType> - 1.  
  
 Um eine Zeichenfolge aus den Zeichen in einem Zeichenarray zu erstellen, rufen die <xref:System.String.%23ctor%28System.Char%5B%5D%29> Konstruktor.  
  
 Um ein Byte-Array zu erstellen, die den codierten Zeichen in einer Zeichenfolge enthält, instanziieren Sie das entsprechende <xref:System.Text.Encoding> Objekt, und rufen die <xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType> Methode. Die folgenden sind einige der standard in .NET verfügbaren Codierungen:  
  
|Codierung|Object|  
|--------------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 Weitere Informationen finden Sie unter [Zeichencodierung in .NET](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.String.ToCharArray%2A> Methode, um die Zeichen in einer Zeichenfolge in ein Zeichenarray zu extrahieren. Es zeigt dann die ursprüngliche Zeichenfolge und die Elemente im Array.  
  
 [!code-csharp[System.String.ToCharArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tochararray/cs/ToCharArray1.cs#1)]
 [!code-vb[System.String.ToCharArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tochararray/vb/ToCharArray1.vb#1)]  
  
 Das folgende Beispiel definiert eine Zeichenfolge, die mit den Zeichen, das als Trennzeichen in eine Zeichenfolge mit Trennzeichen fungieren. Es ruft dann die <xref:System.String.ToCharArray%2A> Methode, um ein Array von Zeichen, die übergeben werden kann, erstellen die <xref:System.String.Split%28System.Char%5B%5D%29> Methode, die durch Trennzeichen getrennte Zeichenfolge in die einzelnen Teilzeichenfolgen zu trennen.  
  
 [!code-cpp[StringSplit2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringSplit2/CPP/stringsplit2.cpp#1)] 
 [!code-csharp[StringSplit2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/stringsplit2.cs#1)] 
 [!code-vb[StringSplit2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit2.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
      </Docs>
    </Member>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray (startIndex As Integer, length As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : int * int -&gt; char[]" Usage="string.ToCharArray (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Die Anfangsposition einer Teilzeichenfolge innerhalb dieser Instanz.</param>
        <param name="length">Die Länge einer Teilzeichenfolge innerhalb dieser Instanz.</param>
        <summary>Kopiert die Zeichen einer angegebenen Teilzeichenfolge dieser Instanz in ein Array von Unicode-Zeichen.</summary>
        <returns>Ein Array von Unicode-Zeichen, dessen Elemente die <paramref name="length" />-Zeichen dieser Instanz ab Zeichenposition <paramref name="startIndex" /> sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kopiert die Zeichen in einem Abschnitt einer Zeichenfolge in ein Zeichenarray. Rufen Sie zum Erstellen einer Zeichenfolge aus einem Bereich von Zeichen in ein Array von Zeichen der <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Konstruktor.  
  
 Die `startIndex` Parameter ist nullbasiert. Der Index des ersten Zeichens in der Zeichenfolgeninstanz ist 0 (null).  
  
 Wenn `length` 0 (null), ist das zurückgegebene Array leer ist, und weist eine Länge von 0 (null). Wenn diese Instanz ist `null` oder eine leere Zeichenfolge (""), das zurückgegebene Array leer ist, und weist eine Länge von 0 (null).  
  
 Um ein Byte-Array zu erstellen, die den codierten Zeichen in einem Abschnitt einer Zeichenfolge enthält, instanziieren Sie das entsprechende <xref:System.Text.Encoding> Objekt, und rufen die <xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29> Methode. Einige der standard in .NET verfügbaren Codierungen einschließen:  
  
|Codierung|Object|  
|--------------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 Weitere Informationen finden Sie unter [Zeichencodierung in .NET](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Teilzeichenfolge innerhalb einer Zeichenfolge in ein Array von Zeichen, konvertiert und dann listet auf und zeigt die Elemente des Arrays.  
  
 [!code-cpp[string.tochararray1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.ToCharArray1/CPP/tocharry1.cpp#1)]
 [!code-csharp[string.tochararray1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.ToCharArray1/CS/tocharry1.cs#1)]
 [!code-vb[string.tochararray1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.ToCharArray1/VB/tocharry1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> oder <paramref name="length" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="startIndex" /> plus <paramref name="length" /> ist größer als die Länge dieser Instanz.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine in Kleinbuchstaben konvertierte Kopie dieser Zeichenfolge zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower();" />
      <MemberSignature Language="F#" Value="member this.ToLower : unit -&gt; string" Usage="string.ToLower " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine in Kleinbuchstaben konvertierte Kopie dieser Zeichenfolge zurück.</summary>
        <returns>Eine Zeichenfolge aus Kleinbuchstaben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode berücksichtigt die Regeln der Groß-und Kleinschreibung der aktuellen Kultur.  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge, die in der alle Zeichen in der aktuellen Instanz in Kleinbuchstaben konvertiert wurden zurückgegeben.  
  
## <a name="security-considerations"></a>Sicherheitsüberlegungen  
 Der Schreibweise-Vorgang, der aus den Aufrufen resultiert die <xref:System.String.ToLower> Methode berücksichtigt die Groß-/ Kleinschreibungskonventionen der aktuellen Kultur. Bei Bedarf die klein- oder Großbuchstabe Version eines Betriebssystems Bezeichners steht, z. B. einen Dateinamen ein, mit dem Namen Pipe oder einen Registrierungsschlüssel verwenden die <xref:System.String.ToLowerInvariant%2A> oder <xref:System.String.ToUpperInvariant%2A> Methoden. Dies erzeugt das gleiche Ergebnis in jeder Kultur (im Gegensatz zu den <xref:System.String.ToLower> Methode) und effizienter ausgeführt werden.  
  
   
  
## Examples  
 Im folgende Beispiel konvertiert mehrere Zeichenfolgen, die gemischte Groß-/Kleinschreibung in Kleinbuchstaben.  
  
 [!code-cpp[stringlowerupper#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringlowerupper/CPP/stringtolower.cpp#1)]
 [!code-csharp[stringlowerupper#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringlowerupper/CS/stringtolower.cs#1)]
 [!code-vb[stringlowerupper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringlowerupper/VB/stringtolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Siehe [bewährte Methoden für die Verwendung von Zeichenfolgen](~/docs/standard/base-types/best-practices-strings.md), es wird empfohlen, dass Sie vermeiden, Aufrufmethoden Zeichenfolge Groß-/Kleinschreibung, die Standardwerte ersetzen, und rufen stattdessen die Methoden, die für Parameter explizit angegeben werden müssen. Um ein Zeichen, das mit die Groß-/ Kleinschreibungskonventionen der aktuellen Kultur in Kleinbuchstaben zu konvertieren, rufen die <see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /> methodenüberladung mit einem Wert von <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> für seine <paramref name="culture" /> Parameter.</para></block>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToLower : System.Globalization.CultureInfo -&gt; string" Usage="string.ToLower culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">Ein Objekt, das kulturspezifische Regeln zur Groß- und Kleinschreibung bereitstellt.</param>
        <summary>Gibt eine in Kleinbuchstaben konvertierte Kopie dieser Zeichenfolge zurück, wobei die Regeln der Groß- und Kleinschreibung der angegebenen Kultur verwendet werden.</summary>
        <returns>Die Entsprechung der aktuellen Zeichenfolge in Kleinbuchstaben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Groß-/ Kleinschreibregeln der Kultur angegeben werden, indem die `culture` Parameter zu bestimmen, wie im Fall von der Zeichenfolge geändert wird.  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge, die in der alle Zeichen in der aktuellen Instanz in Kleinbuchstaben konvertiert wurden zurückgegeben.  
  
## <a name="security-considerations"></a>Sicherheitsüberlegungen  
 Übergeben der <xref:System.String.ToLower%28System.Globalization.CultureInfo%29> Methode eine <xref:System.Globalization.CultureInfo> Objekt außer <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, der Vorgang zur Groß-und Kleinschreibung wird berücksichtigt kulturspezifischen Regeln. Bei Bedarf die klein- oder Großbuchstabe Version eines Betriebssystems Bezeichners steht, z. B. einen Dateinamen ein, mit dem Namen Pipe oder einen Registrierungsschlüssel verwenden die <xref:System.String.ToLowerInvariant%2A> oder <xref:System.String.ToUpperInvariant%2A> Methode. Dies führt zum gleichen Ergebnis in jeder Kultur und effizienter ausgeführt werden.  
  
   
  
## Examples  
 Im folgende Beispiel konvertiert die beiden Zeichenfolgen von Großbuchstaben in Kleinbuchstaben unter Verwendung der Kulturen Englisch-USA und Türkisch-Türkei, und klicken Sie dann Kleinbuchstaben. Die Zeichenfolgen in Großbuchstaben sind identisch, außer dass bei jeder Instanz des Unicode-LATIN CAPITAL LETTER I in einer Zeichenfolge, die andere Zeichenfolge LATIN CAPITAL LETTER I mit Punkt oben enthält.  
  
 [!code-cpp[string.tolower1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tolower1/CPP/tolower.cpp#1)]
 [!code-csharp[string.tolower1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tolower1/CS/tolower.cs#1)]
 [!code-vb[string.tolower1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tolower1/VB/tolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.ToUpper" />
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public string ToLowerInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLowerInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLowerInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLowerInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLowerInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToLowerInvariant : unit -&gt; string" Usage="string.ToLowerInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine in Kleinbuchstaben konvertierte Kopie dieses <see cref="T:System.String" />-Objekts zurück, wobei die Regeln der Groß- und Kleinschreibung der invarianten Kultur verwendet werden.</summary>
        <returns>Die Entsprechung der aktuellen Zeichenfolge in Kleinbuchstaben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die invariante Kultur darstellt, eine Kultur, die kulturunabhängig ist. Es ist verknüpft mit der englischen Sprache jedoch nicht mit einem bestimmten Land oder Region. Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>-Eigenschaft.  
  
 Wenn Ihre Anwendung abhängt, auf eine Zeichenfolge, die Änderung in einer vorhersagbaren Weise, die von der aktuellen Kultur, verwenden nicht beeinträchtigt wird die Groß-/Kleinschreibung der <xref:System.String.ToLowerInvariant%2A> Methode. Die <xref:System.String.ToLowerInvariant%2A> Methode entspricht dem `ToLower(CultureInfo.InvariantCulture)`. Die Methode wird empfohlen, wenn eine Auflistung von Zeichenfolgen, die in einer vorhersagbaren Reihenfolge in einem Steuerelement der Benutzeroberfläche angezeigt werden muss.  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge, die in der alle Zeichen in der aktuellen Instanz in Kleinbuchstaben konvertiert wurden zurückgegeben.  
  
## <a name="security-considerations"></a>Sicherheitsüberlegungen  
 Bei Bedarf die klein- oder Großbuchstabe Version eines Betriebssystems Bezeichners steht, z. B. einen Dateinamen ein, mit dem Namen Pipe oder einen Registrierungsschlüssel verwenden die <xref:System.String.ToLowerInvariant%2A> oder <xref:System.String.ToUpperInvariant%2A> Methoden.  
  
   
  
## Examples  
 Das folgende Beispiel definiert ein Zeichenfolgenarray, das ein einzelnes Wort in einer Reihe von Sprachen enthält. Die <xref:System.String.ToLowerInvariant%2A> Methode wird verwendet, um die Elemente der parallelen Arrays durch die Groß-/Kleinschreibung einzelnen Word-Version zu füllen. Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> Methode wird verwendet, um die Groß-/Kleinschreibung beachtet, entsprechend der Reihenfolge der Elemente im Array stellen Sie sicher, dass Elemente in der gleichen Reihenfolge unabhängig von der Sprache Kleinbuchstaben Array zu sortieren.  
  
 [!code-csharp[System.String.ToLowerInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tolowerinvariant/cs/tolowerinvariant.cs#1)]
 [!code-vb[System.String.ToLowerInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tolowerinvariant/vb/tolowerinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToUpperInvariant" />
        <altmember cref="M:System.String.ToLower(System.Globalization.CultureInfo)" />
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert den Wert dieser Instanz in einen <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="string.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt diese Instanz von <see cref="T:System.String" /> zurück. Es wird keine wirkliche Konvertierung durchgeführt.</summary>
        <returns>Die aktuelle Zeichenfolge.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da diese Methode einfach mit die aktuelle Zeichenfolge unverändert zurückgibt, besteht keine Notwendigkeit, sie direkt aufzurufen. In der Regel wird es implizit in eine zur kombinierten Formatierung-Operation, wie im Beispiel gezeigt aufgerufen.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.String.ToString%2A> Methode. Beachten Sie, die im Beispiel nicht explizit aufrufen, wird die <xref:System.String.ToString%2A> Methode. Stattdessen die Methode wird aufgerufen, implizit von der [kombinierte Formatierung](~/docs/standard/base-types/composite-formatting.md) Feature.  
  
 [!code-cpp[string.tostring#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tostring/CPP/string.tostring.cpp#1)]
 [!code-csharp[string.tostring#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tostring/CS/string.tostring.cs#1)]
 [!code-vb[string.tostring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tostring/VB/string.tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Clone" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="string.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">(Reserviert) Ein Objekt, das kulturabhängige Formatierungsinformationen bereitstellt.</param>
        <summary>Gibt diese Instanz von <see cref="T:System.String" /> zurück. Es wird keine wirkliche Konvertierung durchgeführt.</summary>
        <returns>Die aktuelle Zeichenfolge.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `provider` ist reserviert und derzeit nicht bei diesem Vorgang beteiligt.  
  
 Da diese Methode einfach mit die aktuelle Zeichenfolge unverändert zurückgibt, besteht keine Notwendigkeit, sie direkt aufzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine in Großbuchstaben konvertierte Kopie dieser Zeichenfolge zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper();" />
      <MemberSignature Language="F#" Value="member this.ToUpper : unit -&gt; string" Usage="string.ToUpper " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine in Großbuchstaben konvertierte Kopie dieser Zeichenfolge zurück.</summary>
        <returns>Die Entsprechung der aktuellen Zeichenfolge in Großbuchstaben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die Regeln der Groß-und Kleinschreibung der aktuellen Kultur, um jedes Zeichen in der aktuellen Instanz in dessen Entsprechung in Großbuchstaben zu konvertieren. Wenn ein Zeichen keine Groß geschriebene Variante verfügbar sein, wird es unverändert in die zurückgegebene Zeichenfolge eingefügt.  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge, die in der alle Zeichen in der aktuellen Instanz in Großbuchstaben konvertiert wurden zurückgegeben.  
  
 Die <xref:System.String.ToUpper%2A> Methode wird häufig verwendet, um eine Zeichenfolge in Großbuchstaben zu konvertieren, sodass sie in einem Vergleich Groß-/Kleinschreibung verwendet werden kann. Eine bessere Methode zum Ausführen von Groß-/Kleinschreibung Vergleich wird eine Methode zum Zeichenfolgenvergleich aufzurufen, die eine <xref:System.StringComparison> Parameter, dessen Wert Sie, um festlegen <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType> einen Vergleich Kultur, Unterscheidung nach Groß-/Kleinschreibung.  
  
## <a name="security-considerations"></a>Sicherheitsüberlegungen  
 Der Schreibweise-Vorgang, der aus den Aufrufen resultiert die <xref:System.String.ToUpper> Methode berücksichtigt die Groß-/ Kleinschreibungskonventionen der aktuellen Kultur. Bei Bedarf die klein- oder Großbuchstabe Version eines Betriebssystems Bezeichners steht, z. B. einen Dateinamen ein, mit dem Namen Pipe oder einen Registrierungsschlüssel verwenden die <xref:System.String.ToLowerInvariant%2A> oder <xref:System.String.ToUpperInvariant%2A> Methode. Dies erzeugt das gleiche Ergebnis in jeder Kultur (im Gegensatz zu den <xref:System.String.ToUpper> Methode) und effizienter ausgeführt werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.String.ToUpper%2A> Methode, um eine Reihe von einem Zeichen von Zeichenfolgen zu konvertieren, die jedes Zeichen in die grundlegenden lateinischen, Lateinisch-1, Ergänzung und Latin Extended-A-Zeichensätze enthalten. Anschließend wird jede Zeichenfolge, deren Großbuchstaben von seinem Kleinbuchstaben unterscheidet, angezeigt.  
  
 [!code-cpp[System.String.ToUpper#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.ToUpper/cpp/ToUpperEx.cpp#1)]
 [!code-csharp[System.String.ToUpper#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.ToUpper/cs/ToUpperEx.cs#1)]
 [!code-vb[System.String.ToUpper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.ToUpper/vb/ToUpperEx.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Siehe [bewährte Methoden für die Verwendung von Zeichenfolgen](~/docs/standard/base-types/best-practices-strings.md), es wird empfohlen, dass Sie vermeiden, Aufrufmethoden Zeichenfolge Groß-/Kleinschreibung, die Standardwerte ersetzen, und rufen stattdessen die Methoden, die für Parameter explizit angegeben werden müssen. Um eine Zeichenfolge, die mit die Groß-/ Kleinschreibungskonventionen der aktuellen Kultur in Großbuchstaben zu konvertieren, rufen die <see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /> methodenüberladung mit einem Wert von <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> für seine <paramref name="culture" /> Parameter.</para></block>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToUpper : System.Globalization.CultureInfo -&gt; string" Usage="string.ToUpper culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">Ein Objekt, das kulturspezifische Regeln zur Groß- und Kleinschreibung bereitstellt.</param>
        <summary>Gibt eine in Großbuchstaben konvertierte Kopie dieser Zeichenfolge zurück, wobei die Regeln der Groß- und Kleinschreibung der angegebenen Kultur verwendet werden.</summary>
        <returns>Die Entsprechung der aktuellen Zeichenfolge in Großbuchstaben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Groß-/ Kleinschreibregeln der Kultur angegeben werden, indem die `culture` Parameter zu bestimmen, wie die Groß-/Kleinschreibung einer Zeichenfolge geändert wird.  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge, die in der alle Zeichen in der aktuellen Instanz in Großbuchstaben konvertiert wurden zurückgegeben.  
  
## <a name="security-considerations"></a>Sicherheitsüberlegungen  
 Übergeben der <xref:System.String.ToUpper%28System.Globalization.CultureInfo%29> Methode eine <xref:System.Globalization.CultureInfo> Objekt außer <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, der Vorgang zur Groß-und Kleinschreibung wird berücksichtigt kulturspezifischen Regeln. Bei Bedarf die klein- oder Großbuchstabe Version eines Betriebssystems Bezeichners steht, z. B. einen Dateinamen ein, mit dem Namen Pipe oder einen Registrierungsschlüssel verwenden die <xref:System.String.ToLowerInvariant%2A> oder <xref:System.String.ToUpperInvariant%2A> Methode. Dies führt zum gleichen Ergebnis in jeder Kultur und effizienter ausgeführt werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Zeichenfolge von Kleinbuchstaben in zwei Zeichenfolgen unter Verwendung der Kulturen Englisch-USA und Türkisch-Türkei Zeichen in Großschreibung konvertiert, und vergleicht dann die Zeichenfolgen in Großbuchstaben. Die Zeichenfolgen in Großbuchstaben sind identisch, außer dass bei jeder Instanz des Unicode-LATIN CAPITAL LETTER I in einer Zeichenfolge, die andere Zeichenfolge LATIN CAPITAL LETTER I mit Punkt oben enthält.  
  
 [!code-csharp[string.toupper1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.toupper1/CS/toupper.cs#1)]
 [!code-vb[string.toupper1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.toupper1/VB/toupper.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public string ToUpperInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpperInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpperInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpperInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpperInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToUpperInvariant : unit -&gt; string" Usage="string.ToUpperInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine in Großbuchstaben konvertierte Kopie dieses <see cref="T:System.String" />-Objekts zurück, wobei die Regeln der Groß- und Kleinschreibung der invarianten Kultur verwendet werden.</summary>
        <returns>Die Entsprechung der aktuellen Zeichenfolge in Großbuchstaben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die invariante Kultur darstellt, eine Kultur, die kulturunabhängig ist. Es ist verknüpft mit der englischen Sprache jedoch nicht mit einem bestimmten Land oder Region. Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>-Eigenschaft.  
  
 Wenn Ihre Anwendung abhängt, auf eine Zeichenfolge, die Änderung in einer vorhersagbaren Weise, die von der aktuellen Kultur, verwenden nicht beeinträchtigt wird die Groß-/Kleinschreibung der <xref:System.String.ToUpperInvariant%2A> Methode. Die <xref:System.String.ToUpperInvariant%2A> Methode entspricht dem `ToUpper(CultureInfo.InvariantCulture)`. Die Methode wird empfohlen, wenn eine Auflistung von Zeichenfolgen, die in einer vorhersagbaren Reihenfolge in einem Steuerelement der Benutzeroberfläche angezeigt werden muss.  
  
> [!NOTE]
>  Diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge, die in der alle Zeichen in der aktuellen Instanz in Großbuchstaben konvertiert wurden zurückgegeben.  
  
## <a name="security-considerations"></a>Sicherheitsüberlegungen  
 Bei Bedarf die klein- oder Großbuchstabe Version eines Betriebssystems Bezeichners steht, z. B. einen Dateinamen ein, mit dem Namen Pipe oder einen Registrierungsschlüssel verwenden die <xref:System.String.ToLowerInvariant%2A> oder <xref:System.String.ToUpperInvariant%2A> Methoden.  
  
   
  
## Examples  
 Das folgende Beispiel definiert ein Zeichenfolgenarray, das ein einzelnes Wort in einer Reihe von Sprachen enthält. Die <xref:System.String.ToUpperInvariant%2A> Methode wird verwendet, um die Elemente der parallelen Arrays durch die Groß-/Kleinschreibung einzelnen Word-Version zu füllen. Die <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> Methode wird verwendet, um die Groß-/Kleinschreibung beachtet, entsprechend der Reihenfolge der Elemente im Array in Großbuchstaben, stellen Sie sicher, dass Elemente in der gleichen Reihenfolge unabhängig von der Sprache Array zu sortieren.  
  
 [!code-csharp[System.String.ToUpperInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.toupperinvariant/cs/toupperinvariant.cs#1)]
 [!code-vb[System.String.ToUpperInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.toupperinvariant/vb/toupperinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Trim">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine neue Zeichenfolge zurück, in der alle führenden und nachgestellten Vorkommen eines Satzes von angegebenen Zeichen aus dem aktuellen <see cref="T:System.String" />-Objekt entfernt wurden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim();" />
      <MemberSignature Language="F#" Value="member this.Trim : unit -&gt; string" Usage="string.Trim " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle führenden und nachgestellten Leerraumzeichen aus dem aktuellen <see cref="T:System.String" />-Objekt.</summary>
        <returns>Die resultierende Zeichenfolge nach dem Entfernen alle Leerraumzeichen am Anfang und Ende der aktuellen Zeichenfolge. Wenn keine Zeichen in der aktuellen Instanz gekürzt werden können, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.Trim%2A> Methode wird aus der aktuellen Zeichenfolge entfernt, alle führende und nachgestellte Leerraumzeichen. Jede führenden und nachfolgenden Vorgang wird beendet, wenn eine nicht-Leerzeichen erkannt wird. Wenn die aktuelle Zeichenfolge "Abc Xyz" wird z. B. die <xref:System.String.Trim%2A> Methodenrückgabe "Xyz" Abc ". Verwenden Sie zum Entfernen von Leerzeichen zwischen Wörtern in einer Zeichenfolge [reguläre Ausdrücke von .NET](~/docs/standard/base-types/regular-expressions.md).  
  
> [!NOTE]
>  Wenn die <xref:System.String.Trim%2A> -Methode entfernt alle Zeichen aus der aktuellen Instanz, die diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge, die in der alle führenden und nachgestellten Leerraumzeichen finden Sie in der aktuellen Instanz entfernt werden zurückgegeben.  
  
 Wenn die aktuelle Zeichenfolge entspricht <xref:System.String.Empty> oder alle Zeichen in der aktuellen Instanz bestehen von Leerzeichen ab, der Methodenrückgabe <xref:System.String.Empty>.  
  
 Leerzeichen werden durch den Unicode-Standard definiert. Die <xref:System.String.Trim> -Methode entfernt alle führenden und nachgestellten Zeichen, die der Rückgabewert erzeugen `true` sie werden beim übergeben, um die <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.String.Trim?displayProperty=nameWithType> Methode, um zusätzliche Leerzeichen in Zeichenfolgen, die vom Benutzer eingegeben werden vor der Verkettung zu entfernen.  
  
 [!code-cpp[System.String.Trim#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim2.cpp#2)]
 [!code-csharp[System.String.Trim#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim2.cs#2)]
 [!code-vb[System.String.Trim#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Die [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und frühere Versionen behalten eine interne Liste von Leerzeichen, die diese Methode entfernt. Beginnend mit der [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], schneidet die Methode alle Unicode-Leerzeichen (d. h. Zeichen, erzeugen einen <see langword="true" /> Wert zurückgeben, wenn es sich bei der Übergabe an die <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> Methode). Aufgrund dieser Änderung der <see cref="M:System.String.Trim" /> -Methode in der der [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und frühere Versionen werden zwei Zeichen, NULLBREITE (U + 200 b) und 0 (null) Breite geschütztes Leerzeichen (U + FEFF), entfernt, die die <see cref="M:System.String.Trim" /> -Methode in der die [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]und höhere Versionen ist nicht entfernen. Darüber hinaus die <see cref="M:System.String.Trim" /> -Methode in der die [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und frühere Versionen nicht abtrennt drei Unicode-Zeichen enthalten: MONGOLISCH VOKALTRENNZEICHEN (U + 180E), SCHMALEN geschütztes Leerzeichen (U + 202F) und mittlere MATHEMATISCHE Leerzeichen (U + 205F).</para></block>
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.Trim : char -&gt; string" Usage="string.Trim trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.Trim : char[] -&gt; string" Usage="string.Trim trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Ein Array mit den zu entfernenden Unicode-Zeichen oder <see langword="null" />.</param>
        <summary>Entfernt alle führenden und nachgestellten Vorkommen der Zeichen im angegebenen Array aus dem aktuellen <see cref="T:System.String" />-Objekt.</summary>
        <returns>Die resultierende Zeichenfolge, nachdem alle im <paramref name="trimChars" />-Parameter übergebenen Zeichen am Anfang und Ende der aktuellen Zeichenfolge entfernt wurden. Wenn <paramref name="trimChars" /> <see langword="null" /> oder ein leeres Array ist, werden stattdessen Leerzeichen entfernt. Wenn keine Zeichen in der aktuellen Instanz gekürzt werden können, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.Trim%2A> Methode wird aus der aktuellen Zeichenfolge entfernt, alle führende und nachgestellte Zeichen in der `trimChars` Parameter. Jede führende und nachfolgende trim-Vorgang wird beendet, wenn ein Zeichen, das nicht `trimChars` festgestellt wird. Wenn die aktuelle Zeichenfolge "123abc456xyz789" lautet z. B. und `trimChars` die Ziffern von "1" bis "9", enthält die <xref:System.String.Trim%2A> Methodenrückgabe "abc456xyz".  
  
> [!NOTE]
>  Wenn die <xref:System.String.Trim%2A> -Methode entfernt alle Zeichen aus der aktuellen Instanz, die diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge zurückgegeben, in dem alle führenden und nachfolgenden `trimChars` Zeichen, die in der aktuellen Instanz gefunden werden entfernt.  
  
 Gleich die aktuelle Zeichenfolge <xref:System.String.Empty> oder alle Zeichen in der aktuellen Instanz von Zeichen in der `trimChars` array, der Methodenrückgabe <xref:System.String.Empty>.  
  
 Wenn `trimChars` ist `null` oder ein leeres Array, das diese Methode entfernt alle führenden oder nachgestellten Zeichen, die in der Methode zurückgeben zu `true` sie werden beim übergeben, um die <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> -Methode  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=nameWithType> Methode, um Speicherplatz, Sternchen (*) und Apostroph (')-Zeichen aus einer Zeichenfolge zu entfernen.  
  
 [!code-cpp[System.String.Trim#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim1.cpp#1)]
 [!code-csharp[System.String.Trim#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim1.cs#1)]
 [!code-vb[System.String.Trim#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Die [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und frühere Versionen verwaltet eine interne Liste von Leerzeichen, die diese Methode entfernt, wenn <paramref name="trimChars" /> ist <see langword="null" /> oder ein leeres Array. Beginnend mit der [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], wenn <paramref name="trimChars" /> ist <see langword="null" /> oder ein leeres Array, der die Methode entfernt alle Leerzeichen-Unicode-Zeichen (d. h. Zeichen, erzeugen einen <see langword="true" /> Wert zurückgeben, wenn es sich bei der Übergabe an die <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> Methode). Aufgrund dieser Änderung der <see cref="M:System.String.Trim" /> -Methode in der der [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und frühere Versionen werden zwei Zeichen, NULLBREITE (U + 200 b) und 0 (null) Breite geschütztes Leerzeichen (U + FEFF), entfernt, die die <see cref="M:System.String.Trim" /> -Methode in der die [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]und höhere Versionen ist nicht entfernen. Darüber hinaus die <see cref="M:System.String.Trim" /> -Methode in der die [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und frühere Versionen nicht abtrennt drei Unicode-Zeichen enthalten: MONGOLISCH VOKALTRENNZEICHEN (U + 180E), SCHMALEN geschütztes Leerzeichen (U + 202F) und mittlere MATHEMATISCHE Leerzeichen (U + 205F).</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd();" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : unit -&gt; string" Usage="string.TrimEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char -&gt; string" Usage="string.TrimEnd trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char[] -&gt; string" Usage="string.TrimEnd trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Ein Array mit den zu entfernenden Unicode-Zeichen oder <see langword="null" />.</param>
        <summary>Entfernt alle nachgestellten Vorkommen der Zeichen im angegebenen Array aus dem aktuellen <see cref="T:System.String" />-Objekt.</summary>
        <returns>Die resultierende Zeichenfolge, nachdem alle im <paramref name="trimChars" />-Parameter übergebenen Zeichen am Ende der aktuellen Zeichenfolge entfernt wurden. Wenn <paramref name="trimChars" /> <see langword="null" /> oder ein leeres Array ist, werden stattdessen Leerzeichen entfernt. Wenn keine Zeichen in der aktuellen Instanz gekürzt werden können, gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.TrimEnd%2A> Methode wird aus der aktuellen Zeichenfolge entfernt, alle nachgestellte Zeichen in der `trimChars` Parameter. Der Vorgang wird beendet, wenn das erste Zeichen, die nicht in `trimChars` am Ende der Zeichenfolge auftritt. Wenn die aktuelle Zeichenfolge "123abc456xyz789" lautet z. B. und `trimChars` die Ziffern von "1" bis "9", enthält die <xref:System.String.TrimEnd%2A> Methodenrückgabe "123abc456xyz zurück".  
  
> [!NOTE]
>  Wenn die <xref:System.String.TrimEnd%2A> -Methode entfernt alle Zeichen aus der aktuellen Instanz, die diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge zurückgegeben, in der alle Zeichen finden Sie unter `trimChars` aus der aktuellen Zeichenfolge entfernt werden.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt Informationen zur Verwendung der <xref:System.String.TrimEnd%28System.Char%5B%5D%29> Methode zum Kürzen von Leerzeichen oder Satzzeichen vom Ende einer Zeichenfolge.  
  
 [!code-csharp[System.String.TrimEnd#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimEnd/cs/sample2.cs#2)]
 [!code-vb[System.String.TrimEnd#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimEnd/vb/Sample2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Die [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und frühere Versionen verwaltet eine interne Liste von Leerzeichen, die diese Methode entfernt, wenn <paramref name="trimChars" /> ist <see langword="null" /> oder ein leeres Array. Beginnend mit der [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], wenn <paramref name="trimChars" /> ist <see langword="null" /> oder ein leeres Array, der die Methode entfernt alle Leerzeichen-Unicode-Zeichen (d. h. Zeichen, erzeugen einen <see langword="true" /> Wert zurückgeben, wenn es sich bei der Übergabe an die <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> Methode). Aufgrund dieser Änderung der <see cref="M:System.String.Trim" /> -Methode in der der [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und frühere Versionen werden zwei Zeichen, NULLBREITE (U + 200 b) und 0 (null) Breite geschütztes Leerzeichen (U + FEFF), entfernt, die die <see cref="M:System.String.Trim" /> -Methode in der die [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] und höhere Versionen ist nicht entfernen. Darüber hinaus die <see cref="M:System.String.Trim" /> -Methode in der die [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und frühere Versionen nicht abtrennt drei Unicode-Zeichen enthalten: MONGOLISCH VOKALTRENNZEICHEN (U + 180E), SCHMALEN geschütztes Leerzeichen (U + 202F) und mittlere MATHEMATISCHE Leerzeichen (U + 205F).</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart();" />
      <MemberSignature Language="F#" Value="member this.TrimStart : unit -&gt; string" Usage="string.TrimStart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char -&gt; string" Usage="string.TrimStart trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char[] -&gt; string" Usage="string.TrimStart trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Ein Array mit den zu entfernenden Unicode-Zeichen oder <see langword="null" />.</param>
        <summary>Entfernt alle nachgestellten Vorkommen der Zeichen im angegebenen Array aus dem aktuellen <see cref="T:System.String" />-Objekt.</summary>
        <returns>Die resultierende Zeichenfolge, nachdem alle im <paramref name="trimChars" />-Parameter übergebenen Zeichen am Anfang der aktuellen Zeichenfolge entfernt wurden. Wenn <paramref name="trimChars" /> <see langword="null" /> oder ein leeres Array ist, werden stattdessen Leerzeichen entfernt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.String.TrimStart%2A> Methode wird aus der aktuellen Zeichenfolge entfernt, alle führende Zeichen in der `trimChars` Parameter. Der Vorgang wird beendet, wenn eine Zeichen-, der nicht `trimChars` festgestellt wird. Wenn die aktuelle Zeichenfolge "123abc456xyz789" lautet z. B. und `trimChars` die Ziffern von "1" bis "9", enthält die <xref:System.String.TrimStart%2A> Methodenrückgabe "abc456xyz789".  
  
> [!NOTE]
>  Wenn die <xref:System.String.TrimStart%2A> -Methode entfernt alle Zeichen aus der aktuellen Instanz, die diese Methode ändert nicht den Wert der aktuellen Instanz. Stattdessen wird eine neue Zeichenfolge, die in der alle führenden Leerzeichen in der aktuellen Instanz gefunden entfernt wurden zurückgegeben.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die grundlegende Funktionen des die <xref:System.String.TrimStart%2A> Methode:

 [!code-csharp[System.String.TrimStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#1)]
 [!code-vb[System.String.TrimStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#1)]

 Im folgenden Beispiel wird die <xref:System.String.TrimStart%2A> Methode, um das Kürzen von Leerzeichen und die kommentierungszeichen von Quellcodezeilen. Die `StripComments` Methode umschließt einen Aufruf von <xref:System.String.TrimStart%2A> und übergibt ein Array von Zeichen, die ein Leerzeichen und die Kommentarzeichen, die ein Apostroph (') ist in Visual Basic und Schrägstrich (/) in C# -Code enthält. Die <xref:System.String.TrimStart%2A> Methode auch aufgerufen, um die führendes Leerzeichen zu entfernen, bei der Auswertung, ob eine Zeichenfolge einen Kommentar.  
  
 [!code-csharp[System.String.TrimStart#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#2)]
 [!code-vb[System.String.TrimStart#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#2)]  
  
 Im folgenden Beispiel wird ein Aufruf der `StripComments`-Methode veranschaulicht.  
  
 [!code-csharp[System.String.TrimStart#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#3)]
 [!code-vb[System.String.TrimStart#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Die [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und frühere Versionen verwaltet eine interne Liste von Leerzeichen, die diese Methode entfernt, wenn <paramref name="trimChars" /> ist <see langword="null" /> oder ein leeres Array. Beginnend mit der [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], wenn <paramref name="trimChars" /> ist <see langword="null" /> oder ein leeres Array, der die Methode entfernt alle Leerzeichen-Unicode-Zeichen (d. h. Zeichen, erzeugen einen <see langword="true" /> Wert zurückgeben, wenn es sich bei der Übergabe an die <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> Methode). Aufgrund dieser Änderung der <see cref="M:System.String.Trim" /> -Methode in der der [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und frühere Versionen werden zwei Zeichen, NULLBREITE (U + 200 b) und 0 (null) Breite geschütztes Leerzeichen (U + FEFF), entfernt, die die <see cref="M:System.String.Trim" /> -Methode in der die [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] und höhere Versionen ist nicht entfernen. Darüber hinaus die <see cref="M:System.String.Trim" /> -Methode in der die [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] und frühere Versionen nicht abtrennt drei Unicode-Zeichen enthalten: MONGOLISCH VOKALTRENNZEICHEN (U + 180E), SCHMALEN geschütztes Leerzeichen (U + 202F) und mittlere MATHEMATISCHE Leerzeichen (U + 205F).</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
  </Members>
</Type>